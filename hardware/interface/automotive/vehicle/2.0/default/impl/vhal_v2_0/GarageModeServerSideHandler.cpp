/*
 * Copyright (C) 2020 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "GarageModeServerSideHandler.h"
#include <chrono>
#include <condition_variable>
#include <fstream>
#include <thread>
#include <errno.h>
#include <chrono>
#include <stdlib.h>
#include <sys/inotify.h>
#include <android-base/logging.h>
#include <utils/SystemClock.h>
#include "vhal_v2_0/VehicleUtils.h"
#include <log/log.h>
#include "PropertyUtils.h"
#include "CanMap.h"
#include <android-base/properties.h>
#include <android/hardware/automotive/vehicle/2.0/types.h>

namespace android::hardware::automotive::vehicle::V2_0::impl {

using std::chrono::duration_cast;
using std::chrono::steady_clock;
using std::literals::chrono_literals::operator""s;

class GarageModeServerSideHandlerImpl : public GarageModeServerSideHandler {
  public:
    GarageModeServerSideHandlerImpl(
       VehiclePropValuePool* vehicleObjectPool, PropertyManager* pm, EmulatedVehicleHalIface* hal)
       : mValueObjectPool(vehicleObjectPool),
         mPropertyManager(pm),
         mHal(hal)
         {
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::can071_Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::can30A_Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::can30B_Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::can30C_Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ev_vcu_mcu_power_statusWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ccm_soc_power_statusWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_pt_stWatcher, this));  
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_batterycurrentWatcher, this));  
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_packvoltageWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_packvoltage_vWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_remainingchargetimeWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_batterysocWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_mcu_motortorqueWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_mcu_motorspdWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_mcu_buscurrentWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_mcu_busvoltWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_mcu_motortempWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_mcu_igbttempWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_mcu_igbt_overheat_warningWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_mcu_motor_overheat_warningWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_packtotalcellnumWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_packtotaltempnumWatcher, this));  
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_mintempmonomercellWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_maxtempmonomercellWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_maxtempcellWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_mintempcellWatcher, this));  
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_minvoltmonomercellWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_maxvoltmonomercellWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_maxvoltcellWatcher, this));  
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_minvoltcellWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_packudvoltWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_packovervoltWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_overtempWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_deltatempWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_lowinsresWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_celludvoltWatcher, this));  
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_cellovervoltWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_packlowsocWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_packfastchgsocWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_packhighsocWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_packoverchargeWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_ucellinconWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_h_vilfaultWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_batsysnotmtcWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_actual_gearWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_park_stateWatcher, this));  
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_creep_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_chrg_cnctr_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_average_energy_consumptionWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_instant_energy_consumptionWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_chraging_mode_spWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ccm_driver_buckle_statusWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_total_odometerWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_drive_modeWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_brak_sys_warnWatcher, this));
       mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_drive_pwr_limWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_mcu_errWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_hv_batt_errWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_operat_licenceWatcher, this));
       mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_actual_rema_range_vdWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_cltc_rema_range_vdWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_vehicle_spdWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_vehicle_spd_dspWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_actual_rema_rangeWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_cltc_rema_rangeWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_b2_v_v_frame_noWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_b2_v_v_cell_volt_n1Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_b2_v_v_cell_volt_n2Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_b2_v_v_cell_volt_n3Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_b2_v_t_frame_noWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_b2_v_t_cell_temp_n1Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_b2_v_t_cell_temp_n2Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_b2_v_t_cell_temp_n3Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_b2_v_t_cell_temp_n4Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_b2_v_t_cell_temp_n5Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_b2_v_t_cell_temp_n6Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_ac_blower_levelWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_ac_fresh_reci_stateWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_ac_front_defrost_stateWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_ac_heat_stateWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_ac_havc_stateWatcher, this));  
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_ac_ai_rdistribution_modeWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_ac_a_cstateWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_ac_left_set_temperatureWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_ccu_remote_car_searchWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_ccu_remote_lockWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_position_light_statusWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_high_beam_statusWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_low_beam_statusWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_turn_indcr_riWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_turn_indcr_leWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_hazard_light_statusWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_rl_door_ajar_statusWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_rr_door_ajar_statusWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_fr_door_ajar_statusWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_fl_door_ajar_statusWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_rear_fog_light_statusWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_tr_cls_stWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_power_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_brakelight_stWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_park_un_lock_ackWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_pdc1_modeWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_pdc1_buzzer_alarm_patternWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_pdc1_distance_rrmWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_pdc1_distance_rrWatcher, this));
       mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_avas_stateWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_tpms_receiverstateWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_tpms_transducer_locationWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_tpms_tyrestate_frWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_tpms_tyrestate_flWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_tpms_tyrestate_rlWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_tpms_tyrestate_rrWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_tpms_tyretemperatureWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_tpms_tyrepressure_flWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_tpms_tyrepressure_frWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_tpms_tyrepressure_rrWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_tpms_tyrepressure_rlWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::cc_abs_abs_fail_statusWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::cc_eps_run_stateWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_lamplet_statusWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_main_seat_pressure_statusWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_brake_level_alarm_statusWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_main_seat_safety_belt_statusWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_engine_statusWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_low_vol_battery_volWatcher, this));
		mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_key_previous_songWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_key_next_songWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_key_volume_upWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_key_volume_dowmWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_key_mode_muteWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_key_telephoneWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_key_voiceWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_key_homeWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_key_customWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_key_distanceWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_key_speedupWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_key_speeddownWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_key_pagedownWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_key_pageupWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_key_okayWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::sc_ec_ccm_batt_maintain_ctr_cmdWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::sc_ec_ccm_batt_maintain_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::sc_ec_ccm_versionWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::sc_ec_ccm_target_chrg_currWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::sc_ccm_remt_ctrl_flagWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::sc_ec_ccm_operat_licenceWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::interval_time, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ccm_appointment_mode, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ccm_chraging_begin_time_hour, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ccm_chraging_begin_time_minute, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ccm_chraging_end_time_hour, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ccm_chraging_end_time_minute, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ccm_chraging_sunday_loop, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ccm_chraging_monday_loop, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ccm_chraging_tuesday_loop, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ccm_chraging_wednesday_loop, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ccm_chraging_thursday_loop, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ccm_chraging_friday_loop, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ccm_chraging_saturday_loop, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ccm_chraging_target_soc, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_key_long_volume_upWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_key_long_volume_dowmWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_key_long_telephoneWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_key_long_customWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_key_long_previous_songWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_key_long_next_songWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_light_levelWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mcu_voiume_navigationWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mcu_voiume_voicWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mcu_voiume_multimediaWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mcu_voiume_phoneWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mcu_voiume_alarmWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mcu_voiume_keyWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mcu_info_vinWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mcu_info_sn1Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mcu_info_sn2Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mcu_info_sn3Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mcu_info_versionWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_travel_rangeWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_travel_timeWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_average_energy_consumptionWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::rangeModeSet, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::gecko_headlighthSet, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_remind_inrWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_remind_start_timeWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_remind_distanceWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_remind_start_odoWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_ac_hybrid_eco_mode_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_wipr_intl_time_set_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_flwr_me_hm_ctrl_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_illmnd_unlock_sts_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_illmnd_lock_sts_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_lock_horn_on_st_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_esc_disableWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ehb_avh_appld_stWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ehb_epb_system_stateWatcher, this));
	mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ehb_brk_dis_wip_acWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_elec_steer_mode_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_veh_act_recuperate_pwrWatcher, this));
	mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vehicle_driving_pwrWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_srs_passenger_airbag_sta_rsvrWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_front_fog_light_statusWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_key_lo_batt_lvl_warnWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_warn_no_key_foundWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_auto_lamp_statusWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_indication_shiftto_neutralWatcher, this));
	mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_12_v_bat_low_vol_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_sibs_kl30_voltageWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_srs_airbag_warning_lamp_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_srs_drv_seatbelt_buckle_validWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ipu_obc_inlet_connect_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_dcs_inlet_connect_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_pwr_train_connect_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ehb_brake_liquid_level_warnWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_ebd_failedWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_vhcl_p_gear_errorWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_motor_high_temp_wrningWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_mcu_high_temp_wrningWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bcm_central_lock_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_pcu_fail_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_warn_key_out_reminderWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_light_intensityWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_indication_key_closerWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_srs_pass_seatbelt_bucklestatusWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_srs_pass_seatbelt_buckle_validWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_srs_pass_seat_occupant_sensor_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_srs_mid_seat_belt_bucklestatusWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_srs_mid_seat_belt_buckle_validWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_srs_mid_seat_occupant_sensor_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ipu_obc_actl_oprt_modeWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_dcs_act_oprt_modeWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_reserve_powerWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_motor_actual_powerWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_motor_actual_power_typeWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_hdc_statusWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_es_cor_tcs_failedWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_tcs_active_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_esp_active_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ehb_avh_lamp_reqWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ehb_epb_display_msg_idWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ehb_avh_disp_msgWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ehb_epb_warn_lamp_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_obc_oprt_cmd_to_icuWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_ac_envir_temp_vWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_ac_envir_tempWatcher, this));

        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::config_query_sim_cardWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::config_query_4g_strengthWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::config_query_wifi_strengthWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::config_query_wifi_statusWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::config_query_gps_lonWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::config_query_gps_latWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::vcu_chraging_mode_sp_reqWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_pp_fl_distWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_pp_fml_distWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_pp_fmr_distWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_pp_fr_distWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_pp_sdwfsl_distWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_pp_sdwfsl_mid_distWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_pp_sdwfsr_mid_distWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_pp_sensor_fault_sts_frmWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_pp_sensor_fault_sts_frWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_pp_sdwrsr_distWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_pp_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_pp_sw_fdbkWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fcm_elk_set_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fcm_aeb_set_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fcm_hma_set_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fcm_tsr_spd_lim_warnWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fcm_tsr_spd_lim_warn_auWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fcm_tsr_spd_lim_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fcm_slwf_set_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fcm_fcm_intializationWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fcm_elk_left_modeWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fcm_elk_right_modeWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fcm_slif_set_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fcm_trfc_signWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fcm_tsr_lgt_dstWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fcm_tsr_lat_dstWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fcm_tsr_set_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fcm_tsr_spd_limWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fcm_slif_oper_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fcm_audio_warn_hands_offWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fcm_fault_text_infoWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fcm_lka_audio_warningWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fcm_act_drv_asst_sts_hmiWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fcm_tar_obj_accWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fcm_adas_not_avl_reasWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fcm_acc_startWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fcm_ica_truck_set_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fcm_ica_set_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fcm_adas_quit_reasWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fcm_acc_mode_hmiWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fcm_pcw_pre_warnWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fcm_pcw_latent_warnWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fcm_text_info_lka1Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fcm_ldw_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fcm_ldw_set_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fcm_lka_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fcm_le_line_color_fctWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fcm_lka_set_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fcm_ri_line_color_fctWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fcm_ldw_alert_method_set_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fcm_v_set_disWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fcm_aeb_obj_idWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fcm_raeb_work_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fcm_ldw_audio_warnWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fcm_laterallimitWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ipu_obc_inlelt_actl_powerWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_srs_crash_output_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_insulation_wrning_distgshWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_thermalrunaway_wrnWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_dcs_actl_chrg_voltageWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_icu_vehicle_speed_displayed_vWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_icu_icu_trip_a_odometerWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_icu_icu_trip_b_odometerWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::cc_eps_basic_elec_steer_failedWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::cc_eps_mode_set_inhibit_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::cc_eps_sws_hod_hands_off_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_vcu_info_dispWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_vcu_vhcl_speed_fast_warnWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_vcu_drive_mode_key_stagnationWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_vcu_cc_key_stagnationWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_vcu_shift_key_stagnationWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_vcu_lock_veh_warmWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_vcu_sibs_kl30_voltageWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_vcu_sibs_rtcwu_chg_numWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_vcu_sibs_chg_num_allowWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_vcu_sibs_rtcwu_chg_fail_numWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_vcu_sibs_rtc_chrg_stWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_vcu_sibs_wup_volt_allowWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_vcu_sibs_bms_bat_soc_allowWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_vcu_sibs_fb_rtc_wup_flgWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_vcu_ac_chrg_max_currWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_vcu_ac_chrg_modeWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_ccu_open_ventilation_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_ac_ac_unlock_vent_set_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_ac_remote_defrost_ctl_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_ac_temp_set_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_ac_remt_ctrl_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_ccu_remote_power_lock_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_vcu_speed_limit_level_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_vcu_operat_licence_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_vcu_version_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_vcu_vesion_set_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_vcu_wgh_confdenceWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_vcu_wgh_estWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_vcu_wgh_distbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_vcu_cruise_ctrl_sta_for_bacWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_vcu_cruise_ctr_tgt_spd_for_bacWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_ac_indoor_tempWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_light_sw_sigWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_ajar_sta_hoodWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_tmps_abnm_prsr_warnWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_tpms_reset_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_fr_windowmotor_flagsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_fl_windowmotor_flagsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_wash_liquid_level_warnWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_front_wash_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_pas_wdw_initWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_drv_pass_win_sw_sigWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_body_warn_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_key_in_car_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_ps_authent_resWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_trunk_lock_sw_ctrl_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_trunk_lock_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_overspd_cntrl_lock_set_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_park_auto_unlock_set_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_chg_wiper_mt_md_sw_set_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_drv_lf_ant_diag_statusWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_lf_init_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_door_lock_operation_recordWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_int_lf_ant_diag_statusWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_pass_lf_ant_diag_statusWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_illmnd_entry_sts_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_steer_whl_tempWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_steer_whl_heat_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_rear_mirror_heat_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_mai_drvr_seat_tempWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_mai_drvr_seat_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_logo_active_flagWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_rf_init_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_rear_fog_li_fault_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_front_fog_li_fault_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_pos_li_fault_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_back_li_fault_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_brake_li_fault_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_reverse_li_fault_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_day_run_li_fault_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ehb_epb_flt_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ehb_epb_switch_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ehb_failure_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_vhcl_actl_gear_pos_vWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bcm_sys_pwr_mode_vWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bcm_sys_pwr_modeWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bcm_sys_power_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bcm_door_lock_sta_flWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_pwr_recup_intensityWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ccu_diag_tester_onlineWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bcm_back_ladjval_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_rmi_active_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_slope_percent_vWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_slope_percentWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_inv_antithft_auth_rsltWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_ac_auto_blower_mode_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fcm_fcw_set_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_ac_extd_defrost_actv_reqWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_scs_left_swt_vdWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_scs_left_1_swtWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_scs_left_2_swtWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_scs_left_3_swtWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_scs_left_4_swtWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_scs_left_5_swtWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_scs_left_6_swtWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_scs_left_7_swtWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_scs_left_8_swtWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_avas_state_rolling_counterWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_current_over_wrningWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_battery_sub_sys_numWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_battery_sub_sys_codWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_battery_dtc_numWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_battery_dtc_listWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_battery_dtc_indexWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_inv_1_rolling_counterWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_inv_4_err_bitsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_inv_4_rolling_counterWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_scs_right_swt_vdWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_scs_right_14_swtWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_scs_right_15_swtWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_scs_right_16_swtWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_crrr_bsd_warn_rightWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_crrr_bsd_warn_leftWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_crrr_bsd_set_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_crrr_rcta_warn_rightWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_crrr_rcta_warn_leftWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_crrr_rcta_set_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_crrr_rcw_warningWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_crrr_rcw_set_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_crrr_rear_corner_failureWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_crrr_rear_corner_blindnessWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_crrr_dow_set_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_crrr_dow_warn_frWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_crrr_dow_warn_flWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_crrr_dow_warn_rrWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_crrr_dow_warn_rlWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_crrr_dow_warn_rightWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_crrr_dow_warn_leftWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_typ1Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_lat_dst1Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_lgt_dst1Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_lgt_rel_spd1Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_posn_agl1Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_lgt_rel_spd7Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_dir1Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_lgt_rel_spd8Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_sta1Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_typ2Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_lat_dst2Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_lgt_dst2Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_posn_agl2Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_lgt_rel_spd2Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_lgt_rel_spd9Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_dir2Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_sta2Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_typ3Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_lat_dst3Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_lgt_dst3Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_posn_agl3Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_lgt_rel_spd3Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_dir3Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_sta3Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_typ4Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_lat_dst4Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_lgt_dst4Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_posn_agl4Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_lgt_rel_spd4Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_sta4Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_dir4Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_dir7Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_typ5Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_lat_dst5Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_lgt_dst5Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_posn_agl5Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_lgt_rel_spd5Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_dir5Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_sta5Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_sta9Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_typ6Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_lat_dst6Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_lgt_dst6Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_posn_agl6Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_lgt_rel_spd6Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_dir9Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_sta6Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_dir6Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_typ7Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_lat_dst7Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_lgt_dst7Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_posn_agl7Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_sta7Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_lat_dst8Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_lgt_dst8Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_typ8Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_typ9Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_sta8Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_posn_agl8Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_lat_dst9Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_lgt_dst9Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_posn_agl9Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_dir8Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_typ10Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_lat_dst10Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_lgt_dst10Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_posn_agl10Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_sta10Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_lat_dst11Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_lgt_dst11Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_typ11Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_posn_agl11Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_sta11Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_lat_dst12Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_lgt_dst12Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_typ12Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_dir11Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_posn_agl12Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_typ13Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_lat_dst13Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_lgt_dst13Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_sta13Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_posn_agl13Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_lat_dst14Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_lgt_dst14Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_typ14Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_sta14Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_posn_agl14Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_lat_dst15Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_lgt_dst15Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_typ15Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_dir14Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_posn_agl15Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_typ16Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_lat_dst16Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_lgt_dst16Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_lat_dst17Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_lgt_dst17Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_sta16Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_dir16Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_typ17Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_typ18Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_sta17Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_lat_dst18Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_lgt_dst18Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_posn_agl18Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_dir17Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_dir18Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_sta18Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_lgt_rel_spd10Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_posn_agl16Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_lgt_rel_spd11Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_posn_agl17Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_lgt_rel_spd12Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_lgt_rel_spd13Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_dir10Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_lgt_rel_spd14Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_sta12Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_lgt_rel_spd15Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_dir12Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_lgt_rel_spd16Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_dir13Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_sta15Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_lgt_rel_spd17Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_lgt_rel_spd18Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_dir15Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_nr_of_lineWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_le_line_typWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_le_line_rdWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_le_line_dstWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_le_line_c1Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_le_line_c2Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_ri_line_typWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_le_line_c3Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_ri_line_rdWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_ri_line_dstWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_ri_line_c1Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_ri_line_c3Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_ri_line_c2Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_le_le_line_typWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_le_le_line_c1Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_le_le_line_c3Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_le_le_line_rdWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_le_le_line_dstWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_ri_ri_line_c1Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_ri_ri_line_c3Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_ri_ri_line_rdWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_ri_ri_line_dstWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_ri_ri_line_typWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_le_le_line_c2Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_ri_ri_line_c2Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_spd_downin_cor_sfkWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_vcu_speed_limit_level_set_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_abs_active_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ipu_dcc_actl_oprt_modeWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ipu_over_temperature_failWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_accl_pedal_posWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_brk_pedal_posWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_iso_resistanceWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ehb_brk_pedl_valWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ehb_brk_pedl_val_vldWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ehb_brk_pedl_val_percWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ehb_brk_pedl_val_perc_vldWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_travel_average_speedWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ipu_dcc_sys_fail_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bcm_brake_pedal_staWatcher, this));

        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::fcm_adas_drvr_reqWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::fcm_elk_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::fcm_slifs_spd_limWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::fcm_aeb_statusWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::fcm_aeb_statsadsusWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::hu_dowenaswtWatcher, this));

        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::sc_fcm_acc_take_over_reqWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::fcm_tjatakeoverreqWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fcm_aeb_recreqWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::hu_hma_enable_swWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::hu_ica_enable_sw_tWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::hu_ica_avd_truck_setWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::hu_ldw_alert_method_swWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::hu_lka_enable_swWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::hu_elk_enb_swWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::hu_fcw_enable_swWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::hu_abe_enable_swWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::hu_bsd_enable_swWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::hu_rcw_enable_swWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::hu_rcta_enable_swWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::hu_slif_enableswWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::hu_slwf_enableswWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::hu_navi_country_codeWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_avalueble_key_in_carWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_sys_fail_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ccu_remt_steer_whl_heat_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ccu_remt_power_ctrl_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ccu_remt_mai_dr_seat_heat_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_pp_sensor_fault_sts_rlWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_pp_sensor_fault_sts_rlmWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_pp_sensor_fault_sts_rrmWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_pp_sensor_fault_sts_rrWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_pp_rl_distWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_pp_rlm_distWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_pp_rrm_distWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_pp_rr_distWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_pp_sdwfsr_distWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_pp_sdwrsl_distWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_pp_sdwrsl_mid_distWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_pp_sdwrsr_mid_distWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fm_auto_seek_resWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::fm_searchWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::fm_volumeWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_err_amountWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_err_bitWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_carriage_light_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_eps_steer_wheel_angleWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_eps_steer_wheel_angle_validWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_eps_rot_speedWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_eps_steer_wheel_angle_failureWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_eps_electric_power_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_eps_steer_wheel_angle_calibratedWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_eps_mot_tqWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_lgt_fct_actv_flgWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_eps_set_steer_whl_aglWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_steer_tq_req_activeWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_eps_ctrl_reqWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_drvr_warn_vib_reqWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_daeps_mode_reqWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_act_drv_asst_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_overtake_ass_sys_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_turn_lamp_reqWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_tjaica_supps_abortnWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_lka_torq_fact_reqWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_hma_supps_abortnWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_lkaldw_supps_abortnWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_flt_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_elk_supps_abortnWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_acc_whl_tq_req_valWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_acc_whl_tq_req_actvWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_acc_whl_deceWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_acc_tar_accrnWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_acc_supp_abortWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_acc_tar_accrn_req_actvWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_epb_req_vWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_epb_reqWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_acc_shutdown_modeWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_ahd_obj_idWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_acc_tgt_axWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_aeb_tgt_axWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_acc_modeWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_acc_req_standstillWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_aeb_reqWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_aeb_standstill_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_aeb_standstill_sts_vWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_aba_levelWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_awb_levelWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_aba_reqWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_eba_reqWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_awb_reqWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_abp_reqWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_acc_tgt_ax_reqWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_crv_decel_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_acc_req_drive_offWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_scs_frnt_wipr_swt_stWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_scs_low_beam_swt_stWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_scs_hi_beam_swt_stWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_scs_over_veh_beam_swt_stWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_scs_lamp_auto_stWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_scs_le_turn_lmp_swt_stWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_scs_ri_turn_lmp_swt_stWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_hv_bat_cell_temp_aveWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_dcs_actl_chrg_currentWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_scs_gear_shift_lever_pst_reqWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_ac_chrg_atcl_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_outlet_coolant_actl_tempWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_outlet_coolant_actl_temp_validWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_inlet_coolant_actl_tempWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_inlet_coolant_actl_temp_validWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_max_chrg_voltage_acWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_max_chrg_current_acWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_bat_sohWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_temp_max_dc_charge_socketWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_pcb_temp_maxWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_max_allow_chrg_cur_dcWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_max_allow_chrg_vol_dcWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_electronic_lock_ctrlWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_electronic_lock_stateWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_contactor_state_dc_chargerWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_dcs_charge_requestWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_dcs_chrg_a_plusWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_run_stateWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_contactor_state_negativeWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_contactor_state_positiveWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_contactor_state_prechargeWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_supply_voltage_statusWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_emeshutdown_reqWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_charge_interlock_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_dis_charge_interlock_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_batt_balance_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_therm_runaway_snsr_fltWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_therm_runaway_vlv_stWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ipu_obc_uac_act_l1Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ipu_obc_uac_act_l2Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ipu_obc_uac_act_l3Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ipu_obc_iac_act_l1Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ipu_obc_iac_act_l2Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ipu_obc_iac_act_l3Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ipu_device_int_tempWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ipu_obc_temp_inletWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ipu_obc_ac_max_pw_allowWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ipu_obc_inlet_electronic_lockWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ipu_obc_s2_stateWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ipu_obc_wake_up_modeWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ipu_obc_voltage_ok_l1Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ipu_obc_voltage_ok_l2Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ipu_obc_voltage_ok_l3Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ipu_dcc_high_volt_actl_curWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ipu_dcc_high_volt_actl_volWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ipu_obc_hvdc_actl_curWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ipu_obc_connect_main_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ipu_obc_requestWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ipu_obc_sys_fail_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ipu_obc_hvdc_actl_volWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ipu_obc_errbitWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ipu_dcc_low_vol_actl_volWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ipu_dcc_low_vol_actl_curWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ipu_dcc_precharge_completeWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ipu_dcc_derating_oprt_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ipu_hvil_fail_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ipu_dcc_errbitWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ipu_obc_c_cor_cp_cnctd_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ipu_obc_cp_dutyWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ipu_obc_cp_max_voltWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ipu_obc_process_codeWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ipu_obc_cc_resisdentWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_eps_torsion_bar_torqueWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_eps_torsion_bar_torque_dirWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_eps_torsion_bar_torque_validWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_eps_elect_power_consumptionWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_eps_advanced_mode_statusWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_eps_lat_drv_lvl12_srv_avlWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_eps_lat_mc_hptc_wrn_srv_avlWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_eps_pscm_int_rpc_max_trqWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_eps_torsion_bar_torque_qfWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_eps_pscm_int_rpc_min_trqWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_eps_lat_mc_steer_tq_activeWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_eps_lat_mc_hptc_wrn_activeWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_eps_max_allwd_rot_spdWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_eps_lks_agl_sys_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_eps_max_allwd_aglWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_eps_steer_tqWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_eps_lks_abort_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_eps_lks_agl_ctrl_avl_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_req_brake_light_onWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_ebd_active_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_ess_activeWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_cdp_activeWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_brake_temp_over_heatWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_dtc_active_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_vhcl_standstill_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_dtc_request_rbs_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_dtc_failure_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_wheel_speed_kph_v_flWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_wheel_direction_flWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_wheel_speed_kph_flWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_wheel_speed_kph_v_frWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_wheel_direction_frWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_wheel_speed_kph_frWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_master_cylinder_presrWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_master_cylinder_presr_vWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_wheel_speed_kph_v_rlWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_wheel_direction_rlWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_wheel_speed_kph_rlWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_wheel_speed_kph_v_rrWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_wheel_direction_rrWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_wheel_speed_kph_rrWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_wheel_speed_rc_sts_flWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_wheel_speed_rc_sts_frWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_wheel_speed_rc_sts_rlWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_wheel_speed_rc_sts_rrWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_wheel_speed_rc_flWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_wheel_speed_rc_frWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_wheel_speed_rc_rlWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_wheel_speed_rc_rrWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_long_acc_sensor_valueWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_long_acc_sensor_value_vldWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_lat_acc_sensor_value_vldWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_lat_acc_sensor_valueWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_yaw_rateWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_yaw_rate_vldWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_epb_right_currentWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_epb_right_fault_stateWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_hbb_hbc_availableWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_epb_actuator_st_rWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_hbb_hbc_activeWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_whl_tq_dec_req_actvWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_whl_tq_dec_req_valWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_whl_tq_inc_req_actvWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_whl_tq_inc_req_valWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ehb_cdp_requestWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ehb_epb_actuator_st_rWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ehb_epb_actuator_st_lWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ehb_hhc_active_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ehb_rgn_brk_stWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ehb_ext_req_statusWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ehb_blaWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ehb_hmi_warning_onWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ehb_epb_dynamic_apply_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ehb_pedl_trvl_snsr_fail_pdfWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ehb_req_brk_li_onWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ehb_pedl_trvl_snsr_fail_pdtWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ehb_p_runout_pressureWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ehb_brake_pedal_appliedWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ehb_brake_pedal_applied_qWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ehb_cdd_temp_offWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ehb_s_output_rod_hydraulic_targetWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ehb_s_output_rod_driver_percWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ehb_aba_active_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ehb_aba_available_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ehb_awb_active_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ehb_awb_available_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ehb_aeb_active_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ehb_aeb_available_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ehb_abp_active_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ehb_abp_available_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_pp_raeb_set_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_pp_raeb_work_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_pp_raeb_brkg_reqWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_pp_raeb_brkg_req_valWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_pp_raeb_distance_to_collisionWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_crrr_rctb_decelarationWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_crrr_rctb_reqWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_crrr_rctb_brkg_vldWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_crrr_fov_chg_set_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_max_con_dis_curntWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_pwr_recup_max_con_chrg_curntWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_max_instan_dis_curntWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_pwr_recup_max_instan_chrg_curntWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_cell_vol_aveWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_contactor_temp_negativeWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_max_cell_temp_limitWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_max_cell_vol_limitWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_pwr_limd_flgWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_min_cell_temp_limitWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_min_cell_vol_limitWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_err_tab_indexWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_battery_typeWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_hw_versionWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_pack_identityWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_sw_versionWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_nom_cell_capWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_bat_capacityWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_cst_abort_by_bmsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_cst_abort_by_faultWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_cst_abort_by_userWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_cst_abort_achive_conditionWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_cst_abort_fault_energe_transmitWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_cst_abort_fault_charger_inner_tempWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_cst_abort_fault_connetorWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_cst_abort_fault_charger_tempWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_cst_abort_fault_otherWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_cst_abort_fault_charger_stopWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_cst_abort_error_voltageWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_cst_abort_error_currentWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bcm_rear_view_mirr_heating_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_tms_ohx_out_tmpWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_tms_evap_tmpWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_tms_evap_out_tmpWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_tms_chiller_out_tmpWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bcm_high_beam_li_fault_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bcm_low_beam_li_fault_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bcm_vhcl_seekWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bcm_illmnd_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bcm_key_frbdnWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bcm_frbdn_key_nrWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bcm_start_reqWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bcm_drv_pe_authent_acsdWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bcm_frpe_authent_acsdWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bcm_ps_reqWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bcm_frnt_le_door_hndl_swtWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bcm_frnt_ri_door_hndl_swtWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bcm_save_power_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bcm_front_wiper_motor_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bcm_fl_window_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bcm_fr_window_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bcm_fl_windowmotor_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bcm_fr_windowmotor_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bcm_wiper_ctrl_frontWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bcm_drv_seat_occupant_sensor_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bcm_heavy_rain_indWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_tpms_pressure_value_rrWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_tpms_pressure_value_rlWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_tpms_pressure_sta_rlWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_tpms_pressure_sta_rrWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_tpms_pressure_value_frWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_tpms_pressure_value_flWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_tpms_pressure_sta_flWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_tpms_pressure_sta_frWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bcm_dome_light_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bcm_back_lamp_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bcm_bass_horn_reqWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bcm_ajar_sta_v_hoodWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bcm_frnt_fog_li_sw_sigWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bcm_rear_fog_li_sw_sigWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bcm_day_run_light_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bcm_reverse_lamp_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bcm_brake_lamp_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bcm_turn_li_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_actl_motor_rotate_spdWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_actl_motor_rotate_spd_vWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_remt_ac_ctrl_stWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_remt_ac_defrostl_reqWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_remt_ac_ctrl_reqWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_charging_conditions_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_accl_pedal_pos_snsr_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_req_epbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_acc_trq_ctrl_avlWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_acc_standstill_reqWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_acc_tgt_axWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_acc_tgt_ax_reqWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_drv_req_torq_override_fcmWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_cruise_ctr_tgt_spdWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_cruise_ctrl_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_scs_right_11_swtWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_scs_right_12_swtWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_scs_right_13_swtWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_scs_gear_shift_lever_pst_req_vdWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_dcs_actl_chrg_powerWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ccu_keep_awake_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_bra_tor_reqWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_pp_sensor_fault_sts_flmWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_pp_sensor_fault_sts_flWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bcm_authent_key_nrWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bcm_key_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bcm_wiper_stop_pos_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_insulation_wrningWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_tau_gap_setWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::gecko_e2p_rom_resultWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::gecko_key_code_resultWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_hma_highbeam_reqWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bcm_hazard_lamp_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_rke_reqWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fcm_hma_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_le_turn_li_fault_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_ri_turn_li_fault_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_ac_ac_sta_fbWatcher, this));
	 //短期记忆
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_travel_short_rangeWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_travel_short_average_speedWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_travel_short_average_pwr_consum_Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_travel_short_timeWatcher, this));
}

    ~GarageModeServerSideHandlerImpl() {
        mShuttingDownFlag.store(true);
        mHeartbeatCV.notify_all();
        for (auto& thread : mThreads) {
            if (thread.joinable()) {
                thread.join();
            }
        }
    }

    void HandleHeartbeat() override;
  public:
    double TotalMileageEEPROM = 0.0;  // 从EEPROM中读取的总里程值（示例值，单位：km）

    // 使用公式计算总里程
    double totalMileageCur = 0;
    int32_t beginTotalMileage = 0;
    float begintravelMileage = 0;
    std::deque<float> spdQueue;
    const unsigned long spdSaveCounter = 10;
    std::condition_variable spdcv;
    std::mutex spdmtx;
    bool fed = false;
    bool spdCanDisp = false;
    int64_t powerOnTimestamp = 0;   //点火开始时间戳
    int64_t travelBeginTimes = 0;   //短期记忆开始时间
    int64_t travelTimes = 0;   //短期记忆行驶时间(秒)
    int64_t lastTravelTimes = 0;   //短期记忆行驶时间(秒)
    float averageEnergyConsumption = 0.0;
    int64_t  lastMilliTime = 0;
    int64_t updateTravelTimes = -1;
    float powerOnMileage = 0;       //点火周期开始里程
    int32_t powerOnSts = 0;         //点火状态
    int32_t lastPowerOnSts = 0;     //上次电源状态
    int64_t power_on_milege_time = 0;     //短期记忆行驶里程更新时间
    int64_t power_on_average_speed_time = 0;     //短期记忆平均速度更新时间
    int64_t power_on_average_energy_consumption_time = 0;     //短期记忆平均电耗更新时间
    float consumption = 0.0;
    float updateaverageEnergy = 0;
    int32_t updateAverageSpd = -1024;
    float updatePowerOnMileage = -1024;


    int32_t monitorTime = 1;        // 监听时长为1秒
    float invalidValueFloat = -1024.0;
    int32_t invalidValueInt = -1024;

	  bool energyConsumptionFlag = false;   //统计电耗标志位
	  float totalEnergyConsumption = 0;     //点多周期内瞬时电耗总量  
    bool isEnergyConsumption = false;
    int32_t energyCount = 0;


    int32_t chraging_sunday_loop = 0;       //预约充电周日循环标识
    int32_t chraging_monday_loop = 0;
    int32_t chraging_tuesday_loop = 0;
    int32_t chraging_wednesday_loop = 0;
    int32_t chraging_thursday_loop = 0;
    int32_t chraging_friday_loop = 0;
    int32_t chraging_saturday_loop = 0;
    //档位更新时间
    std::mutex  bcTpmsTyrepressureFlMtx;
    std::condition_variable  bcTpmsTyrepressureFlCv;

    std::mutex  bcTpmsTyrepressureFrMtx;
    std::condition_variable  bcTpmsTyrepressureFrCv;

    std::mutex  bcTpmsTyrepressureRlMtx;
    std::condition_variable  bcTpmsTyrepressureRlCv;

    std::mutex  bcTpmsTyrepressureRrMtx; 
    std::condition_variable  bcTpmsTyrepressureRrCv;

    std::mutex eVcuChrgStsMtx;                  
    std::condition_variable ecVcuChrgStsCv;

		std::mutex 	bcTpmsTyretemperatureMtx;
		std::condition_variable bcTpmsTyretemperatureCv;
    std::mutex ecMomerMaxTempCellMtx;
    std::condition_variable ecMomerMaxTempCellCv;
    std::mutex ecMomerMinTempCellMtx;
    std::condition_variable ecMomerMinTempCellCv;
  private:
    int SpeedCalculate(float& speedvalue,float newvalue);
    void spdwatchDog();

    void can071_Watcher();
    void can30A_Watcher();
    void can30B_Watcher();
    void can30C_Watcher();

    void loopSendDynamicOrCTLC();
    // 监听充电状态在1秒中内是否有变化
    //void monitorChargState();
    // 监听轮胎温度在1秒中内是否有变化
    void monitorTpmsTyretemperatureState();
    // 监听单体电芯最高温度在1秒中内是否有变化
    void monitorMomerMaxTempCell();
    // 监听单体电芯最低温度在1秒中内是否有变化
    void monitorMomerMinTempCell();
    // 监听前左轮胎在1秒中内是否有变化
    void monitorTpmsTyrepressureFlState();
    // 监听前右轮胎在1秒中内是否有变化
    void monitorTpmsTyrepressureFrState();
    // 监听后左轮胎在1秒中内是否有变化
    void monitorTpmsTyrepressureRlState();
    // 监听后右轮胎在1秒中内是否有变化
    void monitorTpmsTyrepressureRrState();

    // 监听MCU电源状态
    void ev_vcu_mcu_power_statusWatcher();
    // 监听soc电源状态
    void ccm_soc_power_statusWatcher();
    int32_t wait_standby_Entry_condition();
    int32_t wait_active_Entry_condition();
    int32_t wait_SHUTDOWN_CANCELLED_condition();
    int32_t wait_SHUTDOWN_PREPARE_condition();
    int32_t wait_ON_condition();
    int32_t wait_FINISH_condition();
    int32_t wait_str_DEEP_SLEEP_Entry_condition();

    void HeartbeatTimeoutWatcher();
    void SpeedWatcher();
    void ec_vcu_d_cdischrg_permWatcher();
    void ec_vcu_pt_stWatcher();
    void ec_vcu_hvpowerWatcher();
    void ec_vcu_dcd_cworkenableWatcher();
    void ec_vcu_charallowWatcher();
    void ec_vcu_igonWatcher();
    void ec_vcu_sleepindicationsignalWatcher();
    void ec_vcu_livecounter_0x100Watcher();
    void ec_vcu_checksum_0x100Watcher();
    void ec_bms_heatrelaystatusWatcher();
    void ec_bms_cc2statusWatcher();
    void ec_bms_livecounter_0x120Watcher();
    void ec_bms_checksum_0x120Watcher();
    void ec_bms_batinsulatresistanceWatcher();
    void ec_bms_batterycurrentWatcher();
    void ec_bms_packvoltageWatcher();
    void ec_bms_packvoltage_vWatcher();
    void ec_bms_livecounter_0x125Watcher();
    void ec_bms_checksum_0x125Watcher();
    void ec_bms_remainingchargetimeWatcher();
    void ec_bms_batterysocWatcher();
    void ec_bms_livecounter_0x135Watcher();
    void ec_bms_checksum_0x135Watcher();
    void ec_mcu_motortorqueWatcher();
    void ec_mcu_motorspdWatcher();
    void ec_mcu_llivecounter_0x200Watcher();
    void ec_mcu_checksum_0x200Watcher();
    void ec_mcu_buscurrentWatcher();
    void ec_mcu_busvoltWatcher();
    void ec_mcu_llivecounter_0x201Watcher();
    void ec_mcu_checksum_0x201Watcher();
    void ec_mcu_err_codeWatcher();
    void ec_mcu_motortempWatcher();
    void ec_mcu_igbttempWatcher();
    void ec_mcu_motoropermodeWatcher();
    void ec_mcu_llivecounter_0x202Watcher();
    void ec_mcu_checksum_0x202Watcher();
    void ec_mcu_motor_fault_total_numWatcher();
    void ec_mcu_motor_stateWatcher();
    void ec_mcu_igbt_overheat_warningWatcher();
    void ec_mcu_motor_overheat_warningWatcher();
    void ec_mcu_llivecounter_0x203Watcher();
    void ec_mcu_checksum_0x203Watcher();
    void ec_ipu_smart_dc_stWatcher();
    void ec_ipu_livecounter_0x450Watcher();
    void ec_ipu_checksum_0x450Watcher();
    void ec_ipu_c_cresistancevalueWatcher();
    void ec_ipu_livecounter_0x470Watcher();
    void ec_ipu_checksum_0x470Watcher();
    void ec_ipu_ob_cinputvoltageWatcher();
    void ec_ipu_c_pdutycycleWatcher();
    void ec_ipu_ob_cinputcurrentWatcher();
    void ec_ipu_dcd_crealtimeopcurrWatcher();
    void ec_ipu_dcd_coperatingmodeWatcher();
    void ec_ipu_dcd_crealtimeopvoltWatcher();
    void ec_ipu_dcd_cbodytempWatcher();
    void ec_ipu_livecounter_0x490Watcher();
    void ec_ipu_checksum_0x490Watcher();
    void ec_ipu_dcdc_over_tempWatcher();
    void ec_bms_battery_pack_average_tempWatcher();
    void ec_bms_packtotalcellnumWatcher();
    void ec_bms_packtotaltempnumWatcher();
    void ec_bms_maxvoltcellpacknumWatcher();
    void ec_bms_minvoltcellpacknumWatcher();
    void ec_bms_livecounter_0x510Watcher();
    void ec_bms_checksum_0x510Watcher();
    void ec_bms_mintempmonomercellWatcher();
    void ec_bms_maxtempmonomercellWatcher();
    void ec_bms_maxtempcellWatcher();
    void ec_bms_mintempcellWatcher();
    void ec_bms_maxtempcellpacknumWatcher();
    void ec_bms_mintempcellpacknumWatcher();
    void ec_bms_deg_d_ccharsockettemp2Watcher();
    void ec_bms_deg_d_ccharsockettemp1Watcher();
    void ec_bms_livecounter0x511Watcher();
    void ec_bms_checksum_0x511Watcher();
    void ec_bms_minvoltmonomercellWatcher();
    void ec_bms_maxvoltmonomercellWatcher();
    void ec_bms_maxvoltcellWatcher();
    void ec_bms_minvoltcellWatcher();
    void ec_bms_livecounter_0x512Watcher();
    void ec_bms_checksum_0x512Watcher();
    void ec_bms_packratecapWatcher();
    void ec_bms_pack_rate_voltWatcher();
    void ec_bms_packrateenergyWatcher();
    void ec_bms_batt_typeWatcher();
    void ec_bms_battcooltypeWatcher();
    void ec_bms_livecounter_0x520Watcher();
    void ec_bms_checksum_0x520Watcher();
    void ec_bms_packudvoltWatcher();
    void ec_bms_packovervoltWatcher();
    void ec_bms_overtempWatcher();
    void ec_bms_deltatempWatcher();
    void ec_bms_lowinsresWatcher();
    void ec_bms_celludvoltWatcher();
    void ec_bms_cellovervoltWatcher();
    void ec_bms_packlowsocWatcher();
    void ec_bms_packfastchgsocWatcher();
    void ec_bms_packhighsocWatcher();
    void ec_bms_packoverchargeWatcher();
    void ec_bms_ucellinconWatcher();
    void ec_bms_thermalrunawayalarmWatcher();
    void ec_bms_h_vilfaultWatcher();
    void ec_bms_batsysnotmtcWatcher();
    void ec_bms_fault_codeWatcher();
    void ec_bms_batt_fault_total_numWatcher();
    void ec_bms_livecounter_0x522Watcher();
    void ec_bms_checksum_0x522Watcher();
    void ec_vcu_shif_faultWatcher();
    void ec_vcu_shift_positionWatcher();
    void ec_vcu_actual_gearWatcher();
    void ec_vcu_bp_statusWatcher();
    void ec_vcu_park_faultWatcher();
    void ec_vcu_park_stateWatcher();
    void ec_vcu_switch_gear_warnWatcher();
    void ec_vcu_delay_mon_modeWatcher();
    void ec_vcu_ap_statusWatcher();
    void ec_vcu_brk_lamp_ctr_cmdWatcher();
    void ec_vcu_lock_veh_warnWatcher();
    void ec_vcu_creep_stsWatcher();
    void ec_vcu_single_ped_stsWatcher();
    void ec_vcu_ap_faultWatcher();
    void ec_vcu_bp_faultWatcher();
    void ec_vcu_brk_pdl_posWatcher();
    void ec_vcu_livecounter_0x350Watcher();
    void ec_vcu_checksum_0x350Watcher();
    void ec_vcu_chrg_stsWatcher();
    void ec_vcu_chrg_cnctr_stsWatcher();
    void ec_vcu_pt_rdyWatcher();
    void ec_vcu_smart_dc_reqWatcher();
    void ec_vcu_chrg_soc_tar_spWatcher();
    void ec_vcu_dis_chrg_stsWatcher();
    void ec_vcu_dc_chrg_rly_stsWatcher();
    void ec_vcu_average_energy_consum_vdWatcher();
    void ec_vcu_dc_chrg_rly_auxil_cntac_stsWatcher();
    void ec_vcu_braking_remindWatcher();
    void ec_vcu_average_energy_consumptionWatcher();
    void ec_vcu_instant_energy_consumptionWatcher();
    void ec_vcu_instant_energy_consum_vdWatcher();
    void ec_vcu_chraging_mode_spWatcher();
    void ec_vcu_livecounter_0x351Watcher();
    void ec_vcu_checksum_0x351Watcher();
    void ec_ccm_veh_tar_socWatcher();
    void ec_ccm_batt_maintain_ctr_cmdWatcher();
    void ec_ota_modelWatcher();
    void ec_ccm_rechrgn_lv_reqWatcher();
    void ec_ccm_driver_buckle_statusWatcher();
    void ec_ccm_drive_mode_reqWatcher();
    void ec_ccm_operat_licenceWatcher();
    void ec_ccm_versionWatcher();
    void ec_ccm_speed_limit_levelWatcher();
    void ec_ccm_charging_conditionsWatcher();
    void ec_total_odometerWatcher();
    void ec_ccm_target_chrg_currWatcher();
    void ec_ccm_batt_maintain_stsWatcher();
    void ec_ccm_livecounter_0x353Watcher();
    void ec_ccm_checksum_0x353Watcher();
    void ec_ccm_remt_ctrl_flagWatcher();
    void ec_ccm_charging_requestWatcher();
    void ec_ccm_chraging_modeWatcher();
    void ec_ccm_energy_recov_level_cmdWatcher();
    void ec_ccm_creep_ctr_cmdWatcher();
    void ec_ccm_single_ped_ctr_cmdWatcher();
    void ec_ccm_rema_range_dispWatcher();
    void ec_ccm_rema_range_disp_vdWatcher();
    void ec_ccm_livecounter_0x354Watcher();
    void ec_ccm_checksum_0x354Watcher();
    void ec_vcu_drive_modeWatcher();
    void ec_vcu_low_soc_warnWatcher();
    void ec_vcu_can_timeout_faultWatcher();
    void ec_vcu_eas_ins_staWatcher();
    void ec_vcu_faultlevelWatcher();
    void ec_vcu_dc_discharging_fail_warnWatcher();
    void ec_vcu_dc_charging_fail_warnWatcher();
    void ec_vcu_ac_charging_fail_warnWatcher();
    void ec_vcu_12_v_charging_fail_warnWatcher();
    void ec_vcu_brak_sys_warnWatcher();
    void ec_vcu_veh_unable_dri_warnWatcher();
    void ec_vcu_brk_liquid_level_lowWatcher();
    void ec_vcu_vacum_pump_faultWatcher();
    void ec_vcu_mot_water_pump_statusWatcher();
    void ec_vcu_fault_codeWatcher();
    void ec_vcu_fault_treat_levelWatcher();
    void ec_vcu_drive_pwr_limWatcher();
    void ec_vcu_mcu_errWatcher();
    void ec_vcu_hv_batt_errWatcher();
    void ec_vcu_operat_licenceWatcher();
    void ec_vcu_versionWatcher();
    void ec_vcu_speed_limit_levelWatcher();
    void ec_vcu_charging_conditionsWatcher();
    void ec_vcu_livecounter_0x352Watcher();
    void ec_vcu_checksum_0x352Watcher();
    void ec_vcu_comp_neg_rel_staWatcher();
    void ec_vcu_comp_pos_rel_staWatcher();
    void ec_vcu_ipu_errWatcher();
    void ec_vcu_cooling_fail_warnWatcher();
    void ec_vcu_lv_elec_sys_errWatcher();
    void ec_vcu_ac_hv_sys_errWatcher();
    void ec_vcu_ptc2_rel_staWatcher();
    void ec_vcu_ptc1_rel_staWatcher();
    void ec_vcu_highpower_voltageWatcher();
    void ec_vcu_fan_relay_pin_stsWatcher();
    void ec_vcu_water_pump_relay_pin_stsWatcher();
    void ec_vcu_awake_obc_pin_stsWatcher();
    void ec_vcu_awake_bms_pin_stsWatcher();
    void ec_vcu_awake_mcu_pin_stsWatcher();
    void ec_vcu_main_relay_pin_stsWatcher();
    void ec_vcu_dc_chrg_awake_pin_stsWatcher();
    void ec_vcu_ac_chrg_awake_pin_stsWatcher();
    void ec_vcu_water_pump_pwmWatcher();
    void ec_vcu_power_supply_voltagWatcher();
    void ec_vcu_livecounter_0x215Watcher();
    void ec_vcu_checksum_0x215Watcher();
    void ec_vcu_pump_stateWatcher();
    void ec_vcu_mid_door_ajar_statusWatcher();
    void ec_vcu_actual_rema_range_vdWatcher();
    void ec_vcu_cltc_rema_range_vdWatcher();
    void ec_vcu_pt_cenableWatcher();
    void ec_vcu_accmenableWatcher();
    void ec_vcu_vehicle_spdWatcher();
    void ec_vcu_vehicle_spd_dspWatcher();
    //void HandlePowerOnspd(float speed);
    void ec_vcu_actual_rema_rangeWatcher();
    void ec_vcu_cltc_rema_rangeWatcher();
    void bcm_mcu_display_rangeWatcher();    
    void ec_vcu_livecounter_0x250Watcher();
    void ec_vcu_checksum_0x250Watcher();
    void ec_vcu_sofeware_numWatcher();
    void ec_vcu_hardware_numWatcher();
    void ec_vcu_yearWatcher();
    void ec_vcu_monthWatcher();
    void ec_vcu_dayWatcher();
    void ec_ccm_a_ckeyWatcher();
    void ec_ccm_ac_havc_stateWatcher();
    void ec_ccm_vehicle_spd_dspWatcher();
    void ec_ccm_livecounter_0x310Watcher();
    void ec_ccm_checksum_0x310Watcher();
    void ec_b2_v_v_frame_noWatcher();
    void ec_b2_v_v_cell_volt_n1Watcher();
    void ec_b2_v_v_cell_volt_n2Watcher();
    void ec_b2_v_v_cell_volt_n3Watcher();
    void ec_b2_v_t_frame_noWatcher();
    void ec_b2_v_t_cell_temp_n1Watcher();
    void ec_b2_v_t_cell_temp_n2Watcher();
    void ec_b2_v_t_cell_temp_n3Watcher();
    void ec_b2_v_t_cell_temp_n4Watcher();
    void ec_b2_v_t_cell_temp_n5Watcher();
    void ec_b2_v_t_cell_temp_n6Watcher();
    void ec_b2_v_t_cell_temp_n7Watcher();
    void ec_b2_v_gbsn_frame_noWatcher();
    void ec_b2_v_gbsn_sys_code_lengthWatcher();
    void ec_b2_v_gbsn_sys_code_1_7_13_19Watcher();
    void ec_b2_v_gbsn_sys_code_2_8_14_20Watcher();
    void ec_b2_v_gbsn_sys_code_3_9_15_21Watcher();
    void ec_b2_v_gbsn_sys_code_4_10_16_22Watcher();
    void ec_b2_v_gbsn_sys_code_5_11_17_23Watcher();
    void ec_b2_v_gbsn_sys_code_6_12_18_24Watcher();
    void ec_vcu_work_reqWatcher();
    void ec_vcu_livecounter_0x661Watcher();
    void ec_vcu_checksum_0x661Watcher();
    void ec_str_work_reqWatcher();
    void ec_ccm_nm_bitWatcher();
    void ec_ccm_livecounter_0x66_cWatcher();
    void ec_ccm_checksum_0x66_cWatcher();
    void ec_tbox_time_statusWatcher();
    void ec_tbox_yearWatcher();
    void ec_tbox_monthWatcher();
    void ec_tbox_dayWatcher();
    void ec_tbox_hourWatcher();
    void ec_tbox_minuteWatcher();
    void ec_tbox_secondWatcher();
    void ec_ccm_soc_sofeware_numWatcher();
    void ec_ccm_soc_hardware_numWatcher();
    void ec_ccm_mcu_sofeware_numWatcher();
    void ec_ccm_mcu_hardware_numWatcher();
    void ec_bms_batterysoc_virtualWatcher();
    void ec_bms_single_chrg_energyWatcher();
    void ec_bms_livecounter_0x513Watcher();
    void ec_bms_checksum_0x513Watcher();
    void ec_bms_batt_info4_dc_charg_req_currWatcher();
    void ec_bms_batt_info4_dc_charg_req_volWatcher();
    void ec_bms_batt_info4_mach_put_currWatcher();
    void ec_bms_batt_info4_mach_put_voltWatcher();
    void ec_tbox_cpu_temperature_lowWatcher();
    void ec_tbox_cpu_temperature_highWatcher();
    void ec_pcb_temperature_lowWatcher();
    void ec_pcb_temperature_highWatcher();
    void ec_main_power_supply_voltahe_lowWatcher();
    void ec_main_power_supply_voltahe_highWatcher();
    void ec_sim_card_not_presentWatcher();
    void ec_wifi_device_lostWatcher();
    void ec_ccm_detects_eas_node_lossWatcher();
    void ec_ccm_detects_bms_node_lossWatcher();
    void ec_ccm_detects_ipu_node_lossWatcher();
    void ec_ccm_detects_vcu_node_lossWatcher();
    void ec_private_can3_bus_offWatcher();
    void ec_private_can2_bus_offWatcher();
    void ec_private_can1_bus_offWatcher();
    void ec_detect_backup_battery_lostWatcher();
    void ec_ccm_detects_acu_node_lossWatcher();
    void ec_ccm_detects_bcm_node_lossWatcher();
    void ec_ccm_detects_ac_node_lossWatcher();
    void bc_eas_motspdWatcher();
    void bc_eas_eashvil_staWatcher();
    void bc_eas_crtstsWatcher();
    void bc_eas_ip_mtempWatcher();
    void bc_eas_ctrlrstsWatcher();
    void bc_eas_crtpwrWatcher();
    void bc_eas_ctrlrcrtWatcher();
    void bc_eas_ctrlrvoltWatcher();
    void bc_ac_blower_levelWatcher();
    void bc_ac_fan_reqWatcher();
    void bc_ac_fresh_reci_stateWatcher();
    void bc_ac_front_defrost_stateWatcher();
    void bc_ac_heat_stateWatcher();
    void bc_ac_havc_stateWatcher();
    void bc_ac_ai_rdistribution_modeWatcher();
    void bc_ac_a_cstateWatcher();
    void bc_ac_left_set_temperatureWatcher();
    void bc_ac_fan_pwmWatcher();
    void bc_ac_fan_feed_back_voltageWatcher();
    void bc_ac_pt_ctempWatcher();
    void bc_ac_fault_statusWatcher();
    void bc_ac_ptc_over_heatWatcher();
    void bc_ac_eas_speed_reqWatcher();
    void bc_ac_ptcp_power_reqWatcher();
    void bc_ac_press_swtich_stateWatcher();
    void bc_ac_livecounter_0x233Watcher();
    void bc_ac_checksum_0x233Watcher();
    void bc_ccm_fresh_reci_keyWatcher();
    void bc_ccm_front_defrost_keyWatcher();
    void bc_ccm_a_ckeyWatcher();
    void bc_ccm_blower_levelWatcher();
    void bc_ccm_ac_havc_stateWatcher();
    void bc_ccm_air_distribution_mode_reqWatcher();
    void bc_ccm_heat_keyWatcher();
    void bc_ccm_left_set_tempWatcher();
    void bc_ccm_avassetWatcher();
    void bc_ccm_livecounter_0x310Watcher();
    void bc_ccm_checksum_0x310Watcher();
    void bc_ccm_rear_fog_lamp_setWatcher();
    void bc_ccm_left_mirror_setWatcher();
    void bc_ccm_park_un_lock_reqWatcher();
    void bc_ccm_auto_lock_reqWatcher();
    void bc_ccm_auto_unlock_reqWatcher();
    void bc_ccm_remt_contr_lamp_ctr_cmdWatcher();
    void bc_ccu_remote_car_searchWatcher();
    void bc_ccu_remote_lockWatcher();
    void bc_ccm_right_mirror_setWatcher();
    void bc_ccm_livecounter_0x311Watcher();
    void bc_ccm_checksum_0x311Watcher();
    void bc_bcm_position_light_statusWatcher();
    void bc_bcm_high_beam_statusWatcher();
    void bc_bcm_low_beam_statusWatcher();
    void bc_bcm_turn_indcr_riWatcher();
    void bc_bcm_turn_indcr_leWatcher();
    void bc_bcm_hazard_light_statusWatcher();
    void bc_bcm_position_light_warningWatcher();
    void bc_bcm_rl_door_ajar_statusWatcher();
    void bc_bcm_rr_door_ajar_statusWatcher();
    void bc_bcm_fr_door_ajar_statusWatcher();
    void bc_bcm_fl_door_ajar_statusWatcher();
    void bc_bcm_rear_fog_light_statusWatcher();
    void bc_bcm_tr_cls_stWatcher();
    void bc_bcm_power_stsWatcher();
    void bc_bcm_ccm_open_door_warn_feedWatcher();
    void bc_bcm_dtc_fault_statusWatcher();
    void bc_bcm_veh_alrm_sys_stWatcher();
    void bc_bcm_drivelock_stWatcher();
    void bc_bcm_reversinglight_stWatcher();
    void bc_bcm_brakelight_stWatcher();
    void bc_bcm_interiorlight_stWatcher();
    void bc_bcm_right_mirror_set_ackWatcher();
    void bc_bcm_left_mirror_set_ackWatcher();
    void bc_bcm_park_un_lock_ackWatcher();
    void bc_bcm_auto_lock_ackWatcher();
    void bc_bcm_auto_unlock_ackWatcher();
    void bc_bcm_livecounter_0x330Watcher();
    void bc_bcm_checksum_0x330Watcher();
    void bc_bcm_high_beam_rly_errWatcher();
    void bc_bcm_turn_indcr_ri_errWatcher();
    void bc_bcm_turn_indcr_le_errWatcher();
    void bc_bcm_daytime_running_light_errWatcher();
    void bc_bcm_brakelight_errWatcher();
    void bc_bcm_reversinglight_errWatcher();
    void bc_bcm_rear_fog_light_errWatcher();
    void bc_bcm_loss_com_with_acuWatcher();
    int32_t getElectricErr();
    void bc_bcm_loss_com_with_ccmWatcher();
    void bc_bcm_loss_com_with_vcuWatcher();
    void bc_bcm_lv_batt_over_voltWatcher();
    void bc_bcm_lv_batt_under_voltWatcher();
    void bc_bcm_horn_rly_errWatcher();
    void bc_bcm_low_beam_rly_errWatcher();
    void bc_bcm_livecounter_0x331Watcher();
    void bc_bcm_checksum_0x331Watcher();
    void bc_pdc1_button_pressWatcher();
    void bc_pdc1_modeWatcher();
    void bc_pdc1_buzzer_alarm_patternWatcher();
    void bc_pdc1_distance_rmWatcher();
    void bc_pdc1_distance_rrmWatcher();
    void bc_pdc1_distance_rlWatcher();
    void bc_pdc1_distance_rrWatcher();
    void bc_pdc_livecounter_0x165Watcher();
    void bc_pdc_checksum_0x165Watcher();
    void bc_bcm_work_reqWatcher();
    void bc_bcm_livecounter_0x669Watcher();
    void bc_bcm_checksum_0x669Watcher();
    void bc_str_work_reqWatcher();
    void bc_ccm_nm_bitWatcher();
    void bc_ccm_livecounter_0x66_bWatcher();
    void bc_ccm_checksum_0x66_bWatcher();
    void bc_avas_stateWatcher();
    void bc_avas_livecounter_0x411Watcher();
    void bc_avas_checksum_0x411Watcher();
    void bc_bcm_ccm_reset_stWatcher();
    void bc_ota_modelWatcher();
    void bc_ccm_bcm_open_door_warn_setWatcher();
    void bc_ccm_livecounter_0x353Watcher();
    void bc_ccm_checksum_0x353Watcher();
    void bc_ccm_tpms_learning_validWatcher();
    void bc_ccm_remt_ctrl_flagWatcher();
    void bc_ccm_livecounter_0x354Watcher();
    void bc_ccm_checksum_0x354Watcher();
    void bc_tpms_receiverstateWatcher();
    void bc_tpms_transducer_locationWatcher();
    void bc_tpms_tyrestate_frWatcher();
    void bc_tpms_tyrestate_flWatcher();
    void bc_tpms_tyrestate_rlWatcher();
    void bc_tpms_tyrestate_rrWatcher();
    void bc_tpms_tyretemperatureWatcher();
    void bc_tpms_tyrepressure_flWatcher();
    void bc_tpms_tyrepressure_frWatcher();
    void bc_tpms_tyrepressure_rrWatcher();
    void bc_tpms_tyrepressure_rlWatcher();
    void cc_acu_gsensor_faultWatcher();
    void cc_acu_system_stsWatcher();
    void cc_acu_airb_warn_lamp_stWatcher();
    void cc_acu_crash_outp_stsWatcher();
    void cc_acu_livecounter_0x133Watcher();
    void cc_acu_checksum_0x133Watcher();
    void cc_abs_abs_fail_statusWatcher();
    void cc_abs_llivecounter_0x171Watcher();
    void cc_abs_checksum_0x171Watcher();
    void cc_eps_run_stateWatcher();
    void cc_eps_livecounter_0x300Watcher();
    void cc_eps_checksum_0x300Watcher();
    void cc_eps_motor_curr_fltWatcher();
    void cc_eps_motor_volt_fltWatcher();
    void cc_eps_torq_snr_s_sig_out_rng_fltWatcher();
    void cc_eps_torq_snr_p_sig_out_rng_fltWatcher();
    void cc_eps_torq_snr_t1_t2_sig_sync_fltWatcher();
    void cc_eps_torq_snr_t1_sig_out_rng_fltWatcher();
    void cc_eps_torq_snr_t2_sig_out_rng_fltWatcher();
    void cc_eps_torq_snr5_v_fltWatcher();
    void cc_eps_can_bus_fltWatcher();
    void cc_eps_over_volt_fltWatcher();
    void cc_eps_under_volt_fltWatcher();
    void cc_eps_uncalibrated_angle_fltWatcher();
    void cc_eps_over_heat_fltWatcher();
    void cc_eps_relay_fltWatcher();
    void cc_eps_motor_curr_fellow_fltWatcher();
    void cc_eps_motor_drv_fltWatcher();
    void cc_eps_vcu_time_out_fltWatcher();
    void cc_eps_livecounter_0x301Watcher();
    void cc_eps_checksum_0x301Watcher();
    void cc_abs_wheel_speed_fr_no_signal_errWatcher();
    void cc_abs_wheel_speed_fr_interm_errWatcher();
    void cc_abs_wheel_speed_fr_open_short_errWatcher();
    void cc_abs_wheel_speed_fl_no_signal_errWatcher();
    void cc_abs_wheel_speed_fl_interm_errWatcher();
    void cc_abs_wheel_speed_fl_open_short_errWatcher();
    void cc_abs_power_undervoltWatcher();
    void cc_abs_power_overvoltWatcher();
    void cc_abs_valve_relay_errWatcher();
    void cc_abs_wheel_speed_freq_errWatcher();
    void cc_abs_wheel_speed_rr_no_signal_errWatcher();
    void cc_abs_wheel_speed_rr_interm_errWatcher();
    void cc_abs_wheel_speed_rr_open_short_errWatcher();
    void cc_abs_wheel_speed_rl_no_signal_errWatcher();
    void cc_abs_wheel_speed_rl_interm_errWatcher();
    void cc_abs_wheel_speed_rl_open_short_errWatcher();
    void cc_abs_outlet_valve_rr_errWatcher();
    void cc_abs_inlet_valve_rr_errWatcher();
    void cc_abs_outlet_valve_rl_errWatcher();
    void cc_abs_inlet_valve_rl_errWatcher();
    void cc_abs_outlet_valve_fr_errWatcher();
    void cc_abs_inlet_valve_fr_errWatcher();
    void cc_abs_outlet_valve_fl_errWatcher();
    void cc_abs_inlet_valve_fl_errWatcher();
    void cc_abs_current_max_fault_levelWatcher();
    void cc_abs_can_bus_off_errWatcher();
    void cc_abs_can_hardware_errWatcher();
    void cc_abs_ecu_hardware_errWatcher();
    void cc_abs_motor_relay_errWatcher();
    void cc_abs_motor_errWatcher();
    void cc_abs_valve_errWatcher();
    void cc_abs_livecounter_0x420Watcher();
    void cc_abs_checksum_0x420Watcher();
    void mc_lamplet_statusWatcher();
    void mc_main_seat_pressure_statusWatcher();
    void mc_brake_level_alarm_statusWatcher();
    void mc_main_seat_safety_belt_statusWatcher();
    void mc_engine_statusWatcher();
    void mc_low_vol_battery_volWatcher();
	void mc_key_previous_songWatcher();
    void mc_key_next_songWatcher();
    void mc_key_volume_upWatcher();
    void mc_key_volume_dowmWatcher();
    void mc_key_mode_muteWatcher();
    void mc_key_telephoneWatcher();
    void mc_key_voiceWatcher();
    void mc_key_homeWatcher();
    void mc_key_customWatcher();
    void mc_key_distanceWatcher();
    void mc_key_speedupWatcher();
    void mc_key_speeddownWatcher();
    void mc_key_pagedownWatcher();
    void mc_key_pageupWatcher();
    void mc_key_okayWatcher();
    void mc_key_long_volume_upWatcher();
    void mc_key_long_volume_dowmWatcher();
    void mc_key_long_telephoneWatcher();
    void mc_key_long_customWatcher();
    void mc_key_long_previous_songWatcher();
    void mc_key_long_next_songWatcher();
    void mc_light_levelWatcher();
    void sc_ec_ccm_batt_maintain_ctr_cmdWatcher();
    void sc_ec_ccm_batt_maintain_stsWatcher();
    void sc_ec_ccm_versionWatcher();
    void sc_ec_ccm_soc_sofeware_numWatcher();
    void sc_ec_ccm_soc_hardware_numWatcher();
    void sc_ec_ccm_mcu_software_numWatcher();
    void sc_ec_ccm_mcu_hardware_numWatcher();
    void sc_ec_ccm_target_chrg_currWatcher();
    void sc_ccm_remote_lockWatcher();
    void sc_ccm_remote_car_searchWatcher();
    void sc_ccm_remt_ctrl_flagWatcher();
    void sc_ec_ccm_operat_licenceWatcher();
    void ec_bms_realtimealowdischapowerWatcher();
    void ec_ipu_ipuhvil_staWatcher();
    void ec_ipu_mainrelayposistatusWatcher();
    void ec_ipu_workstatusWatcher();
    void ec_vcu_tqreqWatcher();
    void ec_bms_softwareversionWatcher();
    void ec_ipu_hardware_numWatcher();
    void ec_ipu_sofeware_numWatcher();
    void interval_time();
    float getActualFloatValue(int32_t raw_value, float factor, int offset);
    float getActualFloatValue_offset_is_float(int32_t raw_value, float factor, float offset);
    void ccm_appointment_mode();
    void ccm_chraging_begin_time_hour();
    void ccm_chraging_begin_time_minute();
    void ccm_chraging_end_time_hour();
    void ccm_chraging_end_time_minute();
    void ccm_chraging_sunday_loop();
    void ccm_chraging_monday_loop();
    void ccm_chraging_tuesday_loop();
    void ccm_chraging_wednesday_loop();
    void ccm_chraging_thursday_loop();
    void ccm_chraging_friday_loop();
    void ccm_chraging_saturday_loop();
    void ccm_chraging_target_soc();
    void ec_ipu_obc_output_voltageWatcher();
    void ec_ipu_obc_output_currentWatcher();
    void ec_bms_mainrelaynega_statusWatcher();
    void ec_bms_batterysohWatcher();
    void ec_bms_soeWatcher();
    void ec_bms_hv_batt_stWatcher();		
    void ec_bms_initstatusWatcher();
    void bcm_rear_fog_light_errWatcher();	       
    void bcm_reversinglight_errWatcher();	       
    void bcm_brakelight_errWatcher();	           
    void bcm_daytime_running_light_errWatcher();	
    void bcm_position_light_errWatcher();	       
    void bcm_turn_indcr_le_errWatcher();	        
    void bcm_turn_indcr_ri_errWatcher();	        
    void bcm_high_beam_rly_errWatcher();	        
    void bcm_low_beam_rly_errWatcher();
    void mcu_voiume_navigationWatcher();
    void mcu_voiume_voicWatcher();
    void mcu_voiume_multimediaWatcher();
    void mcu_voiume_phoneWatcher();
    void mcu_voiume_alarmWatcher();
    void mcu_voiume_keyWatcher();  	                		
    void mcu_info_vin1Watcher();
    void mcu_info_vin2Watcher();
    void mcu_info_vin3Watcher();
    void mcu_info_vinWatcher();
    void mcu_info_sn1Watcher();
    void mcu_info_sn2Watcher();
    void mcu_info_sn3Watcher();
    void mcu_info_versionWatcher();
    void mc_travel_rangeWatcher();
    void mc_travel_timeWatcher();
    void mc_average_energy_consumptionWatcher();
    void rangeModeSet();
    void gecko_headlighthSet();
    void mc_remind_inrWatcher();
    void mc_remind_start_timeWatcher();
    void mc_remind_distanceWatcher();
    void mc_remind_start_odoWatcher();
    void bc_ac_hybrid_eco_mode_staWatcher();
    void bc_bcm_wipr_intl_time_set_fbWatcher();
    void bc_bcm_flwr_me_hm_ctrl_fbWatcher();
    void bc_bcm_illmnd_unlock_sts_fbWatcher();
    void bc_bcm_illmnd_lock_sts_fbWatcher();
    void bc_bcm_lock_horn_on_st_fbWatcher();
    void ec_esc_esc_disableWatcher();
    void ec_ehb_avh_appld_stWatcher();
    void ec_ehb_epb_system_stateWatcher();
    void ec_ehb_brk_dis_wip_acWatcher();
    void ec_elec_steer_mode_staWatcher();
    void bc_veh_act_recuperate_pwrWatcher();
    void ec_vehicle_driving_pwrWatcher();
    void ec_srs_passenger_airbag_sta_rsvrWatcher();
    void bc_bcm_front_fog_light_statusWatcher();
    void bc_bcm_key_lo_batt_lvl_warnWatcher();
    void bc_bcm_warn_no_key_foundWatcher();
    void bc_bcm_auto_lamp_statusWatcher();
    void bc_bcm_indication_shiftto_neutralWatcher();
    void ec_vcu_12_v_bat_low_vol_staWatcher();
    void ec_vcu_sibs_kl30_voltageWatcher();
    void ec_srs_airbag_warning_lamp_stsWatcher();
    void ec_srs_drv_seatbelt_buckle_validWatcher();
    void ec_ipu_obc_inlet_connect_staWatcher();
    void ec_bms_dcs_inlet_connect_staWatcher();
    void ec_bms_pwr_train_connect_staWatcher();
    void ec_ehb_brake_liquid_level_warnWatcher();
    void ec_esc_ebd_failedWatcher();
    void ec_vcu_vhcl_p_gear_errorWatcher();
    void ec_vcu_motor_high_temp_wrningWatcher();
    void ec_vcu_mcu_high_temp_wrningWatcher();
    void ec_bcm_central_lock_stsWatcher();
    void ec_vcu_pcu_fail_staWatcher();
    void bc_bcm_warn_key_out_reminderWatcher();
    void bc_bcm_light_intensityWatcher();
    void bc_bcm_indication_key_closerWatcher();
    void ec_srs_pass_seatbelt_bucklestatusWatcher();
    void ec_srs_pass_seatbelt_buckle_validWatcher();
    void ec_srs_pass_seat_occupant_sensor_stsWatcher();
    void ec_srs_mid_seat_belt_bucklestatusWatcher();
    void ec_srs_mid_seat_belt_buckle_validWatcher();
    void ec_srs_mid_seat_occupant_sensor_stsWatcher();
    void ec_ipu_obc_actl_oprt_modeWatcher();
    void ec_bms_dcs_act_oprt_modeWatcher();
    void ec_vcu_reserve_powerWatcher();
    void ec_vcu_motor_actual_powerWatcher();
    void ec_vcu_motor_actual_power_typeWatcher();
    void ec_vcu_hdc_statusWatcher();
    void ec_esc_es_cor_tcs_failedWatcher();
    void ec_esc_tcs_active_staWatcher();
    void ec_esc_esp_active_staWatcher();
    void ec_ehb_avh_lamp_reqWatcher();
    void ec_ehb_epb_display_msg_idWatcher();
    void ec_ehb_avh_disp_msgWatcher();
    void ec_ehb_epb_warn_lamp_staWatcher();
    void ec_vcu_obc_oprt_cmd_to_icuWatcher();
    void bc_ac_envir_temp_vWatcher();
    void bc_ac_envir_tempWatcher();
    void config_query_sim_cardWatcher();
    void config_query_4g_strengthWatcher();
    void config_query_wifi_strengthWatcher();
    void config_query_wifi_statusWatcher();
    void config_query_gps_lonWatcher();
    void config_query_gps_latWatcher();
    void vcu_chraging_mode_sp_reqWatcher();
     void bc_pp_fl_distWatcher();
     void bc_pp_fml_distWatcher();
     void bc_pp_fmr_distWatcher();
     void bc_pp_fr_distWatcher();
     void bc_pp_sdwfsl_distWatcher();
     void bc_pp_sdwfsl_mid_distWatcher();
     void bc_pp_sdwfsr_mid_distWatcher();
     void bc_pp_sensor_fault_sts_frmWatcher();
     void bc_pp_sensor_fault_sts_frWatcher();
     void bc_pp_sdwrsr_distWatcher();
     void bc_pp_staWatcher();
     void bc_pp_sw_fdbkWatcher();
     void bc_fcm_elk_set_fbWatcher();
     void bc_fcm_aeb_set_fbWatcher();
     void bc_fcm_hma_set_fbWatcher();
     void bc_fcm_tsr_spd_lim_warnWatcher();
     void bc_fcm_tsr_spd_lim_warn_auWatcher();
     void bc_fcm_tsr_spd_lim_stsWatcher();
     void bc_fcm_slwf_set_fbWatcher();
     void bc_fcm_fcm_intializationWatcher();
     void bc_fcm_elk_left_modeWatcher();
     void bc_fcm_elk_right_modeWatcher();
     void bc_fcm_slif_set_fbWatcher();
     void bc_fcm_trfc_signWatcher();
     void bc_fcm_tsr_lgt_dstWatcher();
     void bc_fcm_tsr_lat_dstWatcher();
     void bc_fcm_tsr_set_fbWatcher();
     void bc_fcm_tsr_spd_limWatcher();
     void bc_fcm_slif_oper_stsWatcher();
     void bc_fcm_audio_warn_hands_offWatcher();
     void bc_fcm_fault_text_infoWatcher();
     void bc_fcm_lka_audio_warningWatcher();
     void bc_fcm_act_drv_asst_sts_hmiWatcher();
     void bc_fcm_tar_obj_accWatcher();
     void bc_fcm_adas_not_avl_reasWatcher();
     void bc_fcm_acc_startWatcher();
     void bc_fcm_ica_truck_set_fbWatcher();
     void bc_fcm_ica_set_fbWatcher();
     void bc_fcm_adas_quit_reasWatcher();
     void bc_fcm_acc_mode_hmiWatcher();
     void bc_fcm_pcw_pre_warnWatcher();
     void bc_fcm_pcw_latent_warnWatcher();
     void bc_fcm_text_info_lka1Watcher();
     void bc_fcm_ldw_stsWatcher();
     void bc_fcm_ldw_set_fbWatcher();
     void bc_fcm_lka_stsWatcher();
     void bc_fcm_le_line_color_fctWatcher();
     void bc_fcm_lka_set_fbWatcher();
     void bc_fcm_ri_line_color_fctWatcher();
     void bc_fcm_ldw_alert_method_set_fbWatcher();
     void bc_fcm_v_set_disWatcher();
     void bc_fcm_aeb_obj_idWatcher();
     void bc_fcm_raeb_work_stsWatcher();
     void bc_fcm_ldw_audio_warnWatcher();
     void bc_fcm_laterallimitWatcher();
     void ec_ipu_obc_inlelt_actl_powerWatcher();
     void ec_srs_crash_output_stsWatcher();
     void ec_bms_insulation_wrning_distgshWatcher();
     void ec_bms_thermalrunaway_wrnWatcher();
     void ec_bms_dcs_actl_chrg_voltageWatcher();
     void ec_icu_vehicle_speed_displayed_vWatcher();
     void ec_icu_icu_trip_a_odometerWatcher();
     void ec_icu_icu_trip_b_odometerWatcher();
     void cc_eps_basic_elec_steer_failedWatcher();
     void cc_eps_mode_set_inhibit_fbWatcher();
     void cc_eps_sws_hod_hands_off_stsWatcher();
     void bc_vcu_info_dispWatcher();
     void bc_vcu_vhcl_speed_fast_warnWatcher();
     void bc_vcu_drive_mode_key_stagnationWatcher();
     void bc_vcu_cc_key_stagnationWatcher();
     void bc_vcu_shift_key_stagnationWatcher();
     void bc_vcu_lock_veh_warmWatcher();
     void bc_vcu_sibs_kl30_voltageWatcher();
     void bc_vcu_sibs_rtcwu_chg_numWatcher();
     void bc_vcu_sibs_chg_num_allowWatcher();
     void bc_vcu_sibs_rtcwu_chg_fail_numWatcher();
     void bc_vcu_sibs_rtc_chrg_stWatcher();
     void bc_vcu_sibs_wup_volt_allowWatcher();
     void bc_vcu_sibs_bms_bat_soc_allowWatcher();
     void bc_vcu_sibs_fb_rtc_wup_flgWatcher();
     void bc_vcu_ac_chrg_max_currWatcher();
     void bc_vcu_ac_chrg_modeWatcher();
     void bc_ccu_open_ventilation_fbWatcher();
     void bc_ac_ac_unlock_vent_set_fbWatcher();
     void bc_ac_remote_defrost_ctl_fbWatcher();
     void bc_ac_temp_set_fbWatcher();
     void bc_ac_remt_ctrl_fbWatcher();
     void bc_ccu_remote_power_lock_fbWatcher();
     void bc_vcu_speed_limit_level_fbWatcher();
     void bc_vcu_operat_licence_fbWatcher();
     void bc_vcu_version_fbWatcher();
     void bc_vcu_vesion_set_fbWatcher();
     void bc_vcu_wgh_confdenceWatcher();
     void bc_vcu_wgh_estWatcher();
     void bc_vcu_wgh_distbWatcher();
     void bc_vcu_cruise_ctrl_sta_for_bacWatcher();
     void bc_vcu_cruise_ctr_tgt_spd_for_bacWatcher();
     void bc_ac_indoor_tempWatcher();
     void bc_bcm_light_sw_sigWatcher();
     void bc_bcm_ajar_sta_hoodWatcher();
     void bc_tmps_abnm_prsr_warnWatcher();
     void bc_bcm_tpms_reset_stsWatcher();
     void bc_bcm_fr_windowmotor_flagsWatcher();
     void bc_bcm_fl_windowmotor_flagsWatcher();
     void bc_bcm_wash_liquid_level_warnWatcher();
     void bc_bcm_front_wash_stsWatcher();
     void bc_bcm_pas_wdw_initWatcher();
     void bc_bcm_drv_pass_win_sw_sigWatcher();
     void bc_bcm_body_warn_stsWatcher();
     void bc_bcm_key_in_car_staWatcher();
     void bc_bcm_ps_authent_resWatcher();
     void bc_bcm_trunk_lock_sw_ctrl_fbWatcher();
     void bc_bcm_trunk_lock_staWatcher();
     void bc_bcm_overspd_cntrl_lock_set_fbWatcher();
     void bc_bcm_park_auto_unlock_set_fbWatcher();
     void bc_bcm_chg_wiper_mt_md_sw_set_fbWatcher();
     void bc_drv_lf_ant_diag_statusWatcher();
     void bc_bcm_lf_init_staWatcher();
     void bc_bcm_door_lock_operation_recordWatcher();
     void bc_int_lf_ant_diag_statusWatcher();
     void bc_pass_lf_ant_diag_statusWatcher();
     void bc_bcm_illmnd_entry_sts_fbWatcher();
     void bc_bcm_steer_whl_tempWatcher();
     void bc_bcm_steer_whl_heat_stsWatcher();
     void bc_bcm_rear_mirror_heat_stsWatcher();
     void bc_bcm_mai_drvr_seat_tempWatcher();
     void bc_bcm_mai_drvr_seat_stsWatcher();
     void bc_bcm_logo_active_flagWatcher();
     void bc_bcm_rf_init_staWatcher();
     void bc_bcm_rear_fog_li_fault_fbWatcher();
     void bc_bcm_front_fog_li_fault_fbWatcher();
     void bc_bcm_pos_li_fault_fbWatcher();
     void bc_bcm_back_li_fault_fbWatcher();
     void bc_bcm_brake_li_fault_fbWatcher();
     void bc_bcm_reverse_li_fault_fbWatcher();
     void bc_bcm_day_run_li_fault_fbWatcher();
     void ec_ehb_epb_flt_stsWatcher();
     void ec_ehb_epb_switch_stsWatcher();
     void ec_ehb_failure_stsWatcher();
     void ec_vcu_vhcl_actl_gear_pos_vWatcher();
     void ec_bcm_sys_pwr_mode_vWatcher();
     void ec_bcm_sys_pwr_modeWatcher();
     void ec_bcm_sys_power_stsWatcher();
     void ec_bcm_door_lock_sta_flWatcher();
     void ec_vcu_pwr_recup_intensityWatcher();
     void ec_ccu_diag_tester_onlineWatcher();
     void ec_bcm_back_ladjval_fbWatcher();
     void ec_esc_rmi_active_staWatcher();
     void ec_esc_slope_percent_vWatcher();
     void ec_esc_slope_percentWatcher();
     void ec_inv_antithft_auth_rsltWatcher();
     void bc_ac_auto_blower_mode_staWatcher();
     void bc_fcm_fcw_set_fbWatcher();
     void bc_ac_extd_defrost_actv_reqWatcher();
     void ec_scs_left_swt_vdWatcher();
     void ec_scs_left_1_swtWatcher();
     void ec_scs_left_2_swtWatcher();
     void ec_scs_left_3_swtWatcher();
     void ec_scs_left_4_swtWatcher();
     void ec_scs_left_5_swtWatcher();
     void ec_scs_left_6_swtWatcher();
     void ec_scs_left_7_swtWatcher();
     void ec_scs_left_8_swtWatcher();
     void ec_avas_state_rolling_counterWatcher();
     void ec_bms_current_over_wrningWatcher();
     void ec_bms_battery_sub_sys_numWatcher();
     void ec_bms_battery_sub_sys_codWatcher();
     void ec_bms_battery_dtc_numWatcher();
     void ec_bms_battery_dtc_listWatcher();
     void ec_bms_battery_dtc_indexWatcher();
     void ec_inv_1_rolling_counterWatcher();
     void ec_inv_4_err_bitsWatcher();
     void ec_inv_4_rolling_counterWatcher();
     void ec_scs_right_swt_vdWatcher();
     void ec_scs_right_14_swtWatcher();
     void ec_scs_right_15_swtWatcher();
     void ec_scs_right_16_swtWatcher();
     void ec_crrr_bsd_warn_rightWatcher();
     void ec_crrr_bsd_warn_leftWatcher();
     void ec_crrr_bsd_set_fbWatcher();
     void ec_crrr_rcta_warn_rightWatcher();
     void ec_crrr_rcta_warn_leftWatcher();
     void ec_crrr_rcta_set_fbWatcher();
     void ec_crrr_rcw_warningWatcher();
     void ec_crrr_rcw_set_fbWatcher();
     void ec_crrr_rear_corner_failureWatcher();
     void ec_crrr_rear_corner_blindnessWatcher();
     void ec_crrr_dow_set_fbWatcher();
     void ec_crrr_dow_warn_frWatcher();
     void ec_crrr_dow_warn_flWatcher();
     void ec_crrr_dow_warn_rrWatcher();
     void ec_crrr_dow_warn_rlWatcher();
     void ec_crrr_dow_warn_rightWatcher();
     void ec_crrr_dow_warn_leftWatcher();
     void ec_fcm_obj_typ1Watcher();
     void ec_fcm_obj_lat_dst1Watcher();
     void ec_fcm_obj_lgt_dst1Watcher();
     void ec_fcm_lgt_rel_spd1Watcher();
     void ec_fcm_obj_posn_agl1Watcher();
     void ec_fcm_lgt_rel_spd7Watcher();
     void ec_fcm_obj_movmt_dir1Watcher();
     void ec_fcm_lgt_rel_spd8Watcher();
     void ec_fcm_obj_movmt_sta1Watcher();
     void ec_fcm_obj_typ2Watcher();
     void ec_fcm_obj_lat_dst2Watcher();
     void ec_fcm_obj_lgt_dst2Watcher();
     void ec_fcm_obj_posn_agl2Watcher();
     void ec_fcm_lgt_rel_spd2Watcher();
     void ec_fcm_lgt_rel_spd9Watcher();
     void ec_fcm_obj_movmt_dir2Watcher();
     void ec_fcm_obj_movmt_sta2Watcher();
     void ec_fcm_obj_typ3Watcher();
     void ec_fcm_obj_lat_dst3Watcher();
     void ec_fcm_obj_lgt_dst3Watcher();
     void ec_fcm_obj_posn_agl3Watcher();
     void ec_fcm_lgt_rel_spd3Watcher();
     void ec_fcm_obj_movmt_dir3Watcher();
     void ec_fcm_obj_movmt_sta3Watcher();
     void ec_fcm_obj_typ4Watcher();
     void ec_fcm_obj_lat_dst4Watcher();
     void ec_fcm_obj_lgt_dst4Watcher();
     void ec_fcm_obj_posn_agl4Watcher();
     void ec_fcm_lgt_rel_spd4Watcher();
     void ec_fcm_obj_movmt_sta4Watcher();
     void ec_fcm_obj_movmt_dir4Watcher();
     void ec_fcm_obj_movmt_dir7Watcher();
     void ec_fcm_obj_typ5Watcher();
     void ec_fcm_obj_lat_dst5Watcher();
     void ec_fcm_obj_lgt_dst5Watcher();
     void ec_fcm_obj_posn_agl5Watcher();
     void ec_fcm_lgt_rel_spd5Watcher();
     void ec_fcm_obj_movmt_dir5Watcher();
     void ec_fcm_obj_movmt_sta5Watcher();
     void ec_fcm_obj_movmt_sta9Watcher();
     void ec_fcm_obj_typ6Watcher();
     void ec_fcm_obj_lat_dst6Watcher();
     void ec_fcm_obj_lgt_dst6Watcher();
     void ec_fcm_obj_posn_agl6Watcher();
     void ec_fcm_lgt_rel_spd6Watcher();
     void ec_fcm_obj_movmt_dir9Watcher();
     void ec_fcm_obj_movmt_sta6Watcher();
     void ec_fcm_obj_movmt_dir6Watcher();
     void ec_fcm_obj_typ7Watcher();
     void ec_fcm_obj_lat_dst7Watcher();
     void ec_fcm_obj_lgt_dst7Watcher();
     void ec_fcm_obj_posn_agl7Watcher();
     void ec_fcm_obj_movmt_sta7Watcher();
     void ec_fcm_obj_lat_dst8Watcher();
     void ec_fcm_obj_lgt_dst8Watcher();
     void ec_fcm_obj_typ8Watcher();
     void ec_fcm_obj_typ9Watcher();
     void ec_fcm_obj_movmt_sta8Watcher();
     void ec_fcm_obj_posn_agl8Watcher();
     void ec_fcm_obj_lat_dst9Watcher();
     void ec_fcm_obj_lgt_dst9Watcher();
     void ec_fcm_obj_posn_agl9Watcher();
     void ec_fcm_obj_movmt_dir8Watcher();
     void ec_fcm_obj_typ10Watcher();
     void ec_fcm_obj_lat_dst10Watcher();
     void ec_fcm_obj_lgt_dst10Watcher();
     void ec_fcm_obj_posn_agl10Watcher();
     void ec_fcm_obj_movmt_sta10Watcher();
     void ec_fcm_obj_lat_dst11Watcher();
     void ec_fcm_obj_lgt_dst11Watcher();
     void ec_fcm_obj_typ11Watcher();
     void ec_fcm_obj_posn_agl11Watcher();
     void ec_fcm_obj_movmt_sta11Watcher();
     void ec_fcm_obj_lat_dst12Watcher();
     void ec_fcm_obj_lgt_dst12Watcher();
     void ec_fcm_obj_typ12Watcher();
     void ec_fcm_obj_movmt_dir11Watcher();
     void ec_fcm_obj_posn_agl12Watcher();
     void ec_fcm_obj_typ13Watcher();
     void ec_fcm_obj_lat_dst13Watcher();
     void ec_fcm_obj_lgt_dst13Watcher();
     void ec_fcm_obj_movmt_sta13Watcher();
     void ec_fcm_obj_posn_agl13Watcher();
     void ec_fcm_obj_lat_dst14Watcher();
     void ec_fcm_obj_lgt_dst14Watcher();
     void ec_fcm_obj_typ14Watcher();
     void ec_fcm_obj_movmt_sta14Watcher();
     void ec_fcm_obj_posn_agl14Watcher();
     void ec_fcm_obj_lat_dst15Watcher();
     void ec_fcm_obj_lgt_dst15Watcher();
     void ec_fcm_obj_typ15Watcher();
     void ec_fcm_obj_movmt_dir14Watcher();
     void ec_fcm_obj_posn_agl15Watcher();
     void ec_fcm_obj_typ16Watcher();
     void ec_fcm_obj_lat_dst16Watcher();
     void ec_fcm_obj_lgt_dst16Watcher();
     void ec_fcm_obj_lat_dst17Watcher();
     void ec_fcm_obj_lgt_dst17Watcher();
     void ec_fcm_obj_movmt_sta16Watcher();
     void ec_fcm_obj_movmt_dir16Watcher();
     void ec_fcm_obj_typ17Watcher();
     void ec_fcm_obj_typ18Watcher();
     void ec_fcm_obj_movmt_sta17Watcher();
     void ec_fcm_obj_lat_dst18Watcher();
     void ec_fcm_obj_lgt_dst18Watcher();
     void ec_fcm_obj_posn_agl18Watcher();
     void ec_fcm_obj_movmt_dir17Watcher();
     void ec_fcm_obj_movmt_dir18Watcher();
     void ec_fcm_obj_movmt_sta18Watcher();
     void ec_fcm_lgt_rel_spd10Watcher();
     void ec_fcm_obj_posn_agl16Watcher();
     void ec_fcm_lgt_rel_spd11Watcher();
     void ec_fcm_obj_posn_agl17Watcher();
     void ec_fcm_lgt_rel_spd12Watcher();
     void ec_fcm_lgt_rel_spd13Watcher();
     void ec_fcm_obj_movmt_dir10Watcher();
     void ec_fcm_lgt_rel_spd14Watcher();
     void ec_fcm_obj_movmt_sta12Watcher();
     void ec_fcm_lgt_rel_spd15Watcher();
     void ec_fcm_obj_movmt_dir12Watcher();
     void ec_fcm_lgt_rel_spd16Watcher();
     void ec_fcm_obj_movmt_dir13Watcher();
     void ec_fcm_obj_movmt_sta15Watcher();
     void ec_fcm_lgt_rel_spd17Watcher();
     void ec_fcm_lgt_rel_spd18Watcher();
     void ec_fcm_obj_movmt_dir15Watcher();
     void ec_fcm_nr_of_lineWatcher();
     void ec_fcm_le_line_typWatcher();
     void ec_fcm_le_line_rdWatcher();
     void ec_fcm_le_line_dstWatcher();
     void ec_fcm_le_line_c1Watcher();
     void ec_fcm_le_line_c2Watcher();
     void ec_fcm_ri_line_typWatcher();
     void ec_fcm_le_line_c3Watcher();
     void ec_fcm_ri_line_rdWatcher();
     void ec_fcm_ri_line_dstWatcher();
     void ec_fcm_ri_line_c1Watcher();
     void ec_fcm_ri_line_c3Watcher();
     void ec_fcm_ri_line_c2Watcher();
     void ec_fcm_le_le_line_typWatcher();
     void ec_fcm_le_le_line_c1Watcher();
     void ec_fcm_le_le_line_c3Watcher();
     void ec_fcm_le_le_line_rdWatcher();
     void ec_fcm_le_le_line_dstWatcher();
     void ec_fcm_ri_ri_line_c1Watcher();
     void ec_fcm_ri_ri_line_c3Watcher();
     void ec_fcm_ri_ri_line_rdWatcher();
     void ec_fcm_ri_ri_line_dstWatcher();
     void ec_fcm_ri_ri_line_typWatcher();
     void ec_fcm_le_le_line_c2Watcher();
     void ec_fcm_ri_ri_line_c2Watcher();
     void ec_fcm_spd_downin_cor_sfkWatcher();
     void bc_vcu_speed_limit_level_set_fbWatcher();
     void ec_esc_abs_active_staWatcher();
     void ec_ipu_dcc_actl_oprt_modeWatcher();
     void ec_ipu_over_temperature_failWatcher();
     void ec_vcu_accl_pedal_posWatcher();
     void ec_vcu_brk_pedal_posWatcher();
     void ec_bms_iso_resistanceWatcher();
     void ec_ehb_brk_pedl_valWatcher();
     void ec_ehb_brk_pedl_val_vldWatcher();
     void ec_ehb_brk_pedl_val_percWatcher();
     void ec_ehb_brk_pedl_val_perc_vldWatcher();
     void mc_travel_average_speedWatcher();
     void ec_ipu_dcc_sys_fail_staWatcher();
     void ec_bms_chrg_target_socWatcher();
     void ec_bcm_brake_pedal_staWatcher();

     void fcm_adas_drvr_reqWatcher();
     void fcm_elk_stsWatcher();
     void fcm_slifs_spd_limWatcher();
     void fcm_aeb_statusWatcher();
     void fcm_aeb_statsadsusWatcher();
     void hu_dowenaswtWatcher();

     void sc_fcm_acc_take_over_reqWatcher();
     void fcm_tjatakeoverreqWatcher();
     void bc_fcm_aeb_recreqWatcher();
     void hu_hma_enable_swWatcher();
     void hu_ica_enable_sw_tWatcher();
     void hu_ica_avd_truck_setWatcher();
     void hu_ldw_alert_method_swWatcher();
     void hu_lka_enable_swWatcher();
     void hu_elk_enb_swWatcher();
     void hu_fcw_enable_swWatcher();
     void hu_abe_enable_swWatcher();
     void hu_bsd_enable_swWatcher();
     void hu_rcw_enable_swWatcher();
     void hu_rcta_enable_swWatcher();
     void hu_slif_enableswWatcher();
     void hu_slwf_enableswWatcher();
     void hu_navi_country_codeWatcher();
     void bc_bcm_avalueble_key_in_carWatcher();
     void ec_vcu_sys_fail_staWatcher();
     void ec_ccu_remt_steer_whl_heat_fbWatcher();
     void ec_ccu_remt_power_ctrl_fbWatcher();
     void ec_ccu_remt_mai_dr_seat_heat_fbWatcher();

     void bc_pp_sensor_fault_sts_rlWatcher();
     void bc_pp_sensor_fault_sts_rlmWatcher();
     void bc_pp_sensor_fault_sts_rrmWatcher();
     void bc_pp_sensor_fault_sts_rrWatcher();
     void bc_pp_rl_distWatcher();
     void bc_pp_rlm_distWatcher();
     void bc_pp_rrm_distWatcher();
     void bc_pp_rr_distWatcher();
     void bc_pp_sdwfsr_distWatcher();
     void bc_pp_sdwrsl_distWatcher();
     void bc_pp_sdwrsl_mid_distWatcher();
     void bc_pp_sdwrsr_mid_distWatcher();
     void bc_fm_auto_seek_resWatcher();
     void fm_searchWatcher();
     void fm_volumeWatcher();
     void ec_vcu_err_amountWatcher();
     void ec_vcu_err_bitWatcher();
     void bc_bcm_carriage_light_staWatcher();
     void ec_eps_steer_wheel_angleWatcher();
     void ec_eps_steer_wheel_angle_validWatcher();
     void ec_eps_rot_speedWatcher();
     void ec_eps_steer_wheel_angle_failureWatcher();
     void ec_eps_electric_power_staWatcher();
     void ec_eps_steer_wheel_angle_calibratedWatcher();
     void ec_eps_mot_tqWatcher();
     void ec_fcm_lgt_fct_actv_flgWatcher();
     void ec_fcm_eps_set_steer_whl_aglWatcher();
     void ec_fcm_steer_tq_req_activeWatcher();
     void ec_fcm_eps_ctrl_reqWatcher();
     void ec_fcm_drvr_warn_vib_reqWatcher();
     void ec_fcm_daeps_mode_reqWatcher();
     void ec_fcm_act_drv_asst_stsWatcher();
     void ec_fcm_overtake_ass_sys_stsWatcher();
     void ec_fcm_turn_lamp_reqWatcher();
     void ec_fcm_tjaica_supps_abortnWatcher();
     void ec_fcm_lka_torq_fact_reqWatcher();
     void ec_fcm_hma_supps_abortnWatcher();
     void ec_fcm_lkaldw_supps_abortnWatcher();
     void ec_fcm_flt_stsWatcher();
     void ec_fcm_elk_supps_abortnWatcher();
     void ec_fcm_acc_whl_tq_req_valWatcher();
     void ec_fcm_acc_whl_tq_req_actvWatcher();
     void ec_fcm_acc_whl_deceWatcher();
     void ec_fcm_acc_tar_accrnWatcher();
     void ec_fcm_acc_supp_abortWatcher();
     void ec_fcm_acc_tar_accrn_req_actvWatcher();
     void ec_fcm_epb_req_vWatcher();
     void ec_fcm_epb_reqWatcher();
     void ec_fcm_acc_shutdown_modeWatcher();
     void ec_fcm_ahd_obj_idWatcher();
     void ec_fcm_acc_tgt_axWatcher();
     void ec_fcm_aeb_tgt_axWatcher();
     void ec_fcm_acc_modeWatcher();
     void ec_fcm_acc_req_standstillWatcher();
     void ec_fcm_aeb_reqWatcher();
     void ec_fcm_aeb_standstill_stsWatcher();
     void ec_fcm_aeb_standstill_sts_vWatcher();
     void ec_fcm_aba_levelWatcher();
     void ec_fcm_awb_levelWatcher();
     void ec_fcm_aba_reqWatcher();
     void ec_fcm_eba_reqWatcher();
     void ec_fcm_awb_reqWatcher();
     void ec_fcm_abp_reqWatcher();
     void ec_fcm_acc_tgt_ax_reqWatcher();
     void ec_fcm_crv_decel_staWatcher();
     void ec_fcm_acc_req_drive_offWatcher();
     void mc_scs_frnt_wipr_swt_stWatcher();
     void mc_scs_low_beam_swt_stWatcher();
     void mc_scs_hi_beam_swt_stWatcher();
     void mc_scs_over_veh_beam_swt_stWatcher();
     void mc_scs_lamp_auto_stWatcher();
     void mc_scs_le_turn_lmp_swt_stWatcher();
     void mc_scs_ri_turn_lmp_swt_stWatcher();
    void ec_bms_hv_bat_cell_temp_aveWatcher();
    void ec_bms_dcs_actl_chrg_currentWatcher();
    void ec_scs_gear_shift_lever_pst_reqWatcher();
    void ec_bms_ac_chrg_atcl_staWatcher();
    void ec_bms_outlet_coolant_actl_tempWatcher();
    void ec_bms_outlet_coolant_actl_temp_validWatcher();
    void ec_bms_inlet_coolant_actl_tempWatcher();
    void ec_bms_inlet_coolant_actl_temp_validWatcher();
    void ec_bms_max_chrg_voltage_acWatcher();
    void ec_bms_max_chrg_current_acWatcher();
    void ec_bms_bat_sohWatcher();
    void ec_bms_temp_max_dc_charge_socketWatcher();
    void ec_bms_pcb_temp_maxWatcher();
    void ec_bms_max_allow_chrg_cur_dcWatcher();
    void ec_bms_max_allow_chrg_vol_dcWatcher();
    void ec_bms_electronic_lock_ctrlWatcher();
    void ec_bms_electronic_lock_stateWatcher();
    void ec_bms_contactor_state_dc_chargerWatcher();
    void ec_bms_dcs_charge_requestWatcher();
    void ec_bms_dcs_chrg_a_plusWatcher();
    void ec_bms_run_stateWatcher();
    void ec_bms_contactor_state_negativeWatcher();
    void ec_bms_contactor_state_positiveWatcher();
    void ec_bms_contactor_state_prechargeWatcher();
    void ec_bms_supply_voltage_statusWatcher();
    void ec_bms_emeshutdown_reqWatcher();
    void ec_bms_charge_interlock_staWatcher();
    void ec_bms_dis_charge_interlock_staWatcher();
    void ec_bms_batt_balance_staWatcher();
    void ec_bms_therm_runaway_snsr_fltWatcher();
    void ec_bms_therm_runaway_vlv_stWatcher();
    void ec_ipu_obc_uac_act_l1Watcher();
    void ec_ipu_obc_uac_act_l2Watcher();
    void ec_ipu_obc_uac_act_l3Watcher();
    void ec_ipu_obc_iac_act_l1Watcher();
    void ec_ipu_obc_iac_act_l2Watcher();
    void ec_ipu_obc_iac_act_l3Watcher();
    void ec_ipu_device_int_tempWatcher();
    void ec_ipu_obc_temp_inletWatcher();
    void ec_ipu_obc_ac_max_pw_allowWatcher();
    void ec_ipu_obc_inlet_electronic_lockWatcher();
    void ec_ipu_obc_s2_stateWatcher();
    void ec_ipu_obc_wake_up_modeWatcher();
    void ec_ipu_obc_voltage_ok_l1Watcher();
    void ec_ipu_obc_voltage_ok_l2Watcher();
    void ec_ipu_obc_voltage_ok_l3Watcher();
    void ec_ipu_dcc_high_volt_actl_curWatcher();
    void ec_ipu_dcc_high_volt_actl_volWatcher();
    void ec_ipu_obc_hvdc_actl_curWatcher();
    void ec_ipu_obc_connect_main_staWatcher();
    void ec_ipu_obc_requestWatcher();
    void ec_ipu_obc_sys_fail_staWatcher();
    void ec_ipu_obc_hvdc_actl_volWatcher();
    void ec_ipu_obc_errbitWatcher();
    void ec_ipu_dcc_low_vol_actl_volWatcher();
    void ec_ipu_dcc_low_vol_actl_curWatcher();
    void ec_ipu_dcc_precharge_completeWatcher();
    void ec_ipu_dcc_derating_oprt_staWatcher();
    void ec_ipu_hvil_fail_staWatcher();
    void ec_ipu_dcc_errbitWatcher();
    void ec_ipu_obc_c_cor_cp_cnctd_stsWatcher();
    void ec_ipu_obc_cp_dutyWatcher();
    void ec_ipu_obc_cp_max_voltWatcher();
    void ec_ipu_obc_process_codeWatcher();
    void ec_ipu_obc_cc_resisdentWatcher();
    void ec_eps_torsion_bar_torqueWatcher();
    void ec_eps_torsion_bar_torque_dirWatcher();
    void ec_eps_torsion_bar_torque_validWatcher();
    void ec_eps_elect_power_consumptionWatcher();
    void ec_eps_advanced_mode_statusWatcher();
    void ec_eps_lat_drv_lvl12_srv_avlWatcher();
    void ec_eps_lat_mc_hptc_wrn_srv_avlWatcher();
    void ec_eps_pscm_int_rpc_max_trqWatcher();
    void ec_eps_torsion_bar_torque_qfWatcher();
    void ec_eps_pscm_int_rpc_min_trqWatcher();
    void ec_eps_lat_mc_steer_tq_activeWatcher();
    void ec_eps_lat_mc_hptc_wrn_activeWatcher();
    void ec_eps_max_allwd_rot_spdWatcher();
    void ec_eps_lks_agl_sys_stsWatcher();
    void ec_eps_max_allwd_aglWatcher();
    void ec_eps_steer_tqWatcher();
    void ec_eps_lks_abort_fbWatcher();
    void ec_eps_lks_agl_ctrl_avl_stsWatcher();
    void ec_esc_req_brake_light_onWatcher();
    void ec_esc_ebd_active_staWatcher();
    void ec_esc_ess_activeWatcher();
    void ec_esc_cdp_activeWatcher();
    void ec_esc_brake_temp_over_heatWatcher();
    void ec_esc_dtc_active_stsWatcher();
    void ec_esc_vhcl_standstill_staWatcher();
    void ec_esc_dtc_request_rbs_stsWatcher();
    void ec_esc_dtc_failure_stsWatcher();
    void ec_esc_wheel_speed_kph_v_flWatcher();
    void ec_esc_wheel_direction_flWatcher();
    void ec_esc_wheel_speed_kph_flWatcher();
    void ec_esc_wheel_speed_kph_v_frWatcher();
    void ec_esc_wheel_direction_frWatcher();
    void ec_esc_wheel_speed_kph_frWatcher();
    void ec_esc_master_cylinder_presrWatcher();
    void ec_esc_master_cylinder_presr_vWatcher();
    void ec_esc_wheel_speed_kph_v_rlWatcher();
    void ec_esc_wheel_direction_rlWatcher();
    void ec_esc_wheel_speed_kph_rlWatcher();
    void ec_esc_wheel_speed_kph_v_rrWatcher();
    void ec_esc_wheel_direction_rrWatcher();
    void ec_esc_wheel_speed_kph_rrWatcher();
    void ec_esc_wheel_speed_rc_sts_flWatcher();
    void ec_esc_wheel_speed_rc_sts_frWatcher();
    void ec_esc_wheel_speed_rc_sts_rlWatcher();
    void ec_esc_wheel_speed_rc_sts_rrWatcher();
    void ec_esc_wheel_speed_rc_flWatcher();
    void ec_esc_wheel_speed_rc_frWatcher();
    void ec_esc_wheel_speed_rc_rlWatcher();
    void ec_esc_wheel_speed_rc_rrWatcher();
    void ec_esc_long_acc_sensor_valueWatcher();
    void ec_esc_long_acc_sensor_value_vldWatcher();
    void ec_esc_lat_acc_sensor_value_vldWatcher();
    void ec_esc_lat_acc_sensor_valueWatcher();
    void ec_esc_yaw_rateWatcher();
    void ec_esc_yaw_rate_vldWatcher();
    void ec_esc_epb_right_currentWatcher();
    void ec_esc_epb_right_fault_stateWatcher();
    void ec_esc_hbb_hbc_availableWatcher();
    void ec_esc_epb_actuator_st_rWatcher();
    void ec_esc_hbb_hbc_activeWatcher();
    void ec_esc_whl_tq_dec_req_actvWatcher();
    void ec_esc_whl_tq_dec_req_valWatcher();
    void ec_esc_whl_tq_inc_req_actvWatcher();
    void ec_esc_whl_tq_inc_req_valWatcher();
    void ec_ehb_cdp_requestWatcher();
    void ec_ehb_epb_actuator_st_rWatcher();
    void ec_ehb_epb_actuator_st_lWatcher();
    void ec_ehb_hhc_active_staWatcher();
    void ec_ehb_rgn_brk_stWatcher();
    void ec_ehb_ext_req_statusWatcher();
    void ec_ehb_blaWatcher();
    void ec_ehb_hmi_warning_onWatcher();
    void ec_ehb_epb_dynamic_apply_staWatcher();
    void ec_ehb_pedl_trvl_snsr_fail_pdfWatcher();
    void ec_ehb_req_brk_li_onWatcher();
    void ec_ehb_pedl_trvl_snsr_fail_pdtWatcher();
    void ec_ehb_p_runout_pressureWatcher();
    void ec_ehb_brake_pedal_appliedWatcher();
    void ec_ehb_brake_pedal_applied_qWatcher();
    void ec_ehb_cdd_temp_offWatcher();
    void ec_ehb_s_output_rod_hydraulic_targetWatcher();
    void ec_ehb_s_output_rod_driver_percWatcher();
    void ec_ehb_aba_active_staWatcher();
    void ec_ehb_aba_available_staWatcher();
    void ec_ehb_awb_active_staWatcher();
    void ec_ehb_awb_available_staWatcher();
    void ec_ehb_aeb_active_staWatcher();
    void ec_ehb_aeb_available_staWatcher();
    void ec_ehb_abp_active_staWatcher();
    void ec_ehb_abp_available_staWatcher();
    void ec_pp_raeb_set_fbWatcher();
    void ec_pp_raeb_work_stsWatcher();
    void ec_pp_raeb_brkg_reqWatcher();
    void ec_pp_raeb_brkg_req_valWatcher();
    void ec_pp_raeb_distance_to_collisionWatcher();
    void ec_crrr_rctb_decelarationWatcher();
    void ec_crrr_rctb_reqWatcher();
    void ec_crrr_rctb_brkg_vldWatcher();
    void ec_crrr_fov_chg_set_fbWatcher();
    void ec_bms_max_con_dis_curntWatcher();
    void ec_bms_pwr_recup_max_con_chrg_curntWatcher();
    void ec_bms_max_instan_dis_curntWatcher();
    void ec_bms_pwr_recup_max_instan_chrg_curntWatcher();
    void ec_bms_cell_vol_aveWatcher();
    void ec_bms_contactor_temp_negativeWatcher();
    void ec_bms_max_cell_temp_limitWatcher();
    void ec_bms_max_cell_vol_limitWatcher();
    void ec_bms_pwr_limd_flgWatcher();
    void ec_bms_min_cell_temp_limitWatcher();
    void ec_bms_min_cell_vol_limitWatcher();
    void ec_bms_err_tab_indexWatcher();
    void ec_bms_battery_typeWatcher();
    void ec_bms_hw_versionWatcher();
    void ec_bms_pack_identityWatcher();
    void ec_bms_sw_versionWatcher();
    void ec_bms_nom_cell_capWatcher();
    void ec_bms_bat_capacityWatcher();
    void ec_cst_abort_by_bmsWatcher();
    void ec_cst_abort_by_faultWatcher();
    void ec_cst_abort_by_userWatcher();
    void ec_cst_abort_achive_conditionWatcher();
    void ec_cst_abort_fault_energe_transmitWatcher();
    void ec_cst_abort_fault_charger_inner_tempWatcher();
    void ec_cst_abort_fault_connetorWatcher();
    void ec_cst_abort_fault_charger_tempWatcher();
    void ec_cst_abort_fault_otherWatcher();
    void ec_cst_abort_fault_charger_stopWatcher();
    void ec_cst_abort_error_voltageWatcher();
    void ec_cst_abort_error_currentWatcher();
    void ec_bcm_rear_view_mirr_heating_stsWatcher();
    void ec_tms_ohx_out_tmpWatcher();
    void ec_tms_evap_tmpWatcher();
    void ec_tms_evap_out_tmpWatcher();
    void ec_tms_chiller_out_tmpWatcher();
    void ec_bcm_high_beam_li_fault_fbWatcher();
    void ec_bcm_low_beam_li_fault_fbWatcher();
    void ec_bcm_vhcl_seekWatcher();
    void ec_bcm_illmnd_stsWatcher();
    void ec_bcm_key_frbdnWatcher();
    void ec_bcm_frbdn_key_nrWatcher();
    void ec_bcm_start_reqWatcher();
    void ec_bcm_drv_pe_authent_acsdWatcher();
    void ec_bcm_frpe_authent_acsdWatcher();
    void ec_bcm_ps_reqWatcher();
    void ec_bcm_frnt_le_door_hndl_swtWatcher();
    void ec_bcm_frnt_ri_door_hndl_swtWatcher();
    void ec_bcm_save_power_staWatcher();
    void ec_bcm_front_wiper_motor_stsWatcher();
    void ec_bcm_fl_window_stsWatcher();
    void ec_bcm_fr_window_stsWatcher();
    void ec_bcm_fl_windowmotor_stsWatcher();
    void ec_bcm_fr_windowmotor_stsWatcher();
    void ec_bcm_wiper_ctrl_frontWatcher();
    void ec_bcm_drv_seat_occupant_sensor_stsWatcher();
    void ec_bcm_heavy_rain_indWatcher();
    void ec_tpms_pressure_value_rrWatcher();
    void ec_tpms_pressure_value_rlWatcher();
    void ec_tpms_pressure_sta_rlWatcher();
    void ec_tpms_pressure_sta_rrWatcher();
    void ec_tpms_pressure_value_frWatcher();
    void ec_tpms_pressure_value_flWatcher();
    void ec_tpms_pressure_sta_flWatcher();
    void ec_tpms_pressure_sta_frWatcher();
    void ec_bcm_dome_light_staWatcher();
    void ec_bcm_back_lamp_staWatcher();
    void ec_bcm_bass_horn_reqWatcher();
    void ec_bcm_ajar_sta_v_hoodWatcher();
    void ec_bcm_frnt_fog_li_sw_sigWatcher();
    void ec_bcm_rear_fog_li_sw_sigWatcher();
    void ec_bcm_day_run_light_staWatcher();
    void ec_bcm_reverse_lamp_staWatcher();
    void ec_bcm_brake_lamp_staWatcher();
    void ec_bcm_turn_li_stsWatcher();
    void ec_vcu_actl_motor_rotate_spdWatcher();
    void ec_vcu_actl_motor_rotate_spd_vWatcher();
    void ec_vcu_remt_ac_ctrl_stWatcher();
    void ec_vcu_remt_ac_defrostl_reqWatcher();
    void ec_vcu_remt_ac_ctrl_reqWatcher();
    void ec_vcu_charging_conditions_fbWatcher();
    void ec_vcu_accl_pedal_pos_snsr_staWatcher();
    void ec_vcu_req_epbWatcher();
    void ec_vcu_acc_trq_ctrl_avlWatcher();
    void ec_vcu_acc_standstill_reqWatcher();
    void ec_vcu_acc_tgt_axWatcher();
    void ec_vcu_acc_tgt_ax_reqWatcher();
    void ec_vcu_drv_req_torq_override_fcmWatcher();
    void ec_vcu_cruise_ctr_tgt_spdWatcher();
    void ec_vcu_cruise_ctrl_staWatcher();
     void ec_scs_right_11_swtWatcher();
     void ec_scs_right_12_swtWatcher();
     void ec_scs_right_13_swtWatcher();
    void ec_scs_gear_shift_lever_pst_req_vdWatcher();
    void ec_bms_dcs_actl_chrg_powerWatcher();
    void ec_ccu_keep_awake_staWatcher();
    void ec_vcu_bra_tor_reqWatcher();
    void ec_pp_sensor_fault_sts_flmWatcher();
    void ec_pp_sensor_fault_sts_flWatcher();
    void ec_bcm_authent_key_nrWatcher();
    void ec_bcm_key_staWatcher();
    void ec_bcm_wiper_stop_pos_staWatcher();
    void ec_bms_insulation_wrningWatcher();
    void ec_fcm_tau_gap_setWatcher();
    void gecko_e2p_rom_resultWatcher();
    void gecko_key_code_resultWatcher();
    void ec_fcm_hma_highbeam_reqWatcher();
    void ec_bcm_hazard_lamp_stsWatcher();
    void bc_bcm_rke_reqWatcher();
    void bc_fcm_hma_stsWatcher();
    void bc_bcm_le_turn_li_fault_fbWatcher();
    void bc_bcm_ri_turn_li_fault_fbWatcher();
    void bc_ac_ac_sta_fbWatcher();
     int GetFcwAebValue();
    void mc_travel_short_rangeWatcher();
    void mc_travel_short_average_speedWatcher();
    void mc_travel_short_average_pwr_consum_Watcher();
    void mc_travel_short_timeWatcher();
  private:

    recyclable_ptr<VehiclePropValue> CreatespeedReq(float speed);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_d_cdischrg_permReq(float ec_vcu_d_cdischrg_perm);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_pt_stReq(int32_t ec_vcu_pt_st);
    recyclable_ptr<VehiclePropValue> Create_mcu_power_stReq(int32_t mcu_power_st);
    recyclable_ptr<VehiclePropValue> Create_soc_power_stReq(int32_t soc_power_st,int32_t para_value);
    recyclable_ptr<VehiclePropValue> To_notification_tbox_soc_power_status(int32_t soc_power_st);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_hvpowerReq(int32_t ec_vcu_hvpower);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_dcd_cworkenableReq(int32_t ec_vcu_dcd_cworkenable);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_charallowReq(float ec_vcu_charallow);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_igonReq(int32_t ec_vcu_igon);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_sleepindicationsignalReq(float ec_vcu_sleepindicationsignal);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_livecounter_0x100Req(float ec_vcu_livecounter_0x100);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_checksum_0x100Req(float ec_vcu_checksum_0x100);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_heatrelaystatusReq(int32_t ec_bms_heatrelaystatus);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_cc2statusReq(float ec_bms_cc2status);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_livecounter_0x120Req(float ec_bms_livecounter_0x120);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_checksum_0x120Req(float ec_bms_checksum_0x120);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_batinsulatresistanceReq(int ec_bms_batinsulatresistance);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_batterycurrentReq(float ec_bms_batterycurrent);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_packvoltageReq(int32_t ec_bms_packvoltage);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_packvoltage_vReq(int32_t ec_bms_packvoltage_v);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_livecounter_0x125Req(float ec_bms_livecounter_0x125);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_checksum_0x125Req(float ec_bms_checksum_0x125);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_remainingchargetimeReq(int32_t ec_bms_remainingchargetime);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_batterysocReq(float ec_bms_batterysoc);
    recyclable_ptr<VehiclePropValue> Create_ec_batterylowsignalReq(int32_t batterylowsignal);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_livecounter_0x135Req(float ec_bms_livecounter_0x135);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_checksum_0x135Req(float ec_bms_checksum_0x135);
    recyclable_ptr<VehiclePropValue> Create_ec_mcu_motortorqueReq(int ec_mcu_motortorque);
    recyclable_ptr<VehiclePropValue> Create_ec_mcu_motorspdReq(float ec_mcu_motorspd);
    recyclable_ptr<VehiclePropValue> Create_ec_mcu_llivecounter_0x200Req(float ec_mcu_llivecounter_0x200);
    recyclable_ptr<VehiclePropValue> Create_ec_mcu_checksum_0x200Req(float ec_mcu_checksum_0x200);
    recyclable_ptr<VehiclePropValue> Create_ec_mcu_buscurrentReq(int ec_mcu_buscurrent);
    recyclable_ptr<VehiclePropValue> Create_ec_mcu_busvoltReq(int ec_mcu_busvolt);
    recyclable_ptr<VehiclePropValue> Create_ec_mcu_llivecounter_0x201Req(float ec_mcu_llivecounter_0x201);
    recyclable_ptr<VehiclePropValue> Create_ec_mcu_checksum_0x201Req(float ec_mcu_checksum_0x201);
    recyclable_ptr<VehiclePropValue> Create_ec_mcu_err_codeReq(int32_t ec_mcu_err_code);
    recyclable_ptr<VehiclePropValue> Create_ec_mcu_motortempReq(int32_t ec_mcu_motortemp);
    recyclable_ptr<VehiclePropValue> Create_ec_mcu_igbttempReq(int32_t ec_mcu_igbttemp);
    recyclable_ptr<VehiclePropValue> Create_ec_mcu_motoropermodeReq(int32_t ec_mcu_motoropermode);
    recyclable_ptr<VehiclePropValue> Create_ec_mcu_llivecounter_0x202Req(float ec_mcu_llivecounter_0x202);
    recyclable_ptr<VehiclePropValue> Create_ec_mcu_checksum_0x202Req(float ec_mcu_checksum_0x202);
    recyclable_ptr<VehiclePropValue> Create_ec_mcu_motor_fault_total_numReq(int32_t ec_mcu_motor_fault_total_num);
    recyclable_ptr<VehiclePropValue> Create_ec_mcu_motor_stateReq(int32_t ec_mcu_motor_state);
    recyclable_ptr<VehiclePropValue> Create_ec_mcu_igbt_overheat_warningReq(int32_t ec_mcu_igbt_overheat_warning);
    recyclable_ptr<VehiclePropValue> Create_ec_mcu_motor_overheat_warningReq(int32_t ec_mcu_motor_overheat_warning);
    recyclable_ptr<VehiclePropValue> Create_ec_mcu_llivecounter_0x203Req(float ec_mcu_llivecounter_0x203);
    recyclable_ptr<VehiclePropValue> Create_ec_mcu_checksum_0x203Req(float ec_mcu_checksum_0x203);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_smart_dc_stReq(int32_t ec_ipu_smart_dc_st);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_livecounter_0x450Req(float ec_ipu_livecounter_0x450);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_checksum_0x450Req(float ec_ipu_checksum_0x450);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_c_cresistancevalueReq(float ec_ipu_c_cresistancevalue);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_livecounter_0x470Req(float ec_ipu_livecounter_0x470);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_checksum_0x470Req(float ec_ipu_checksum_0x470);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_ob_cinputvoltageReq(int32_t ec_ipu_ob_cinputvoltage);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_c_pdutycycleReq(int ec_ipu_c_pdutycycle);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_ob_cinputcurrentReq(int32_t ec_ipu_ob_cinputcurrent);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_dcd_crealtimeopcurrReq(int32_t ec_ipu_dcd_crealtimeopcurr);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_dcd_coperatingmodeReq(int32_t ec_ipu_dcd_coperatingmode);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_dcd_crealtimeopvoltReq(int32_t ec_ipu_dcd_crealtimeopvolt);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_dcd_cbodytempReq(int32_t ec_ipu_dcd_cbodytemp);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_livecounter_0x490Req(float ec_ipu_livecounter_0x490);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_checksum_0x490Req(float ec_ipu_checksum_0x490);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_dcdc_over_tempReq(int32_t ec_ipu_dcdc_over_temp);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_battery_pack_average_tempReq(float ec_bms_battery_pack_average_temp);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_packtotalcellnumReq(int32_t ec_bms_packtotalcellnum);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_packtotaltempnumReq(int32_t ec_bms_packtotaltempnum);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_maxvoltcellpacknumReq(int ec_bms_maxvoltcellpacknum);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_minvoltcellpacknumReq(int ec_bms_minvoltcellpacknum);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_livecounter_0x510Req(float ec_bms_livecounter_0x510);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_checksum_0x510Req(float ec_bms_checksum_0x510);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_mintempmonomercellReq(int ec_bms_mintempmonomercell);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_maxtempmonomercellReq(int ec_bms_maxtempmonomercell);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_maxtempcellReq(float ec_bms_maxtempcell);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_mintempcellReq(float ec_bms_mintempcell);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_maxtempcellpacknumReq(int ec_bms_maxtempcellpacknum);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_mintempcellpacknumReq(int ec_bms_mintempcellpacknum);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_deg_d_ccharsockettemp2Req(int ec_bms_deg_d_ccharsockettemp2);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_deg_d_ccharsockettemp1Req(int ec_bms_deg_d_ccharsockettemp1);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_livecounter0x511Req(float ec_bms_livecounter0x511);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_checksum_0x511Req(float ec_bms_checksum_0x511);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_minvoltmonomercellReq(int ec_bms_minvoltmonomercell);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_maxvoltmonomercellReq(int ec_bms_maxvoltmonomercell);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_maxvoltcellReq(float ec_bms_maxvoltcell);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_minvoltcellReq(float ec_bms_minvoltcell);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_livecounter_0x512Req(float ec_bms_livecounter_0x512);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_checksum_0x512Req(float ec_bms_checksum_0x512);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_packratecapReq(float ec_bms_packratecap);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_pack_rate_voltReq(float ec_bms_pack_rate_volt);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_packrateenergyReq(float ec_bms_packrateenergy);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_batt_typeReq(float ec_bms_batt_type);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_battcooltypeReq(float ec_bms_battcooltype);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_livecounter_0x520Req(float ec_bms_livecounter_0x520);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_checksum_0x520Req(float ec_bms_checksum_0x520);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_packudvoltReq(int32_t ec_bms_packudvolt);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_packovervoltReq(int32_t ec_bms_packovervolt);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_overtempReq(int32_t ec_bms_overtemp);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_deltatempReq(int32_t ec_bms_deltatemp);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_lowinsresReq(int32_t ec_bms_lowinsres);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_celludvoltReq(int32_t ec_bms_celludvolt);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_cellovervoltReq(int32_t ec_bms_cellovervolt);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_packlowsocReq(int32_t ec_bms_packlowsoc);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_packfastchgsocReq(int32_t ec_bms_packfastchgsoc);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_packhighsocReq(int32_t ec_bms_packhighsoc);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_packoverchargeReq(int32_t ec_bms_packovercharge);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_ucellinconReq(int32_t ec_bms_ucellincon);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_thermalrunawayalarmReq(int32_t ec_bms_thermalrunawayalarm);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_h_vilfaultReq(int32_t ec_bms_h_vilfault);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_batsysnotmtcReq(int32_t ec_bms_batsysnotmtc);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_fault_codeReq(int32_t ec_bms_fault_code);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_batt_fault_total_numReq(int32_t ec_bms_batt_fault_total_num);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_livecounter_0x522Req(float ec_bms_livecounter_0x522);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_checksum_0x522Req(float ec_bms_checksum_0x522);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_shif_faultReq(float ec_vcu_shif_fault);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_shift_positionReq(int32_t ec_vcu_shift_position);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_actual_gearReq(int32_t ec_vcu_actual_gear);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_bp_statusReq(int ec_vcu_bp_status);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_park_faultReq(float ec_vcu_park_fault);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_park_stateReq(int32_t ec_vcu_park_state);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_switch_gear_warnReq(int32_t ec_vcu_switch_gear_warn);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_delay_mon_modeReq(float ec_vcu_delay_mon_mode);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_ap_statusReq(int ec_vcu_ap_status);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_brk_lamp_ctr_cmdReq(float ec_vcu_brk_lamp_ctr_cmd);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_lock_veh_warnReq(int32_t ec_vcu_lock_veh_warn);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_creep_stsReq(int32_t ec_vcu_creep_sts);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_single_ped_stsReq(int32_t ec_vcu_single_ped_sts);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_ap_faultReq(float ec_vcu_ap_fault);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_bp_faultReq(float ec_vcu_bp_fault);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_brk_pdl_posReq(float ec_vcu_brk_pdl_pos);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_livecounter_0x350Req(float ec_vcu_livecounter_0x350);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_checksum_0x350Req(float ec_vcu_checksum_0x350);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_chrg_stsReq(int32_t ec_vcu_chrg_sts);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_chrg_cnctr_stsReq(int32_t ec_vcu_chrg_cnctr_sts);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_pt_rdyReq(int32_t ec_vcu_pt_rdy);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_smart_dc_reqReq(int32_t ec_vcu_smart_dc_req);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_chrg_soc_tar_spReq(int32_t ec_vcu_chrg_soc_tar_sp);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_dis_chrg_stsReq(int32_t ec_vcu_dis_chrg_sts);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_dc_chrg_rly_stsReq(int32_t ec_vcu_dc_chrg_rly_sts);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_average_energy_consum_vdReq(int32_t ec_vcu_average_energy_consum_vd);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_dc_chrg_rly_auxil_cntac_stsReq(float ec_vcu_dc_chrg_rly_auxil_cntac_sts);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_braking_remindReq(int32_t ec_vcu_braking_remind);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_average_energy_consumptionReq(float ec_vcu_average_energy_consumption);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_instant_energy_consumptionReq(float ec_vcu_instant_energy_consumption);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_instant_energy_consum_vdReq(int32_t ec_vcu_instant_energy_consum_vd);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_chraging_mode_spReq(int32_t ec_vcu_chraging_mode_sp);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_livecounter_0x351Req(float ec_vcu_livecounter_0x351);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_checksum_0x351Req(float ec_vcu_checksum_0x351);
    recyclable_ptr<VehiclePropValue> Create_ec_ccm_veh_tar_socReq(float ec_ccm_veh_tar_soc);
    recyclable_ptr<VehiclePropValue> Create_ec_ccm_batt_maintain_ctr_cmdReq(float ec_ccm_batt_maintain_ctr_cmd);
    recyclable_ptr<VehiclePropValue> Create_ec_ota_modelReq(float ec_ota_model);
    recyclable_ptr<VehiclePropValue> Create_ec_ccm_rechrgn_lv_reqReq(float ec_ccm_rechrgn_lv_req);
    recyclable_ptr<VehiclePropValue> Create_ec_ccm_driver_buckle_statusReq(int32_t ec_ccm_driver_buckle_status, int32_t areaId);
    recyclable_ptr<VehiclePropValue> Create_ec_ccm_drive_mode_reqReq(float ec_ccm_drive_mode_req);
    recyclable_ptr<VehiclePropValue> Create_ec_ccm_operat_licenceReq(float ec_ccm_operat_licence);
    recyclable_ptr<VehiclePropValue> Create_ec_ccm_versionReq(float ec_ccm_version);
    recyclable_ptr<VehiclePropValue> Create_ec_ccm_speed_limit_levelReq(float ec_ccm_speed_limit_level);
    recyclable_ptr<VehiclePropValue> Create_ec_ccm_charging_conditionsReq(float ec_ccm_charging_conditions);
    recyclable_ptr<VehiclePropValue> Create_ec_total_odometerReq(float ec_total_odometer);
    recyclable_ptr<VehiclePropValue> Create_power_on_milegeReq(float power_on_milege);
    recyclable_ptr<VehiclePropValue> Create_power_on_average_speedReq(int32_t power_on_average_speed);
    recyclable_ptr<VehiclePropValue> Create_power_on_average_energy_consumptionReq(float ec_total_odometer);
    recyclable_ptr<VehiclePropValue> Create_power_on_timeReq(int32_t power_on_time);
    recyclable_ptr<VehiclePropValue> Create_ec_ccm_target_chrg_currReq(float ec_ccm_target_chrg_curr);
    recyclable_ptr<VehiclePropValue> Create_ec_ccm_batt_maintain_stsReq(float ec_ccm_batt_maintain_sts);
    recyclable_ptr<VehiclePropValue> Create_ec_ccm_livecounter_0x353Req(float ec_ccm_livecounter_0x353);
    recyclable_ptr<VehiclePropValue> Create_ec_ccm_checksum_0x353Req(float ec_ccm_checksum_0x353);
    recyclable_ptr<VehiclePropValue> Create_ec_ccm_remt_ctrl_flagReq(float ec_ccm_remt_ctrl_flag);
    recyclable_ptr<VehiclePropValue> Create_ec_ccm_charging_requestReq(float ec_ccm_charging_request);
    recyclable_ptr<VehiclePropValue> Create_ec_ccm_chraging_modeReq(float ec_ccm_chraging_mode);
    recyclable_ptr<VehiclePropValue> Create_ec_ccm_energy_recov_level_cmdReq(float ec_ccm_energy_recov_level_cmd);
    recyclable_ptr<VehiclePropValue> Create_ec_ccm_creep_ctr_cmdReq(float ec_ccm_creep_ctr_cmd);
    recyclable_ptr<VehiclePropValue> Create_ec_ccm_single_ped_ctr_cmdReq(float ec_ccm_single_ped_ctr_cmd);
    recyclable_ptr<VehiclePropValue> Create_ec_ccm_rema_range_dispReq(float ec_ccm_rema_range_disp);
    recyclable_ptr<VehiclePropValue> Create_ec_ccm_rema_range_disp_vdReq(float ec_ccm_rema_range_disp_vd);
    recyclable_ptr<VehiclePropValue> Create_ec_ccm_livecounter_0x354Req(float ec_ccm_livecounter_0x354);
    recyclable_ptr<VehiclePropValue> Create_ec_ccm_checksum_0x354Req(float ec_ccm_checksum_0x354);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_drive_modeReq(int32_t ec_vcu_drive_mode);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_low_soc_warnReq(int32_t ec_vcu_low_soc_warn);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_can_timeout_faultReq(float ec_vcu_can_timeout_fault);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_eas_ins_staReq(int32_t ec_vcu_eas_ins_sta);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_faultlevelReq(int32_t ec_vcu_faultlevel);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_dc_discharging_fail_warnReq(int32_t ec_vcu_dc_discharging_fail_warn);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_dc_charging_fail_warnReq(int32_t ec_vcu_dc_charging_fail_warn);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_ac_charging_fail_warnReq(int32_t ec_vcu_ac_charging_fail_warn);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_12_v_charging_fail_warnReq(int32_t ec_vcu_12_v_charging_fail_warn);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_brak_sys_warnReq(int32_t ec_vcu_brak_sys_warn);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_veh_unable_dri_warnReq(int32_t ec_vcu_veh_unable_dri_warn);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_brk_liquid_level_lowReq(float ec_vcu_brk_liquid_level_low);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_vacum_pump_faultReq(int32_t ec_vcu_vacum_pump_fault);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_mot_water_pump_statusReq(int32_t ec_vcu_mot_water_pump_status);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_fault_codeReq(int32_t ec_vcu_fault_code);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_fault_treat_levelReq(float ec_vcu_fault_treat_level);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_drive_pwr_limReq(int32_t ec_vcu_drive_pwr_lim);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_mcu_errReq(int32_t ec_vcu_mcu_err);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_hv_batt_errReq(int32_t ec_vcu_hv_batt_err);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_operat_licenceReq(int32_t ec_vcu_operat_licence);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_versionReq(int32_t ec_vcu_version);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_speed_limit_levelReq(int32_t ec_vcu_speed_limit_level);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_charging_conditionsReq(int32_t ec_vcu_charging_conditions);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_livecounter_0x352Req(float ec_vcu_livecounter_0x352);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_checksum_0x352Req(float ec_vcu_checksum_0x352);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_comp_neg_rel_staReq(float ec_vcu_comp_neg_rel_sta);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_comp_pos_rel_staReq(float ec_vcu_comp_pos_rel_sta);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_ipu_errReq(int32_t ec_vcu_ipu_err);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_cooling_fail_warnReq(int32_t ec_vcu_cooling_fail_warn);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_lv_elec_sys_errReq(int32_t ec_vcu_lv_elec_sys_err);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_ac_hv_sys_errReq(int32_t ec_vcu_ac_hv_sys_err);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_ptc2_rel_staReq(int32_t ec_vcu_ptc2_rel_sta);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_ptc1_rel_staReq(int32_t ec_vcu_ptc1_rel_sta);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_highpower_voltageReq(float ec_vcu_highpower_voltage);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_fan_relay_pin_stsReq(int32_t ec_vcu_fan_relay_pin_sts);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_water_pump_relay_pin_stsReq(float ec_vcu_water_pump_relay_pin_sts);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_awake_obc_pin_stsReq(float ec_vcu_awake_obc_pin_sts);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_awake_bms_pin_stsReq(float ec_vcu_awake_bms_pin_sts);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_awake_mcu_pin_stsReq(float ec_vcu_awake_mcu_pin_sts);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_main_relay_pin_stsReq(float ec_vcu_main_relay_pin_sts);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_dc_chrg_awake_pin_stsReq(float ec_vcu_dc_chrg_awake_pin_sts);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_ac_chrg_awake_pin_stsReq(float ec_vcu_ac_chrg_awake_pin_sts);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_water_pump_pwmReq(int32_t ec_vcu_water_pump_pwm);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_power_supply_voltagReq(int32_t ec_vcu_power_supply_voltag);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_livecounter_0x215Req(float ec_vcu_livecounter_0x215);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_checksum_0x215Req(float ec_vcu_checksum_0x215);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_pump_stateReq(float ec_vcu_pump_state);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_mid_door_ajar_statusReq(int32_t ec_vcu_mid_door_ajar_status);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_actual_rema_range_vdReq(int32_t ec_vcu_actual_rema_range_vd);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_cltc_rema_range_vdReq(int32_t ec_vcu_cltc_rema_range_vd);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_pt_cenableReq(float ec_vcu_pt_cenable);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_accmenableReq(float ec_vcu_accmenable);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_vehicle_spdReq(float ec_vcu_vehicle_spd);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_actual_rema_rangeReq(float ec_vcu_actual_rema_range);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_cltc_rema_rangeReq(float ec_vcu_cltc_rema_range);
    recyclable_ptr<VehiclePropValue> Create_bcm_mcu_display_rangeReq(int32_t bcm_mcu_display_range);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_livecounter_0x250Req(float ec_vcu_livecounter_0x250);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_checksum_0x250Req(float ec_vcu_checksum_0x250);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_sofeware_numReq(int32_t ec_vcu_sofeware_num);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_hardware_numReq(int32_t ec_vcu_hardware_num);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_yearReq(float ec_vcu_year);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_monthReq(float ec_vcu_month);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_dayReq(float ec_vcu_day);
    recyclable_ptr<VehiclePropValue> Create_ec_ccm_a_ckeyReq(float ec_ccm_a_ckey);
    recyclable_ptr<VehiclePropValue> Create_ec_ccm_ac_havc_stateReq(float ec_ccm_ac_havc_state);
    recyclable_ptr<VehiclePropValue> Create_ec_ccm_vehicle_spd_dspReq(float ec_ccm_vehicle_spd_dsp);
    recyclable_ptr<VehiclePropValue> Create_ec_ccm_livecounter_0x310Req(float ec_ccm_livecounter_0x310);
    recyclable_ptr<VehiclePropValue> Create_ec_ccm_checksum_0x310Req(float ec_ccm_checksum_0x310);
    recyclable_ptr<VehiclePropValue> Create_ec_b2_v_v_frame_noReq(int32_t ec_b2_v_v_frame_no);
    recyclable_ptr<VehiclePropValue> Create_ec_b2_v_v_cell_volt_n1Req(int32_t ec_b2_v_v_cell_volt_n1);
    recyclable_ptr<VehiclePropValue> Create_ec_b2_v_v_cell_volt_n2Req(int32_t ec_b2_v_v_cell_volt_n2);
    recyclable_ptr<VehiclePropValue> Create_ec_b2_v_v_cell_volt_n3Req(int32_t ec_b2_v_v_cell_volt_n3);
    recyclable_ptr<VehiclePropValue> Create_ec_b2_v_t_frame_noReq(int32_t ec_b2_v_t_frame_no);
    recyclable_ptr<VehiclePropValue> Create_ec_b2_v_t_cell_temp_n1Req(int32_t ec_b2_v_t_cell_temp_n1);
    recyclable_ptr<VehiclePropValue> Create_ec_b2_v_t_cell_temp_n2Req(int32_t ec_b2_v_t_cell_temp_n2);
    recyclable_ptr<VehiclePropValue> Create_ec_b2_v_t_cell_temp_n3Req(int32_t ec_b2_v_t_cell_temp_n3);
    recyclable_ptr<VehiclePropValue> Create_ec_b2_v_t_cell_temp_n4Req(int32_t ec_b2_v_t_cell_temp_n4);
    recyclable_ptr<VehiclePropValue> Create_ec_b2_v_t_cell_temp_n5Req(int32_t ec_b2_v_t_cell_temp_n5);
    recyclable_ptr<VehiclePropValue> Create_ec_b2_v_t_cell_temp_n6Req(int32_t ec_b2_v_t_cell_temp_n6);
    recyclable_ptr<VehiclePropValue> Create_ec_b2_v_t_cell_temp_n7Req(int32_t ec_b2_v_t_cell_temp_n7);
    recyclable_ptr<VehiclePropValue> Create_ec_b2_v_gbsn_frame_noReq(float ec_b2_v_gbsn_frame_no);
    recyclable_ptr<VehiclePropValue> Create_ec_b2_v_gbsn_sys_code_lengthReq(float ec_b2_v_gbsn_sys_code_length);
    recyclable_ptr<VehiclePropValue> Create_ec_b2_v_gbsn_sys_code_1_7_13_19Req(float ec_b2_v_gbsn_sys_code_1_7_13_19);
    recyclable_ptr<VehiclePropValue> Create_ec_b2_v_gbsn_sys_code_2_8_14_20Req(float ec_b2_v_gbsn_sys_code_2_8_14_20);
    recyclable_ptr<VehiclePropValue> Create_ec_b2_v_gbsn_sys_code_3_9_15_21Req(float ec_b2_v_gbsn_sys_code_3_9_15_21);
    recyclable_ptr<VehiclePropValue> Create_ec_b2_v_gbsn_sys_code_4_10_16_22Req(float ec_b2_v_gbsn_sys_code_4_10_16_22);
    recyclable_ptr<VehiclePropValue> Create_ec_b2_v_gbsn_sys_code_5_11_17_23Req(float ec_b2_v_gbsn_sys_code_5_11_17_23);
    recyclable_ptr<VehiclePropValue> Create_ec_b2_v_gbsn_sys_code_6_12_18_24Req(float ec_b2_v_gbsn_sys_code_6_12_18_24);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_work_reqReq(float ec_vcu_work_req);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_livecounter_0x661Req(float ec_vcu_livecounter_0x661);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_checksum_0x661Req(float ec_vcu_checksum_0x661);
    recyclable_ptr<VehiclePropValue> Create_ec_str_work_reqReq(float ec_str_work_req);
    recyclable_ptr<VehiclePropValue> Create_ec_ccm_nm_bitReq(float ec_ccm_nm_bit);
    recyclable_ptr<VehiclePropValue> Create_ec_ccm_livecounter_0x66_cReq(float ec_ccm_livecounter_0x66_c);
    recyclable_ptr<VehiclePropValue> Create_ec_ccm_checksum_0x66_cReq(float ec_ccm_checksum_0x66_c);
    recyclable_ptr<VehiclePropValue> Create_ec_tbox_time_statusReq(float ec_tbox_time_status);
    recyclable_ptr<VehiclePropValue> Create_ec_tbox_yearReq(float ec_tbox_year);
    recyclable_ptr<VehiclePropValue> Create_ec_tbox_monthReq(float ec_tbox_month);
    recyclable_ptr<VehiclePropValue> Create_ec_tbox_dayReq(float ec_tbox_day);
    recyclable_ptr<VehiclePropValue> Create_ec_tbox_hourReq(float ec_tbox_hour);
    recyclable_ptr<VehiclePropValue> Create_ec_tbox_minuteReq(float ec_tbox_minute);
    recyclable_ptr<VehiclePropValue> Create_ec_tbox_secondReq(float ec_tbox_second);
    recyclable_ptr<VehiclePropValue> Create_ec_ccm_soc_sofeware_numReq(float ec_ccm_soc_sofeware_num);
    recyclable_ptr<VehiclePropValue> Create_ec_ccm_soc_hardware_numReq(float ec_ccm_soc_hardware_num);
    recyclable_ptr<VehiclePropValue> Create_ec_ccm_mcu_sofeware_numReq(float ec_ccm_mcu_sofeware_num);
    recyclable_ptr<VehiclePropValue> Create_ec_ccm_mcu_hardware_numReq(float ec_ccm_mcu_hardware_num);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_batterysoc_virtualReq(float ec_bms_batterysoc_virtual);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_single_chrg_energyReq(int32_t ec_bms_single_chrg_energy);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_livecounter_0x513Req(float ec_bms_livecounter_0x513);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_checksum_0x513Req(float ec_bms_checksum_0x513);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_batt_info4_dc_charg_req_currReq(float ec_bms_batt_info4_dc_charg_req_curr);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_batt_info4_dc_charg_req_volReq(float ec_bms_batt_info4_dc_charg_req_vol);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_batt_info4_mach_put_currReq(float ec_bms_batt_info4_mach_put_curr);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_batt_info4_mach_put_voltReq(float ec_bms_batt_info4_mach_put_volt);
    recyclable_ptr<VehiclePropValue> Create_ec_tbox_cpu_temperature_lowReq(float ec_tbox_cpu_temperature_low);
    recyclable_ptr<VehiclePropValue> Create_ec_tbox_cpu_temperature_highReq(float ec_tbox_cpu_temperature_high);
    recyclable_ptr<VehiclePropValue> Create_ec_pcb_temperature_lowReq(float ec_pcb_temperature_low);
    recyclable_ptr<VehiclePropValue> Create_ec_pcb_temperature_highReq(float ec_pcb_temperature_high);
    recyclable_ptr<VehiclePropValue> Create_ec_main_power_supply_voltahe_lowReq(float ec_main_power_supply_voltahe_low);
    recyclable_ptr<VehiclePropValue> Create_ec_main_power_supply_voltahe_highReq(float ec_main_power_supply_voltahe_high);
    recyclable_ptr<VehiclePropValue> Create_ec_sim_card_not_presentReq(float ec_sim_card_not_present);
    recyclable_ptr<VehiclePropValue> Create_ec_wifi_device_lostReq(float ec_wifi_device_lost);
    recyclable_ptr<VehiclePropValue> Create_ec_ccm_detects_eas_node_lossReq(float ec_ccm_detects_eas_node_loss);
    recyclable_ptr<VehiclePropValue> Create_ec_ccm_detects_bms_node_lossReq(float ec_ccm_detects_bms_node_loss);
    recyclable_ptr<VehiclePropValue> Create_ec_ccm_detects_ipu_node_lossReq(float ec_ccm_detects_ipu_node_loss);
    recyclable_ptr<VehiclePropValue> Create_ec_ccm_detects_vcu_node_lossReq(float ec_ccm_detects_vcu_node_loss);
    recyclable_ptr<VehiclePropValue> Create_ec_private_can3_bus_offReq(float ec_private_can3_bus_off);
    recyclable_ptr<VehiclePropValue> Create_ec_private_can2_bus_offReq(float ec_private_can2_bus_off);
    recyclable_ptr<VehiclePropValue> Create_ec_private_can1_bus_offReq(float ec_private_can1_bus_off);
    recyclable_ptr<VehiclePropValue> Create_ec_detect_backup_battery_lostReq(float ec_detect_backup_battery_lost);
    recyclable_ptr<VehiclePropValue> Create_ec_ccm_detects_acu_node_lossReq(float ec_ccm_detects_acu_node_loss);
    recyclable_ptr<VehiclePropValue> Create_ec_ccm_detects_bcm_node_lossReq(float ec_ccm_detects_bcm_node_loss);
    recyclable_ptr<VehiclePropValue> Create_ec_ccm_detects_ac_node_lossReq(float ec_ccm_detects_ac_node_loss);
    recyclable_ptr<VehiclePropValue> Create_bc_eas_motspdReq(float bc_eas_motspd);
    recyclable_ptr<VehiclePropValue> Create_bc_eas_eashvil_staReq(float bc_eas_eashvil_sta);
    recyclable_ptr<VehiclePropValue> Create_bc_eas_crtstsReq(float bc_eas_crtsts);
    recyclable_ptr<VehiclePropValue> Create_bc_eas_ip_mtempReq(float bc_eas_ip_mtemp);
    recyclable_ptr<VehiclePropValue> Create_bc_eas_ctrlrstsReq(float bc_eas_ctrlrsts);
    recyclable_ptr<VehiclePropValue> Create_bc_eas_crtpwrReq(int32_t bc_eas_crtpwr);
    recyclable_ptr<VehiclePropValue> Create_bc_eas_ctrlrcrtReq(float bc_eas_ctrlrcrt);
    recyclable_ptr<VehiclePropValue> Create_bc_eas_ctrlrvoltReq(float bc_eas_ctrlrvolt);
    recyclable_ptr<VehiclePropValue> Create_bc_ac_blower_levelReq(int32_t bc_ac_blower_level);
    recyclable_ptr<VehiclePropValue> Create_bc_ac_fan_reqReq(float bc_ac_fan_req);
    recyclable_ptr<VehiclePropValue> Create_bc_ac_fresh_reci_stateReq(int32_t bc_ac_fresh_reci_state);
    recyclable_ptr<VehiclePropValue> Create_bc_ac_front_defrost_stateReq(int32_t bc_ac_front_defrost_state, int32_t areaId);
    recyclable_ptr<VehiclePropValue> Create_bc_ac_heat_stateReq(int32_t bc_ac_heat_state);
    recyclable_ptr<VehiclePropValue> Create_bc_ac_havc_stateReq(int32_t bc_ac_havc_state);
    recyclable_ptr<VehiclePropValue> Create_bc_ac_ai_rdistribution_modeReq(int32_t bc_ac_ai_rdistribution_mode);
    recyclable_ptr<VehiclePropValue> Create_bc_ac_a_cstateReq(int32_t bc_ac_a_cstate);
    recyclable_ptr<VehiclePropValue> Create_bc_ac_left_set_temperatureReq(float bc_ac_left_set_temperature, int32_t areaId);
    recyclable_ptr<VehiclePropValue> Create_bc_ac_fan_pwmReq(float bc_ac_fan_pwm);
    recyclable_ptr<VehiclePropValue> Create_bc_ac_fan_feed_back_voltageReq(float bc_ac_fan_feed_back_voltage);
    recyclable_ptr<VehiclePropValue> Create_bc_ac_pt_ctempReq(float bc_ac_pt_ctemp);
    recyclable_ptr<VehiclePropValue> Create_bc_ac_fault_statusReq(int32_t bc_ac_fault_status);
    recyclable_ptr<VehiclePropValue> Create_bc_ac_ptc_over_heatReq(float bc_ac_ptc_over_heat);
    recyclable_ptr<VehiclePropValue> Create_bc_ac_eas_speed_reqReq(float bc_ac_eas_speed_req);
    recyclable_ptr<VehiclePropValue> Create_bc_ac_ptcp_power_reqReq(float bc_ac_ptcp_power_req);
    recyclable_ptr<VehiclePropValue> Create_bc_ac_press_swtich_stateReq(float bc_ac_press_swtich_state);
    recyclable_ptr<VehiclePropValue> Create_bc_ac_livecounter_0x233Req(float bc_ac_livecounter_0x233);
    recyclable_ptr<VehiclePropValue> Create_bc_ac_checksum_0x233Req(float bc_ac_checksum_0x233);
    recyclable_ptr<VehiclePropValue> Create_bc_ccm_fresh_reci_keyReq(float bc_ccm_fresh_reci_key);
    recyclable_ptr<VehiclePropValue> Create_bc_ccm_front_defrost_keyReq(float bc_ccm_front_defrost_key);
    recyclable_ptr<VehiclePropValue> Create_bc_ccm_a_ckeyReq(float bc_ccm_a_ckey);
    recyclable_ptr<VehiclePropValue> Create_bc_ccm_blower_levelReq(float bc_ccm_blower_level);
    recyclable_ptr<VehiclePropValue> Create_bc_ccm_ac_havc_stateReq(float bc_ccm_ac_havc_state);
    recyclable_ptr<VehiclePropValue> Create_bc_ccm_air_distribution_mode_reqReq(float bc_ccm_air_distribution_mode_req);
    recyclable_ptr<VehiclePropValue> Create_bc_ccm_heat_keyReq(float bc_ccm_heat_key);
    recyclable_ptr<VehiclePropValue> Create_bc_ccm_left_set_tempReq(float bc_ccm_left_set_temp);
    recyclable_ptr<VehiclePropValue> Create_bc_ccm_avassetReq(float bc_ccm_avasset);
    recyclable_ptr<VehiclePropValue> Create_bc_ccm_livecounter_0x310Req(float bc_ccm_livecounter_0x310);
    recyclable_ptr<VehiclePropValue> Create_bc_ccm_checksum_0x310Req(float bc_ccm_checksum_0x310);
    recyclable_ptr<VehiclePropValue> Create_bc_ccm_rear_fog_lamp_setReq(float bc_ccm_rear_fog_lamp_set);
    recyclable_ptr<VehiclePropValue> Create_bc_ccm_left_mirror_setReq(float bc_ccm_left_mirror_set);
    recyclable_ptr<VehiclePropValue> Create_bc_ccm_park_un_lock_reqReq(float bc_ccm_park_un_lock_req);
    recyclable_ptr<VehiclePropValue> Create_bc_ccm_auto_lock_reqReq(float bc_ccm_auto_lock_req);
    recyclable_ptr<VehiclePropValue> Create_bc_ccm_auto_unlock_reqReq(float bc_ccm_auto_unlock_req);
    recyclable_ptr<VehiclePropValue> Create_bc_ccm_remt_contr_lamp_ctr_cmdReq(float bc_ccm_remt_contr_lamp_ctr_cmd);
    recyclable_ptr<VehiclePropValue> Create_bc_ccu_remote_car_searchReq(int32_t bc_ccm_remote_car_search);
    recyclable_ptr<VehiclePropValue> Create_bc_ccu_remote_lockReq(int32_t bc_ccu_remote_lock);
    recyclable_ptr<VehiclePropValue> Create_bc_ccm_right_mirror_setReq(float bc_ccm_right_mirror_set);
    recyclable_ptr<VehiclePropValue> Create_bc_ccm_livecounter_0x311Req(float bc_ccm_livecounter_0x311);
    recyclable_ptr<VehiclePropValue> Create_bc_ccm_checksum_0x311Req(float bc_ccm_checksum_0x311);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_position_light_statusReq(int32_t bc_bcm_position_light_status);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_high_beam_statusReq(int32_t bc_bcm_high_beam_status);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_low_beam_statusReq(int32_t bc_bcm_low_beam_status);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_turn_indcr_riReq(int32_t bc_bcm_turn_indcr_ri);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_turn_indcr_leReq(int32_t bc_bcm_turn_indcr_le);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_hazard_light_statusReq(int32_t bc_bcm_hazard_light_status);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_position_light_warningReq(int32_t bc_bcm_position_light_warning);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_rl_door_ajar_statusReq(int32_t bc_bcm_rl_door_ajar_status);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_rr_door_ajar_statusReq(int32_t bc_bcm_rr_door_ajar_status);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_fr_door_ajar_statusReq(int32_t bc_bcm_fr_door_ajar_status);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_fl_door_ajar_statusReq(int32_t bc_bcm_fl_door_ajar_status);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_rear_fog_light_statusReq(int32_t bc_bcm_rear_fog_light_status);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_tr_cls_stReq(int32_t bc_bcm_tr_cls_st);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_power_stsReq(int32_t bc_bcm_power_sts);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_ccm_open_door_warn_feedReq(int32_t bc_bcm_ccm_open_door_warn_feed);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_dtc_fault_statusReq(int32_t bc_bcm_dtc_fault_status);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_veh_alrm_sys_stReq(int32_t bc_bcm_veh_alrm_sys_st);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_drivelock_stReq(int32_t bc_bcm_drivelock_st);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_reversinglight_stReq(float bc_bcm_reversinglight_st);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_brakelight_stReq(int32_t bc_bcm_brakelight_st);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_interiorlight_stReq(int32_t bc_bcm_interiorlight_st);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_right_mirror_set_ackReq(int32_t bc_bcm_right_mirror_set_ack);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_left_mirror_set_ackReq(int32_t bc_bcm_left_mirror_set_ack);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_park_un_lock_ackReq(int32_t bc_bcm_park_un_lock_ack);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_auto_lock_ackReq(int32_t bc_bcm_auto_lock_ack);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_auto_unlock_ackReq(int32_t bc_bcm_auto_unlock_ack);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_livecounter_0x330Req(float bc_bcm_livecounter_0x330);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_checksum_0x330Req(float bc_bcm_checksum_0x330);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_high_beam_rly_errReq(float bc_bcm_high_beam_rly_err);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_turn_indcr_ri_errReq(float bc_bcm_turn_indcr_ri_err);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_turn_indcr_le_errReq(float bc_bcm_turn_indcr_le_err);
    //recyclable_ptr<VehiclePropValue> Create_bc_bcm_position_light_errReq(float bc_bcm_position_light_err);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_daytime_running_light_errReq(float bc_bcm_daytime_running_light_err);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_brakelight_errReq(float bc_bcm_brakelight_err);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_reversinglight_errReq(float bc_bcm_reversinglight_err);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_rear_fog_light_errReq(float bc_bcm_rear_fog_light_err);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_loss_com_with_acuReq(float bc_bcm_loss_com_with_acu);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_loss_com_with_ccmReq(float bc_bcm_loss_com_with_ccm);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_loss_com_with_vcuReq(float bc_bcm_loss_com_with_vcu);
    recyclable_ptr<VehiclePropValue> Create_electric_errReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_lv_batt_over_voltReq(float bc_bcm_lv_batt_over_volt);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_lv_batt_under_voltReq(float bc_bcm_lv_batt_under_volt);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_horn_rly_errReq(float bc_bcm_horn_rly_err);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_low_beam_rly_errReq(float bc_bcm_low_beam_rly_err);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_livecounter_0x331Req(float bc_bcm_livecounter_0x331);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_checksum_0x331Req(float bc_bcm_checksum_0x331);
    recyclable_ptr<VehiclePropValue> Create_bc_pdc1_button_pressReq(int32_t bc_pdc1_button_press);
    recyclable_ptr<VehiclePropValue> Create_bc_pdc1_modeReq(int32_t bc_pdc1_mode);
    recyclable_ptr<VehiclePropValue> Create_bc_pdc1_buzzer_alarm_patternReq(int32_t bc_pdc1_buzzer_alarm_pattern);
    recyclable_ptr<VehiclePropValue> Create_bc_pdc1_distance_rmReq(int32_t bc_pdc1_distance_rm);
    recyclable_ptr<VehiclePropValue> Create_bc_pdc1_distance_rrmReq(int32_t bc_pdc1_distance_rrm);
    recyclable_ptr<VehiclePropValue> Create_bc_pdc1_distance_rlReq(int32_t bc_pdc1_distance_rl);
    recyclable_ptr<VehiclePropValue> Create_bc_pdc1_distance_rrReq(int32_t bc_pdc1_distance_rr);
    recyclable_ptr<VehiclePropValue> Create_bc_pdc_livecounter_0x165Req(float bc_pdc_livecounter_0x165);
    recyclable_ptr<VehiclePropValue> Create_bc_pdc_checksum_0x165Req(float bc_pdc_checksum_0x165);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_work_reqReq(float bc_bcm_work_req);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_livecounter_0x669Req(float bc_bcm_livecounter_0x669);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_checksum_0x669Req(float bc_bcm_checksum_0x669);
    recyclable_ptr<VehiclePropValue> Create_bc_str_work_reqReq(float bc_str_work_req);
    recyclable_ptr<VehiclePropValue> Create_bc_ccm_nm_bitReq(float bc_ccm_nm_bit);
    recyclable_ptr<VehiclePropValue> Create_bc_ccm_livecounter_0x66_bReq(float bc_ccm_livecounter_0x66_b);
    recyclable_ptr<VehiclePropValue> Create_bc_ccm_checksum_0x66_bReq(float bc_ccm_checksum_0x66_b);
    recyclable_ptr<VehiclePropValue> Create_bc_avas_stateReq(int32_t bc_avas_state);
    recyclable_ptr<VehiclePropValue> Create_bc_avas_livecounter_0x411Req(float bc_avas_livecounter_0x411);
    recyclable_ptr<VehiclePropValue> Create_bc_avas_checksum_0x411Req(float bc_avas_checksum_0x411);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_ccm_reset_stReq(float bc_bcm_ccm_reset_st);
    recyclable_ptr<VehiclePropValue> Create_bc_ota_modelReq(float bc_ota_model);
    recyclable_ptr<VehiclePropValue> Create_bc_ccm_bcm_open_door_warn_setReq(float bc_ccm_bcm_open_door_warn_set);
    recyclable_ptr<VehiclePropValue> Create_bc_ccm_livecounter_0x353Req(float bc_ccm_livecounter_0x353);
    recyclable_ptr<VehiclePropValue> Create_bc_ccm_checksum_0x353Req(float bc_ccm_checksum_0x353);
    recyclable_ptr<VehiclePropValue> Create_bc_ccm_tpms_learning_validReq(float bc_ccm_tpms_learning_valid);
    recyclable_ptr<VehiclePropValue> Create_bc_ccm_remt_ctrl_flagReq(float bc_ccm_remt_ctrl_flag);
    recyclable_ptr<VehiclePropValue> Create_bc_ccm_livecounter_0x354Req(float bc_ccm_livecounter_0x354);
    recyclable_ptr<VehiclePropValue> Create_bc_ccm_checksum_0x354Req(float bc_ccm_checksum_0x354);
    recyclable_ptr<VehiclePropValue> Create_bc_tpms_receiverstateReq(int32_t bc_tpms_receiverstate);
    recyclable_ptr<VehiclePropValue> Create_bc_tpms_transducer_locationReq(int32_t bc_tpms_transducer_location);
    recyclable_ptr<VehiclePropValue> Create_bc_tpms_tyrestate_frReq(int32_t bc_tpms_tyrestate_fr);
    recyclable_ptr<VehiclePropValue> Create_bc_tpms_tyrestate_flReq(int32_t bc_tpms_tyrestate_fl);
    recyclable_ptr<VehiclePropValue> Create_bc_tpms_tyrestate_rlReq(int32_t bc_tpms_tyrestate_rl);
    recyclable_ptr<VehiclePropValue> Create_bc_tpms_tyrestate_rrReq(int32_t bc_tpms_tyrestate_rr);
    recyclable_ptr<VehiclePropValue> Create_bc_tpms_tyretemperatureReq(float bc_tpms_tyretemperature,int current_tyre);
    recyclable_ptr<VehiclePropValue> Create_bc_tpms_tyrepressure_flReq(float bc_tpms_tyrepressure_fl);
    recyclable_ptr<VehiclePropValue> Create_bc_tpms_tyrepressure_frReq(float bc_tpms_tyrepressure_fr);
    recyclable_ptr<VehiclePropValue> Create_bc_tpms_tyrepressure_rrReq(float bc_tpms_tyrepressure_rr);
    recyclable_ptr<VehiclePropValue> Create_bc_tpms_tyrepressure_rlReq(float bc_tpms_tyrepressure_rl);
    recyclable_ptr<VehiclePropValue> Create_cc_acu_gsensor_faultReq(int32_t cc_acu_gsensor_fault);
    recyclable_ptr<VehiclePropValue> Create_cc_acu_system_stsReq(float cc_acu_system_sts);
    recyclable_ptr<VehiclePropValue> Create_cc_acu_airb_warn_lamp_stReq(int32_t cc_acu_airb_warn_lamp_st);
    recyclable_ptr<VehiclePropValue> Create_cc_acu_crash_outp_stsReq(float cc_acu_crash_outp_sts);
    recyclable_ptr<VehiclePropValue> Create_cc_acu_livecounter_0x133Req(float cc_acu_livecounter_0x133);
    recyclable_ptr<VehiclePropValue> Create_cc_acu_checksum_0x133Req(float cc_acu_checksum_0x133);
    recyclable_ptr<VehiclePropValue> Create_cc_abs_abs_fail_statusReq(int32_t cc_abs_abs_fail_status);
    recyclable_ptr<VehiclePropValue> Create_cc_abs_llivecounter_0x171Req(float cc_abs_llivecounter_0x171);
    recyclable_ptr<VehiclePropValue> Create_cc_abs_checksum_0x171Req(float cc_abs_checksum_0x171);
    recyclable_ptr<VehiclePropValue> Create_cc_eps_run_stateReq(int32_t cc_eps_run_state);
    recyclable_ptr<VehiclePropValue> Create_cc_eps_livecounter_0x300Req(float cc_eps_livecounter_0x300);
    recyclable_ptr<VehiclePropValue> Create_cc_eps_checksum_0x300Req(float cc_eps_checksum_0x300);
    recyclable_ptr<VehiclePropValue> Create_cc_eps_motor_curr_fltReq(float cc_eps_motor_curr_flt);
    recyclable_ptr<VehiclePropValue> Create_cc_eps_motor_volt_fltReq(float cc_eps_motor_volt_flt);
    recyclable_ptr<VehiclePropValue> Create_cc_eps_torq_snr_s_sig_out_rng_fltReq(float cc_eps_torq_snr_s_sig_out_rng_flt);
    recyclable_ptr<VehiclePropValue> Create_cc_eps_torq_snr_p_sig_out_rng_fltReq(float cc_eps_torq_snr_p_sig_out_rng_flt);
    recyclable_ptr<VehiclePropValue> Create_cc_eps_torq_snr_t1_t2_sig_sync_fltReq(float cc_eps_torq_snr_t1_t2_sig_sync_flt);
    recyclable_ptr<VehiclePropValue> Create_cc_eps_torq_snr_t1_sig_out_rng_fltReq(float cc_eps_torq_snr_t1_sig_out_rng_flt);
    recyclable_ptr<VehiclePropValue> Create_cc_eps_torq_snr_t2_sig_out_rng_fltReq(float cc_eps_torq_snr_t2_sig_out_rng_flt);
    recyclable_ptr<VehiclePropValue> Create_cc_eps_torq_snr5_v_fltReq(float cc_eps_torq_snr5_v_flt);
    recyclable_ptr<VehiclePropValue> Create_cc_eps_can_bus_fltReq(float cc_eps_can_bus_flt);
    recyclable_ptr<VehiclePropValue> Create_cc_eps_over_volt_fltReq(float cc_eps_over_volt_flt);
    recyclable_ptr<VehiclePropValue> Create_cc_eps_under_volt_fltReq(float cc_eps_under_volt_flt);
    recyclable_ptr<VehiclePropValue> Create_cc_eps_uncalibrated_angle_fltReq(float cc_eps_uncalibrated_angle_flt);
    recyclable_ptr<VehiclePropValue> Create_cc_eps_over_heat_fltReq(float cc_eps_over_heat_flt);
    recyclable_ptr<VehiclePropValue> Create_cc_eps_relay_fltReq(float cc_eps_relay_flt);
    recyclable_ptr<VehiclePropValue> Create_cc_eps_motor_curr_fellow_fltReq(float cc_eps_motor_curr_fellow_flt);
    recyclable_ptr<VehiclePropValue> Create_cc_eps_motor_drv_fltReq(float cc_eps_motor_drv_flt);
    recyclable_ptr<VehiclePropValue> Create_cc_eps_vcu_time_out_fltReq(float cc_eps_vcu_time_out_flt);
    recyclable_ptr<VehiclePropValue> Create_cc_eps_livecounter_0x301Req(float cc_eps_livecounter_0x301);
    recyclable_ptr<VehiclePropValue> Create_cc_eps_checksum_0x301Req(float cc_eps_checksum_0x301);
    recyclable_ptr<VehiclePropValue> Create_cc_abs_wheel_speed_fr_no_signal_errReq(float cc_abs_wheel_speed_fr_no_signal_err);
    recyclable_ptr<VehiclePropValue> Create_cc_abs_wheel_speed_fr_interm_errReq(float cc_abs_wheel_speed_fr_interm_err);
    recyclable_ptr<VehiclePropValue> Create_cc_abs_wheel_speed_fr_open_short_errReq(float cc_abs_wheel_speed_fr_open_short_err);
    recyclable_ptr<VehiclePropValue> Create_cc_abs_wheel_speed_fl_no_signal_errReq(float cc_abs_wheel_speed_fl_no_signal_err);
    recyclable_ptr<VehiclePropValue> Create_cc_abs_wheel_speed_fl_interm_errReq(float cc_abs_wheel_speed_fl_interm_err);
    recyclable_ptr<VehiclePropValue> Create_cc_abs_wheel_speed_fl_open_short_errReq(float cc_abs_wheel_speed_fl_open_short_err);
    recyclable_ptr<VehiclePropValue> Create_cc_abs_power_undervoltReq(float cc_abs_power_undervolt);
    recyclable_ptr<VehiclePropValue> Create_cc_abs_power_overvoltReq(float cc_abs_power_overvolt);
    recyclable_ptr<VehiclePropValue> Create_cc_abs_valve_relay_errReq(float cc_abs_valve_relay_err);
    recyclable_ptr<VehiclePropValue> Create_cc_abs_wheel_speed_freq_errReq(float cc_abs_wheel_speed_freq_err);
    recyclable_ptr<VehiclePropValue> Create_cc_abs_wheel_speed_rr_no_signal_errReq(float cc_abs_wheel_speed_rr_no_signal_err);
    recyclable_ptr<VehiclePropValue> Create_cc_abs_wheel_speed_rr_interm_errReq(float cc_abs_wheel_speed_rr_interm_err);
    recyclable_ptr<VehiclePropValue> Create_cc_abs_wheel_speed_rr_open_short_errReq(float cc_abs_wheel_speed_rr_open_short_err);
    recyclable_ptr<VehiclePropValue> Create_cc_abs_wheel_speed_rl_no_signal_errReq(float cc_abs_wheel_speed_rl_no_signal_err);
    recyclable_ptr<VehiclePropValue> Create_cc_abs_wheel_speed_rl_interm_errReq(float cc_abs_wheel_speed_rl_interm_err);
    recyclable_ptr<VehiclePropValue> Create_cc_abs_wheel_speed_rl_open_short_errReq(float cc_abs_wheel_speed_rl_open_short_err);
    recyclable_ptr<VehiclePropValue> Create_cc_abs_outlet_valve_rr_errReq(float cc_abs_outlet_valve_rr_err);
    recyclable_ptr<VehiclePropValue> Create_cc_abs_inlet_valve_rr_errReq(float cc_abs_inlet_valve_rr_err);
    recyclable_ptr<VehiclePropValue> Create_cc_abs_outlet_valve_rl_errReq(float cc_abs_outlet_valve_rl_err);
    recyclable_ptr<VehiclePropValue> Create_cc_abs_inlet_valve_rl_errReq(float cc_abs_inlet_valve_rl_err);
    recyclable_ptr<VehiclePropValue> Create_cc_abs_outlet_valve_fr_errReq(float cc_abs_outlet_valve_fr_err);
    recyclable_ptr<VehiclePropValue> Create_cc_abs_inlet_valve_fr_errReq(float cc_abs_inlet_valve_fr_err);
    recyclable_ptr<VehiclePropValue> Create_cc_abs_outlet_valve_fl_errReq(float cc_abs_outlet_valve_fl_err);
    recyclable_ptr<VehiclePropValue> Create_cc_abs_inlet_valve_fl_errReq(float cc_abs_inlet_valve_fl_err);
    recyclable_ptr<VehiclePropValue> Create_cc_abs_current_max_fault_levelReq(float cc_abs_current_max_fault_level);
    recyclable_ptr<VehiclePropValue> Create_cc_abs_can_bus_off_errReq(float cc_abs_can_bus_off_err);
    recyclable_ptr<VehiclePropValue> Create_cc_abs_can_hardware_errReq(float cc_abs_can_hardware_err);
    recyclable_ptr<VehiclePropValue> Create_cc_abs_ecu_hardware_errReq(float cc_abs_ecu_hardware_err);
    recyclable_ptr<VehiclePropValue> Create_cc_abs_motor_relay_errReq(float cc_abs_motor_relay_err);
    recyclable_ptr<VehiclePropValue> Create_cc_abs_motor_errReq(float cc_abs_motor_err);
    recyclable_ptr<VehiclePropValue> Create_cc_abs_valve_errReq(float cc_abs_valve_err);
    recyclable_ptr<VehiclePropValue> Create_cc_abs_livecounter_0x420Req(float cc_abs_livecounter_0x420);
    recyclable_ptr<VehiclePropValue> Create_cc_abs_checksum_0x420Req(float cc_abs_checksum_0x420);
    recyclable_ptr<VehiclePropValue> Create_mc_lamplet_statusReq(int32_t mc_lamplet_status);
    recyclable_ptr<VehiclePropValue> Create_mc_main_seat_pressure_statusReq(int32_t mc_main_seat_pressure_status);
    recyclable_ptr<VehiclePropValue> Create_mc_brake_level_alarm_statusReq(int32_t mc_brake_level_alarm_status);
    recyclable_ptr<VehiclePropValue> Create_mc_main_seat_safety_belt_statusReq(int32_t mc_main_seat_safety_belt_status);
    recyclable_ptr<VehiclePropValue> Create_mc_engine_statusReq(int32_t mc_engine_status);
    recyclable_ptr<VehiclePropValue> Create_mc_low_vol_battery_volReq(float mc_low_vol_battery_vol);
	  recyclable_ptr<VehiclePropValue> Create_mcu_steering_002_keyWatcher(int32_t mcu_steering_002_action, KeyCodeType mcu_steering_002_keycode);
    recyclable_ptr<VehiclePropValue> Create_mcu_steering_002_customWatcher(int32_t mcu_steering_002_action, CustomInputType mcu_steering_002_keycode);
    recyclable_ptr<VehiclePropValue> Create_sc_ec_ccm_batt_maintain_ctr_cmdReq(int32_t sc_ec_ccm_batt_maintain_ctr_cmd);
    recyclable_ptr<VehiclePropValue> Create_sc_ec_ccm_batt_maintain_stsReq(int32_t sc_ec_ccm_batt_maintain_sts);
    recyclable_ptr<VehiclePropValue> Create_sc_ec_ccm_versionReq(int32_t sc_ec_ccm_version);
    recyclable_ptr<VehiclePropValue> Create_sc_ec_ccm_soc_sofeware_numReq(int32_t sc_ec_ccm_soc_sofeware_num);
    recyclable_ptr<VehiclePropValue> Create_sc_ec_ccm_soc_hardware_numReq(int32_t sc_ec_ccm_soc_hardware_num);
    recyclable_ptr<VehiclePropValue> Create_sc_ec_ccm_mcu_software_numReq(int32_t sc_ec_ccm_mcu_software_num);
    recyclable_ptr<VehiclePropValue> Create_sc_ec_ccm_mcu_hardware_numReq(int32_t sc_ec_ccm_mcu_hardware_num);
    recyclable_ptr<VehiclePropValue> Create_sc_ec_ccm_target_chrg_currReq(int32_t sc_ec_ccm_target_chrg_curr);
    recyclable_ptr<VehiclePropValue> Create_sc_ccm_remote_lockReq(int32_t sc_ccm_remote_lock);
    recyclable_ptr<VehiclePropValue> Create_sc_ccm_remote_car_searchReq(int32_t sc_ccm_remote_car_search);
    recyclable_ptr<VehiclePropValue> Create_sc_ccm_remt_ctrl_flagReq(int32_t sc_ccm_remt_ctrl_flag);
    recyclable_ptr<VehiclePropValue> Create_sc_ec_ccm_operat_licenceReq(int32_t sc_ec_ccm_operat_licence);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_realtimealowdischapowerReq(int32_t ec_bms_realtimealowdischapower);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_ipuhvil_staReq(int32_t ec_ipu_ipuhvil_sta);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_mainrelayposistatusReq(int ec_ipu_mainrelayposistatus);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_workstatusReq(int ec_ipu_workstatus);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_tqreqReq(int ec_vcu_tqreq);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_softwareversionReq(int ec_bms_softwareversion);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_hardware_numReq(int ec_ipu_hardware_num);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_sofeware_numReq(int ec_ipu_sofeware_num);
    recyclable_ptr<VehiclePropValue> Create_appointment_modeReq(int32_t appointment_mode_type);
    recyclable_ptr<VehiclePropValue> Create_chraging_begin_time_hourReq(int32_t chraging_begin_time_hour);
    recyclable_ptr<VehiclePropValue> Create_chraging_begin_time_minuteReq(int32_t chraging_begin_time_minute);
    recyclable_ptr<VehiclePropValue> Create_chraging_end_time_hourReq(int32_t chraging_end_time_hour);
    recyclable_ptr<VehiclePropValue> Create_chraging_end_time_minuteReq(int32_t chraging_end_time_minute);
    recyclable_ptr<VehiclePropValue> Create_chraging_loopReq();
    recyclable_ptr<VehiclePropValue> Create_chraging_target_socReq(int32_t chraging_target_soc);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_obc_output_voltageReq(int32_t ipu_obc_output_voltage);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_obc_output_currentReq(int32_t ec_ipu_obc_output_current);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_mainrelaynega_statusReq(int32_t ec_bms_mainrelaynega_status);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_batterysohReq(int32_t ec_bms_batterysoh);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_soeReq(int32_t ec_bms_soe);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_hv_batt_stReq(int32_t ec_bms_hv_batt_st);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_initstatusReq(int32_t ec_bms_initstatus);
    recyclable_ptr<VehiclePropValue> Create_mc_light_levelReq(int32_t mc_light_level);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_rear_fog_light_errReq(int32_t value);       
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_reversinglight_errReq(int32_t value);       
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_brakelight_errReq(int32_t value);           
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_daytime_running_light_errReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_position_light_errReq(int32_t value);       
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_turn_indcr_le_errReq(int32_t value);            
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_turn_indcr_ri_errReq(int32_t value);            
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_high_beam_rly_errReq(int32_t value);            
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_low_beam_rly_errReq(int32_t value);             
    recyclable_ptr<VehiclePropValue> Create_bc_motion_park_stateReq(int32_t value);                
    recyclable_ptr<VehiclePropValue> Create_bc_park_chrg_cnctr_stsReq(int32_t value); 
    recyclable_ptr<VehiclePropValue> Create_mcu_voiume_navigationReq(int32_t value); 
    recyclable_ptr<VehiclePropValue> Create_mcu_voiume_voicReq(int32_t value); 
    recyclable_ptr<VehiclePropValue> Create_mcu_voiume_multimediaReq(int32_t value); 
    recyclable_ptr<VehiclePropValue> Create_mcu_voiume_phoneReq(int32_t value); 
    recyclable_ptr<VehiclePropValue> Create_mcu_voiume_alarmReq(int32_t value); 
    recyclable_ptr<VehiclePropValue> Create_mcu_voiume_keyReq(int32_t value); 
    recyclable_ptr<VehiclePropValue> Create_mcu_info_vin1Req(std::string value);
    recyclable_ptr<VehiclePropValue> Create_mcu_info_vin2Req(std::string value);
    recyclable_ptr<VehiclePropValue> Create_mcu_info_vin3Req(std::string value);
    recyclable_ptr<VehiclePropValue> Create_mcu_info_vinReq(std::string value);
    recyclable_ptr<VehiclePropValue> Create_mcu_info_sn1Req(std::string value);
    recyclable_ptr<VehiclePropValue> Create_mcu_info_sn2Req(std::string value);
    recyclable_ptr<VehiclePropValue> Create_mcu_info_sn3Req(std::string value);
    recyclable_ptr<VehiclePropValue> Create_mcu_info_versionReq(std::string value);
    recyclable_ptr<VehiclePropValue> Create_mc_travel_rangeReq(float value);
    recyclable_ptr<VehiclePropValue> Create_mc_travel_timeReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_mc_average_energy_consumptionReq(float value);
    recyclable_ptr<VehiclePropValue> Creat_range_modeReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Creat_gecko_headlighthReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_mc_remind_inrReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_mc_remind_start_timeReq(uint32_t value);
    recyclable_ptr<VehiclePropValue> Create_mc_remind_distanceReq(uint32_t value);
    recyclable_ptr<VehiclePropValue> Create_mc_remind_start_odoReq(float value);
    recyclable_ptr<VehiclePropValue> Create_bc_ac_hybrid_eco_mode_staReq(int32_t bc_ac_hybrid_eco_mode_sta);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_wipr_intl_time_set_fbReq(int32_t bc_bcm_wipr_intl_time_set_fb);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_flwr_me_hm_ctrl_fbReq(int32_t bc_bcm_flwr_me_hm_ctrl_fb);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_illmnd_unlock_sts_fbReq(int32_t bc_bcm_illmnd_unlock_sts_fb);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_illmnd_lock_sts_fbReq(int32_t bc_bcm_illmnd_lock_sts_fb);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_lock_horn_on_st_fbReq(int32_t bc_bcm_lock_horn_on_st_fb);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_esc_disableReq(int32_t ec_esc_esc_disable);
    recyclable_ptr<VehiclePropValue> Create_ec_ehb_avh_appld_stReq(int32_t ec_ehb_avh_appld_st);
    recyclable_ptr<VehiclePropValue> Create_ec_ehb_epb_system_stateReq(int32_t ec_ehb_epb_system_state);
    recyclable_ptr<VehiclePropValue> Create_ec_ehb_brk_dis_wip_acReq(int32_t ec_ehb_brk_dis_wip_ac);
    recyclable_ptr<VehiclePropValue> Create_ec_elec_steer_mode_staReq(int32_t ec_elec_steer_mode_sta);
    recyclable_ptr<VehiclePropValue> Create_bc_veh_act_recuperate_pwrReq(int32_t bc_veh_act_recuperate_pwr);
    recyclable_ptr<VehiclePropValue> Create_ec_vehicle_driving_pwrReq(int32_t ec_vehicle_driving_pwr);
    recyclable_ptr<VehiclePropValue> Create_ec_srs_passenger_airbag_sta_rsvrReq(int32_t ec_srs_passenger_airbag_sta_rsvr);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_front_fog_light_statusReq(int32_t bc_bcm_front_fog_light_status);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_key_lo_batt_lvl_warnReq(int32_t bc_bcm_key_lo_batt_lvl_warn);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_warn_no_key_foundReq(int32_t bc_bcm_warn_no_key_found);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_auto_lamp_statusReq(int32_t bc_bcm_auto_lamp_status);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_indication_shiftto_neutralReq(int32_t bc_bcm_indication_shiftto_neutral);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_12_v_bat_low_vol_staReq(int32_t ec_vcu_12_v_bat_low_vol_sta);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_sibs_kl30_voltageReq(int32_t ec_vcu_sibs_kl30_voltage);
    recyclable_ptr<VehiclePropValue> Create_ec_srs_airbag_warning_lamp_stsReq(int32_t ec_srs_airbag_warning_lamp_sts);
    recyclable_ptr<VehiclePropValue> Create_ec_srs_drv_seatbelt_buckle_validReq(int32_t ec_srs_drv_seatbelt_buckle_valid);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_obc_inlet_connect_staReq(int32_t ec_ipu_obc_inlet_connect_sta);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_dcs_inlet_connect_staReq(int32_t ec_bms_dcs_inlet_connect_sta);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_pwr_train_connect_staReq(int32_t ec_bms_pwr_train_connect_sta);
    recyclable_ptr<VehiclePropValue> Create_ec_ehb_brake_liquid_level_warnReq(int32_t ec_ehb_brake_liquid_level_warn);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_ebd_failedReq(int32_t ec_esc_ebd_failed);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_vhcl_p_gear_errorReq(int32_t ec_vcu_vhcl_p_gear_error);
    recyclable_ptr<VehiclePropValue> Create_ec_bcm_central_lock_stsReq(int32_t ec_bcm_central_lock_sts);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_pcu_fail_staReq(int32_t ec_vcu_pcu_fail_sta);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_mcu_high_temp_wrningReq(int32_t ec_vcu_mcu_high_temp_wrning);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_motor_high_temp_wrningReq(int32_t ec_vcu_motor_high_temp_wrning);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_warn_key_out_reminderReq(int32_t bc_bcm_warn_key_out_reminder);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_light_intensityReq(int32_t bc_bcm_light_intensity);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_indication_key_closerReq(int32_t bc_bcm_indication_key_closer);
    recyclable_ptr<VehiclePropValue> Create_ec_srs_pass_seatbelt_bucklestatusReq(int32_t ec_srs_pass_seatbelt_bucklestatus);
    recyclable_ptr<VehiclePropValue> Create_ec_srs_pass_seatbelt_buckle_validReq(int32_t ec_srs_pass_seatbelt_buckle_valid);
    recyclable_ptr<VehiclePropValue> Create_ec_srs_pass_seat_occupant_sensor_stsReq(int32_t ec_srs_pass_seat_occupant_sensor_sts);
    recyclable_ptr<VehiclePropValue> Create_ec_srs_mid_seat_belt_bucklestatusReq(int32_t ec_srs_mid_seat_belt_bucklestatus);
    recyclable_ptr<VehiclePropValue> Create_ec_srs_mid_seat_belt_buckle_validReq(int32_t ec_srs_mid_seat_belt_buckle_valid);
    recyclable_ptr<VehiclePropValue> Create_ec_srs_mid_seat_occupant_sensor_stsReq(int32_t ec_srs_mid_seat_occupant_sensor_sts);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_obc_actl_oprt_modeReq(int32_t ec_ipu_obc_actl_oprt_mode);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_dcs_act_oprt_modeReq(int32_t ec_bms_dcs_act_oprt_mode);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_reserve_powerReq(int32_t ec_vcu_reserve_power);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_motor_actual_powerReq(int32_t ec_vcu_motor_actual_power);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_motor_actual_power_typeReq(int32_t ec_vcu_motor_actual_power_type);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_hdc_statusReq(int32_t ec_vcu_hdc_status);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_es_cor_tcs_failedReq(int32_t ec_esc_es_cor_tcs_failed);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_tcs_active_staReq(int32_t ec_esc_tcs_active_sta);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_esp_active_staReq(int32_t ec_esc_esp_active_sta);
    recyclable_ptr<VehiclePropValue> Create_ec_ehb_avh_lamp_reqReq(int32_t ec_ehb_avh_lamp_req);
    recyclable_ptr<VehiclePropValue> Create_ec_ehb_epb_display_msg_idReq(int32_t ec_ehb_epb_display_msg_id);
    recyclable_ptr<VehiclePropValue> Create_ec_ehb_avh_disp_msgReq(int32_t ec_ehb_avh_disp_msg);
    recyclable_ptr<VehiclePropValue> Create_ec_ehb_epb_warn_lamp_staReq(int32_t ec_ehb_epb_warn_lamp_sta);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_obc_oprt_cmd_to_icuReq(int32_t ec_vcu_obc_oprt_cmd_to_icu);
    recyclable_ptr<VehiclePropValue> Create_bc_ac_envir_temp_vReq(int32_t bc_ac_envir_temp_v);
    recyclable_ptr<VehiclePropValue> Create_bc_ac_envir_tempReq(float bc_ac_envir_temp);
    recyclable_ptr<VehiclePropValue> Create_config_queryReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_vcu_chraging_mode_sp_reqReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_pp_fl_distReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_pp_fml_distReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_pp_fmr_distReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_pp_fr_distReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_pp_sdwfsl_distReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_pp_sdwfsl_mid_distReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_pp_sdwfsr_mid_distReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_pp_sensor_fault_sts_frmReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_pp_sensor_fault_sts_frReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_pp_sdwrsr_distReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_pp_staReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_pp_sw_fdbkReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_elk_set_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_aeb_set_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_aeb_and_fcw_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_hma_set_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_tsr_spd_lim_warnReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_tsr_spd_lim_warn_auReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_tsr_spd_lim_stsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_slwf_set_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_fcm_intializationReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_elk_left_modeReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_elk_right_modeReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_slif_set_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_trfc_signReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_tsr_lgt_dstReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_tsr_lat_dstReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_tsr_set_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_tsr_spd_limReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_slif_oper_stsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_audio_warn_hands_offReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_fault_text_infoReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_lka_audio_warningReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_act_drv_asst_sts_hmiReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_tar_obj_accReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_adas_not_avl_reasReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_acc_startReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_ica_truck_set_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_ica_set_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_adas_quit_reasReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_acc_mode_hmiReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_pcw_pre_warnReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_pcw_latent_warnReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_text_info_lka1Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_ldw_stsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_ldw_set_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_lka_stsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_le_line_color_fctReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_lka_set_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_ri_line_color_fctReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_ldw_alert_method_set_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_v_set_disReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_aeb_obj_idReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_raeb_work_stsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_ldw_audio_warnReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_laterallimitReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_obc_inlelt_actl_powerReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_srs_crash_output_stsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_insulation_wrning_distgshReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_thermalrunaway_wrnReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_dcs_actl_chrg_voltageReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_icu_vehicle_speed_displayed_vReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_icu_icu_trip_a_odometerReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_icu_icu_trip_b_odometerReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_cc_eps_basic_elec_steer_failedReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_cc_eps_mode_set_inhibit_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_cc_eps_sws_hod_hands_off_stsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_vcu_info_dispReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_vcu_vhcl_speed_fast_warnReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_vcu_drive_mode_key_stagnationReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_vcu_cc_key_stagnationReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_vcu_shift_key_stagnationReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_vcu_lock_veh_warmReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_vcu_sibs_kl30_voltageReq(float value);
    recyclable_ptr<VehiclePropValue> Create_bc_vcu_sibs_rtcwu_chg_numReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_vcu_sibs_chg_num_allowReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_vcu_sibs_rtcwu_chg_fail_numReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_vcu_sibs_rtc_chrg_stReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_vcu_sibs_wup_volt_allowReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_vcu_sibs_bms_bat_soc_allowReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_vcu_sibs_fb_rtc_wup_flgReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_vcu_ac_chrg_max_currReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_vcu_ac_chrg_modeReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_ccu_open_ventilation_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_ac_ac_unlock_vent_set_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_ac_remote_defrost_ctl_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_ac_temp_set_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_ac_remt_ctrl_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_ccu_remote_power_lock_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_vcu_speed_limit_level_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_vcu_operat_licence_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_vcu_version_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_vcu_vesion_set_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_vcu_wgh_confdenceReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_vcu_wgh_estReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_vcu_wgh_distbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_vcu_cruise_ctrl_sta_for_bacReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_vcu_cruise_ctr_tgt_spd_for_bacReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_ac_indoor_tempReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_light_sw_sigReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_ajar_sta_hoodReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_tmps_abnm_prsr_warnReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_tpms_reset_stsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_fr_windowmotor_flagsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_fl_windowmotor_flagsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_wash_liquid_level_warnReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_front_wash_stsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_pas_wdw_initReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_drv_pass_win_sw_sigReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_body_warn_stsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_key_in_car_staReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_ps_authent_resReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_trunk_lock_sw_ctrl_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_trunk_lock_staReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_overspd_cntrl_lock_set_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_park_auto_unlock_set_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_chg_wiper_mt_md_sw_set_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_drv_lf_ant_diag_statusReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_lf_init_staReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_door_lock_operation_recordReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_int_lf_ant_diag_statusReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_pass_lf_ant_diag_statusReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_illmnd_entry_sts_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_steer_whl_tempReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_steer_whl_heat_stsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_rear_mirror_heat_stsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_mai_drvr_seat_tempReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_mai_drvr_seat_stsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_logo_active_flagReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_rf_init_staReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_rear_fog_li_fault_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_front_fog_li_fault_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_pos_li_fault_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_back_li_fault_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_brake_li_fault_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_reverse_li_fault_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_day_run_li_fault_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ehb_epb_flt_stsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ehb_epb_switch_stsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ehb_failure_stsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_vhcl_actl_gear_pos_vReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bcm_sys_pwr_mode_vReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bcm_sys_pwr_modeReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bcm_sys_power_stsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bcm_door_lock_sta_flReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_pwr_recup_intensityReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ccu_diag_tester_onlineReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bcm_back_ladjval_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_rmi_active_staReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_slope_percent_vReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_slope_percentReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_inv_antithft_auth_rsltReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_ac_auto_blower_mode_staReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_fcw_set_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_ac_extd_defrost_actv_reqReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_scs_left_swt_vdReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_scs_left_1_swtReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_scs_left_2_swtReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_scs_left_3_swtReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_scs_left_4_swtReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_scs_left_5_swtReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_scs_left_6_swtReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_scs_left_7_swtReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_scs_left_8_swtReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_avas_state_rolling_counterReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_current_over_wrningReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_battery_sub_sys_numReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_battery_sub_sys_codReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_battery_dtc_numReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_battery_dtc_listReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_battery_dtc_indexReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_inv_1_rolling_counterReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_inv_4_err_bitsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_inv_4_rolling_counterReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_scs_right_swt_vdReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_scs_right_14_swtReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_scs_right_15_swtReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_scs_right_16_swtReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_crrr_bsd_warn_rightReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_crrr_bsd_warn_leftReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_crrr_bsd_set_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_crrr_rcta_warn_rightReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_crrr_rcta_warn_leftReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_crrr_rcta_set_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_crrr_rcw_warningReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_crrr_rcw_set_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_crrr_rear_corner_failureReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_crrr_rear_corner_blindnessReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_crrr_dow_set_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_crrr_dow_warn_frReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_crrr_dow_warn_flReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_crrr_dow_warn_rrReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_crrr_dow_warn_rlReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_crrr_dow_warn_rightReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_crrr_dow_warn_leftReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_typ1Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_lat_dst1Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_lgt_dst1Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_lgt_rel_spd1Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_posn_agl1Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_lgt_rel_spd7Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_movmt_dir1Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_lgt_rel_spd8Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_movmt_sta1Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_typ2Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_lat_dst2Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_lgt_dst2Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_posn_agl2Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_lgt_rel_spd2Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_lgt_rel_spd9Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_movmt_dir2Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_movmt_sta2Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_typ3Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_lat_dst3Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_lgt_dst3Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_posn_agl3Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_lgt_rel_spd3Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_movmt_dir3Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_movmt_sta3Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_typ4Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_lat_dst4Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_lgt_dst4Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_posn_agl4Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_lgt_rel_spd4Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_movmt_sta4Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_movmt_dir4Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_movmt_dir7Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_typ5Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_lat_dst5Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_lgt_dst5Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_posn_agl5Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_lgt_rel_spd5Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_movmt_dir5Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_movmt_sta5Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_movmt_sta9Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_typ6Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_lat_dst6Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_lgt_dst6Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_posn_agl6Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_lgt_rel_spd6Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_movmt_dir9Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_movmt_sta6Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_movmt_dir6Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_typ7Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_lat_dst7Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_lgt_dst7Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_posn_agl7Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_movmt_sta7Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_lat_dst8Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_lgt_dst8Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_typ8Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_typ9Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_movmt_sta8Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_posn_agl8Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_lat_dst9Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_lgt_dst9Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_posn_agl9Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_movmt_dir8Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_typ10Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_lat_dst10Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_lgt_dst10Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_posn_agl10Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_movmt_sta10Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_lat_dst11Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_lgt_dst11Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_typ11Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_posn_agl11Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_movmt_sta11Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_lat_dst12Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_lgt_dst12Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_typ12Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_movmt_dir11Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_posn_agl12Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_typ13Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_lat_dst13Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_lgt_dst13Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_movmt_sta13Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_posn_agl13Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_lat_dst14Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_lgt_dst14Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_typ14Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_movmt_sta14Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_posn_agl14Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_lat_dst15Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_lgt_dst15Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_typ15Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_movmt_dir14Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_posn_agl15Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_typ16Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_lat_dst16Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_lgt_dst16Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_lat_dst17Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_lgt_dst17Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_movmt_sta16Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_movmt_dir16Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_typ17Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_typ18Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_movmt_sta17Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_lat_dst18Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_lgt_dst18Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_posn_agl18Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_movmt_dir17Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_movmt_dir18Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_movmt_sta18Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_lgt_rel_spd10Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_posn_agl16Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_lgt_rel_spd11Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_posn_agl17Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_lgt_rel_spd12Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_lgt_rel_spd13Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_movmt_dir10Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_lgt_rel_spd14Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_movmt_sta12Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_lgt_rel_spd15Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_movmt_dir12Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_lgt_rel_spd16Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_movmt_dir13Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_movmt_sta15Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_lgt_rel_spd17Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_lgt_rel_spd18Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_movmt_dir15Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_nr_of_lineReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_le_line_typReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_le_line_rdReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_le_line_dstReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_le_line_c1Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_le_line_c2Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_ri_line_typReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_le_line_c3Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_ri_line_rdReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_ri_line_dstReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_ri_line_c1Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_ri_line_c3Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_ri_line_c2Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_le_le_line_typReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_le_le_line_c1Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_le_le_line_c3Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_le_le_line_rdReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_le_le_line_dstReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_ri_ri_line_c1Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_ri_ri_line_c3Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_ri_ri_line_rdReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_ri_ri_line_dstReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_ri_ri_line_typReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_le_le_line_c2Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_ri_ri_line_c2Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_spd_downin_cor_sfkReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_vcu_speed_limit_level_set_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_abs_active_staReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_dcc_actl_oprt_modeReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_over_temperature_failReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_accl_pedal_posReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_brk_pedal_posReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_iso_resistanceReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ehb_brk_pedl_valReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ehb_brk_pedl_val_vldReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ehb_brk_pedl_val_percReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ehb_brk_pedl_val_perc_vldReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_mc_travel_average_speedReq(float value);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_dcc_sys_fail_staReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_chrg_target_socReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bcm_brake_pedal_staReq(int32_t value);

    recyclable_ptr<VehiclePropValue> Create_fcm_adas_drvr_req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_fcm_elk_sts(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_fcm_slifs_spd_lim(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_fcm_aeb_status(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_fcm_aeb_statsadsus(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_hu_dowenaswt(int32_t value);

    recyclable_ptr<VehiclePropValue> Create_sc_fcm_acc_take_over_reqWatcher(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_fcm_tjatakeoverreqWatcher(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_aeb_recreqWatcher(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_hu_hma_enable_swWatcher(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_hu_ica_enable_sw_tWatcher(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_hu_ica_avd_truck_setWatcher(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_hu_ldw_alert_method_swWatcher(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_hu_lka_enable_swWatcher(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_hu_elk_enb_swWatcher(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_hu_fcw_enable_swWatcher(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_hu_abe_enable_swWatcher(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_hu_bsd_enable_swWatcher(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_hu_rcw_enable_swWatcher(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_hu_rcta_enable_swWatcher(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_hu_slif_enableswWatcher(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_hu_slwf_enableswWatcher(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_hu_navi_country_codeWatcher(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_avalueble_key_in_carReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_sys_fail_staReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ccu_remt_steer_whl_heat_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ccu_remt_power_ctrl_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ccu_remt_mai_dr_seat_heat_fbReq(int32_t value);

    recyclable_ptr<VehiclePropValue> Create_bc_pp_sensor_fault_sts_rlReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_pp_sensor_fault_sts_rlmReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_pp_sensor_fault_sts_rrmReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_pp_sensor_fault_sts_rrReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_pp_rl_distReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_pp_rlm_distReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_pp_rrm_distReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_pp_rr_distReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_pp_sdwfsr_distReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_pp_sdwrsl_distReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_pp_sdwrsl_mid_distReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_pp_sdwrsr_mid_distReq(int32_t value);

    recyclable_ptr<VehiclePropValue> Create_bc_fm_auto_seek_resWatcherReq(std::vector<int16_t> value);
    recyclable_ptr<VehiclePropValue> Create_fm_searchWatcherReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_fm_volumeWatcherReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_err_amountReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_err_bitReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_carriage_light_staReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_eps_steer_wheel_angleReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_eps_steer_wheel_angle_validReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_eps_rot_speedReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_eps_steer_wheel_angle_failureReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_eps_electric_power_staReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_eps_steer_wheel_angle_calibratedReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_eps_mot_tqReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_lgt_fct_actv_flgReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_eps_set_steer_whl_aglReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_steer_tq_req_activeReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_eps_ctrl_reqReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_drvr_warn_vib_reqReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_daeps_mode_reqReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_act_drv_asst_stsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_overtake_ass_sys_stsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_turn_lamp_reqReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_tjaica_supps_abortnReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_lka_torq_fact_reqReq(float value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_hma_supps_abortnReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_lkaldw_supps_abortnReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_flt_stsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_elk_supps_abortnReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_acc_whl_tq_req_valReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_acc_whl_tq_req_actvReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_acc_whl_deceReq(float value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_acc_tar_accrnReq(float value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_acc_supp_abortReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_acc_tar_accrn_req_actvReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_epb_req_vReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_epb_reqReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_acc_shutdown_modeReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_ahd_obj_idReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_acc_tgt_axReq(float value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_aeb_tgt_axReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_acc_modeReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_acc_req_standstillReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_aeb_reqReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_aeb_standstill_stsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_aeb_standstill_sts_vReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_aba_levelReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_awb_levelReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_aba_reqReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_eba_reqReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_awb_reqReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_abp_reqReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_acc_tgt_ax_reqReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_crv_decel_staReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_acc_req_drive_offReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_mc_scs_frnt_wipr_swt_stReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_mc_scs_low_beam_swt_stReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_mc_scs_hi_beam_swt_stReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_mc_scs_over_veh_beam_swt_stReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_mc_scs_lamp_auto_stReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_mc_scs_le_turn_lmp_swt_stReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_mc_scs_ri_turn_lmp_swt_stReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_hv_bat_cell_temp_aveReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_dcs_actl_chrg_currentReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_scs_gear_shift_lever_pst_reqReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_ac_chrg_atcl_staReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_outlet_coolant_actl_tempReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_outlet_coolant_actl_temp_validReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_inlet_coolant_actl_tempReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_inlet_coolant_actl_temp_validReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_max_chrg_voltage_acReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_max_chrg_current_acReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_bat_sohReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_temp_max_dc_charge_socketReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_pcb_temp_maxReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_max_allow_chrg_cur_dcReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_max_allow_chrg_vol_dcReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_electronic_lock_ctrlReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_electronic_lock_stateReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_contactor_state_dc_chargerReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_dcs_charge_requestReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_dcs_chrg_a_plusReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_run_stateReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_contactor_state_negativeReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_contactor_state_positiveReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_contactor_state_prechargeReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_supply_voltage_statusReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_emeshutdown_reqReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_charge_interlock_staReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_dis_charge_interlock_staReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_batt_balance_staReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_therm_runaway_snsr_fltReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_therm_runaway_vlv_stReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_obc_uac_act_l1Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_obc_uac_act_l2Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_obc_uac_act_l3Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_obc_iac_act_l1Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_obc_iac_act_l2Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_obc_iac_act_l3Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_device_int_tempReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_obc_temp_inletReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_obc_ac_max_pw_allowReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_obc_inlet_electronic_lockReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_obc_s2_stateReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_obc_wake_up_modeReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_obc_voltage_ok_l1Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_obc_voltage_ok_l2Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_obc_voltage_ok_l3Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_dcc_high_volt_actl_curReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_dcc_high_volt_actl_volReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_obc_hvdc_actl_curReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_obc_connect_main_staReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_obc_requestReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_obc_sys_fail_staReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_obc_hvdc_actl_volReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_obc_errbitReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_dcc_low_vol_actl_volReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_dcc_low_vol_actl_curReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_dcc_precharge_completeReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_dcc_derating_oprt_staReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_hvil_fail_staReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_dcc_errbitReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_obc_c_cor_cp_cnctd_stsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_obc_cp_dutyReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_obc_cp_max_voltReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_obc_process_codeReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_obc_cc_resisdentReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_eps_torsion_bar_torqueReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_eps_torsion_bar_torque_dirReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_eps_torsion_bar_torque_validReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_eps_elect_power_consumptionReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_eps_advanced_mode_statusReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_eps_lat_drv_lvl12_srv_avlReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_eps_lat_mc_hptc_wrn_srv_avlReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_eps_pscm_int_rpc_max_trqReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_eps_torsion_bar_torque_qfReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_eps_pscm_int_rpc_min_trqReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_eps_lat_mc_steer_tq_activeReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_eps_lat_mc_hptc_wrn_activeReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_eps_max_allwd_rot_spdReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_eps_lks_agl_sys_stsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_eps_max_allwd_aglReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_eps_steer_tqReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_eps_lks_abort_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_eps_lks_agl_ctrl_avl_stsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_req_brake_light_onReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_ebd_active_staReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_ess_activeReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_cdp_activeReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_brake_temp_over_heatReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_dtc_active_stsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_vhcl_standstill_staReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_dtc_request_rbs_stsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_dtc_failure_stsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_wheel_speed_kph_v_flReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_wheel_direction_flReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_wheel_speed_kph_flReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_wheel_speed_kph_v_frReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_wheel_direction_frReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_wheel_speed_kph_frReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_master_cylinder_presrReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_master_cylinder_presr_vReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_wheel_speed_kph_v_rlReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_wheel_direction_rlReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_wheel_speed_kph_rlReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_wheel_speed_kph_v_rrReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_wheel_direction_rrReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_wheel_speed_kph_rrReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_wheel_speed_rc_sts_flReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_wheel_speed_rc_sts_frReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_wheel_speed_rc_sts_rlReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_wheel_speed_rc_sts_rrReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_wheel_speed_rc_flReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_wheel_speed_rc_frReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_wheel_speed_rc_rlReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_wheel_speed_rc_rrReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_long_acc_sensor_valueReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_long_acc_sensor_value_vldReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_lat_acc_sensor_value_vldReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_lat_acc_sensor_valueReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_yaw_rateReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_yaw_rate_vldReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_epb_right_currentReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_epb_right_fault_stateReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_hbb_hbc_availableReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_epb_actuator_st_rReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_hbb_hbc_activeReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_whl_tq_dec_req_actvReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_whl_tq_dec_req_valReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_whl_tq_inc_req_actvReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_whl_tq_inc_req_valReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ehb_cdp_requestReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ehb_epb_actuator_st_rReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ehb_epb_actuator_st_lReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ehb_hhc_active_staReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ehb_rgn_brk_stReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ehb_ext_req_statusReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ehb_blaReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ehb_hmi_warning_onReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ehb_epb_dynamic_apply_staReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ehb_pedl_trvl_snsr_fail_pdfReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ehb_req_brk_li_onReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ehb_pedl_trvl_snsr_fail_pdtReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ehb_p_runout_pressureReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ehb_brake_pedal_appliedReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ehb_brake_pedal_applied_qReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ehb_cdd_temp_offReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ehb_s_output_rod_hydraulic_targetReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ehb_s_output_rod_driver_percReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ehb_aba_active_staReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ehb_aba_available_staReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ehb_awb_active_staReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ehb_awb_available_staReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ehb_aeb_active_staReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ehb_aeb_available_staReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ehb_abp_active_staReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ehb_abp_available_staReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_pp_raeb_set_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_pp_raeb_work_stsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_pp_raeb_brkg_reqReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_pp_raeb_brkg_req_valReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_pp_raeb_distance_to_collisionReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_crrr_rctb_decelarationReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_crrr_rctb_reqReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_crrr_rctb_brkg_vldReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_crrr_fov_chg_set_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_max_con_dis_curntReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_pwr_recup_max_con_chrg_curntReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_max_instan_dis_curntReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_pwr_recup_max_instan_chrg_curntReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_cell_vol_aveReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_contactor_temp_negativeReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_max_cell_temp_limitReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_max_cell_vol_limitReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_pwr_limd_flgReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_min_cell_temp_limitReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_min_cell_vol_limitReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_err_tab_indexReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_battery_typeReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_hw_versionReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_pack_identityReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_sw_versionReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_nom_cell_capReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_bat_capacityReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bem_spn2560_aaReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bem_spn2560_00Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bem_spn3904_croReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bem_spn3903_cml_ctsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bem_spn3906_cstReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bem_spn3905_ccsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bem_spn3907_csdReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_cem_bms_identify_timoutReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_cem_bms_finish_charge_timeoutReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_cem_battery_parameter_timoutReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_cem_bms_abort_charge_timeoutReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_cem_battery_charge_require_timeoutReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_cem_battery_state_timeoutReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_cem_bms_charge_statistics_timeoutReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bst_abort_achive_dcsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bst_abort_achive_single_voltReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bst_abort_achive_total_voltReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bst_abort_achive_socReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bst_abort_fault_connectorReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bst_abort_fault_bms_tempReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bst_abort_fault_connector_tempReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bst_abort_fault_insulationReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bst_abort_fault_otherReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bst_abort_fault_voltageReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bst_abort_fault_hvReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bst_abort_fault_battery_tempReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bst_abort_error_voltageReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bst_abort_error_currentReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_cst_abort_by_bmsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_cst_abort_by_faultReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_cst_abort_by_userReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_cst_abort_achive_conditionReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_cst_abort_fault_energe_transmitReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_cst_abort_fault_charger_inner_tempReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_cst_abort_fault_connetorReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_cst_abort_fault_charger_tempReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_cst_abort_fault_otherReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_cst_abort_fault_charger_stopReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_cst_abort_error_voltageReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_cst_abort_error_currentReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bcm_rear_view_mirr_heating_stsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_tms_ohx_out_tmpReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_tms_evap_tmpReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_tms_evap_out_tmpReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_tms_chiller_out_tmpReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bcm_high_beam_li_fault_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bcm_low_beam_li_fault_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bcm_vhcl_seekReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bcm_illmnd_stsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bcm_key_frbdnReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bcm_frbdn_key_nrReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bcm_start_reqReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bcm_drv_pe_authent_acsdReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bcm_frpe_authent_acsdReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bcm_ps_reqReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bcm_frnt_le_door_hndl_swtReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bcm_frnt_ri_door_hndl_swtReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bcm_save_power_staReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bcm_front_wiper_motor_stsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bcm_fl_window_stsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bcm_fr_window_stsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bcm_fl_windowmotor_stsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bcm_fr_windowmotor_stsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bcm_wiper_ctrl_frontReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bcm_drv_seat_occupant_sensor_stsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bcm_heavy_rain_indReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_tpms_pressure_value_rrReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_tpms_pressure_value_rlReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_tpms_pressure_sta_rlReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_tpms_pressure_sta_rrReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_tpms_pressure_value_frReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_tpms_pressure_value_flReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_tpms_pressure_sta_flReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_tpms_pressure_sta_frReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bcm_dome_light_staReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bcm_back_lamp_staReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bcm_bass_horn_reqReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bcm_ajar_sta_v_hoodReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bcm_frnt_fog_li_sw_sigReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bcm_rear_fog_li_sw_sigReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bcm_day_run_light_staReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bcm_reverse_lamp_staReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bcm_brake_lamp_staReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bcm_turn_li_stsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_act_whl_tqReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_act_whl_tq_vldReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_drv_req_whl_tqReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_drv_whl_tq_allwd_maxReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_pwr_recup_max_avlb_whl_tq_stsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_pwr_recup_actl_whl_tq_stsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_brk_pwr_recup_max_avlb_whl_tqReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_pwr_recup_act_whl_tqReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_brk_pwr_recup_act_whl_tqReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_brk_pwr_recup_actl_whl_tq_stsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_acc_req_drive_offReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_actl_motor_rotate_spdReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_actl_motor_rotate_spd_vReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_remt_ac_ctrl_stReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_remt_ac_defrostl_reqReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_remt_ac_ctrl_reqReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_charging_conditions_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_accl_pedal_pos_snsr_staReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_req_epbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_acc_trq_ctrl_avlReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_acc_standstill_reqReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_acc_tgt_axReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_acc_tgt_ax_reqReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_drv_req_torq_override_fcmReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_cruise_ctr_tgt_spdReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_cruise_ctrl_staReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_scs_right_11_swtReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_scs_right_12_swtReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_scs_right_13_swtReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_scs_gear_shift_lever_pst_req_vdReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_dcs_actl_chrg_powerReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ccu_keep_awake_staReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_bra_tor_reqReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_pp_sensor_fault_sts_flmReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_pp_sensor_fault_sts_flReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bcm_authent_key_nrReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bcm_key_staReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bcm_wiper_stop_pos_staReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_drv_req_whl_tq_vldReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_insulation_wrningReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_tau_gap_setReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_gecko_e2p_rom_resultReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_gecko_key_code_resultReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_hma_highbeam_reqReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bcm_hazard_lamp_stsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_rke_reqReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_hma_stsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_le_turn_li_fault_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_ri_turn_li_fault_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_ac_ac_sta_fbReq(int32_t value);
    VehiclePropValuePool* const mValueObjectPool;
    PropertyManager* const mPropertyManager;
    EmulatedVehicleHalIface* const mHal;

    // TODO(chenhaosjtuacm): use std::filesystem when toolchain >= gcc8 is available
    const std::string mPowerStateMarkerPath;

    std::atomic<bool> mSystemShuttingDownPrepareFlag{false};
    std::atomic<bool> mShuttingDownFlag{false};
    std::atomic<steady_clock::time_point> mLastHeartbeatTime{};
    std::vector<std::thread> mThreads;
    std::condition_variable mHeartbeatCV;
    std::mutex mHeartbeatMutex;
//    const std::string mSpeedFilePath = "./speed.txt";  // 车速文件路径

};

/*
1：BATOFF模式：车辆蓄电池亏电模式;
2： SLEEP模式：整车休眠模式;
3： STANDBY模式：待机模式;
4： ACTIVE模式：全功能运行模式;
5： STR模式：SOC挂起到RAM模式;
*/
#define SYSFS_PATH "/sys/kernel/need_power_key_lock_debug"  // sysfs 文件路径
#define SYSFS_PATH1 "/sys/kernel/power_key_lock_debug"  // sysfs 文件路径
int clr_power_key_status(){

    int fd;
    char buf[2];  // 假设只写入1或0

    // 打开 sysfs 节点
    fd = open(SYSFS_PATH, O_WRONLY);
    if (fd < 0) {
        perror("Failed to open sysfs file");
        return -1;
    }

    // 将整数转换为字符串并写入 sysfs 节点
    snprintf(buf, sizeof(buf), "%d", 0);

    if (write(fd, buf, sizeof(buf)) < 0) {
        perror("Failed to write to sysfs file");
        close(fd);
        return -1;
    }

    // 关闭文件
    close(fd);
    // 打开 sysfs 节点
    fd = open(SYSFS_PATH1, O_WRONLY);
    if (fd < 0) {
        perror("Failed to open sysfs file");
        return -1;
    }

    // 将整数转换为字符串并写入 sysfs 节点
    snprintf(buf, sizeof(buf), "%d", 0);

    if (write(fd, buf, sizeof(buf)) < 0) {
        perror("Failed to write to sysfs file");
        close(fd);
        return -1;
    }

    // 关闭文件
    close(fd);

    return 0;
}
int set_power_key_lock(int value)
{
    int fd;
    char buf[2];  // 假设只写入1或0

    // 打开 sysfs 节点
    fd = open(SYSFS_PATH, O_WRONLY);
    if (fd < 0) {
        perror("Failed to open sysfs file");
        return -1;
    }

    // 将整数转换为字符串并写入 sysfs 节点
    snprintf(buf, sizeof(buf), "%d", value);

    if (write(fd, buf, sizeof(buf)) < 0) {
        perror("Failed to write to sysfs file");
        close(fd);
        return -1;
    }

    // 关闭文件
    close(fd);
    // 打开 sysfs 节点
    fd = open(SYSFS_PATH1, O_WRONLY);
    if (fd < 0) {
        perror("Failed to open sysfs file");
        return -1;
    }

    // 将整数转换为字符串并写入 sysfs 节点
    snprintf(buf, sizeof(buf), "%d", 0);

    if (write(fd, buf, sizeof(buf)) < 0) {
        perror("Failed to write to sysfs file");
        close(fd);
        return -1;
    }

    // 关闭文件
    close(fd);

    return 0;
}
int get_need_power_key_lock(int *value)
{
    int fd;
    char buf[2];  // 假设只读取1或0
    // 打开 sysfs 节点
    fd = open(SYSFS_PATH, O_RDONLY);
    if (fd < 0) {
        perror("Failed to open sysfs file");
        return -1;
    }
    // 从 sysfs 节点读取值
    if (read(fd, buf, sizeof(buf)) < 0) {
        perror("Failed to read from sysfs file");
        close(fd);
        return -1;
    }
    // 将字符串转换为整数
    *value = atoi(buf);
    // 关闭文件
    close(fd);
    return 0;
}
int get_power_key_lock(int *value)
{
    int fd;
    char buf[2];  // 假设只读取1或0
    // 打开 sysfs 节点
    fd = open(SYSFS_PATH1, O_RDONLY);
    if (fd < 0) {
        perror("Failed to open sysfs file");
        return -1;
    }
    // 从 sysfs 节点读取值
    if (read(fd, buf, sizeof(buf)) < 0) {
        perror("Failed to read from sysfs file");
        close(fd);
        return -1;
    }
    // 将字符串转换为整数
    *value = atoi(buf);
    // 关闭文件
    close(fd);
    return 0;
}

void GarageModeServerSideHandlerImpl::HandleHeartbeat() {
    LOG(DEBUG) << __func__ << ": received heartbeat from the client";
    mLastHeartbeatTime.store(steady_clock::now());
}

void GarageModeServerSideHandlerImpl::HeartbeatTimeoutWatcher() {
    constexpr auto kHeartbeatTimeout = duration_cast<steady_clock::duration>(5s);
    constexpr auto kHeartbeatCheckPeriod = 1s;
    while (!mShuttingDownFlag.load()) {
        if (!mSystemShuttingDownPrepareFlag.load()) {
            std::unique_lock<std::mutex> heartbeatLock(mHeartbeatMutex);
            mHeartbeatCV.wait(heartbeatLock, [this]() {
                return mSystemShuttingDownPrepareFlag.load() || mShuttingDownFlag.load();
            });

            // Reset mLastHeartbeatTime everytime after entering shutdown state
            HandleHeartbeat();
        }
        auto timeSinceLastHeartbeat = steady_clock::now() - mLastHeartbeatTime.load();
        if (timeSinceLastHeartbeat > kHeartbeatTimeout) {
            LOG(ERROR) << __func__ << ": heartbeat timeout!";
            // TODO(chenhaosjtuacm): Shutdown AGL
            break;
        }
        std::this_thread::sleep_for(kHeartbeatCheckPeriod);
    }
}
/*
新调整一个报文进行一次更新，减少线程池消耗，缩减至60个线程
*/
void GarageModeServerSideHandlerImpl::can071_Watcher() {
    
  ConfigDBC* mp0 = mPropertyManager->findCProperty("ec_vcu_act_whl_tq_vld");
  ConfigDBC* mp1 = mPropertyManager->findCProperty("ec_vcu_act_whl_tq");
  ConfigDBC* mp2 = mPropertyManager->findCProperty("ec_vcu_drv_req_whl_tq_vld");
  ConfigDBC* mp3 = mPropertyManager->findCProperty("ec_vcu_drv_req_whl_tq");
  ConfigDBC* mp4 = mPropertyManager->findCProperty("ec_vcu_drv_whl_tq_allwd_max");
  ConfigDBC* mp5 = mPropertyManager->findCProperty("ec_vcu_pwr_recup_actl_whl_tq_sts");
  ConfigDBC* mp6 = mPropertyManager->findCProperty("ec_vcu_pwr_recup_max_avlb_whl_tq_sts");
  ConfigDBC* mp7 = mPropertyManager->findCProperty("ec_vcu_brk_pwr_recup_max_avlb_whl_tq");
  ConfigDBC* mp8 = mPropertyManager->findCProperty("ec_vcu_pwr_recup_act_whl_tq");
  ConfigDBC* mp9 = mPropertyManager->findCProperty("ec_vcu_acc_req_drive_off");
  ConfigDBC* mp10 = mPropertyManager->findCProperty("ec_vcu_brk_pwr_recup_actl_whl_tq_sts");
  ConfigDBC* mp11 = mPropertyManager->findCProperty("ec_vcu_brk_pwr_recup_act_whl_tq");
  int32_t ec_vcu_act_whl_tq_vld = 0;
  int32_t ec_vcu_act_whl_tq = 0;
  int32_t ec_vcu_drv_req_whl_tq_vld = 0;
  int32_t ec_vcu_drv_req_whl_tq = 0;
  int32_t ec_vcu_drv_whl_tq_allwd_max = 0;
  int32_t ec_vcu_pwr_recup_actl_whl_tq_sts = 0;
  int32_t ec_vcu_pwr_recup_max_avlb_whl_tq_sts = 0;
  int32_t ec_vcu_brk_pwr_recup_max_avlb_whl_tq = 0;
  int32_t ec_vcu_pwr_recup_act_whl_tq = 0;
  int32_t ec_vcu_acc_req_drive_off = 0;
  int32_t ec_vcu_brk_pwr_recup_actl_whl_tq_sts = 0;
  int32_t ec_vcu_brk_pwr_recup_act_whl_tq = 0;
  while(!mShuttingDownFlag.load()){
    //检测报文更新状态
    mPropertyManager->getCan071State();
    if (mPropertyManager->getCProValue(mp0,&ec_vcu_act_whl_tq_vld)){
      mHal->onPropertyValue(*Create_ec_vcu_act_whl_tq_vldReq(ec_vcu_act_whl_tq_vld),true);
    }

    if (mPropertyManager->getCProValue(mp1, &ec_vcu_act_whl_tq)) {
      mHal->onPropertyValue(*Create_ec_vcu_act_whl_tqReq(ec_vcu_act_whl_tq), true);
    }
    
    if (mPropertyManager->getCProValue(mp2, &ec_vcu_drv_req_whl_tq_vld)) {
      mHal->onPropertyValue(*Create_ec_vcu_drv_req_whl_tq_vldReq(ec_vcu_drv_req_whl_tq_vld), true);
    }
    
    if (mPropertyManager->getCProValue(mp3, &ec_vcu_drv_req_whl_tq)) {
      mHal->onPropertyValue(*Create_ec_vcu_drv_req_whl_tqReq(ec_vcu_drv_req_whl_tq), true);
    }
    
    if (mPropertyManager->getCProValue(mp4, &ec_vcu_drv_whl_tq_allwd_max)) {
      mHal->onPropertyValue(*Create_ec_vcu_drv_whl_tq_allwd_maxReq(ec_vcu_drv_whl_tq_allwd_max), true);
    }
    if (mPropertyManager->getCProValue(mp5, &ec_vcu_pwr_recup_actl_whl_tq_sts)) {
      mHal->onPropertyValue(*Create_ec_vcu_pwr_recup_actl_whl_tq_stsReq(ec_vcu_pwr_recup_actl_whl_tq_sts), true);
    }
    
    if (mPropertyManager->getCProValue(mp6, &ec_vcu_pwr_recup_max_avlb_whl_tq_sts)) {
      mHal->onPropertyValue(*Create_ec_vcu_pwr_recup_max_avlb_whl_tq_stsReq(ec_vcu_pwr_recup_max_avlb_whl_tq_sts), true);
    }
    
    if (mPropertyManager->getCProValue(mp7, &ec_vcu_brk_pwr_recup_max_avlb_whl_tq)) {
      mHal->onPropertyValue(*Create_ec_vcu_brk_pwr_recup_max_avlb_whl_tqReq(ec_vcu_brk_pwr_recup_max_avlb_whl_tq), true);
    }
    
    if (mPropertyManager->getCProValue(mp8, &ec_vcu_pwr_recup_act_whl_tq)) {
      mHal->onPropertyValue(*Create_ec_vcu_pwr_recup_act_whl_tqReq(ec_vcu_pwr_recup_act_whl_tq), true);
    }
    
    if (mPropertyManager->getCProValue(mp9, &ec_vcu_acc_req_drive_off)) {
      mHal->onPropertyValue(*Create_ec_vcu_acc_req_drive_offReq(ec_vcu_acc_req_drive_off), true);
    }
    
    if (mPropertyManager->getCProValue(mp10, &ec_vcu_brk_pwr_recup_actl_whl_tq_sts)) {
      mHal->onPropertyValue(*Create_ec_vcu_brk_pwr_recup_actl_whl_tq_stsReq(ec_vcu_brk_pwr_recup_actl_whl_tq_sts), true);
    }
    
    if (mPropertyManager->getCProValue(mp11, &ec_vcu_brk_pwr_recup_act_whl_tq)) {
      mHal->onPropertyValue(*Create_ec_vcu_brk_pwr_recup_act_whl_tqReq(ec_vcu_brk_pwr_recup_act_whl_tq), true);
    }
  }
}

void GarageModeServerSideHandlerImpl::can30A_Watcher() {
    ConfigDBC* mp0 = mPropertyManager->findCProperty("ec_bem_spn2560_aa");
    ConfigDBC* mp1 = mPropertyManager->findCProperty("ec_bem_spn2560_00");
    ConfigDBC* mp2 = mPropertyManager->findCProperty("ec_bem_spn3904_cro");
    ConfigDBC* mp3 = mPropertyManager->findCProperty("ec_bem_spn3903_cml_cts");
    ConfigDBC* mp4 = mPropertyManager->findCProperty("ec_bem_spn3906_cst");
    ConfigDBC* mp5 = mPropertyManager->findCProperty("ec_bem_spn3905_ccs");
    ConfigDBC* mp6 = mPropertyManager->findCProperty("ec_bem_spn3907_csd");
    int32_t ec_bem_spn2560_aa = 0;
    int32_t ec_bem_spn2560_00 = 0;
    int32_t ec_bem_spn3904_cro = 0;
    int32_t ec_bem_spn3903_cml_cts = 0;
    int32_t ec_bem_spn3906_cst = 0;
    int32_t ec_bem_spn3905_ccs = 0;
    int32_t ec_bem_spn3907_csd = 0;
    while(!mShuttingDownFlag.load()){
      //检测报文更新状态
      mPropertyManager->getCan30AState();
      if (mPropertyManager->getCProValue(mp0, &ec_bem_spn2560_aa)){
        mHal->onPropertyValue(*Create_ec_bem_spn2560_aaReq(ec_bem_spn2560_aa),true);
      }

      if (mPropertyManager->getCProValue(mp1, &ec_bem_spn2560_00)){
        mHal->onPropertyValue(*Create_ec_bem_spn2560_00Req(ec_bem_spn2560_00),true);
      }

      if (mPropertyManager->getCProValue(mp2, &ec_bem_spn3904_cro)){
        mHal->onPropertyValue(*Create_ec_bem_spn3904_croReq(ec_bem_spn3904_cro),true);
      }

      if (mPropertyManager->getCProValue(mp3, &ec_bem_spn3903_cml_cts)){
        mHal->onPropertyValue(*Create_ec_bem_spn3903_cml_ctsReq(ec_bem_spn3903_cml_cts),true);
      }

      if (mPropertyManager->getCProValue(mp4, &ec_bem_spn3906_cst)){
        mHal->onPropertyValue(*Create_ec_bem_spn3906_cstReq(ec_bem_spn3906_cst),true);
      }

      if (mPropertyManager->getCProValue(mp5, &ec_bem_spn3905_ccs)){
        mHal->onPropertyValue(*Create_ec_bem_spn3905_ccsReq(ec_bem_spn3905_ccs),true);
      }

      if (mPropertyManager->getCProValue(mp6, &ec_bem_spn3907_csd)){
        mHal->onPropertyValue(*Create_ec_bem_spn3907_csdReq(ec_bem_spn3907_csd),true);
      }
    }
}

void GarageModeServerSideHandlerImpl::can30B_Watcher() {
  ConfigDBC* mp0 = mPropertyManager->findCProperty("ec_cem_bms_identify_timout");
  ConfigDBC* mp1 = mPropertyManager->findCProperty("ec_cem_bms_finish_charge_timeout");
  ConfigDBC* mp2 = mPropertyManager->findCProperty("ec_cem_battery_parameter_timout");
  ConfigDBC* mp3 = mPropertyManager->findCProperty("ec_cem_bms_abort_charge_timeout");
  ConfigDBC* mp4 = mPropertyManager->findCProperty("ec_cem_battery_charge_require_timeout");
  ConfigDBC* mp5 = mPropertyManager->findCProperty("ec_cem_battery_state_timeout");
  ConfigDBC* mp6 = mPropertyManager->findCProperty("ec_cem_bms_charge_statistics_timeout");

  int32_t ec_cem_bms_identify_timout = 0;
  int32_t ec_cem_bms_finish_charge_timeout = 0;
  int32_t ec_cem_battery_parameter_timout = 0;
  int32_t ec_cem_bms_abort_charge_timeout = 0;
  int32_t ec_cem_battery_charge_require_timeout = 0;
  int32_t ec_cem_battery_state_timeout = 0;
  int32_t ec_cem_bms_charge_statistics_timeout = 0;

  while(!mShuttingDownFlag.load()){
    //检测报文更新状态
    mPropertyManager->getCan30BState();
    if (mPropertyManager->getCProValue(mp0,&ec_cem_bms_identify_timout)){
      mHal->onPropertyValue(*Create_ec_cem_bms_identify_timoutReq(ec_cem_bms_identify_timout),true);
    }

    if (mPropertyManager->getCProValue(mp1,&ec_cem_bms_finish_charge_timeout)){
      mHal->onPropertyValue(*Create_ec_cem_bms_finish_charge_timeoutReq(ec_cem_bms_finish_charge_timeout),true);
    }

    if (mPropertyManager->getCProValue(mp2,&ec_cem_battery_parameter_timout)){
      mHal->onPropertyValue(*Create_ec_cem_battery_parameter_timoutReq(ec_cem_battery_parameter_timout),true);
    }

    if (mPropertyManager->getCProValue(mp3,&ec_cem_bms_abort_charge_timeout)){
      mHal->onPropertyValue(*Create_ec_cem_bms_abort_charge_timeoutReq(ec_cem_bms_abort_charge_timeout),true);
    }

    if (mPropertyManager->getCProValue(mp4,&ec_cem_battery_charge_require_timeout)){
      mHal->onPropertyValue(*Create_ec_cem_battery_charge_require_timeoutReq(ec_cem_battery_charge_require_timeout),true);
    }

    if (mPropertyManager->getCProValue(mp5,&ec_cem_battery_state_timeout)){
      mHal->onPropertyValue(*Create_ec_cem_battery_state_timeoutReq(ec_cem_battery_state_timeout),true);
    }

    if (mPropertyManager->getCProValue(mp6,&ec_cem_bms_charge_statistics_timeout)){
      mHal->onPropertyValue(*Create_ec_cem_bms_charge_statistics_timeoutReq(ec_cem_bms_charge_statistics_timeout),true);
    }
  }
}

void GarageModeServerSideHandlerImpl::can30C_Watcher() {
  ConfigDBC* mp0 = mPropertyManager->findCProperty("ec_bst_abort_achive_dcs");
  ConfigDBC* mp1 = mPropertyManager->findCProperty("ec_bst_abort_achive_single_volt");
  ConfigDBC* mp2 = mPropertyManager->findCProperty("ec_bst_abort_achive_total_volt");
  ConfigDBC* mp3 = mPropertyManager->findCProperty("ec_bst_abort_achive_soc");
  ConfigDBC* mp4 = mPropertyManager->findCProperty("ec_bst_abort_fault_connector");
  ConfigDBC* mp5 = mPropertyManager->findCProperty("ec_bst_abort_fault_bms_temp");
  ConfigDBC* mp6 = mPropertyManager->findCProperty("ec_bst_abort_fault_connector_temp");
  ConfigDBC* mp7 = mPropertyManager->findCProperty("ec_bst_abort_fault_insulation");
  ConfigDBC* mp8 = mPropertyManager->findCProperty("ec_bst_abort_fault_other");
  ConfigDBC* mp9 = mPropertyManager->findCProperty("ec_bst_abort_fault_voltage");
  ConfigDBC* mp10 = mPropertyManager->findCProperty("ec_bst_abort_fault_hv");
  ConfigDBC* mp11 = mPropertyManager->findCProperty("ec_bst_abort_fault_battery_temp");
  ConfigDBC* mp12 = mPropertyManager->findCProperty("ec_bst_abort_error_voltage");
  ConfigDBC* mp13 = mPropertyManager->findCProperty("ec_bst_abort_error_current");
  int32_t ec_bst_abort_achive_dcs = 0;
  int32_t ec_bst_abort_achive_single_volt = 0;
  int32_t ec_bst_abort_achive_total_volt = 0;
  int32_t ec_bst_abort_achive_soc = 0;
  int32_t ec_bst_abort_fault_connector = 0;
  int32_t ec_bst_abort_fault_bms_temp = 0;
  int32_t ec_bst_abort_fault_connector_temp = 0;
  int32_t ec_bst_abort_fault_insulation = 0;
  int32_t ec_bst_abort_fault_other = 0;
  int32_t ec_bst_abort_fault_voltage = 0;
  int32_t ec_bst_abort_fault_hv = 0;
  int32_t ec_bst_abort_fault_battery_temp = 0;
  int32_t ec_bst_abort_error_voltage = 0;
  int32_t ec_bst_abort_error_current = 0;
  while(!mShuttingDownFlag.load()){
    //检测报文更新状态
    mPropertyManager->getCan30CState();
    if (mPropertyManager->getCProValue(mp0,&ec_bst_abort_achive_dcs)){
      mHal->onPropertyValue(*Create_ec_bst_abort_achive_dcsReq(ec_bst_abort_achive_dcs),true);
    }

    if (mPropertyManager->getCProValue(mp1,&ec_bst_abort_achive_single_volt)){
      mHal->onPropertyValue(*Create_ec_bst_abort_achive_single_voltReq(ec_bst_abort_achive_single_volt),true);
    }

    if (mPropertyManager->getCProValue(mp2,&ec_bst_abort_achive_total_volt)){
      mHal->onPropertyValue(*Create_ec_bst_abort_achive_total_voltReq(ec_bst_abort_achive_total_volt),true);
    }

    if (mPropertyManager->getCProValue(mp3,&ec_bst_abort_achive_soc)){
      mHal->onPropertyValue(*Create_ec_bst_abort_achive_socReq(ec_bst_abort_achive_soc),true);
    }

    if (mPropertyManager->getCProValue(mp4,&ec_bst_abort_fault_connector)){
      mHal->onPropertyValue(*Create_ec_bst_abort_fault_connectorReq(ec_bst_abort_fault_connector),true);
    }

    if (mPropertyManager->getCProValue(mp5,&ec_bst_abort_fault_bms_temp)){
      mHal->onPropertyValue(*Create_ec_bst_abort_fault_bms_tempReq(ec_bst_abort_fault_bms_temp),true);
    }

    if (mPropertyManager->getCProValue(mp6,&ec_bst_abort_fault_connector_temp)){
      mHal->onPropertyValue(*Create_ec_bst_abort_fault_connector_tempReq(ec_bst_abort_fault_connector_temp),true);
    }

    if (mPropertyManager->getCProValue(mp7,&ec_bst_abort_fault_insulation)){
      mHal->onPropertyValue(*Create_ec_bst_abort_fault_insulationReq(ec_bst_abort_fault_insulation),true);
    }

    if (mPropertyManager->getCProValue(mp8,&ec_bst_abort_fault_other)){
      mHal->onPropertyValue(*Create_ec_bst_abort_fault_otherReq(ec_bst_abort_fault_other),true);
    }

    if (mPropertyManager->getCProValue(mp9,&ec_bst_abort_fault_voltage)){
      mHal->onPropertyValue(*Create_ec_bst_abort_fault_voltageReq(ec_bst_abort_fault_voltage),true);
    }

    if (mPropertyManager->getCProValue(mp10,&ec_bst_abort_fault_hv)){
      mHal->onPropertyValue(*Create_ec_bst_abort_fault_hvReq(ec_bst_abort_fault_hv),true);
    }

    if (mPropertyManager->getCProValue(mp11,&ec_bst_abort_fault_battery_temp)){
      mHal->onPropertyValue(*Create_ec_bst_abort_fault_battery_tempReq(ec_bst_abort_fault_battery_temp),true);
    }

    if (mPropertyManager->getCProValue(mp12,&ec_bst_abort_error_voltage)){
      mHal->onPropertyValue(*Create_ec_bst_abort_error_voltageReq(ec_bst_abort_error_voltage),true);
    }

    if (mPropertyManager->getCProValue(mp13,&ec_bst_abort_error_current)){
      mHal->onPropertyValue(*Create_ec_bst_abort_error_currentReq(ec_bst_abort_error_current),true);
    }
  }
}


float GarageModeServerSideHandlerImpl::getActualFloatValue(int32_t raw_value, float factor, int offset) {
     if(raw_value == -1024) {
         return raw_value;
     } else {
         return static_cast<float>(raw_value * factor + offset);
     }
}

float GarageModeServerSideHandlerImpl::getActualFloatValue_offset_is_float(int32_t raw_value, float factor, float offset) {
     if(raw_value == -1024) {
         return -1024.0;
     } else {
         return static_cast<float>(raw_value * factor + offset);
     }
}

//此函数实现车速的监视，当车速发生变化时会调用onPropertyValueFromCar上报车速信息
void GarageModeServerSideHandlerImpl::SpeedWatcher() {
  float speed = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_vehicle_spd");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      speed = getActualFloatValue(mPropertyManager->getCProValue(mp),0.05625,0);
      mHal->onPropertyValue(*CreatespeedReq(speed),true);
  }
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::CreatespeedReq(float speed) {
    auto req = mValueObjectPool->obtainFloat(speed);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_d_cdischrg_permWatcher() {
  float ec_vcu_d_cdischrg_perm = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_d_cdischrg_perm");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_d_cdischrg_perm = getActualFloatValue(mPropertyManager->getCProValue(mp),0.1,0);
      mHal->onPropertyValue(*Create_ec_vcu_d_cdischrg_permReq(ec_vcu_d_cdischrg_perm),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_d_cdischrg_permReq(float ec_vcu_d_cdischrg_perm) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_d_cdischrg_perm);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_pt_stWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_pt_st = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_pt_st");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_pt_st = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_vcu_pt_stReq(ec_vcu_pt_st),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_pt_stReq(int32_t ec_vcu_pt_st) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_pt_st);
    req->prop = toInt(VehicleProperty::GECKO_VCU_PT_ST);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ev_vcu_mcu_power_statusWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t mcu_power_st = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("gecko_bcm_mcu_power_status");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      mcu_power_st = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_mcu_power_stReq(mcu_power_st),true);
  }
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_mcu_power_stReq(int32_t mcu_power_st){
    auto req = mValueObjectPool->obtainInt32(mcu_power_st);
    req->prop = toInt(VehicleProperty::GECKO_MCU_POWER_STATUS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

#define WAIT_POWER_STATE_RETRY  650
/*
1：BATOFF模式：车辆蓄电池亏电模式;
2： SLEEP模式：整车休眠模式;
3： STANDBY模式：待机模式;
4： ACTIVE模式：全功能运行模式;
5： STR模式：SOC挂起到RAM模式;
*/
int32_t GarageModeServerSideHandlerImpl::wait_standby_Entry_condition(){
    StatusCode status = StatusCode::OK;
    VehiclePropValue requestProp = VehiclePropValue {};
    requestProp.prop = toInt(VehicleProperty::AP_POWER_STATE_REPORT);
    requestProp.areaId = 0;
    int retry = 0;
    int32_t ret = 0;
    while(1){
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
        if(retry>WAIT_POWER_STATE_RETRY){
		    LOG(INFO) << "wait_standby_Entry_condition timeout";
            break;
	    }
        auto value = mHal->get(requestProp, &status);
        ret = value->value.int32Values[0];
        retry++;
        if(value != nullptr){
            LOG(INFO) << __func__ << " dxy value->value.int32Values[0] " << value->value.int32Values[0];
            if((value->value.int32Values[0]==toInt(VehicleApPowerStateReport::DEEP_SLEEP_EXIT))
               ||(value->value.int32Values[0]==toInt(VehicleApPowerStateReport::ON))
               ||(value->value.int32Values[0]==toInt(VehicleApPowerStateReport::WAIT_FOR_VHAL))
               ||(value->value.int32Values[0]==toInt(VehicleApPowerStateReport::SHUTDOWN_PREPARE))
               ||(value->value.int32Values[0]==toInt(VehicleApPowerStateReport::SHUTDOWN_POSTPONE))
               ||(value->value.int32Values[0]==toInt(VehicleApPowerStateReport::DEEP_SLEEP_ENTRY)))
                break;
        }else{
            LOG(INFO) << "dxy value->value.int32Values[0] is null" ;
        }
    }
    return ret;
}

int32_t GarageModeServerSideHandlerImpl::wait_active_Entry_condition(){
  StatusCode status = StatusCode::OK;
  VehiclePropValue requestProp = VehiclePropValue {};
  requestProp.prop = toInt(VehicleProperty::AP_POWER_STATE_REPORT);
  requestProp.areaId = 0;
  int retry = 0;
  int32_t ret = 0;
  while(1){
      std::this_thread::sleep_for(std::chrono::milliseconds(100));
      if(retry>WAIT_POWER_STATE_RETRY){
      LOG(INFO) << "wait_active_Entry_condition timeout";
          break;
    }
      auto value = mHal->get(requestProp, &status);
      ret = value->value.int32Values[0];
      retry++;
      if(value != nullptr){
          LOG(INFO) << __func__ << " dxy value->value.int32Values[0] " << value->value.int32Values[0];
//            if((value->value.int32Values[0]==toInt(VehicleApPowerStateReport::DEEP_SLEEP_EXIT))||(value->value.int32Values[0]==toInt(VehicleApPowerStateReport::SHUTDOWN_CANCELLED))||(value->value.int32Values[0]==toInt(VehicleApPowerStateReport::WAIT_FOR_VHAL)))
            if((value->value.int32Values[0]==toInt(VehicleApPowerStateReport::DEEP_SLEEP_EXIT))||
                 (value->value.int32Values[0]==toInt(VehicleApPowerStateReport::SHUTDOWN_CANCELLED))||
                 (value->value.int32Values[0]==toInt(VehicleApPowerStateReport::WAIT_FOR_VHAL))||
                 (value->value.int32Values[0]==toInt(VehicleApPowerStateReport::SHUTDOWN_POSTPONE))||
                 (value->value.int32Values[0]==toInt(VehicleApPowerStateReport::ON))||
                 (value->value.int32Values[0]==toInt(VehicleApPowerStateReport::DEEP_SLEEP_ENTRY)))
              break;
      }else{
          LOG(INFO) << "dxy value->value.int32Values[0] is null" ;
      }
  }
  return ret;
}

int32_t GarageModeServerSideHandlerImpl::wait_SHUTDOWN_CANCELLED_condition(){
  StatusCode status = StatusCode::OK;
  VehiclePropValue requestProp = VehiclePropValue {};
  requestProp.prop = toInt(VehicleProperty::AP_POWER_STATE_REPORT);
  requestProp.areaId = 0;
  int retry = 0;
  int32_t ret = 0;
  while(1){
      std::this_thread::sleep_for(std::chrono::milliseconds(100));
      if(retry>WAIT_POWER_STATE_RETRY){
      LOG(INFO) << "wait_active_Entry_condition timeout";
          break;
    }
      auto value = mHal->get(requestProp, &status);
      ret = value->value.int32Values[0];
      retry++;
      if(value != nullptr){
          LOG(INFO) << __func__ << " dxy value->value.int32Values[0] " << value->value.int32Values[0];
            if(value->value.int32Values[0]==toInt(VehicleApPowerStateReport::SHUTDOWN_CANCELLED))
              break;
      }else{
          LOG(INFO) << "dxy value->value.int32Values[0] is null" ;
      }
  }
  return ret;
}
int32_t GarageModeServerSideHandlerImpl::wait_SHUTDOWN_PREPARE_condition(){
  StatusCode status = StatusCode::OK;
  VehiclePropValue requestProp = VehiclePropValue {};
  requestProp.prop = toInt(VehicleProperty::AP_POWER_STATE_REPORT);
  requestProp.areaId = 0;
  int retry = 0;
  int32_t ret = 0;
  while(1){
      std::this_thread::sleep_for(std::chrono::milliseconds(100));
      if(retry>WAIT_POWER_STATE_RETRY){
      LOG(INFO) << __func__ << " timeout";
          break;
    }
      auto value = mHal->get(requestProp, &status);
      ret = value->value.int32Values[0];
      retry++;
      if(value != nullptr){
          LOG(INFO) << __func__ << " dxy value->value.int32Values[0] " << value->value.int32Values[0];
            if(value->value.int32Values[0]==toInt(VehicleApPowerStateReport::SHUTDOWN_PREPARE)||
              (value->value.int32Values[0]==toInt(VehicleApPowerStateReport::SHUTDOWN_POSTPONE)))
              break;
      }else{
          LOG(INFO) << "dxy value->value.int32Values[0] is null" ;
      }
  }
  return ret;
}
int32_t GarageModeServerSideHandlerImpl::wait_ON_condition(){
  StatusCode status = StatusCode::OK;
  VehiclePropValue requestProp = VehiclePropValue {};
  requestProp.prop = toInt(VehicleProperty::AP_POWER_STATE_REPORT);
  requestProp.areaId = 0;
  int retry = 0;
  int32_t ret = 0;
  while(1){
      std::this_thread::sleep_for(std::chrono::milliseconds(100));
      if(retry>WAIT_POWER_STATE_RETRY){
      LOG(INFO) << __func__ << " timeout";
          break;
    }
      auto value = mHal->get(requestProp, &status);
      ret = value->value.int32Values[0];
      retry++;
      if(value != nullptr){
          LOG(INFO) << __func__ << " dxy value->value.int32Values[0] " << value->value.int32Values[0];
            if(value->value.int32Values[0]==toInt(VehicleApPowerStateReport::ON))
              break;
      }else{
          LOG(INFO) << "dxy value->value.int32Values[0] is null" ;
      }
  }
  return ret;
}
int32_t GarageModeServerSideHandlerImpl::wait_FINISH_condition(){
  StatusCode status = StatusCode::OK;
  VehiclePropValue requestProp = VehiclePropValue {};
  requestProp.prop = toInt(VehicleProperty::AP_POWER_STATE_REPORT);
  requestProp.areaId = 0;
  int retry = 0;
  int32_t ret = 0;
  while(1){
      std::this_thread::sleep_for(std::chrono::milliseconds(100));
      if(retry>WAIT_POWER_STATE_RETRY){
      LOG(INFO) << "wait_finish_Entry_condition timeout";
          break;
    }
      auto value = mHal->get(requestProp, &status);
      ret = value->value.int32Values[0];
      retry++;
      if(value != nullptr){
          LOG(INFO) << __func__ << " dxy value->value.int32Values[0] " << value->value.int32Values[0];
            if(value->value.int32Values[0]==toInt(VehicleApPowerStateReport::DEEP_SLEEP_ENTRY))
              break;
      }else{
          LOG(INFO) << "dxy value->value.int32Values[0] is null" ;
      }
  }
  return ret;
}

int32_t GarageModeServerSideHandlerImpl::wait_str_DEEP_SLEEP_Entry_condition(){
    StatusCode status = StatusCode::OK;
    VehiclePropValue requestProp = VehiclePropValue {};
    requestProp.prop = toInt(VehicleProperty::AP_POWER_STATE_REPORT);
    requestProp.areaId = 0;
    int retry = 0;
    int32_t ret = 0;
    while(1){
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
        if(retry>WAIT_POWER_STATE_RETRY){
          LOG(INFO) << "dxy wait_str_DEEP_SLEEP_Entry_condition timeout";
          break;
        }
        auto value = mHal->get(requestProp, &status);
        ret = value->value.int32Values[0];
        retry++;
        if(value != nullptr){
            LOG(INFO) << __func__ << " dxy value->value.int32Values[0] " << value->value.int32Values[0] << " " 
		      << toInt(VehicleApPowerStateReport::DEEP_SLEEP_ENTRY);
	    if(value->value.int32Values[0]==toInt(VehicleApPowerStateReport::SHUTDOWN_POSTPONE)){
		if(mPropertyManager->get_postpone_counter()>10000){
		    retry = 0;
		}
                mPropertyManager->ponstpone_counter_dec(100);
                LOG(INFO) << "dxy wait_str_DEEP_SLEEP_Entry_condition get_postpone_counter:" << mPropertyManager->get_postpone_counter();
		if(mPropertyManager->get_postpone_counter()<=0){
	            //此处最好把记录pwr_key的记录清除
                    clr_power_key_status();
	            return ret;
		}
            }
            if((value->value.int32Values[0]==toInt(VehicleApPowerStateReport::DEEP_SLEEP_ENTRY))||
               (value->value.int32Values[0]==toInt(VehicleApPowerStateReport::ON)))
                break;
        }else{
            LOG(INFO) << "dxy value->value.int32Values[0] is null" ;
        }
    }
    return ret;
}

void GarageModeServerSideHandlerImpl::ccm_soc_power_statusWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(8000));
  int32_t soc_power_st = 0;
  while(!mShuttingDownFlag.load()){
      SLOGW("zhugang# wait for new status");
      std::vector<uint8_t> vecMsg = mPropertyManager->Powerstatusdequeue();
      for (uint8_t byte : vecMsg) {
        SLOGW("zhugang# %d",static_cast<int>(byte));
      }
      soc_power_st = static_cast<int>(vecMsg[0]);
      int32_t to_ready_str {5};
      int32_t ap_power_status = 0;
      SLOGW("dxy-- cmd get gecko_ccm_soc_power_status = %d",soc_power_st);
      {
        android::base::SetProperty("gecko.powerstatus",std::to_string(soc_power_st) );
        if(3 == soc_power_st || 4 == soc_power_st){
          mHal->onPropertyValue(*To_notification_tbox_soc_power_status(soc_power_st),true);
          if(3 == soc_power_st){
            SLOGW("dxy-- cmd standby mode");
            int need_power_key_lock = 0;
            int power_key_lock = 0;
            int retry_counter = 0;
            while(1){
              get_need_power_key_lock(&need_power_key_lock);
              get_power_key_lock(&power_key_lock);
              if(need_power_key_lock==1&&power_key_lock==1){
                retry_counter++;
                if(retry_counter>80){
                  SLOGW("dxy-- standby wait power key lock timeout");
                  break;
                }
                std::this_thread::sleep_for(std::chrono::milliseconds(300));
              }else{
                break;
              }
            }
	          ap_power_status = wait_standby_Entry_condition();
            if((toInt(VehicleApPowerStateReport::DEEP_SLEEP_EXIT) == ap_power_status)||
               (toInt(VehicleApPowerStateReport::ON) == ap_power_status)||
               (toInt(VehicleApPowerStateReport::WAIT_FOR_VHAL) == ap_power_status)){
              SLOGW("dxy-- cmd go to runing standby mode 1 2");
              mHal->onPropertyValue(*Create_soc_power_stReq(1,2),true);     // go to runing garage mode
              wait_SHUTDOWN_PREPARE_condition();
            }
            if((toInt(VehicleApPowerStateReport::DEEP_SLEEP_ENTRY) == ap_power_status)
               ||(toInt(VehicleApPowerStateReport::SHUTDOWN_PREPARE) == ap_power_status)
               ||(toInt(VehicleApPowerStateReport::SHUTDOWN_POSTPONE) == ap_power_status)){
              SLOGW("dxy-- standby mode not change");
            }
          }
          if(4 == soc_power_st){
            SLOGW("dxy-- cmd activity mode");
            mHal->onPropertyValue(*To_notification_tbox_soc_power_status(soc_power_st),true);
            int need_power_key_lock = 0;
            int power_key_lock = 0;
            int retry_counter = 0;
            while(1){
              get_need_power_key_lock(&need_power_key_lock);
              get_power_key_lock(&power_key_lock);
              if(need_power_key_lock==1&&power_key_lock==1){
                retry_counter++;
                if(retry_counter>80){
                  SLOGW("dxy-- active wait power key lock timeout");
                  break;
                }
                std::this_thread::sleep_for(std::chrono::milliseconds(300));
              }else{
                break;
              }
            }
	          ap_power_status = wait_active_Entry_condition();
            if((toInt(VehicleApPowerStateReport::SHUTDOWN_PREPARE) == ap_power_status)||
               (toInt(VehicleApPowerStateReport::SHUTDOWN_POSTPONE) == ap_power_status)||
               (toInt(VehicleApPowerStateReport::DEEP_SLEEP_ENTRY) == ap_power_status)){
              SLOGW("dxy-- cmd activity mode go to runing cancel sleep mode 2 0");
              mHal->onPropertyValue(*Create_soc_power_stReq(2,0),true);     // cancel the sleep mode
              ap_power_status = wait_SHUTDOWN_CANCELLED_condition();
              mHal->onPropertyValue(*Create_soc_power_stReq(0,0),true);
              wait_ON_condition();
            }else if(toInt(VehicleApPowerStateReport::SHUTDOWN_CANCELLED) == ap_power_status){
              SLOGW("dxy-- cmd prevalue is 5 go to run 0 0, on");
              mHal->onPropertyValue(*Create_soc_power_stReq(0,0),true);
              wait_ON_condition();
            }else if(toInt(VehicleApPowerStateReport::DEEP_SLEEP_EXIT) == ap_power_status){
              SLOGW("dxy-- cmd prevalue is 6 go to run 0 0, on");
              mHal->onPropertyValue(*Create_soc_power_stReq(0,0),true);
              wait_ON_condition();
            }else if(toInt(VehicleApPowerStateReport::WAIT_FOR_VHAL) == ap_power_status){
              SLOGW("dxy-- cmd activity mode go to runing activity mode 0 0");
              mHal->onPropertyValue(*Create_soc_power_stReq(0,0),true);
              wait_ON_condition();
            }else if(toInt(VehicleApPowerStateReport::ON) == ap_power_status){
              SLOGW("dxy-- active mode not change");
            }
            //等待上层下设执行状态。//收到休眠状态变更再向下执行
          }
        }
        if(to_ready_str == soc_power_st){
          SLOGW("dxy-- cmd get going to str mode");
          int need_power_key_lock = 0;
          get_need_power_key_lock(&need_power_key_lock); 
          if(0==need_power_key_lock){
            set_power_key_lock(1);
            mHal->onPropertyValue(*To_notification_tbox_soc_power_status(soc_power_st),true);
	          ap_power_status = wait_str_DEEP_SLEEP_Entry_condition();
            if(toInt(VehicleApPowerStateReport::DEEP_SLEEP_ENTRY) == ap_power_status){
              SLOGW("dxy-- cmd get prv process mode 3 go to run finish 3 0" );
              std::this_thread::sleep_for(std::chrono::milliseconds(200));
              mHal->onPropertyValue(*Create_soc_power_stReq(toInt(VehicleApPowerStateReq::FINISHED),0),true);
            }else if(toInt(VehicleApPowerStateReport::ON) == ap_power_status){
              SLOGW("dxy-- cmd get prv process mode 7 go to run 1 4" );
              mHal->onPropertyValue(*Create_soc_power_stReq(toInt(VehicleApPowerStateReq::SHUTDOWN_PREPARE),4),true);
              wait_FINISH_condition();
              mHal->onPropertyValue(*Create_soc_power_stReq(toInt(VehicleApPowerStateReq::FINISHED),0),true);
            }
          }else{
            SLOGW("dxy-- str mode doing");
          }
        }
      }
  }
}

// 通知tbox soc 准备进入到休眠模式
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::To_notification_tbox_soc_power_status(int32_t soc_power_st){
    auto req = mValueObjectPool->obtainInt32(soc_power_st);
    req->prop = toInt(VehicleProperty::GECKO_SOC_POWER_STATUS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}


recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_soc_power_stReq(int32_t soc_power_st, int32_t para_value){
    auto req = mValueObjectPool->obtain(VehiclePropertyType::INT32_VEC, 2);
    req->prop = toInt(VehicleProperty::AP_POWER_STATE_REQ);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    req->value.int32Values[0] = soc_power_st;
    req->value.int32Values[1] = para_value;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_dcd_cworkenableWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_dcd_cworkenable = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_dcd_cworkenable");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_dcd_cworkenable = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_vcu_dcd_cworkenableReq(ec_vcu_dcd_cworkenable),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_dcd_cworkenableReq(int32_t ec_vcu_dcd_cworkenable) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_dcd_cworkenable);
    req->prop = toInt(VehicleProperty::GECKO_DCD_CWORKENABLE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_charallowWatcher() {
  float ec_vcu_charallow = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_charallow");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_charallow = getActualFloatValue(mPropertyManager->getCProValue(mp),0.1,0);
      mHal->onPropertyValue(*Create_ec_vcu_charallowReq(ec_vcu_charallow),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_charallowReq(float ec_vcu_charallow) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_charallow);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_sleepindicationsignalWatcher() {
  float ec_vcu_sleepindicationsignal = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_sleepindicationsignal");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_sleepindicationsignal = getActualFloatValue(mPropertyManager->getCProValue(mp),0.1,0);
      mHal->onPropertyValue(*Create_ec_vcu_sleepindicationsignalReq(ec_vcu_sleepindicationsignal),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_sleepindicationsignalReq(float ec_vcu_sleepindicationsignal) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_sleepindicationsignal);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_livecounter_0x100Watcher() {
  float ec_vcu_livecounter_0x100 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_livecounter_0x100");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_livecounter_0x100 = getActualFloatValue(mPropertyManager->getCProValue(mp),0.1,0);
      mHal->onPropertyValue(*Create_ec_vcu_livecounter_0x100Req(ec_vcu_livecounter_0x100),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_livecounter_0x100Req(float ec_vcu_livecounter_0x100) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_livecounter_0x100);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_checksum_0x100Watcher() {
  float ec_vcu_checksum_0x100 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_checksum_0x100");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_checksum_0x100 = getActualFloatValue(mPropertyManager->getCProValue(mp),0.1,0);
      mHal->onPropertyValue(*Create_ec_vcu_checksum_0x100Req(ec_vcu_checksum_0x100),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_checksum_0x100Req(float ec_vcu_checksum_0x100) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_checksum_0x100);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_bms_cc2statusWatcher() {
  float ec_bms_cc2status = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_cc2status");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_cc2status = getActualFloatValue(mPropertyManager->getCProValue(mp),0.1,0);
      mHal->onPropertyValue(*Create_ec_bms_cc2statusReq(ec_bms_cc2status),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_cc2statusReq(float ec_bms_cc2status) {
    auto req = mValueObjectPool->obtainFloat(ec_bms_cc2status);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_bms_livecounter_0x120Watcher() {
  float ec_bms_livecounter_0x120 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_livecounter_0x120");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_livecounter_0x120 = getActualFloatValue(mPropertyManager->getCProValue(mp),0.1,0);
      mHal->onPropertyValue(*Create_ec_bms_livecounter_0x120Req(ec_bms_livecounter_0x120),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_livecounter_0x120Req(float ec_bms_livecounter_0x120) {
    auto req = mValueObjectPool->obtainFloat(ec_bms_livecounter_0x120);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_bms_checksum_0x120Watcher() {
  float ec_bms_checksum_0x120 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_checksum_0x120");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_checksum_0x120 = getActualFloatValue(mPropertyManager->getCProValue(mp),0.1,0);
      mHal->onPropertyValue(*Create_ec_bms_checksum_0x120Req(ec_bms_checksum_0x120),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_checksum_0x120Req(float ec_bms_checksum_0x120) {
    auto req = mValueObjectPool->obtainFloat(ec_bms_checksum_0x120);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_bms_batinsulatresistanceWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int ec_bms_batinsulatresistance = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_batinsulatresistance");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_batinsulatresistance = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_bms_batinsulatresistanceReq(ec_bms_batinsulatresistance),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_batinsulatresistanceReq(int ec_bms_batinsulatresistance) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_batinsulatresistance);
    req->prop = toInt(VehicleProperty::GECKO_BMS_BATINSULATRESISTANCE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_bms_batterycurrentWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  float ec_bms_batterycurrent = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_batterycurrent");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_batterycurrent = getActualFloatValue(mPropertyManager->getCProValue(mp),0.1,-1000);
      mHal->onPropertyValue(*Create_ec_bms_batterycurrentReq(ec_bms_batterycurrent),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_batterycurrentReq(float ec_bms_batterycurrent) {
    auto req = mValueObjectPool->obtainFloat(ec_bms_batterycurrent);
    req->prop = toInt(VehicleProperty::GECKO_EV_BATTERY_CURRENT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_packvoltageWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bms_packvoltage = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_packvoltage");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_packvoltage = static_cast<int32_t>(getActualFloatValue(mPropertyManager->getCProValue(mp),0.1,0));
      mHal->onPropertyValue(*Create_ec_bms_packvoltageReq(ec_bms_packvoltage),true);

  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_packvoltageReq(int32_t ec_bms_packvoltage) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_packvoltage);
    req->prop = toInt(VehicleProperty::GECKO_EV_BATTERY_VOLTAGE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_packvoltage_vWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bms_packvoltage_v = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_packvoltage_v");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_packvoltage_v = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_bms_packvoltage_vReq(ec_bms_packvoltage_v),true);

  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_packvoltage_vReq(int32_t ec_bms_packvoltage_v) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_packvoltage_v);
    req->prop = toInt(VehicleProperty::GECKO_EV_BATTERY_VOLTAGE_V);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_livecounter_0x125Watcher() {
  float ec_bms_livecounter_0x125 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_livecounter_0x125");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_livecounter_0x125 = getActualFloatValue(mPropertyManager->getCProValue(mp),0.1,0);
      mHal->onPropertyValue(*Create_ec_bms_livecounter_0x125Req(ec_bms_livecounter_0x125),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_livecounter_0x125Req(float ec_bms_livecounter_0x125) {
    auto req = mValueObjectPool->obtainFloat(ec_bms_livecounter_0x125);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_bms_checksum_0x125Watcher() {
  float ec_bms_checksum_0x125 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_checksum_0x125");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_checksum_0x125 = getActualFloatValue(mPropertyManager->getCProValue(mp),0.1,0);
      mHal->onPropertyValue(*Create_ec_bms_checksum_0x125Req(ec_bms_checksum_0x125),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_checksum_0x125Req(float ec_bms_checksum_0x125) {
    auto req = mValueObjectPool->obtainFloat(ec_bms_checksum_0x125);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_bms_remainingchargetimeWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bms_remainingchargetime = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_remainingchargetime");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_remainingchargetime = static_cast<int32_t> (mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_bms_remainingchargetimeReq(ec_bms_remainingchargetime),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_remainingchargetimeReq(int32_t ec_bms_remainingchargetime) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_remainingchargetime);
    req->prop = toInt(VehicleProperty::GECKO_EV_CHARGE_TIME_REMAINING);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_bms_batterysocWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  float ec_bms_batterysoc = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_batterysoc");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_batterysoc = getActualFloatValue(mPropertyManager->getCProValue(mp),0.1,0);
      mHal->onPropertyValue(*Create_ec_bms_batterysocReq(ec_bms_batterysoc),true);
      // int32_t batterylowsigna = 0;
      // if(ec_bms_batterysoc <= 10.0){
      //   batterylowsigna = 1;
      // } else if(ec_bms_batterysoc <= 20.0 && ec_bms_batterysoc > 10.0){
      //   batterylowsigna = 2;
      // }
      // LOG(INFO) << "ec_bms_batterysoc:"<<ec_bms_batterysoc<<"batterylowsigna:"<<batterylowsigna;
      // mHal->onPropertyValue(*Create_ec_batterylowsignalReq(batterylowsigna),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_batterysocReq(float ec_bms_batterysoc) {
    auto req = mValueObjectPool->obtainFloat(ec_bms_batterysoc);
    req->prop = toInt(VehicleProperty::EV_BATTERY_LEVEL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_batterylowsignalReq(int32_t batterylowsigna){
    auto req = mValueObjectPool->obtainInt32(batterylowsigna);
    req->prop = toInt(VehicleProperty::GECKO_BATTERYLOWSIGNAL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_livecounter_0x135Watcher() {
  float ec_bms_livecounter_0x135 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_livecounter_0x135");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_livecounter_0x135 = getActualFloatValue(mPropertyManager->getCProValue(mp),0.1,0);
      mHal->onPropertyValue(*Create_ec_bms_livecounter_0x135Req(ec_bms_livecounter_0x135),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_livecounter_0x135Req(float ec_bms_livecounter_0x135) {
    auto req = mValueObjectPool->obtainFloat(ec_bms_livecounter_0x135);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_bms_checksum_0x135Watcher() {
  float ec_bms_checksum_0x135 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_checksum_0x135");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_checksum_0x135 = getActualFloatValue(mPropertyManager->getCProValue(mp),0.1,0);
      mHal->onPropertyValue(*Create_ec_bms_checksum_0x135Req(ec_bms_checksum_0x135),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_checksum_0x135Req(float ec_bms_checksum_0x135) {
    auto req = mValueObjectPool->obtainFloat(ec_bms_checksum_0x135);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_mcu_motortorqueWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int ec_mcu_motortorque = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_mcu_motortorque");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_mcu_motortorque = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_mcu_motortorqueReq(ec_mcu_motortorque),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_mcu_motortorqueReq(int ec_mcu_motortorque) {
    auto req = mValueObjectPool->obtainInt32(ec_mcu_motortorque);
    req->prop = toInt(VehicleProperty::GECKO_MCU_MOTORTORQUE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_mcu_motorspdWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  float ec_mcu_motorspd = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_mcu_motorspd");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_mcu_motorspd = getActualFloatValue(mPropertyManager->getCProValue(mp),1,-12000);
      mHal->onPropertyValue(*Create_ec_mcu_motorspdReq(ec_mcu_motorspd),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_mcu_motorspdReq(float ec_mcu_motorspd) {
    auto req = mValueObjectPool->obtainFloat(ec_mcu_motorspd);
    req->prop = toInt(VehicleProperty::ENGINE_RPM);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_mcu_llivecounter_0x200Watcher() {
  float ec_mcu_llivecounter_0x200 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_mcu_llivecounter_0x200");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_mcu_llivecounter_0x200 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_mcu_llivecounter_0x200Req(ec_mcu_llivecounter_0x200),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_mcu_llivecounter_0x200Req(float ec_mcu_llivecounter_0x200) {
    auto req = mValueObjectPool->obtainFloat(ec_mcu_llivecounter_0x200);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_mcu_checksum_0x200Watcher() {
  float ec_mcu_checksum_0x200 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_mcu_checksum_0x200");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_mcu_checksum_0x200 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_mcu_checksum_0x200Req(ec_mcu_checksum_0x200),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_mcu_checksum_0x200Req(float ec_mcu_checksum_0x200) {
    auto req = mValueObjectPool->obtainFloat(ec_mcu_checksum_0x200);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_mcu_buscurrentWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int ec_mcu_buscurrent = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_mcu_buscurrent");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_mcu_buscurrent = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_mcu_buscurrentReq(ec_mcu_buscurrent),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_mcu_buscurrentReq(int ec_mcu_buscurrent) {
    auto req = mValueObjectPool->obtainInt32(ec_mcu_buscurrent);
    req->prop = toInt(VehicleProperty::GECKO_MCU_BUSCURRENT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_mcu_busvoltWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int ec_mcu_busvolt = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_mcu_busvolt");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_mcu_busvolt = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_mcu_busvoltReq(ec_mcu_busvolt),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_mcu_busvoltReq(int ec_mcu_busvolt) {
    auto req = mValueObjectPool->obtainInt32(ec_mcu_busvolt);
    req->prop = toInt(VehicleProperty::GECKO_MCU_BUSVOLT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_mcu_llivecounter_0x201Watcher() {
  float ec_mcu_llivecounter_0x201 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_mcu_llivecounter_0x201");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_mcu_llivecounter_0x201 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_mcu_llivecounter_0x201Req(ec_mcu_llivecounter_0x201),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_mcu_llivecounter_0x201Req(float ec_mcu_llivecounter_0x201) {
    auto req = mValueObjectPool->obtainFloat(ec_mcu_llivecounter_0x201);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_mcu_checksum_0x201Watcher() {
  float ec_mcu_checksum_0x201 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_mcu_checksum_0x201");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_mcu_checksum_0x201 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_mcu_checksum_0x201Req(ec_mcu_checksum_0x201),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_mcu_checksum_0x201Req(float ec_mcu_checksum_0x201) {
    auto req = mValueObjectPool->obtainFloat(ec_mcu_checksum_0x201);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_mcu_motortempWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_mcu_motortemp = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_mcu_motortemp");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_mcu_motortemp = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_mcu_motortempReq(ec_mcu_motortemp),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_mcu_motortempReq(int32_t ec_mcu_motortemp) {
    auto req = mValueObjectPool->obtainInt32(ec_mcu_motortemp);
    req->prop = toInt(VehicleProperty::GECKO_ENGINE_TEMP);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_mcu_igbttempWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_mcu_igbttemp = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_mcu_igbttemp");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_mcu_igbttemp = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_mcu_igbttempReq(ec_mcu_igbttemp),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_mcu_igbttempReq(int32_t ec_mcu_igbttemp) {
    auto req = mValueObjectPool->obtainInt32(ec_mcu_igbttemp);
    req->prop = toInt(VehicleProperty::GECKO_MCU_IGBTTEMP);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_mcu_llivecounter_0x202Watcher() {
  float ec_mcu_llivecounter_0x202 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_mcu_llivecounter_0x202");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_mcu_llivecounter_0x202 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_mcu_llivecounter_0x202Req(ec_mcu_llivecounter_0x202),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_mcu_llivecounter_0x202Req(float ec_mcu_llivecounter_0x202) {
    auto req = mValueObjectPool->obtainFloat(ec_mcu_llivecounter_0x202);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_mcu_checksum_0x202Watcher() {
  float ec_mcu_checksum_0x202 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_mcu_checksum_0x202");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_mcu_checksum_0x202 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_mcu_checksum_0x202Req(ec_mcu_checksum_0x202),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_mcu_checksum_0x202Req(float ec_mcu_checksum_0x202) {
    auto req = mValueObjectPool->obtainFloat(ec_mcu_checksum_0x202);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_mcu_motor_stateWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_mcu_motor_state = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_mcu_motor_state");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_mcu_motor_state = static_cast<int32_t> (mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_mcu_motor_stateReq(ec_mcu_motor_state),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_mcu_motor_stateReq(int32_t ec_mcu_motor_state) {
    auto req = mValueObjectPool->obtainInt32(ec_mcu_motor_state);
    req->prop = toInt(VehicleProperty::GECKO_ENGINE_STATE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_mcu_llivecounter_0x203Watcher() {
  float ec_mcu_llivecounter_0x203 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_mcu_llivecounter_0x203");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_mcu_llivecounter_0x203 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_mcu_llivecounter_0x203Req(ec_mcu_llivecounter_0x203),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_mcu_llivecounter_0x203Req(float ec_mcu_llivecounter_0x203) {
    auto req = mValueObjectPool->obtainFloat(ec_mcu_llivecounter_0x203);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_mcu_checksum_0x203Watcher() {
  float ec_mcu_checksum_0x203 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_mcu_checksum_0x203");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_mcu_checksum_0x203 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_mcu_checksum_0x203Req(ec_mcu_checksum_0x203),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_mcu_checksum_0x203Req(float ec_mcu_checksum_0x203) {
    auto req = mValueObjectPool->obtainFloat(ec_mcu_checksum_0x203);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ipu_smart_dc_stWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_ipu_smart_dc_st = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_smart_dc_st");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ipu_smart_dc_st = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_ipu_smart_dc_stReq(ec_ipu_smart_dc_st),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_smart_dc_stReq(int32_t ec_ipu_smart_dc_st) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_smart_dc_st);
    req->prop = toInt(VehicleProperty::GECKO_IPU_SMART_DC_ST);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ipu_livecounter_0x450Watcher() {
  float ec_ipu_livecounter_0x450 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_livecounter_0x450");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ipu_livecounter_0x450 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ipu_livecounter_0x450Req(ec_ipu_livecounter_0x450),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_livecounter_0x450Req(float ec_ipu_livecounter_0x450) {
    auto req = mValueObjectPool->obtainFloat(ec_ipu_livecounter_0x450);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ipu_checksum_0x450Watcher() {
  float ec_ipu_checksum_0x450 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_checksum_0x450");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ipu_checksum_0x450 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ipu_checksum_0x450Req(ec_ipu_checksum_0x450),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_checksum_0x450Req(float ec_ipu_checksum_0x450) {
    auto req = mValueObjectPool->obtainFloat(ec_ipu_checksum_0x450);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ipu_c_cresistancevalueWatcher() {
  float ec_ipu_c_cresistancevalue = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_c_cresistancevalue");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ipu_c_cresistancevalue = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ipu_c_cresistancevalueReq(ec_ipu_c_cresistancevalue),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_c_cresistancevalueReq(float ec_ipu_c_cresistancevalue) {
    auto req = mValueObjectPool->obtainFloat(ec_ipu_c_cresistancevalue);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ipu_livecounter_0x470Watcher() {
  float ec_ipu_livecounter_0x470 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_livecounter_0x470");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ipu_livecounter_0x470 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ipu_livecounter_0x470Req(ec_ipu_livecounter_0x470),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_livecounter_0x470Req(float ec_ipu_livecounter_0x470) {
    auto req = mValueObjectPool->obtainFloat(ec_ipu_livecounter_0x470);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ipu_checksum_0x470Watcher() {
  float ec_ipu_checksum_0x470 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_checksum_0x470");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ipu_checksum_0x470 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ipu_checksum_0x470Req(ec_ipu_checksum_0x470),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_checksum_0x470Req(float ec_ipu_checksum_0x470) {
    auto req = mValueObjectPool->obtainFloat(ec_ipu_checksum_0x470);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_dcd_crealtimeopcurrWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_ipu_dcd_crealtimeopcurr = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_dcd_crealtimeopcurr");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ipu_dcd_crealtimeopcurr = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_ipu_dcd_crealtimeopcurrReq(ec_ipu_dcd_crealtimeopcurr),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_dcd_crealtimeopcurrReq(int32_t ec_ipu_dcd_crealtimeopcurr) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_dcd_crealtimeopcurr);
    req->prop = toInt(VehicleProperty::GECKO_IPU_DCDCREALTIMEOPCURR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ipu_dcd_coperatingmodeWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_ipu_dcd_coperatingmode = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_dcd_coperatingmode");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ipu_dcd_coperatingmode = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_ipu_dcd_coperatingmodeReq(ec_ipu_dcd_coperatingmode),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_dcd_coperatingmodeReq(int32_t ec_ipu_dcd_coperatingmode) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_dcd_coperatingmode);
    req->prop = toInt(VehicleProperty::GECKO_IPU_DCDCOPERATINGMODE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_dcd_crealtimeopvoltWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_ipu_dcd_crealtimeopvolt = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_dcd_crealtimeopvolt");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ipu_dcd_crealtimeopvolt = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_ipu_dcd_crealtimeopvoltReq(ec_ipu_dcd_crealtimeopvolt),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_dcd_crealtimeopvoltReq(int32_t ec_ipu_dcd_crealtimeopvolt) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_dcd_crealtimeopvolt);
    req->prop = toInt(VehicleProperty::GECKO_IPU_DCDCREALTIMEOPVOLT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_dcd_cbodytempWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_ipu_dcd_cbodytemp = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_dcd_cbodytemp");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ipu_dcd_cbodytemp = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_ipu_dcd_cbodytempReq(ec_ipu_dcd_cbodytemp),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_dcd_cbodytempReq(int32_t ec_ipu_dcd_cbodytemp) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_dcd_cbodytemp);
    req->prop = toInt(VehicleProperty::GECKO_IPU_DCDCBODYTEMP);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ipu_livecounter_0x490Watcher() {
  float ec_ipu_livecounter_0x490 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_livecounter_0x490");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ipu_livecounter_0x490 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ipu_livecounter_0x490Req(ec_ipu_livecounter_0x490),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_livecounter_0x490Req(float ec_ipu_livecounter_0x490) {
    auto req = mValueObjectPool->obtainFloat(ec_ipu_livecounter_0x490);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ipu_checksum_0x490Watcher() {
  float ec_ipu_checksum_0x490 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_checksum_0x490");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ipu_checksum_0x490 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ipu_checksum_0x490Req(ec_ipu_checksum_0x490),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_checksum_0x490Req(float ec_ipu_checksum_0x490) {
    auto req = mValueObjectPool->obtainFloat(ec_ipu_checksum_0x490);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_bms_battery_pack_average_tempWatcher() {
  float ec_bms_battery_pack_average_temp = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_battery_pack_average_temp");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_battery_pack_average_temp = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_bms_battery_pack_average_tempReq(ec_bms_battery_pack_average_temp),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_battery_pack_average_tempReq(float ec_bms_battery_pack_average_temp) {
    auto req = mValueObjectPool->obtainFloat(ec_bms_battery_pack_average_temp);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_bms_packtotalcellnumWatcher() {
  int32_t ec_bms_packtotalcellnum = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_packtotalcellnum");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_packtotalcellnum = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_bms_packtotalcellnumReq(ec_bms_packtotalcellnum),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_packtotalcellnumReq(int32_t ec_bms_packtotalcellnum) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_packtotalcellnum);
    req->prop = toInt(VehicleProperty::GECKO_BMS_PACKTOTALCELLNUM);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_bms_packtotaltempnumWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bms_packtotaltempnum = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_packtotaltempnum");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_packtotaltempnum = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_bms_packtotaltempnumReq(ec_bms_packtotaltempnum),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_packtotaltempnumReq(int32_t ec_bms_packtotaltempnum) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_packtotaltempnum);
    req->prop = toInt(VehicleProperty::GECKO_BMS_PACKTOTALTEMPNUM);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_bms_maxvoltcellpacknumWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int ec_bms_maxvoltcellpacknum = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_maxvoltcellpacknum");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_maxvoltcellpacknum = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_bms_maxvoltcellpacknumReq(ec_bms_maxvoltcellpacknum),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_maxvoltcellpacknumReq(int ec_bms_maxvoltcellpacknum) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_maxvoltcellpacknum);
    req->prop = toInt(VehicleProperty::GECKO_BMS_MAXVOLTCELLPACKNUM);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_bms_minvoltcellpacknumWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int ec_bms_minvoltcellpacknum = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_minvoltcellpacknum");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_minvoltcellpacknum = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_bms_minvoltcellpacknumReq(ec_bms_minvoltcellpacknum),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_minvoltcellpacknumReq(int ec_bms_minvoltcellpacknum) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_minvoltcellpacknum);
    req->prop = toInt(VehicleProperty::GECKO_BMS_MINVOLTCELLPACKNUM);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_bms_livecounter_0x510Watcher() {
  float ec_bms_livecounter_0x510 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_livecounter_0x510");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_livecounter_0x510 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_bms_livecounter_0x510Req(ec_bms_livecounter_0x510),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_livecounter_0x510Req(float ec_bms_livecounter_0x510) {
    auto req = mValueObjectPool->obtainFloat(ec_bms_livecounter_0x510);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_bms_checksum_0x510Watcher() {
  float ec_bms_checksum_0x510 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_checksum_0x510");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_checksum_0x510 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_bms_checksum_0x510Req(ec_bms_checksum_0x510),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_checksum_0x510Req(float ec_bms_checksum_0x510) {
    auto req = mValueObjectPool->obtainFloat(ec_bms_checksum_0x510);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_bms_mintempmonomercellWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int ec_bms_mintempmonomercell = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_mintempmonomercell");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_mintempmonomercell = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_bms_mintempmonomercellReq(ec_bms_mintempmonomercell),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_mintempmonomercellReq(int ec_bms_mintempmonomercell) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_mintempmonomercell);
    req->prop = toInt(VehicleProperty::GECKO_BMS_MINTEMPMONOMERCELL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_bms_maxtempmonomercellWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int ec_bms_maxtempmonomercell = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_maxtempmonomercell");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_maxtempmonomercell = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_bms_maxtempmonomercellReq(ec_bms_maxtempmonomercell),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_maxtempmonomercellReq(int ec_bms_maxtempmonomercell) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_maxtempmonomercell);
    req->prop = toInt(VehicleProperty::GECKO_BMS_MAXTEMPMONOMERCELL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_bms_maxtempcellWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  float ec_bms_maxtempcell = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_maxtempcell");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_maxtempcell = getActualFloatValue(mPropertyManager->getCProValue(mp),1.0,-40);
      mHal->onPropertyValue(*Create_ec_bms_maxtempcellReq(ec_bms_maxtempcell),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_maxtempcellReq(float ec_bms_maxtempcell) {
    auto req = mValueObjectPool->obtainFloat(ec_bms_maxtempcell);
    req->prop = toInt(VehicleProperty::GECKO_MOMER_MAX_TEMPCELL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_bms_mintempcellWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  float ec_bms_mintempcell = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_mintempcell");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_mintempcell = getActualFloatValue(mPropertyManager->getCProValue(mp),1.0,-40);
      mHal->onPropertyValue(*Create_ec_bms_mintempcellReq(ec_bms_mintempcell),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_mintempcellReq(float ec_bms_mintempcell) {
    auto req = mValueObjectPool->obtainFloat(ec_bms_mintempcell);
    req->prop = toInt(VehicleProperty::GECKO_MOMER_MIN_TEMPCELL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_bms_maxtempcellpacknumWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int ec_bms_maxtempcellpacknum = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_maxtempcellpacknum");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_maxtempcellpacknum = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_bms_maxtempcellpacknumReq(ec_bms_maxtempcellpacknum),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_maxtempcellpacknumReq(int ec_bms_maxtempcellpacknum) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_maxtempcellpacknum);
    req->prop = toInt(VehicleProperty::GECKO_BMS_MAXTEMPCELLPACKNUM);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_bms_mintempcellpacknumWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int ec_bms_mintempcellpacknum = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_mintempcellpacknum");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_mintempcellpacknum = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_bms_mintempcellpacknumReq(ec_bms_mintempcellpacknum),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_mintempcellpacknumReq(int ec_bms_mintempcellpacknum) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_mintempcellpacknum);
    req->prop = toInt(VehicleProperty::GECKO_BMS_MINTEMPCELLPACKNUM);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_bms_deg_d_ccharsockettemp2Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int ec_bms_deg_d_ccharsockettemp2 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_deg_d_ccharsockettemp2");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_deg_d_ccharsockettemp2 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_bms_deg_d_ccharsockettemp2Req(ec_bms_deg_d_ccharsockettemp2),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_deg_d_ccharsockettemp2Req(int ec_bms_deg_d_ccharsockettemp2) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_deg_d_ccharsockettemp2);
    req->prop = toInt(VehicleProperty::GECKO_BMS_DEG_DCCHARSOCKETTEMP2);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_bms_deg_d_ccharsockettemp1Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int ec_bms_deg_d_ccharsockettemp1 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_deg_d_ccharsockettemp1");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_deg_d_ccharsockettemp1 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_bms_deg_d_ccharsockettemp1Req(ec_bms_deg_d_ccharsockettemp1),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_deg_d_ccharsockettemp1Req(int ec_bms_deg_d_ccharsockettemp1) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_deg_d_ccharsockettemp1);
    req->prop = toInt(VehicleProperty::GECKO_BMS_DEG_DCCHARSOCKETTEMP1);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_bms_livecounter0x511Watcher() {
  float ec_bms_livecounter0x511 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_livecounter0x511");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_livecounter0x511 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_bms_livecounter0x511Req(ec_bms_livecounter0x511),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_livecounter0x511Req(float ec_bms_livecounter0x511) {
    auto req = mValueObjectPool->obtainFloat(ec_bms_livecounter0x511);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_bms_checksum_0x511Watcher() {
  float ec_bms_checksum_0x511 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_checksum_0x511");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_checksum_0x511 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_bms_checksum_0x511Req(ec_bms_checksum_0x511),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_checksum_0x511Req(float ec_bms_checksum_0x511) {
    auto req = mValueObjectPool->obtainFloat(ec_bms_checksum_0x511);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_bms_minvoltmonomercellWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int ec_bms_minvoltmonomercell = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_minvoltmonomercell");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_minvoltmonomercell = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_bms_minvoltmonomercellReq(ec_bms_minvoltmonomercell),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_minvoltmonomercellReq(int ec_bms_minvoltmonomercell) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_minvoltmonomercell);
    req->prop = toInt(VehicleProperty::GECKO_BMS_MINVOLTMONOMERCELL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_bms_maxvoltmonomercellWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int ec_bms_maxvoltmonomercell = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_maxvoltmonomercell");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_maxvoltmonomercell = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_bms_maxvoltmonomercellReq(ec_bms_maxvoltmonomercell),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_maxvoltmonomercellReq(int ec_bms_maxvoltmonomercell) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_maxvoltmonomercell);
    req->prop = toInt(VehicleProperty::GECKO_BMS_MAXVOLTMONOMERCELL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_bms_maxvoltcellWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  float ec_bms_maxvoltcell = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_maxvoltcell");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_maxvoltcell = getActualFloatValue(mPropertyManager->getCProValue(mp),1.0,0);
      mHal->onPropertyValue(*Create_ec_bms_maxvoltcellReq(ec_bms_maxvoltcell),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_maxvoltcellReq(float ec_bms_maxvoltcell) {
    auto req = mValueObjectPool->obtainFloat(ec_bms_maxvoltcell);
    req->prop = toInt(VehicleProperty::GECKO_MOMER_MAX_VOLTCELL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_bms_minvoltcellWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  float ec_bms_minvoltcell = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_minvoltcell");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_minvoltcell = getActualFloatValue(mPropertyManager->getCProValue(mp),1.0,0);
      mHal->onPropertyValue(*Create_ec_bms_minvoltcellReq(ec_bms_minvoltcell),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_minvoltcellReq(float ec_bms_minvoltcell) {
    auto req = mValueObjectPool->obtainFloat(ec_bms_minvoltcell);
    req->prop = toInt(VehicleProperty::GECKO_MOMER_MIN_VOLTCELL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_bms_livecounter_0x512Watcher() {
  float ec_bms_livecounter_0x512 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_livecounter_0x512");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_livecounter_0x512 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_bms_livecounter_0x512Req(ec_bms_livecounter_0x512),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_livecounter_0x512Req(float ec_bms_livecounter_0x512) {
    auto req = mValueObjectPool->obtainFloat(ec_bms_livecounter_0x512);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_bms_checksum_0x512Watcher() {
  float ec_bms_checksum_0x512 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_checksum_0x512");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_checksum_0x512 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_bms_checksum_0x512Req(ec_bms_checksum_0x512),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_checksum_0x512Req(float ec_bms_checksum_0x512) {
    auto req = mValueObjectPool->obtainFloat(ec_bms_checksum_0x512);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_bms_packratecapWatcher() {
  float ec_bms_packratecap = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_packratecap");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_packratecap = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_bms_packratecapReq(ec_bms_packratecap),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_packratecapReq(float ec_bms_packratecap) {
    auto req = mValueObjectPool->obtainFloat(ec_bms_packratecap);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_bms_pack_rate_voltWatcher() {
  float ec_bms_pack_rate_volt = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_pack_rate_volt");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_pack_rate_volt = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_bms_pack_rate_voltReq(ec_bms_pack_rate_volt),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_pack_rate_voltReq(float ec_bms_pack_rate_volt) {
    auto req = mValueObjectPool->obtainFloat(ec_bms_pack_rate_volt);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_bms_packrateenergyWatcher() {
  float ec_bms_packrateenergy = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_packrateenergy");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_packrateenergy = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_bms_packrateenergyReq(ec_bms_packrateenergy),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_packrateenergyReq(float ec_bms_packrateenergy) {
    auto req = mValueObjectPool->obtainFloat(ec_bms_packrateenergy);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_bms_batt_typeWatcher() {
  float ec_bms_batt_type = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_batt_type");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_batt_type = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_bms_batt_typeReq(ec_bms_batt_type),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_batt_typeReq(float ec_bms_batt_type) {
    auto req = mValueObjectPool->obtainFloat(ec_bms_batt_type);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_bms_battcooltypeWatcher() {
  float ec_bms_battcooltype = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_battcooltype");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_battcooltype = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_bms_battcooltypeReq(ec_bms_battcooltype),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_battcooltypeReq(float ec_bms_battcooltype) {
    auto req = mValueObjectPool->obtainFloat(ec_bms_battcooltype);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_bms_livecounter_0x520Watcher() {
  float ec_bms_livecounter_0x520 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_livecounter_0x520");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_livecounter_0x520 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_bms_livecounter_0x520Req(ec_bms_livecounter_0x520),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_livecounter_0x520Req(float ec_bms_livecounter_0x520) {
    auto req = mValueObjectPool->obtainFloat(ec_bms_livecounter_0x520);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_bms_checksum_0x520Watcher() {
  float ec_bms_checksum_0x520 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_checksum_0x520");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_checksum_0x520 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_bms_checksum_0x520Req(ec_bms_checksum_0x520),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_checksum_0x520Req(float ec_bms_checksum_0x520) {
    auto req = mValueObjectPool->obtainFloat(ec_bms_checksum_0x520);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_thermalrunawayalarmWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bms_thermalrunawayalarm = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_thermalrunawayalarm");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_thermalrunawayalarm = mPropertyManager->getCProValue(mp);
      LOG(INFO) << "ec_bms_thermalrunawayalarm:"<<ec_bms_thermalrunawayalarm;
      mHal->onPropertyValue(*Create_ec_bms_thermalrunawayalarmReq(ec_bms_thermalrunawayalarm),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_thermalrunawayalarmReq(int32_t ec_bms_thermalrunawayalarm) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_thermalrunawayalarm);
    req->prop = toInt(VehicleProperty::GECKO_BMS_THERMALRUNAWAYALARM);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_bms_livecounter_0x522Watcher() {
  float ec_bms_livecounter_0x522 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_livecounter_0x522");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_livecounter_0x522 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_bms_livecounter_0x522Req(ec_bms_livecounter_0x522),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_livecounter_0x522Req(float ec_bms_livecounter_0x522) {
    auto req = mValueObjectPool->obtainFloat(ec_bms_livecounter_0x522);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_bms_checksum_0x522Watcher() {
  float ec_bms_checksum_0x522 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_checksum_0x522");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_checksum_0x522 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_bms_checksum_0x522Req(ec_bms_checksum_0x522),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_checksum_0x522Req(float ec_bms_checksum_0x522) {
    auto req = mValueObjectPool->obtainFloat(ec_bms_checksum_0x522);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_shif_faultWatcher() {
  float ec_vcu_shif_fault = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_shif_fault");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_shif_fault = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_vcu_shif_faultReq(ec_vcu_shif_fault),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_shif_faultReq(float ec_vcu_shif_fault) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_shif_fault);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_shift_positionWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int ec_vcu_shift_position = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_shift_position");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_shift_position = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      ALOGE("dxy----- ec_vcu_shift_position %d",ec_vcu_shift_position);
      mHal->onPropertyValue(*Create_ec_vcu_shift_positionReq(ec_vcu_shift_position),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_shift_positionReq(int32_t ec_vcu_shift_position) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_shift_position);
    req->prop = toInt(VehicleProperty::GEAR_SELECTION);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_actual_gearWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_actual_gear = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_actual_gear");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_actual_gear = static_cast<int32_t>(std::atoi(mp->valueMap[mPropertyManager->getCProValue(mp)].c_str()));
      ALOGE("dxy----- ec_vcu_actual_gear %d",ec_vcu_actual_gear);
      mHal->onPropertyValue(*Create_ec_vcu_actual_gearReq(ec_vcu_actual_gear),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_actual_gearReq(int32_t ec_vcu_actual_gear) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_actual_gear);
    req->prop = toInt(VehicleProperty::CURRENT_GEAR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_bp_statusWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int ec_vcu_bp_status = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_bp_status");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_bp_status = mPropertyManager->getCProValue(mp);
      ALOGE("dxy----- ec_vcu_bp_status %d",ec_vcu_bp_status);
      mHal->onPropertyValue(*Create_ec_vcu_bp_statusReq(ec_vcu_bp_status),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_bp_statusReq(int ec_vcu_bp_status) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_bp_status);
    req->prop = toInt(VehicleProperty::GECKO_VCU_BPSTATUS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_park_faultWatcher() {
  float ec_vcu_park_fault = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_park_fault");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_park_fault = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_vcu_park_faultReq(ec_vcu_park_fault),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_park_faultReq(float ec_vcu_park_fault) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_park_fault);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_park_stateWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_park_state = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_park_state");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_park_state = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_vcu_park_stateReq(ec_vcu_park_state),true);
      LOG(INFO) << "g ec_vcu_park_state: "<<ec_vcu_park_state;

      if(ec_vcu_park_state == 0x01){
        ConfigDBC* mp_spd = mPropertyManager->findCProperty("sc_ccm_vehicle_spd_dsp");
        float sc_ccm_vehicle_spd_dsp = mPropertyManager->getCProValue(mp_spd);

        if(sc_ccm_vehicle_spd_dsp >= 5 && sc_ccm_vehicle_spd_dsp < 255){
          //行车时驻车制动有效文本提示
          mHal->onPropertyValue(*Create_bc_motion_park_stateReq(1),true);
        }

        mHal->onPropertyValue(*Create_bc_park_chrg_cnctr_stsReq(0),true);
      } else {
        mHal->onPropertyValue(*Create_bc_motion_park_stateReq(0),true);

        // 未踩驻车制动插枪文本提示
        ConfigDBC* mp_chrg = mPropertyManager->findCProperty("ec_vcu_chrg_cnctr_sts");
        int32_t ec_vcu_chrg_cnctr_sts = mPropertyManager->getCProValue(mp_chrg);
        if(ec_vcu_chrg_cnctr_sts != 0){
          //VCU_ParkState = 0 and CU_ChrgCnctrSts = 0
          LOG(INFO) << "VCU_ParkState = 0 and CU_ChrgCnctrSts != 0";
          mHal->onPropertyValue(*Create_bc_park_chrg_cnctr_stsReq(1),true);
        }
      }
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_park_stateReq(int32_t ec_vcu_park_state) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_park_state);
    req->prop = toInt(VehicleProperty::GECKO_VCU_PARKSTATE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_switch_gear_warnWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_switch_gear_warn = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_switch_gear_warn");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_switch_gear_warn = mPropertyManager->getCProValue(mp);
      ALOGE("dxy----- ec_vcu_switch_gear_warn %d",ec_vcu_switch_gear_warn);
      mHal->onPropertyValue(*Create_ec_vcu_switch_gear_warnReq(ec_vcu_switch_gear_warn),true);

  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_switch_gear_warnReq(int32_t ec_vcu_switch_gear_warn) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_switch_gear_warn);
    req->prop = toInt(VehicleProperty::GECKO_VCU_SWITCH_GEAR_WARN);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_delay_mon_modeWatcher() {
  float ec_vcu_delay_mon_mode = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_delay_mon_mode");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_delay_mon_mode = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_vcu_delay_mon_modeReq(ec_vcu_delay_mon_mode),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_delay_mon_modeReq(float ec_vcu_delay_mon_mode) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_delay_mon_mode);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_ap_statusWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int ec_vcu_ap_status = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_ap_status");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_ap_status = mPropertyManager->getCProValue(mp);
      ALOGE("dxy----- ec_vcu_ap_status %d",ec_vcu_ap_status);
      mHal->onPropertyValue(*Create_ec_vcu_ap_statusReq(ec_vcu_ap_status),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_ap_statusReq(int ec_vcu_ap_status) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_ap_status);
    req->prop = toInt(VehicleProperty::GECKO_VCU_APSTATUS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_brk_lamp_ctr_cmdWatcher() {
  float ec_vcu_brk_lamp_ctr_cmd = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_brk_lamp_ctr_cmd");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_brk_lamp_ctr_cmd = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_vcu_brk_lamp_ctr_cmdReq(ec_vcu_brk_lamp_ctr_cmd),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_brk_lamp_ctr_cmdReq(float ec_vcu_brk_lamp_ctr_cmd) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_brk_lamp_ctr_cmd);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_lock_veh_warnWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_lock_veh_warn = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_lock_veh_warn");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_lock_veh_warn = mPropertyManager->getCProValue(mp);
      //LOG(INFO) << "ec_vcu_lock_veh_warn:"<<ec_vcu_lock_veh_warn;
      ALOGE("dxy----- ec_vcu_lock_veh_warn %d",ec_vcu_lock_veh_warn);
      mHal->onPropertyValue(*Create_ec_vcu_lock_veh_warnReq(ec_vcu_lock_veh_warn),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_lock_veh_warnReq(int32_t ec_vcu_lock_veh_warn) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_lock_veh_warn);
    req->prop = toInt(VehicleProperty::GECKO_VCU_LOCK_VEH_WARN);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_creep_stsWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_creep_sts = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_creep_sts");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_creep_sts = mPropertyManager->getCProValue(mp);
      ALOGE("dxy----- ec_vcu_creep_sts %d",ec_vcu_creep_sts);
      mHal->onPropertyValue(*Create_ec_vcu_creep_stsReq(ec_vcu_creep_sts),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_creep_stsReq(int32_t ec_vcu_creep_sts) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_creep_sts);
    req->prop = toInt(VehicleProperty::GECKO_CREEP_STATE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_single_ped_stsWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_single_ped_sts = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_single_ped_sts");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_single_ped_sts = static_cast<int32_t>(std::atoi(mp->valueMap[mPropertyManager->getCProValue(mp)].c_str()));
      ALOGE("dxy----- ec_vcu_single_ped_sts %d",ec_vcu_single_ped_sts);
      mHal->onPropertyValue(*Create_ec_vcu_single_ped_stsReq(ec_vcu_single_ped_sts),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_single_ped_stsReq(int32_t ec_vcu_single_ped_sts) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_single_ped_sts);
    req->prop = toInt(VehicleProperty::GECKO_SINGLE_PED_STATE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_ap_faultWatcher() {
  float ec_vcu_ap_fault = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_ap_fault");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_ap_fault = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_vcu_ap_faultReq(ec_vcu_ap_fault),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_ap_faultReq(float ec_vcu_ap_fault) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_ap_fault);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_bp_faultWatcher() {
  float ec_vcu_bp_fault = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_bp_fault");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_bp_fault = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_vcu_bp_faultReq(ec_vcu_bp_fault),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_bp_faultReq(float ec_vcu_bp_fault) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_bp_fault);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_brk_pdl_posWatcher() {
  float ec_vcu_brk_pdl_pos = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_brk_pdl_pos");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_brk_pdl_pos = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_vcu_brk_pdl_posReq(ec_vcu_brk_pdl_pos),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_brk_pdl_posReq(float ec_vcu_brk_pdl_pos) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_brk_pdl_pos);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_livecounter_0x350Watcher() {
  float ec_vcu_livecounter_0x350 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_livecounter_0x350");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_livecounter_0x350 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_vcu_livecounter_0x350Req(ec_vcu_livecounter_0x350),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_livecounter_0x350Req(float ec_vcu_livecounter_0x350) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_livecounter_0x350);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_checksum_0x350Watcher() {
  float ec_vcu_checksum_0x350 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_checksum_0x350");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_checksum_0x350 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_vcu_checksum_0x350Req(ec_vcu_checksum_0x350),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_checksum_0x350Req(float ec_vcu_checksum_0x350) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_checksum_0x350);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_chrg_stsWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_chrg_sts = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_chrg_sts");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_chrg_sts = mPropertyManager->getCProValue(mp);
      //LOG(INFO) << "ec_vcu_chrg_sts:"<<ec_vcu_chrg_sts;
      mHal->onPropertyValue(*Create_ec_vcu_chrg_stsReq(ec_vcu_chrg_sts),true);
  }
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_chrg_stsReq(int32_t ec_vcu_chrg_sts) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_chrg_sts);
    req->prop = toInt(VehicleProperty::GECKO_VCU_CHRG_STS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

// void GarageModeServerSideHandlerImpl::monitorChargState(){
//     std::this_thread::sleep_for(std::chrono::milliseconds(800));
//     ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_chrg_sts");
//     while(!mShuttingDownFlag.load()){
//         mPropertyManager->getUpdateCState(mp);
//         std::unique_lock<std::mutex> lock(eVcuChrgStsMtx);
//         ecVcuChrgStsCv.notify_all();  // 唤醒等待的线程
//   }
// }
// 监控轮胎温度的变化 
void GarageModeServerSideHandlerImpl::monitorTpmsTyretemperatureState(){
    ConfigDBC* mp = mPropertyManager->findCProperty("bc_tpms_tyretemperature");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        std::unique_lock<std::mutex> lock(bcTpmsTyretemperatureMtx);
        bcTpmsTyretemperatureCv.notify_all();  // 唤醒等待的线程
  }
}


// 监听前左轮胎在1秒中内是否有变化
void GarageModeServerSideHandlerImpl::monitorTpmsTyrepressureFlState(){
    ConfigDBC* mp = mPropertyManager->findCProperty("bc_tpms_tyrepressure_fl");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        std::unique_lock<std::mutex> lock(bcTpmsTyrepressureFlMtx);
        bcTpmsTyrepressureFlCv.notify_all();  // 唤醒等待的线程
  }
}

// 监听前右轮胎在1秒中内是否有变化
void GarageModeServerSideHandlerImpl::monitorTpmsTyrepressureFrState(){
    ConfigDBC* mp = mPropertyManager->findCProperty("bc_tpms_tyrepressure_fr");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        std::unique_lock<std::mutex> lock(bcTpmsTyrepressureFrMtx);
        bcTpmsTyrepressureFrCv.notify_all();  // 唤醒等待的线程
  }
}

// 监听后左轮胎在1秒中内是否有变化
void GarageModeServerSideHandlerImpl::monitorTpmsTyrepressureRlState(){
    ConfigDBC* mp = mPropertyManager->findCProperty("bc_tpms_tyrepressure_rl");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        std::unique_lock<std::mutex> lock(bcTpmsTyrepressureRlMtx);
        bcTpmsTyrepressureRlCv.notify_all();  // 唤醒等待的线程
  }
}

// 监听后右轮胎在1秒中内是否有变化
void GarageModeServerSideHandlerImpl::monitorTpmsTyrepressureRrState(){
    ConfigDBC* mp = mPropertyManager->findCProperty("bc_tpms_tyrepressure_rr");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        std::unique_lock<std::mutex> lock(bcTpmsTyrepressureRrMtx);
        bcTpmsTyrepressureRrCv.notify_all();  // 唤醒等待的线程
  }
}

void GarageModeServerSideHandlerImpl::ec_vcu_pt_rdyWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_pt_rdy = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_pt_rdy");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_pt_rdy = mPropertyManager->getCProValue(mp);
      LOG(INFO) << "ec_vcu_pt_rdy:"<<ec_vcu_pt_rdy;
      mHal->onPropertyValue(*Create_ec_vcu_pt_rdyReq(ec_vcu_pt_rdy),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_pt_rdyReq(int32_t ec_vcu_pt_rdy) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_pt_rdy);
    req->prop = toInt(VehicleProperty::GECKO_VCU_PT_RDY);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_smart_dc_reqWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_smart_dc_req = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_smart_dc_req");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_smart_dc_req = mPropertyManager->getCProValue(mp);
      LOG(INFO) << "ec_vcu_smart_dc_req:"<<ec_vcu_smart_dc_req;
      mHal->onPropertyValue(*Create_ec_vcu_smart_dc_reqReq(ec_vcu_smart_dc_req),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_smart_dc_reqReq(int32_t ec_vcu_smart_dc_req) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_smart_dc_req);
    req->prop = toInt(VehicleProperty::GECKO_VCU_SMART_DC_REQ);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_chrg_soc_tar_spWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int ec_vcu_chrg_soc_tar_sp = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_chrg_soc_tar_sp");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_chrg_soc_tar_sp = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_vcu_chrg_soc_tar_spReq(ec_vcu_chrg_soc_tar_sp),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_chrg_soc_tar_spReq(int32_t ec_vcu_chrg_soc_tar_sp) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_chrg_soc_tar_sp);
    req->prop = toInt(VehicleProperty::GECKO_VCU_CHRG_SOC_TAR_SP);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_dis_chrg_stsWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_dis_chrg_sts = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_dis_chrg_sts");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_dis_chrg_sts = mPropertyManager->getCProValue(mp);
      //LOG(INFO) << "ec_vcu_dis_chrg_sts:"<<ec_vcu_dis_chrg_sts;
      mHal->onPropertyValue(*Create_ec_vcu_dis_chrg_stsReq(ec_vcu_dis_chrg_sts),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_dis_chrg_stsReq(int32_t ec_vcu_dis_chrg_sts) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_dis_chrg_sts);
    req->prop = toInt(VehicleProperty::GECKO_VCU_DIS_CHRG_STS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_average_energy_consum_vdWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_average_energy_consum_vd = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_average_energy_consum_vd");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_average_energy_consum_vd = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_vcu_average_energy_consum_vdReq(ec_vcu_average_energy_consum_vd),true);
  }
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_average_energy_consum_vdReq(int32_t ec_vcu_average_energy_consum_vd) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_average_energy_consum_vd);
    req->prop = toInt(VehicleProperty::GECKO_AVERAGE_ENERGY_CONSUM_VD);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_dc_chrg_rly_auxil_cntac_stsWatcher() {
  float ec_vcu_dc_chrg_rly_auxil_cntac_sts = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_dc_chrg_rly_auxil_cntac_sts");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_dc_chrg_rly_auxil_cntac_sts = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_vcu_dc_chrg_rly_auxil_cntac_stsReq(ec_vcu_dc_chrg_rly_auxil_cntac_sts),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_dc_chrg_rly_auxil_cntac_stsReq(float ec_vcu_dc_chrg_rly_auxil_cntac_sts) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_dc_chrg_rly_auxil_cntac_sts);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_braking_remindWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_braking_remind = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_braking_remind");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_braking_remind = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_vcu_braking_remindReq(ec_vcu_braking_remind),true);
      LOG(INFO)<<"gh ec_vcu_braking_remind:"<<ec_vcu_braking_remind;
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_braking_remindReq(int32_t ec_vcu_braking_remind) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_braking_remind);
    req->prop = toInt(VehicleProperty::GECKO_EV_BRAKING_REMIND);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_average_energy_consumptionWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  float ec_vcu_average_energy_consumption = 0.0;
//  Property* mp = mPropertyManager->findProperty("ec_vcu_average_energy_consumption");
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_average_energy_consumption");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_average_energy_consumption = getActualFloatValue(mPropertyManager->getCProValue(mp),0.1,0);

	  //点火周期内瞬时电耗统计
	  #if 0
	  if (energyConsumptionFlag) {
          //ALOGI("hqh---- ec_vcu_average_energy_consumption =%f", ec_vcu_average_energy_consumption);
          totalEnergyConsumption = ec_vcu_average_energy_consumption;
          mHal->onPropertyValue(*Create_power_on_average_energy_consumptionReq(totalEnergyConsumption),true);
          } else {
          mHal->onPropertyValue(*Create_power_on_average_energy_consumptionReq(-1024.0),true);
      }
      mHal->onPropertyValue(*Create_ec_vcu_average_energy_consumptionReq(ec_vcu_average_energy_consumption),true);
      std::chrono::milliseconds ms= std::chrono::duration_cast< std::chrono::milliseconds >(
        std::chrono::system_clock::now().time_since_epoch());
      power_on_average_energy_consumption_time = ms.count();
      #endif
      mHal->onPropertyValue(*Create_ec_vcu_average_energy_consumptionReq(ec_vcu_average_energy_consumption),true);
   }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_average_energy_consumptionReq(float ec_vcu_average_energy_consumption) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_average_energy_consumption);
    req->prop = toInt(VehicleProperty::GECKO_AVERAGE_ENERGY_CONSUMPTION);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_instant_energy_consumptionWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  float ec_vcu_instant_energy_consumption = 0.0;
//  Property* mp = mPropertyManager->findProperty("ec_vcu_instant_energy_consumption");
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_instant_energy_consumption");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      int32_t value = mPropertyManager->getCProValue(mp);
      if(value!=511) {
          ec_vcu_instant_energy_consumption = getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp),0.1, -51.1);
      } else {
          ec_vcu_instant_energy_consumption = 0.0;
      }
      consumption = ec_vcu_instant_energy_consumption;
      LOG(INFO) << "dxy---- ec_vcu_instant_energy_consumption:" << ec_vcu_instant_energy_consumption;
      mHal->onPropertyValue(*Create_ec_vcu_instant_energy_consumptionReq(ec_vcu_instant_energy_consumption),true);
      isEnergyConsumption = true;

  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_instant_energy_consumptionReq(float ec_vcu_instant_energy_consumption) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_instant_energy_consumption);
    req->prop = toInt(VehicleProperty::GECKO_INSTANCE_ENERGY_CONSUMPTION);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_instant_energy_consum_vdWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_instant_energy_consum_vd = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_instant_energy_consum_vd");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_instant_energy_consum_vd = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_vcu_instant_energy_consum_vdReq(ec_vcu_instant_energy_consum_vd),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_instant_energy_consum_vdReq(int32_t ec_vcu_instant_energy_consum_vd) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_instant_energy_consum_vd);
    req->prop = toInt(VehicleProperty::GECKO_INSTANT_ENERGY_CONSUM_VD);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}


void GarageModeServerSideHandlerImpl::ec_vcu_livecounter_0x351Watcher() {
  float ec_vcu_livecounter_0x351 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_livecounter_0x351");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_livecounter_0x351 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_vcu_livecounter_0x351Req(ec_vcu_livecounter_0x351),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_livecounter_0x351Req(float ec_vcu_livecounter_0x351) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_livecounter_0x351);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_checksum_0x351Watcher() {
  float ec_vcu_checksum_0x351 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_checksum_0x351");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_checksum_0x351 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_vcu_checksum_0x351Req(ec_vcu_checksum_0x351),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_checksum_0x351Req(float ec_vcu_checksum_0x351) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_checksum_0x351);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ccm_veh_tar_socWatcher() {
  float ec_ccm_veh_tar_soc = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccm_veh_tar_soc");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ccm_veh_tar_soc = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ccm_veh_tar_socReq(ec_ccm_veh_tar_soc),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccm_veh_tar_socReq(float ec_ccm_veh_tar_soc) {
    auto req = mValueObjectPool->obtainFloat(ec_ccm_veh_tar_soc);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ccm_batt_maintain_ctr_cmdWatcher() {
  float ec_ccm_batt_maintain_ctr_cmd = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccm_batt_maintain_ctr_cmd");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ccm_batt_maintain_ctr_cmd = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ccm_batt_maintain_ctr_cmdReq(ec_ccm_batt_maintain_ctr_cmd),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccm_batt_maintain_ctr_cmdReq(float ec_ccm_batt_maintain_ctr_cmd) {
    auto req = mValueObjectPool->obtainFloat(ec_ccm_batt_maintain_ctr_cmd);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ota_modelWatcher() {
  float ec_ota_model = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ota_model");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ota_model = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ota_modelReq(ec_ota_model),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ota_modelReq(float ec_ota_model) {
    auto req = mValueObjectPool->obtainFloat(ec_ota_model);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ccm_rechrgn_lv_reqWatcher() {
  float ec_ccm_rechrgn_lv_req = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccm_rechrgn_lv_req");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ccm_rechrgn_lv_req = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ccm_rechrgn_lv_reqReq(ec_ccm_rechrgn_lv_req),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccm_rechrgn_lv_reqReq(float ec_ccm_rechrgn_lv_req) {
    auto req = mValueObjectPool->obtainFloat(ec_ccm_rechrgn_lv_req);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ccm_driver_buckle_statusWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_ccm_driver_buckle_status = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccm_driver_buckle_status");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      //notice
      ec_ccm_driver_buckle_status = static_cast<int32_t> (mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_ccm_driver_buckle_statusReq(ec_ccm_driver_buckle_status, 1),true);
      mHal->onPropertyValue(*Create_ec_ccm_driver_buckle_statusReq(ec_ccm_driver_buckle_status, 4),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccm_driver_buckle_statusReq(int32_t ec_ccm_driver_buckle_status, int32_t areaId) {
    auto req = mValueObjectPool->obtainInt32(ec_ccm_driver_buckle_status);
    req->prop = toInt(VehicleProperty::SEAT_BELT_BUCKLED);
    req->areaId = areaId;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ccm_drive_mode_reqWatcher() {
  float ec_ccm_drive_mode_req = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccm_drive_mode_req");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ccm_drive_mode_req = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ccm_drive_mode_reqReq(ec_ccm_drive_mode_req),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccm_drive_mode_reqReq(float ec_ccm_drive_mode_req) {
    auto req = mValueObjectPool->obtainFloat(ec_ccm_drive_mode_req);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ccm_operat_licenceWatcher() {
  float ec_ccm_operat_licence = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccm_operat_licence");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ccm_operat_licence = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ccm_operat_licenceReq(ec_ccm_operat_licence),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccm_operat_licenceReq(float ec_ccm_operat_licence) {
    auto req = mValueObjectPool->obtainFloat(ec_ccm_operat_licence);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ccm_versionWatcher() {
  float ec_ccm_version = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccm_version");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ccm_version = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ccm_versionReq(ec_ccm_version),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccm_versionReq(float ec_ccm_version) {
    auto req = mValueObjectPool->obtainFloat(ec_ccm_version);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ccm_speed_limit_levelWatcher() {
  float ec_ccm_speed_limit_level = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccm_speed_limit_level");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ccm_speed_limit_level = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ccm_speed_limit_levelReq(ec_ccm_speed_limit_level),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccm_speed_limit_levelReq(float ec_ccm_speed_limit_level) {
    auto req = mValueObjectPool->obtainFloat(ec_ccm_speed_limit_level);
    req->prop = toInt(VehicleProperty::GECKO_MCU_SPEED_LIMIT_LEVEL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ccm_charging_conditionsWatcher() {
  float ec_ccm_charging_conditions = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccm_charging_conditions");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ccm_charging_conditions = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ccm_charging_conditionsReq(ec_ccm_charging_conditions),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccm_charging_conditionsReq(float ec_ccm_charging_conditions) {
    auto req = mValueObjectPool->obtainFloat(ec_ccm_charging_conditions);
    req->prop = toInt(VehicleProperty::GECKO_MCU_CHARGING_CONDIONS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_total_odometerWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  float ec_total_odometer = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_total_odometer");
  // 读取系统属性 "gecko.total.mileage" 的值
   std::string totalMileageStr = android::base::GetProperty("gecko.total.mileage", "0.0");
   float floatTotalMileage = std::stof(totalMileageStr);
   LOG(INFO) << "dxy---- gecko.total.mileage:" <<floatTotalMileage;
  //  std::this_thread::sleep_for(std::chrono::milliseconds(1600));             // 此处的值由之前的1000毫秒改成1600毫秒，目的是为了防止设备老化，性能下降而导致默认值初始化函数在短时间内没有跑完而且导致不能对表进行修改而引起的crash。
  //  mHal->onPropertyValue(*Create_ec_total_odometerReq(floatTotalMileage),true);
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_total_odometer = getActualFloatValue(mPropertyManager->getCProValue(mp),0.1,0);
      mHal->onPropertyValue(*Create_ec_total_odometerReq(ec_total_odometer),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_total_odometerReq(float ec_total_odometer) {
    auto req = mValueObjectPool->obtainFloat(ec_total_odometer);
    req->prop = toInt(VehicleProperty::PERF_ODOMETER);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_power_on_milegeReq(float power_on_milege){
  auto req = mValueObjectPool->obtainFloat(power_on_milege);
  req->prop = toInt(VehicleProperty::GECKO_POWER_ON_MILEGE);
  req->areaId = 0;
  req->timestamp = elapsedRealtimeNano();
  req->status = VehiclePropertyStatus::AVAILABLE;
  return req;
}

void GarageModeServerSideHandlerImpl::mc_travel_short_rangeWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(6000));
  float mc_travel_short_range = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("mcu_short_travel_mileage");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      mc_travel_short_range = getActualFloatValue(mPropertyManager->getCProValue(mp), 0.1, 0);
      LOG(INFO) << "mcu_short_travel_mileage:"<< mc_travel_short_range;
      mHal->onPropertyValue(*Create_power_on_milegeReq(mc_travel_short_range),true);
  }
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_power_on_average_speedReq(int32_t power_on_average_speed){
  auto req = mValueObjectPool->obtainInt32(power_on_average_speed);
  req->prop = toInt(VehicleProperty::GECKO_POWER_ON_AVERAGE_SPEED);
  req->areaId = 0;
  req->timestamp = elapsedRealtimeNano();
  req->status = VehiclePropertyStatus::AVAILABLE;
  return req;
}
void GarageModeServerSideHandlerImpl::mc_travel_short_average_speedWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(6000));
  float mc_travel_short_av_spd = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("mcu_short_average_spd");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      mc_travel_short_av_spd = getActualFloatValue(mPropertyManager->getCProValue(mp), 0.1, 0);
      LOG(INFO) << "mcu_short_average_spd:"<< mc_travel_short_av_spd;
      mHal->onPropertyValue(*Create_power_on_average_speedReq(mc_travel_short_av_spd),true);
  }
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_power_on_average_energy_consumptionReq(float ec_total_odometer){
  auto req = mValueObjectPool->obtainFloat(ec_total_odometer);
  req->prop = toInt(VehicleProperty::GECKO_POWER_ON_AVERAGE_ENERGY_CONSUMPTION);
  req->areaId = 0;
  req->timestamp = elapsedRealtimeNano();
  req->status = VehiclePropertyStatus::AVAILABLE;
  return req;
}
void GarageModeServerSideHandlerImpl::mc_travel_short_average_pwr_consum_Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(6000));
  float mc_travel_short_pw_consum = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("mcu_short_average_consum");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      mc_travel_short_pw_consum = getActualFloatValue(mPropertyManager->getCProValue(mp), 0.1, 0);
      LOG(INFO) << "mcu_short_average_consum:"<< mc_travel_short_pw_consum;
      mHal->onPropertyValue(*Create_power_on_average_energy_consumptionReq(mc_travel_short_pw_consum),true);
  }
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_power_on_timeReq(int32_t power_on_time){
  auto req = mValueObjectPool->obtainInt32(power_on_time);
  req->prop = toInt(VehicleProperty::GECKO_POWER_ON_TIME);
  req->areaId = 0;
  req->timestamp = elapsedRealtimeNano();
  req->status = VehiclePropertyStatus::AVAILABLE;
  return req;
}
void GarageModeServerSideHandlerImpl::mc_travel_short_timeWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(6000));
  int32_t mc_short_travel_time = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("mcu_short_travel_time");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      mc_short_travel_time = mPropertyManager->getCProValue(mp);
      LOG(INFO) << "mcu_short_travel_time:"<< mc_short_travel_time;
      if(mc_short_travel_time <= 65535) {
           mHal->onPropertyValue(*Create_power_on_timeReq(mc_short_travel_time),true);
      }
  }
}


void GarageModeServerSideHandlerImpl::ec_ccm_target_chrg_currWatcher() {
  float ec_ccm_target_chrg_curr = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccm_target_chrg_curr");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ccm_target_chrg_curr = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ccm_target_chrg_currReq(ec_ccm_target_chrg_curr),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccm_target_chrg_currReq(float ec_ccm_target_chrg_curr) {
    auto req = mValueObjectPool->obtainFloat(ec_ccm_target_chrg_curr);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ccm_batt_maintain_stsWatcher() {
  float ec_ccm_batt_maintain_sts = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccm_batt_maintain_sts");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ccm_batt_maintain_sts = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ccm_batt_maintain_stsReq(ec_ccm_batt_maintain_sts),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccm_batt_maintain_stsReq(float ec_ccm_batt_maintain_sts) {
    auto req = mValueObjectPool->obtainFloat(ec_ccm_batt_maintain_sts);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ccm_livecounter_0x353Watcher() {
  float ec_ccm_livecounter_0x353 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccm_livecounter_0x353");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ccm_livecounter_0x353 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ccm_livecounter_0x353Req(ec_ccm_livecounter_0x353),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccm_livecounter_0x353Req(float ec_ccm_livecounter_0x353) {
    auto req = mValueObjectPool->obtainFloat(ec_ccm_livecounter_0x353);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ccm_checksum_0x353Watcher() {
  float ec_ccm_checksum_0x353 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccm_checksum_0x353");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ccm_checksum_0x353 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ccm_checksum_0x353Req(ec_ccm_checksum_0x353),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccm_checksum_0x353Req(float ec_ccm_checksum_0x353) {
    auto req = mValueObjectPool->obtainFloat(ec_ccm_checksum_0x353);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ccm_remt_ctrl_flagWatcher() {
  float ec_ccm_remt_ctrl_flag = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccm_remt_ctrl_flag");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ccm_remt_ctrl_flag = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ccm_remt_ctrl_flagReq(ec_ccm_remt_ctrl_flag),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccm_remt_ctrl_flagReq(float ec_ccm_remt_ctrl_flag) {
    auto req = mValueObjectPool->obtainFloat(ec_ccm_remt_ctrl_flag);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ccm_charging_requestWatcher() {
  float ec_ccm_charging_request = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccm_charging_request");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ccm_charging_request = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ccm_charging_requestReq(ec_ccm_charging_request),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccm_charging_requestReq(float ec_ccm_charging_request) {
    auto req = mValueObjectPool->obtainFloat(ec_ccm_charging_request);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ccm_chraging_modeWatcher() {
  float ec_ccm_chraging_mode = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccm_chraging_mode");
  if(!mp) return;  
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ccm_chraging_mode = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ccm_chraging_modeReq(ec_ccm_chraging_mode),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccm_chraging_modeReq(float ec_ccm_chraging_mode) {
    auto req = mValueObjectPool->obtainFloat(ec_ccm_chraging_mode);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ccm_energy_recov_level_cmdWatcher() {
  float ec_ccm_energy_recov_level_cmd = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccm_energy_recov_level_cmd");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ccm_energy_recov_level_cmd = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ccm_energy_recov_level_cmdReq(ec_ccm_energy_recov_level_cmd),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccm_energy_recov_level_cmdReq(float ec_ccm_energy_recov_level_cmd) {
    auto req = mValueObjectPool->obtainFloat(ec_ccm_energy_recov_level_cmd);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ccm_creep_ctr_cmdWatcher() {
  float ec_ccm_creep_ctr_cmd = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccm_creep_ctr_cmd");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ccm_creep_ctr_cmd = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ccm_creep_ctr_cmdReq(ec_ccm_creep_ctr_cmd),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccm_creep_ctr_cmdReq(float ec_ccm_creep_ctr_cmd) {
    auto req = mValueObjectPool->obtainFloat(ec_ccm_creep_ctr_cmd);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ccm_single_ped_ctr_cmdWatcher() {
  float ec_ccm_single_ped_ctr_cmd = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccm_single_ped_ctr_cmd");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ccm_single_ped_ctr_cmd = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ccm_single_ped_ctr_cmdReq(ec_ccm_single_ped_ctr_cmd),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccm_single_ped_ctr_cmdReq(float ec_ccm_single_ped_ctr_cmd) {
    auto req = mValueObjectPool->obtainFloat(ec_ccm_single_ped_ctr_cmd);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ccm_rema_range_dispWatcher() {
  float ec_ccm_rema_range_disp = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccm_rema_range_disp");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ccm_rema_range_disp = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ccm_rema_range_dispReq(ec_ccm_rema_range_disp),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccm_rema_range_dispReq(float ec_ccm_rema_range_disp) {
    auto req = mValueObjectPool->obtainFloat(ec_ccm_rema_range_disp);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ccm_rema_range_disp_vdWatcher() {
  float ec_ccm_rema_range_disp_vd = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccm_rema_range_disp_vd");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ccm_rema_range_disp_vd = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ccm_rema_range_disp_vdReq(ec_ccm_rema_range_disp_vd),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccm_rema_range_disp_vdReq(float ec_ccm_rema_range_disp_vd) {
    auto req = mValueObjectPool->obtainFloat(ec_ccm_rema_range_disp_vd);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ccm_livecounter_0x354Watcher() {
  float ec_ccm_livecounter_0x354 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccm_livecounter_0x354");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ccm_livecounter_0x354 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ccm_livecounter_0x354Req(ec_ccm_livecounter_0x354),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccm_livecounter_0x354Req(float ec_ccm_livecounter_0x354) {
    auto req = mValueObjectPool->obtainFloat(ec_ccm_livecounter_0x354);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ccm_checksum_0x354Watcher() {
  float ec_ccm_checksum_0x354 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccm_checksum_0x354");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ccm_checksum_0x354 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ccm_checksum_0x354Req(ec_ccm_checksum_0x354),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccm_checksum_0x354Req(float ec_ccm_checksum_0x354) {
    auto req = mValueObjectPool->obtainFloat(ec_ccm_checksum_0x354);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_drive_modeWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_drive_mode = 0;
//  Property* mp = mPropertyManager->findProperty("ec_vcu_drive_mode");
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_drive_mode");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_drive_mode = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_vcu_drive_modeReq(ec_vcu_drive_mode),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_drive_modeReq(int32_t ec_vcu_drive_mode) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_drive_mode);
    req->prop = toInt(VehicleProperty::GECKO_VEHICLE_DRIVE_MODE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_low_soc_warnWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_low_soc_warn = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_low_soc_warn");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_low_soc_warn = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      //mHal->onPropertyValue(*Create_ec_vcu_low_soc_warnReq(ec_vcu_low_soc_warn),true);
      mHal->onPropertyValue(*Create_ec_batterylowsignalReq(ec_vcu_low_soc_warn),true);
      ALOGE("ec_vcu_low_soc_warnWatcher ec_vcu_low_soc_warn:%d", ec_vcu_low_soc_warn);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_low_soc_warnReq(int32_t ec_vcu_low_soc_warn) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_low_soc_warn);
    req->prop = toInt(VehicleProperty::GECKO_VCU_LOW_SOC_WARN);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_can_timeout_faultWatcher() {
  float ec_vcu_can_timeout_fault = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_can_timeout_fault");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_can_timeout_fault = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_vcu_can_timeout_faultReq(ec_vcu_can_timeout_fault),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_can_timeout_faultReq(float ec_vcu_can_timeout_fault) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_can_timeout_fault);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_eas_ins_staWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_eas_ins_sta = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_eas_ins_sta");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_eas_ins_sta = mPropertyManager->getCProValue(mp);
      LOG(INFO) << "ec_vcu_eas_ins_sta:"<<ec_vcu_eas_ins_sta;
      mHal->onPropertyValue(*Create_ec_vcu_eas_ins_staReq(ec_vcu_eas_ins_sta),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_eas_ins_staReq(int32_t ec_vcu_eas_ins_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_eas_ins_sta);
    req->prop = toInt(VehicleProperty::GECKO_VCU_EAS_INS_STA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_dc_discharging_fail_warnWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_dc_discharging_fail_warn = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_dc_discharging_fail_warn");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_dc_discharging_fail_warn = mPropertyManager->getCProValue(mp);
      LOG(INFO) << "ec_vcu_dc_discharging_fail_warn:"<<ec_vcu_dc_discharging_fail_warn;
      mHal->onPropertyValue(*Create_ec_vcu_dc_discharging_fail_warnReq(ec_vcu_dc_discharging_fail_warn),true);

  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_dc_discharging_fail_warnReq(int32_t ec_vcu_dc_discharging_fail_warn) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_dc_discharging_fail_warn);
    req->prop = toInt(VehicleProperty::GECKO_VCU_DC_DISCHARGING_FAIL_WARN);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_dc_charging_fail_warnWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_dc_charging_fail_warn = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_dc_charging_fail_warn");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_dc_charging_fail_warn = mPropertyManager->getCProValue(mp);
      LOG(INFO) << "ec_vcu_dc_charging_fail_warn:"<<ec_vcu_dc_charging_fail_warn;
      mHal->onPropertyValue(*Create_ec_vcu_dc_charging_fail_warnReq(ec_vcu_dc_charging_fail_warn),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_dc_charging_fail_warnReq(int32_t ec_vcu_dc_charging_fail_warn) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_dc_charging_fail_warn);
    req->prop = toInt(VehicleProperty::GECKO_VCU_DC_CHARGING_FAIL_WARN);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_ac_charging_fail_warnWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_ac_charging_fail_warn = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_ac_charging_fail_warn");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_ac_charging_fail_warn = mPropertyManager->getCProValue(mp);
      LOG(INFO) << "ec_vcu_ac_charging_fail_warn:"<<ec_vcu_ac_charging_fail_warn;
      mHal->onPropertyValue(*Create_ec_vcu_ac_charging_fail_warnReq(ec_vcu_ac_charging_fail_warn),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_ac_charging_fail_warnReq(int32_t ec_vcu_ac_charging_fail_warn) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_ac_charging_fail_warn);
    req->prop = toInt(VehicleProperty::GECKO_VCU_AC_CHARGING_FAIL_WARN);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_12_v_charging_fail_warnWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_12_v_charging_fail_warn = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_12_v_charging_fail_warn");
  while(!mShuttingDownFlag.load()){
    mPropertyManager->getUpdateCState(mp);
    ec_vcu_12_v_charging_fail_warn = mPropertyManager->getCProValue(mp);
    //LOG(INFO) << "ec_vcu_12_v_charging_fail_warn:"<<ec_vcu_12_v_charging_fail_warn;
    mHal->onPropertyValue(*Create_ec_vcu_12_v_charging_fail_warnReq(ec_vcu_12_v_charging_fail_warn),true);

  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_12_v_charging_fail_warnReq(int32_t ec_vcu_12_v_charging_fail_warn) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_12_v_charging_fail_warn);
    req->prop = toInt(VehicleProperty::GECKO_VCU_12_V_CHARGING_FAIL_WARN);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_veh_unable_dri_warnWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_veh_unable_dri_warn = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_veh_unable_dri_warn");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_veh_unable_dri_warn = mPropertyManager->getCProValue(mp);
      LOG(INFO) << "ec_vcu_veh_unable_dri_warn:"<<ec_vcu_veh_unable_dri_warn;
      mHal->onPropertyValue(*Create_ec_vcu_veh_unable_dri_warnReq(ec_vcu_veh_unable_dri_warn),true);

  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_veh_unable_dri_warnReq(int32_t ec_vcu_veh_unable_dri_warn) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_veh_unable_dri_warn);
    req->prop = toInt(VehicleProperty::GECKO_VCU_VEH_UNABLE_DRI_WARN);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_brk_liquid_level_lowWatcher() {
  float ec_vcu_brk_liquid_level_low = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_brk_liquid_level_low");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_brk_liquid_level_low = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_vcu_brk_liquid_level_lowReq(ec_vcu_brk_liquid_level_low),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_brk_liquid_level_lowReq(float ec_vcu_brk_liquid_level_low) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_brk_liquid_level_low);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_fault_codeWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_fault_code {0};
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_fault_code");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_fault_code = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_vcu_fault_codeReq(ec_vcu_fault_code),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_fault_codeReq(int32_t ec_vcu_fault_code) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_fault_code);
    req->prop = toInt(VehicleProperty::GECKO_VCU_FAULT_CODE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_fault_treat_levelWatcher() {
  float ec_vcu_fault_treat_level = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_fault_treat_level");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_fault_treat_level = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_vcu_fault_treat_levelReq(ec_vcu_fault_treat_level),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_fault_treat_levelReq(float ec_vcu_fault_treat_level) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_fault_treat_level);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_drive_pwr_limWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_drive_pwr_lim = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_drive_pwr_lim");
  while(!mShuttingDownFlag.load()){
    mPropertyManager->getUpdateCState(mp);
    ec_vcu_drive_pwr_lim = mPropertyManager->getCProValue(mp);
    //LOG(INFO) << "ec_vcu_drive_pwr_lim:"<<ec_vcu_drive_pwr_lim;
    mHal->onPropertyValue(*Create_ec_vcu_drive_pwr_limReq(ec_vcu_drive_pwr_lim),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_drive_pwr_limReq(int32_t ec_vcu_drive_pwr_lim) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_drive_pwr_lim);
    req->prop = toInt(VehicleProperty::GECKO_VCU_DRIVE_PWR_LIM);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_mcu_errWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_mcu_err = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_mcu_err");
  while(!mShuttingDownFlag.load()){
    mPropertyManager->getUpdateCState(mp);
    ec_vcu_mcu_err = mPropertyManager->getCProValue(mp);
    //LOG(INFO) << "ec_vcu_mcu_err:"<<ec_vcu_mcu_err;
    mHal->onPropertyValue(*Create_ec_vcu_mcu_errReq(ec_vcu_mcu_err),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_mcu_errReq(int32_t ec_vcu_mcu_err) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_mcu_err);
    req->prop = toInt(VehicleProperty::GECKO_VCU_MCU_ERR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_hv_batt_errWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_hv_batt_err = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_hv_batt_err");
  while(!mShuttingDownFlag.load()){
    mPropertyManager->getUpdateCState(mp);
    ec_vcu_hv_batt_err = mPropertyManager->getCProValue(mp);
    //LOG(INFO) << "ec_vcu_hv_batt_err:"<<ec_vcu_hv_batt_err;
    mHal->onPropertyValue(*Create_ec_vcu_hv_batt_errReq(ec_vcu_hv_batt_err),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_hv_batt_errReq(int32_t ec_vcu_hv_batt_err) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_hv_batt_err);
    req->prop = toInt(VehicleProperty::GECKO_VCU_HV_BATT_ERR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_speed_limit_levelWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_speed_limit_level = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_speed_limit_level");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_speed_limit_level = static_cast<int32_t>(std::atoi(mp->valueMap[mPropertyManager->getCProValue(mp)].c_str()));
      mHal->onPropertyValue(*Create_ec_vcu_speed_limit_levelReq(ec_vcu_speed_limit_level),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_speed_limit_levelReq(int32_t ec_vcu_speed_limit_level) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_speed_limit_level);
    req->prop = toInt(VehicleProperty::GECKO_MCU_SPEED_LIMIT_LEVEL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_charging_conditionsWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_charging_conditions = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_charging_conditions");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_charging_conditions = static_cast<int32_t>(std::atoi(mp->valueMap[mPropertyManager->getCProValue(mp)].c_str()));
      mHal->onPropertyValue(*Create_ec_vcu_charging_conditionsReq(ec_vcu_charging_conditions),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_charging_conditionsReq(int32_t ec_vcu_charging_conditions) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_charging_conditions);
    req->prop = toInt(VehicleProperty::GECKO_MCU_CHARGING_CONDIONS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_livecounter_0x352Watcher() {
  float ec_vcu_livecounter_0x352 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_livecounter_0x352");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_livecounter_0x352 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_vcu_livecounter_0x352Req(ec_vcu_livecounter_0x352),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_livecounter_0x352Req(float ec_vcu_livecounter_0x352) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_livecounter_0x352);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_checksum_0x352Watcher() {
  float ec_vcu_checksum_0x352 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_checksum_0x352");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_checksum_0x352 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_vcu_checksum_0x352Req(ec_vcu_checksum_0x352),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_checksum_0x352Req(float ec_vcu_checksum_0x352) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_checksum_0x352);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_comp_neg_rel_staWatcher() {
  float ec_vcu_comp_neg_rel_sta = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_comp_neg_rel_sta");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_comp_neg_rel_sta = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_vcu_comp_neg_rel_staReq(ec_vcu_comp_neg_rel_sta),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_comp_neg_rel_staReq(float ec_vcu_comp_neg_rel_sta) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_comp_neg_rel_sta);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_comp_pos_rel_staWatcher() {
  float ec_vcu_comp_pos_rel_sta = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_comp_pos_rel_sta");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_comp_pos_rel_sta = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_vcu_comp_pos_rel_staReq(ec_vcu_comp_pos_rel_sta),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_comp_pos_rel_staReq(float ec_vcu_comp_pos_rel_sta) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_comp_pos_rel_sta);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_ipu_errWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_ipu_err = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_ipu_err");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_ipu_err = mPropertyManager->getCProValue(mp);
      LOG(INFO) << "ec_vcu_ipu_err:"<<ec_vcu_ipu_err;
      mHal->onPropertyValue(*Create_ec_vcu_ipu_errReq(ec_vcu_ipu_err),true);

  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_ipu_errReq(int32_t ec_vcu_ipu_err) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_ipu_err);
    req->prop = toInt(VehicleProperty::GECKO_VCU_IPU_ERR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_cooling_fail_warnWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_cooling_fail_warn = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_cooling_fail_warn");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_cooling_fail_warn = mPropertyManager->getCProValue(mp);
      LOG(INFO) << "ec_vcu_cooling_fail_warn:"<<ec_vcu_cooling_fail_warn;
      mHal->onPropertyValue(*Create_ec_vcu_cooling_fail_warnReq(ec_vcu_cooling_fail_warn),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_cooling_fail_warnReq(int32_t ec_vcu_cooling_fail_warn) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_cooling_fail_warn);
    req->prop = toInt(VehicleProperty::GECKO_VCU_COOLING_FAIL_WARN);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_lv_elec_sys_errWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_lv_elec_sys_err = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_lv_elec_sys_err");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_lv_elec_sys_err = mPropertyManager->getCProValue(mp);
      LOG(INFO) << "ec_vcu_lv_elec_sys_err:"<<ec_vcu_lv_elec_sys_err;
      mHal->onPropertyValue(*Create_ec_vcu_lv_elec_sys_errReq(ec_vcu_lv_elec_sys_err),true);
      mHal->onPropertyValue(*Create_electric_errReq(getElectricErr()),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_lv_elec_sys_errReq(int32_t ec_vcu_lv_elec_sys_err) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_lv_elec_sys_err);
    req->prop = toInt(VehicleProperty::GECKO_VCU_LV_ELEC_SYS_ERR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_ac_hv_sys_errWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_ac_hv_sys_err = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_ac_hv_sys_err");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_ac_hv_sys_err = mPropertyManager->getCProValue(mp);
      LOG(INFO) << "ec_vcu_ac_hv_sys_err:"<<ec_vcu_ac_hv_sys_err;
      mHal->onPropertyValue(*Create_ec_vcu_ac_hv_sys_errReq(ec_vcu_ac_hv_sys_err),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_ac_hv_sys_errReq(int32_t ec_vcu_ac_hv_sys_err) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_ac_hv_sys_err);
    req->prop = toInt(VehicleProperty::GECKO_VCU_AC_HV_SYS_ERR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_highpower_voltageWatcher() {
  float ec_vcu_highpower_voltage = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_highpower_voltage");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_highpower_voltage = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_vcu_highpower_voltageReq(ec_vcu_highpower_voltage),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_highpower_voltageReq(float ec_vcu_highpower_voltage) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_highpower_voltage);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_water_pump_relay_pin_stsWatcher() {
  float ec_vcu_water_pump_relay_pin_sts = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_water_pump_relay_pin_sts");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_water_pump_relay_pin_sts = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_vcu_water_pump_relay_pin_stsReq(ec_vcu_water_pump_relay_pin_sts),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_water_pump_relay_pin_stsReq(float ec_vcu_water_pump_relay_pin_sts) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_water_pump_relay_pin_sts);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_awake_obc_pin_stsWatcher() {
  float ec_vcu_awake_obc_pin_sts = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_awake_obc_pin_sts");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_awake_obc_pin_sts = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_vcu_awake_obc_pin_stsReq(ec_vcu_awake_obc_pin_sts),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_awake_obc_pin_stsReq(float ec_vcu_awake_obc_pin_sts) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_awake_obc_pin_sts);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_awake_bms_pin_stsWatcher() {
  float ec_vcu_awake_bms_pin_sts = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_awake_bms_pin_sts");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_awake_bms_pin_sts = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_vcu_awake_bms_pin_stsReq(ec_vcu_awake_bms_pin_sts),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_awake_bms_pin_stsReq(float ec_vcu_awake_bms_pin_sts) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_awake_bms_pin_sts);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_awake_mcu_pin_stsWatcher() {
  float ec_vcu_awake_mcu_pin_sts = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_awake_mcu_pin_sts");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_awake_mcu_pin_sts = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_vcu_awake_mcu_pin_stsReq(ec_vcu_awake_mcu_pin_sts),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_awake_mcu_pin_stsReq(float ec_vcu_awake_mcu_pin_sts) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_awake_mcu_pin_sts);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_main_relay_pin_stsWatcher() {
  float ec_vcu_main_relay_pin_sts = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_main_relay_pin_sts");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_main_relay_pin_sts = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_vcu_main_relay_pin_stsReq(ec_vcu_main_relay_pin_sts),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_main_relay_pin_stsReq(float ec_vcu_main_relay_pin_sts) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_main_relay_pin_sts);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_dc_chrg_awake_pin_stsWatcher() {
  float ec_vcu_dc_chrg_awake_pin_sts = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_dc_chrg_awake_pin_sts");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_dc_chrg_awake_pin_sts = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_vcu_dc_chrg_awake_pin_stsReq(ec_vcu_dc_chrg_awake_pin_sts),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_dc_chrg_awake_pin_stsReq(float ec_vcu_dc_chrg_awake_pin_sts) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_dc_chrg_awake_pin_sts);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_ac_chrg_awake_pin_stsWatcher() {
  float ec_vcu_ac_chrg_awake_pin_sts = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_ac_chrg_awake_pin_sts");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_ac_chrg_awake_pin_sts = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_vcu_ac_chrg_awake_pin_stsReq(ec_vcu_ac_chrg_awake_pin_sts),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_ac_chrg_awake_pin_stsReq(float ec_vcu_ac_chrg_awake_pin_sts) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_ac_chrg_awake_pin_sts);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_livecounter_0x215Watcher() {
  float ec_vcu_livecounter_0x215 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_livecounter_0x215");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_livecounter_0x215 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_vcu_livecounter_0x215Req(ec_vcu_livecounter_0x215),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_livecounter_0x215Req(float ec_vcu_livecounter_0x215) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_livecounter_0x215);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_checksum_0x215Watcher() {
  float ec_vcu_checksum_0x215 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_checksum_0x215");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_checksum_0x215 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_vcu_checksum_0x215Req(ec_vcu_checksum_0x215),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_checksum_0x215Req(float ec_vcu_checksum_0x215) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_checksum_0x215);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_pump_stateWatcher() {
  float ec_vcu_pump_state = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_pump_state");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_pump_state = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_vcu_pump_stateReq(ec_vcu_pump_state),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_pump_stateReq(float ec_vcu_pump_state) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_pump_state);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_mid_door_ajar_statusWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_mid_door_ajar_status = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_mid_door_ajar_status");
  ConfigDBC* mp_spd = mPropertyManager->findCProperty("sc_ccm_vehicle_spd_dsp");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_mid_door_ajar_status = mPropertyManager->getCProValue(mp);
      LOG(INFO) << "ec_vcu_mid_door_ajar_status:"<<ec_vcu_mid_door_ajar_status;
      if(ec_vcu_mid_door_ajar_status == 1){
        float speed = mPropertyManager->getCProValue(mp_spd);
        if(speed >= 3.0){
          mHal->onPropertyValue(*Create_ec_vcu_mid_door_ajar_statusReq(2),true);
        }else {
          mHal->onPropertyValue(*Create_ec_vcu_mid_door_ajar_statusReq(1),true);
        }
      }
      else{
        mHal->onPropertyValue(*Create_ec_vcu_mid_door_ajar_statusReq(ec_vcu_mid_door_ajar_status),true);
      }
      
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_mid_door_ajar_statusReq(int32_t ec_vcu_mid_door_ajar_status) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_mid_door_ajar_status);
    req->prop = toInt(VehicleProperty::GECKO_MID_DOOR_AJAR_STATUS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_actual_rema_range_vdWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_actual_rema_range_vd = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_actual_rema_range_vd");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_actual_rema_range_vd = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_vcu_actual_rema_range_vdReq(ec_vcu_actual_rema_range_vd),true);
  }
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_actual_rema_range_vdReq(int32_t ec_vcu_actual_rema_range_vd) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_actual_rema_range_vd);
    req->prop = toInt(VehicleProperty::GECKO_EV_VCU_ACTUAL_REMA_RANGE_VD);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_cltc_rema_range_vdWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_cltc_rema_range_vd = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_cltc_rema_range_vd");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_cltc_rema_range_vd = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_vcu_cltc_rema_range_vdReq(ec_vcu_cltc_rema_range_vd),true);
  }
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_cltc_rema_range_vdReq(int32_t ec_vcu_cltc_rema_range_vd) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_cltc_rema_range_vd);
    req->prop = toInt(VehicleProperty::GECKO_EV_VCU_CLTC_REMA_RANGE_VD);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_pt_cenableWatcher() {
  float ec_vcu_pt_cenable = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_pt_cenable");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_pt_cenable = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_vcu_pt_cenableReq(ec_vcu_pt_cenable),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_pt_cenableReq(float ec_vcu_pt_cenable) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_pt_cenable);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_accmenableWatcher() {
  float ec_vcu_accmenable = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_accmenable");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_accmenable = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_vcu_accmenableReq(ec_vcu_accmenable),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_accmenableReq(float ec_vcu_accmenable) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_accmenable);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::spdwatchDog() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    ConfigDBC* mp1 = mPropertyManager->findCProperty("sc_ccm_vehicle_spd_dsp");
    while(!mShuttingDownFlag.load()){
        std::unique_lock<std::mutex> lock(spdmtx);
        if(spdcv.wait_for(lock, std::chrono::seconds(monitorTime), [this]{ return fed; })) {  // 等待1秒，狗被喂
            fed = false;
            LOG(INFO) << "Dog has been fed.\n";
        } else {
            if(spdCanDisp) {
                mHal->onPropertyValue(*Create_ec_ccm_vehicle_spd_dspReq(-1.0),true);
                mPropertyManager->updateCPropertyValue(mp1,0);
                LOG(INFO) << "Dog bite event!\n";
            }
        }
    }
}


void GarageModeServerSideHandlerImpl::loopSendDynamicOrCTLC(){
    while(true){
        // 每执行一次休眠100毫秒，然后使用hal 从缓存中读取 CLTC_RANGE_REMAINING 及 DYNAMIC_RANGE_REMAINING 读取值，
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
        StatusCode status = StatusCode::OK;
        VehiclePropValue requestProp = VehiclePropValue {};
        requestProp.prop = toInt(VehicleProperty::GECKO_REMA_RANGE_DISPLAY_MODE);
        requestProp.areaId = 0;
        auto value = mHal->get(requestProp, &status);

        if(value != nullptr){
            if(0 < value->value.int32Values.size()){
              LOG(INFO) << "dxy value->value.int32Values[0]" << value->value.int32Values[0];
            }
        }else{
          LOG(INFO) << "dxy value->value.int32Values[0] is null" ;
        }
        
    }
}


int GarageModeServerSideHandlerImpl::SpeedCalculate(float& speedvalue,float newvalue) {
  spdQueue.push_back(newvalue);
  if(spdQueue.size()<spdSaveCounter){
    return -1;
  }
  do{
    spdQueue.pop_front();
  }while(spdQueue.size()>spdSaveCounter);
  // 如果队列的大小达到18，计算平均值
  if (spdQueue.size() == spdSaveCounter) {
    std::deque<float> tempQueue = spdQueue; // 创建一个副本，以便排序
    std::sort(tempQueue.begin(), tempQueue.end()); // 排序队列
    tempQueue.pop_back(); // 去除最大值
    tempQueue.pop_front(); // 去除最小值

    // 计算平均值
    float sum = 0;
    for (float value : tempQueue) {
      sum += value;
    }
    speedvalue = sum / tempQueue.size();
  }
  if(speedvalue > 5.0)
    speedvalue = speedvalue/0.98 + 1;
  return 0;
}

#if 0 // 短期记忆的数据计算在mcu侧处理
void GarageModeServerSideHandlerImpl::HandlePowerOnspd(float speed){
  if(powerOnSts == 0){
    return;
  }

  if(speed < 0){
      if(updateAverageSpd != -1024){
        mHal->onPropertyValue(*Create_power_on_average_speedReq(-1024),true);
      }
      updateAverageSpd = -1024;

      if(updatePowerOnMileage != -1024){
        mHal->onPropertyValue(*Create_power_on_milegeReq(-1024),true);
      }
      updatePowerOnMileage = -1024;

      ALOGI("HandlePowerOnspd speed < 0 speed=%f", speed);
      return;
  }

  if(begintravelMileage <= 0){
      ConfigDBC* travel = mPropertyManager->findCProperty("mcu_short_mileage");
      begintravelMileage = getActualFloatValue(mPropertyManager->getCProValue(travel), 0.1, 0);
      //ALOGI("HandlePowerOnspd begintravelMileage=%f", begintravelMileage);
  }

        //计算总里程逻辑
      int64_t  currentMilliTime = elapsedRealtime(); // 获取此次数据变更的毫秒时间
      // float current_time_total_kmeter =   mcu_vehicle_spd * 0.01;//乘以0.01 为加载因子
      if(speed >= 0 && (currentMilliTime - lastMilliTime) > 0 && (currentMilliTime - lastMilliTime) < 1000){
          // mcu_vehicle_spd * 0.01 * 1000 / 3600 /1000 计算出毫秒每米
          float milliSecondsPerMeter = (speed  * 1000 / 3600)/1000;
          // 下面的目的是为了计算出时间段内跑的距离 单位为公里
          float mileageDuringTimePeriod  = (milliSecondsPerMeter * (currentMilliTime - lastMilliTime))/1000;
          
          // 更新点火周期内里程
          powerOnMileage += mileageDuringTimePeriod;
          //ALOGI("powerOnMileage%f", powerOnMileage);

      }
      lastMilliTime = currentMilliTime;



  int64_t currentTime = elapsedRealtime();
  int64_t passTime = currentTime - powerOnTimestamp;
  float passHour = static_cast<float>(passTime)/(1000 *3600);
  int32_t averageSpd = static_cast<int>(powerOnMileage/passHour);
  

  // int32_t mileageMeter = powerOnMileage *1000;
  // int64_t passTimeSec = passTime /1000;
  // int32_t averageSpdMeter = mileageMeter/passTimeSec;
  // ALOGI("HandlePowerOnspd mileageMeter = %d passTimeSec =%ld averageSpdMeter=%d", 
  // mileageMeter,passTimeSec, averageSpdMeter);

  if((averageSpd < 256) && (averageSpd != updateAverageSpd)){
    mHal->onPropertyValue(*Create_power_on_average_speedReq(averageSpd),true);
    updateAverageSpd = averageSpd;
  }
  
  // ConfigDBC* odometer = mPropertyManager->findCProperty("ec_total_odometer");
  // int32_t TotalMileage = getActualFloatValue(mPropertyManager->getCProValue(odometer),1,0);
  // int32_t Mileage = TotalMileage - beginTotalMileage;

  ConfigDBC* travel = mPropertyManager->findCProperty("mcu_short_mileage");
  float travelMileage = getActualFloatValue(mPropertyManager->getCProValue(travel), 0.1, 0);
  float Mileage1 = travelMileage - begintravelMileage;

  // LOG(INFO)<<"travelMileage:"<<travelMileage<<" begintravelMileage:"<<begintravelMileage;
  // LOG(INFO)<<"powerOnMileage:"<<powerOnMileage<<" Mileage:"<<Mileage<<" travelMileage:"<<Mileage1<<" speed:"<<speed;

  if(((Mileage1 - updatePowerOnMileage) >= 0.05 || (Mileage1 - updatePowerOnMileage) < 0) && travelMileage >= 0){
    ALOGI("HandlePowerOnspd  Mileage1=%f", Mileage1);
    mHal->onPropertyValue(*Create_power_on_milegeReq(Mileage1),true);
    updatePowerOnMileage = Mileage1;
  }

  if(currentTime%9 == 0){
    ALOGI("HandlePowerOnspd currentTime = %jd powerOnTimestamp =%jd passTime=%jd passHour=%f averageSpd=%d Mileage1=%f, updatePowerOnMileage=%f,travelMileage=%f, begintravelMileage=%f, speed=%f", 
    currentTime,powerOnTimestamp, passTime, passHour, averageSpd, Mileage1,updatePowerOnMileage, travelMileage, begintravelMileage,speed);
  }
  
  //LOG(INFO)<<"powerOnMileage:"<<powerOnMileage<<" updatePowerOnMileage:"<<updatePowerOnMileage;
  

  std::chrono::milliseconds ms_start = std::chrono::duration_cast< std::chrono::milliseconds >(
        std::chrono::system_clock::now().time_since_epoch()
      );

  int64_t nowTimes = ms_start.count();

  power_on_average_speed_time = nowTimes;

}
#endif
// void GarageModeServerSideHandlerImpl::ec_vcu_vehicle_spdWatcher() {
//   std::this_thread::sleep_for(std::chrono::milliseconds(800));
//   float ec_vcu_vehicle_spd = 0.0;
//   float ec_vcu_vehicle_disp_spd = 0.0;
//   // int spd_disp_value = 0;
//   for(unsigned long i = 0;i<spdSaveCounter;i++){
//     spdQueue.push_back(0.0);
//   }
//   ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_vehicle_spd");
//   // ConfigDBC* mp1 = mPropertyManager->findCProperty("sc_ccm_vehicle_spd_dsp");
//   // ec_total_odometer
//   ConfigDBC* totalOdometerMp = mPropertyManager->findCProperty("sc_ccm_vehicle_spd_dsp");

//   int64_t  lastMilliTime = elapsedRealtime();
//   LOG(INFO) << "dxy----onSetProperty currentMilliTime = " << lastMilliTime;
//   float cumulativeDistance = 0.0;

//   while(!mShuttingDownFlag.load()){
//       mPropertyManager->getUpdateCState(mp);
//       spdCanDisp = true;
//       int32_t mcu_vehicle_spd =  mPropertyManager->getCProValue(mp);
//       if(-1024 == mcu_vehicle_spd){
//           mHal->onPropertyValue(*Create_ec_vcu_vehicle_spdReq(-1024.0),true);
//           mHal->onPropertyValue(*Create_ec_ccm_vehicle_spd_dspReq(-1024.0),true);
//           continue;
//       }
//       ec_vcu_vehicle_spd = getActualFloatValue(mcu_vehicle_spd,0.01,0);
//       ALOGI("dxy----ec_vcu_vehicle_spdWatcher ec_vcu_vehicle_spd = %f", ec_vcu_vehicle_spd);
// //      totalMileageCur = ec_vcu_vehicle_spd * 0.05625 * dt + TotalMileageEEPROM;
//       mHal->onPropertyValue(*Create_ec_vcu_vehicle_spdReq(ec_vcu_vehicle_spd),true);                      // 实际车速
//       /*
//         if(speedvalue > 5.0)
//           speedvalue = speedvalue/0.98 + 1;
//       */
//      ec_vcu_vehicle_disp_spd = ec_vcu_vehicle_spd;
//       if(ec_vcu_vehicle_disp_spd > 5){
//         ec_vcu_vehicle_disp_spd = ec_vcu_vehicle_disp_spd/0.98 + 1;
//       }

//       if(ec_vcu_vehicle_disp_spd > 255.0){
//           ec_vcu_vehicle_disp_spd = 255.0;
//         }
//       mHal->onPropertyValue(*Create_ec_ccm_vehicle_spd_dspReq(ec_vcu_vehicle_disp_spd),true);  


//       //计算表显车速逻辑
//       // if(SpeedCalculate(ec_vcu_vehicle_disp_spd,ec_vcu_vehicle_spd)==0){
//       //   ALOGI("dxy----ec_vcu_vehicle_spdWatcher ec_vcu_vehicle_disp_spd = %f", ec_vcu_vehicle_disp_spd);
//       //   if(ec_vcu_vehicle_disp_spd > 255.0){
//       //     ec_vcu_vehicle_disp_spd = 255.0;
//       //   }
//       //   mHal->onPropertyValue(*Create_ec_ccm_vehicle_spd_dspReq(ec_vcu_vehicle_disp_spd),true);
//       // }

//       //计算总里程逻辑
//       int64_t  currentMilliTime = elapsedRealtime(); // 获取此次数据变更的毫秒时间
//       // float current_time_total_kmeter =   mcu_vehicle_spd * 0.01;//乘以0.01 为加载因子
//       if(mcu_vehicle_spd >= 0 && (currentMilliTime - lastMilliTime) > 0 && (currentMilliTime - lastMilliTime) < 1000){
//           // mcu_vehicle_spd * 0.01 * 1000 / 3600 /1000 计算出毫秒每米
//           float milliSecondsPerMeter = (mcu_vehicle_spd * 0.01 * 1000 / 3600)/1000;
//           // 下面的目的是为了计算出时间段内跑的距离 单位为公里
//           float mileageDuringTimePeriod  = (milliSecondsPerMeter * (currentMilliTime - lastMilliTime))/1000;
//           ALOGI("dxy----mileageDuringTimePeriod = %f", mileageDuringTimePeriod);
//           cumulativeDistance += mileageDuringTimePeriod;
//           // 更新点火周期内里程
//           powerOnMileage += mileageDuringTimePeriod;
//           HandlePowerOnspd();
//           mHal->onPropertyValue(*Create_power_on_milegeReq(powerOnMileage),true);
//               std::chrono::milliseconds ms_start = std::chrono::duration_cast< std::chrono::milliseconds >(
//                 std::chrono::system_clock::now().time_since_epoch()
//               );
//           power_on_milege_time = ms_start.count();

//           if(0.1 <= cumulativeDistance){ 
//             // 读取系统属性 "gecko.total.mileage" 的值
//             std::string totalMileageStr = android::base::GetProperty("gecko.total.mileage", "0.0");
//             // 将 totalMileageStr 转换为浮点数
//             float totalMileage = std::stof(totalMileageStr);
//             // 更新 totalMileage
//             totalMileage += cumulativeDistance;
            
//             // 将临时值设置为0
//             cumulativeDistance = 0.0;
//             // 将 totalMileage 转换为字符串
//             std::string newTotalMileageStr = std::to_string(totalMileage);
//             // 存储新值到系统属性 "gecko.total.mileage"       
//             bool result = android::base::SetProperty("gecko.total.mileage", newTotalMileageStr);
//             ALOGI("dxy---- GECKO_POWER_ON_AVERAGE_ENERGY_CONSUMPTION result =%d", result);
//             if(result){
//               mHal->onPropertyValue(*Create_ec_total_odometerReq(totalMileage),true);
//               mPropertyManager->updateCPropertyValue(totalOdometerMp,static_cast<int>(totalMileage));
              
//             }
			
// 			//ALOGI("dxy---- GECKO_POWER_ON_AVERAGE_ENERGY_CONSUMPTION energyConsumptionFlag =%d", energyConsumptionFlag);
// 			ALOGI("dxy---- GECKO_POWER_ON_AVERAGE_ENERGY_CONSUMPTION energyConsumptionFlag =%d,powerOnMileage=%f,totalEnergyConsumption=%f", energyConsumptionFlag,powerOnMileage,totalEnergyConsumption);
// 			// if(energyConsumptionFlag) {
// 			// 	 float averageEnergy = 0.0;
// 			// 	 if(powerOnMileage != 0) {
//       //               averageEnergy = totalEnergyConsumption/powerOnMileage;
					
// 			// 	    ALOGI("dxy---- GECKO_POWER_ON_AVERAGE_ENERGY_CONSUMPTION averageEnergy =%f", averageEnergy);
// 			// 	    mHal->onPropertyValue(*Create_power_on_average_energy_consumptionReq(averageEnergy),true);
// 			// 	 }
// 			// }
//             ALOGI("dxy---- current_time_total_kmeter = %s ,powerOnMileage =%f", newTotalMileageStr.c_str(), powerOnMileage);
//           }
//       }
//       lastMilliTime = currentMilliTime;
//   }
// }

void GarageModeServerSideHandlerImpl::ec_vcu_vehicle_spdWatcher() {
  float ec_vcu_vehicle_spd = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_vehicle_spd");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_vehicle_spd = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_vcu_vehicle_spdReq(ec_vcu_vehicle_spd),true);
  }
}

void GarageModeServerSideHandlerImpl::ec_vcu_vehicle_spd_dspWatcher() {
  uint32_t sc_ccm_vehicle_spd_dsp = 0;
  float vcu_spd_value = 0.0f;
  ConfigDBC* mp = mPropertyManager->findCProperty("sc_ccm_vehicle_spd_dsp");
  ConfigDBC* mp_door = mPropertyManager->findCProperty("ec_vcu_mid_door_ajar_status");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      sc_ccm_vehicle_spd_dsp = mPropertyManager->getCProValue(mp);
      vcu_spd_value = (sc_ccm_vehicle_spd_dsp * 0.05625);
      sc_ccm_vehicle_spd_dsp = static_cast<uint32_t>(vcu_spd_value);
      if(0xffffffff==sc_ccm_vehicle_spd_dsp || sc_ccm_vehicle_spd_dsp > 255){
        sc_ccm_vehicle_spd_dsp = -1;
        mHal->onPropertyValue(*Create_ec_ccm_vehicle_spd_dspReq(-1024),true);
      }else{
        mHal->onPropertyValue(*Create_ec_ccm_vehicle_spd_dspReq((float)(sc_ccm_vehicle_spd_dsp)),true);
      }

      //HandlePowerOnspd(sc_ccm_vehicle_spd_dsp); //短期记忆删除使用

      ConfigDBC* mp_park = mPropertyManager->findCProperty("ec_vcu_park_state");
      int32_t ec_vcu_park_state = mPropertyManager->getCProValue(mp_park);
      if(ec_vcu_park_state == 1 && sc_ccm_vehicle_spd_dsp >= 5 && sc_ccm_vehicle_spd_dsp <= 256){
        //行车时驻车制动有效文本提示
          mHal->onPropertyValue(*Create_bc_motion_park_stateReq(1),true);
      } 
      if(sc_ccm_vehicle_spd_dsp < 5) {
        //行车时驻车制动有效文本提示
          mHal->onPropertyValue(*Create_bc_motion_park_stateReq(0),true);
      }
      int32_t door_status = mPropertyManager->getCProValue(mp_door);
      if(door_status == 1)
      {
        if(sc_ccm_vehicle_spd_dsp >= 3.0){
          mHal->onPropertyValue(*Create_ec_vcu_mid_door_ajar_statusReq(2),true);
        }else {
          mHal->onPropertyValue(*Create_ec_vcu_mid_door_ajar_statusReq(1),true);
        }
      }
  }
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_vehicle_spdReq(float ec_vcu_vehicle_spd) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_vehicle_spd);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_actual_rema_rangeWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  float ec_vcu_actual_rema_range = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_actual_rema_range");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_actual_rema_range = getActualFloatValue(mPropertyManager->getCProValue(mp),1,0);
      mHal->onPropertyValue(*Create_ec_vcu_actual_rema_rangeReq(ec_vcu_actual_rema_range),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_actual_rema_rangeReq(float ec_vcu_actual_rema_range) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_actual_rema_range);
    req->prop = toInt(VehicleProperty::RANGE_REMAINING);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_cltc_rema_rangeWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  float ec_vcu_cltc_rema_range = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_cltc_rema_range");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_cltc_rema_range = getActualFloatValue(mPropertyManager->getCProValue(mp),1,0);
      mHal->onPropertyValue(*Create_ec_vcu_cltc_rema_rangeReq(ec_vcu_cltc_rema_range),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_cltc_rema_rangeReq(float ec_vcu_cltc_rema_range) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_cltc_rema_range);
    req->prop = toInt(VehicleProperty::GECKO_CLTC_RANGE_REMAINING);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bcm_mcu_display_rangeWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bcm_mcu_display_range {0};
  ConfigDBC* mp = mPropertyManager->findCProperty("gecko_bcm_mcu_display_range");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bcm_mcu_display_range = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_bcm_mcu_display_rangeReq(bcm_mcu_display_range),true);
  }
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bcm_mcu_display_rangeReq(int32_t bcm_mcu_display_range) {
    auto req = mValueObjectPool->obtainInt32(bcm_mcu_display_range);
    req->prop = toInt(VehicleProperty::GECKO_MCU_DISPLAY_RANGE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_livecounter_0x250Watcher() {
  float ec_vcu_livecounter_0x250 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_livecounter_0x250");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_livecounter_0x250 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_vcu_livecounter_0x250Req(ec_vcu_livecounter_0x250),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_livecounter_0x250Req(float ec_vcu_livecounter_0x250) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_livecounter_0x250);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_checksum_0x250Watcher() {
  float ec_vcu_checksum_0x250 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_checksum_0x250");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_checksum_0x250 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_vcu_checksum_0x250Req(ec_vcu_checksum_0x250),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_checksum_0x250Req(float ec_vcu_checksum_0x250) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_checksum_0x250);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_yearWatcher() {
  float ec_vcu_year = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_year");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_year = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_vcu_yearReq(ec_vcu_year),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_yearReq(float ec_vcu_year) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_year);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_monthWatcher() {
  float ec_vcu_month = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_month");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_month = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_vcu_monthReq(ec_vcu_month),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_monthReq(float ec_vcu_month) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_month);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_dayWatcher() {
  float ec_vcu_day = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_day");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_day = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_vcu_dayReq(ec_vcu_day),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_dayReq(float ec_vcu_day) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_day);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ccm_a_ckeyWatcher() {
  float ec_ccm_a_ckey = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccm_a_ckey");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ccm_a_ckey = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ccm_a_ckeyReq(ec_ccm_a_ckey),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccm_a_ckeyReq(float ec_ccm_a_ckey) {
    auto req = mValueObjectPool->obtainFloat(ec_ccm_a_ckey);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ccm_ac_havc_stateWatcher() {
  float ec_ccm_ac_havc_state = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccm_ac_havc_state");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ccm_ac_havc_state = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ccm_ac_havc_stateReq(ec_ccm_ac_havc_state),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccm_ac_havc_stateReq(float ec_ccm_ac_havc_state) {
    auto req = mValueObjectPool->obtainFloat(ec_ccm_ac_havc_state);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ccm_vehicle_spd_dspWatcher() {
  float ec_ccm_vehicle_spd_dsp = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccm_vehicle_spd_dsp");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ccm_vehicle_spd_dsp = getActualFloatValue(mPropertyManager->getCProValue(mp),1,0);
      //mHal->onPropertyValue(*Create_ec_ccm_vehicle_spd_dspReq(ec_ccm_vehicle_spd_dsp),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccm_vehicle_spd_dspReq(float ec_ccm_vehicle_spd_dsp) {
    auto req = mValueObjectPool->obtainFloat(ec_ccm_vehicle_spd_dsp);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED_DISPLAY);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ccm_livecounter_0x310Watcher() {
  float ec_ccm_livecounter_0x310 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccm_livecounter_0x310");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ccm_livecounter_0x310 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ccm_livecounter_0x310Req(ec_ccm_livecounter_0x310),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccm_livecounter_0x310Req(float ec_ccm_livecounter_0x310) {
    auto req = mValueObjectPool->obtainFloat(ec_ccm_livecounter_0x310);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ccm_checksum_0x310Watcher() {
  float ec_ccm_checksum_0x310 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccm_checksum_0x310");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ccm_checksum_0x310 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ccm_checksum_0x310Req(ec_ccm_checksum_0x310),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccm_checksum_0x310Req(float ec_ccm_checksum_0x310) {
    auto req = mValueObjectPool->obtainFloat(ec_ccm_checksum_0x310);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_b2_v_gbsn_frame_noWatcher() {
  float ec_b2_v_gbsn_frame_no = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_b2_v_gbsn_frame_no");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_b2_v_gbsn_frame_no = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_b2_v_gbsn_frame_noReq(ec_b2_v_gbsn_frame_no),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_b2_v_gbsn_frame_noReq(float ec_b2_v_gbsn_frame_no) {
    auto req = mValueObjectPool->obtainFloat(ec_b2_v_gbsn_frame_no);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_b2_v_gbsn_sys_code_lengthWatcher() {
  float ec_b2_v_gbsn_sys_code_length = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_b2_v_gbsn_sys_code_length");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_b2_v_gbsn_sys_code_length = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_b2_v_gbsn_sys_code_lengthReq(ec_b2_v_gbsn_sys_code_length),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_b2_v_gbsn_sys_code_lengthReq(float ec_b2_v_gbsn_sys_code_length) {
    auto req = mValueObjectPool->obtainFloat(ec_b2_v_gbsn_sys_code_length);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_b2_v_gbsn_sys_code_1_7_13_19Watcher() {
  float ec_b2_v_gbsn_sys_code_1_7_13_19 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_b2_v_gbsn_sys_code_1_7_13_19");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_b2_v_gbsn_sys_code_1_7_13_19 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_b2_v_gbsn_sys_code_1_7_13_19Req(ec_b2_v_gbsn_sys_code_1_7_13_19),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_b2_v_gbsn_sys_code_1_7_13_19Req(float ec_b2_v_gbsn_sys_code_1_7_13_19) {
    auto req = mValueObjectPool->obtainFloat(ec_b2_v_gbsn_sys_code_1_7_13_19);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_b2_v_gbsn_sys_code_2_8_14_20Watcher() {
  float ec_b2_v_gbsn_sys_code_2_8_14_20 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_b2_v_gbsn_sys_code_2_8_14_20");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_b2_v_gbsn_sys_code_2_8_14_20 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_b2_v_gbsn_sys_code_2_8_14_20Req(ec_b2_v_gbsn_sys_code_2_8_14_20),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_b2_v_gbsn_sys_code_2_8_14_20Req(float ec_b2_v_gbsn_sys_code_2_8_14_20) {
    auto req = mValueObjectPool->obtainFloat(ec_b2_v_gbsn_sys_code_2_8_14_20);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_b2_v_gbsn_sys_code_3_9_15_21Watcher() {
  float ec_b2_v_gbsn_sys_code_3_9_15_21 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_b2_v_gbsn_sys_code_3_9_15_21");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_b2_v_gbsn_sys_code_3_9_15_21 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_b2_v_gbsn_sys_code_3_9_15_21Req(ec_b2_v_gbsn_sys_code_3_9_15_21),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_b2_v_gbsn_sys_code_3_9_15_21Req(float ec_b2_v_gbsn_sys_code_3_9_15_21) {
    auto req = mValueObjectPool->obtainFloat(ec_b2_v_gbsn_sys_code_3_9_15_21);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_b2_v_gbsn_sys_code_4_10_16_22Watcher() {
  float ec_b2_v_gbsn_sys_code_4_10_16_22 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_b2_v_gbsn_sys_code_4_10_16_22");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_b2_v_gbsn_sys_code_4_10_16_22 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_b2_v_gbsn_sys_code_4_10_16_22Req(ec_b2_v_gbsn_sys_code_4_10_16_22),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_b2_v_gbsn_sys_code_4_10_16_22Req(float ec_b2_v_gbsn_sys_code_4_10_16_22) {
    auto req = mValueObjectPool->obtainFloat(ec_b2_v_gbsn_sys_code_4_10_16_22);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_b2_v_gbsn_sys_code_5_11_17_23Watcher() {
  float ec_b2_v_gbsn_sys_code_5_11_17_23 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_b2_v_gbsn_sys_code_5_11_17_23");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_b2_v_gbsn_sys_code_5_11_17_23 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_b2_v_gbsn_sys_code_5_11_17_23Req(ec_b2_v_gbsn_sys_code_5_11_17_23),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_b2_v_gbsn_sys_code_5_11_17_23Req(float ec_b2_v_gbsn_sys_code_5_11_17_23) {
    auto req = mValueObjectPool->obtainFloat(ec_b2_v_gbsn_sys_code_5_11_17_23);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_b2_v_gbsn_sys_code_6_12_18_24Watcher() {
  float ec_b2_v_gbsn_sys_code_6_12_18_24 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_b2_v_gbsn_sys_code_6_12_18_24");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_b2_v_gbsn_sys_code_6_12_18_24 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_b2_v_gbsn_sys_code_6_12_18_24Req(ec_b2_v_gbsn_sys_code_6_12_18_24),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_b2_v_gbsn_sys_code_6_12_18_24Req(float ec_b2_v_gbsn_sys_code_6_12_18_24) {
    auto req = mValueObjectPool->obtainFloat(ec_b2_v_gbsn_sys_code_6_12_18_24);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_work_reqWatcher() {
  float ec_vcu_work_req = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_work_req");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_work_req = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_vcu_work_reqReq(ec_vcu_work_req),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_work_reqReq(float ec_vcu_work_req) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_work_req);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_livecounter_0x661Watcher() {
  float ec_vcu_livecounter_0x661 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_livecounter_0x661");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_livecounter_0x661 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_vcu_livecounter_0x661Req(ec_vcu_livecounter_0x661),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_livecounter_0x661Req(float ec_vcu_livecounter_0x661) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_livecounter_0x661);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_checksum_0x661Watcher() {
  float ec_vcu_checksum_0x661 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_checksum_0x661");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_checksum_0x661 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_vcu_checksum_0x661Req(ec_vcu_checksum_0x661),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_checksum_0x661Req(float ec_vcu_checksum_0x661) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_checksum_0x661);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_str_work_reqWatcher() {
  float ec_str_work_req = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_str_work_req");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_str_work_req = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_str_work_reqReq(ec_str_work_req),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_str_work_reqReq(float ec_str_work_req) {
    auto req = mValueObjectPool->obtainFloat(ec_str_work_req);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ccm_nm_bitWatcher() {
  float ec_ccm_nm_bit = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccm_nm_bit");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ccm_nm_bit = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ccm_nm_bitReq(ec_ccm_nm_bit),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccm_nm_bitReq(float ec_ccm_nm_bit) {
    auto req = mValueObjectPool->obtainFloat(ec_ccm_nm_bit);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ccm_livecounter_0x66_cWatcher() {
  float ec_ccm_livecounter_0x66_c = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccm_livecounter_0x66_c");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ccm_livecounter_0x66_c = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ccm_livecounter_0x66_cReq(ec_ccm_livecounter_0x66_c),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccm_livecounter_0x66_cReq(float ec_ccm_livecounter_0x66_c) {
    auto req = mValueObjectPool->obtainFloat(ec_ccm_livecounter_0x66_c);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ccm_checksum_0x66_cWatcher() {
  float ec_ccm_checksum_0x66_c = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccm_checksum_0x66_c");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ccm_checksum_0x66_c = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ccm_checksum_0x66_cReq(ec_ccm_checksum_0x66_c),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccm_checksum_0x66_cReq(float ec_ccm_checksum_0x66_c) {
    auto req = mValueObjectPool->obtainFloat(ec_ccm_checksum_0x66_c);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_tbox_time_statusWatcher() {
  float ec_tbox_time_status = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_tbox_time_status");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_tbox_time_status = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_tbox_time_statusReq(ec_tbox_time_status),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_tbox_time_statusReq(float ec_tbox_time_status) {
    auto req = mValueObjectPool->obtainFloat(ec_tbox_time_status);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_tbox_yearWatcher() {
  float ec_tbox_year = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_tbox_year");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_tbox_year = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_tbox_yearReq(ec_tbox_year),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_tbox_yearReq(float ec_tbox_year) {
    auto req = mValueObjectPool->obtainFloat(ec_tbox_year);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_tbox_monthWatcher() {
  float ec_tbox_month = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_tbox_month");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_tbox_month = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_tbox_monthReq(ec_tbox_month),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_tbox_monthReq(float ec_tbox_month) {
    auto req = mValueObjectPool->obtainFloat(ec_tbox_month);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_tbox_dayWatcher() {
  float ec_tbox_day = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_tbox_day");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_tbox_day = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_tbox_dayReq(ec_tbox_day),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_tbox_dayReq(float ec_tbox_day) {
    auto req = mValueObjectPool->obtainFloat(ec_tbox_day);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_tbox_hourWatcher() {
  float ec_tbox_hour = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_tbox_hour");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_tbox_hour = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_tbox_hourReq(ec_tbox_hour),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_tbox_hourReq(float ec_tbox_hour) {
    auto req = mValueObjectPool->obtainFloat(ec_tbox_hour);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_tbox_minuteWatcher() {
  float ec_tbox_minute = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_tbox_minute");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_tbox_minute = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_tbox_minuteReq(ec_tbox_minute),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_tbox_minuteReq(float ec_tbox_minute) {
    auto req = mValueObjectPool->obtainFloat(ec_tbox_minute);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_tbox_secondWatcher() {
  float ec_tbox_second = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_tbox_second");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_tbox_second = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_tbox_secondReq(ec_tbox_second),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_tbox_secondReq(float ec_tbox_second) {
    auto req = mValueObjectPool->obtainFloat(ec_tbox_second);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ccm_soc_sofeware_numWatcher() {
  float ec_ccm_soc_sofeware_num = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccm_soc_sofeware_num");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ccm_soc_sofeware_num = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ccm_soc_sofeware_numReq(ec_ccm_soc_sofeware_num),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccm_soc_sofeware_numReq(float ec_ccm_soc_sofeware_num) {
    auto req = mValueObjectPool->obtainFloat(ec_ccm_soc_sofeware_num);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ccm_soc_hardware_numWatcher() {
  float ec_ccm_soc_hardware_num = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccm_soc_hardware_num");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ccm_soc_hardware_num = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ccm_soc_hardware_numReq(ec_ccm_soc_hardware_num),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccm_soc_hardware_numReq(float ec_ccm_soc_hardware_num) {
    auto req = mValueObjectPool->obtainFloat(ec_ccm_soc_hardware_num);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ccm_mcu_sofeware_numWatcher() {
  float ec_ccm_mcu_sofeware_num = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccm_mcu_sofeware_num");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ccm_mcu_sofeware_num = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ccm_mcu_sofeware_numReq(ec_ccm_mcu_sofeware_num),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccm_mcu_sofeware_numReq(float ec_ccm_mcu_sofeware_num) {
    auto req = mValueObjectPool->obtainFloat(ec_ccm_mcu_sofeware_num);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ccm_mcu_hardware_numWatcher() {
  float ec_ccm_mcu_hardware_num = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccm_mcu_hardware_num");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ccm_mcu_hardware_num = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ccm_mcu_hardware_numReq(ec_ccm_mcu_hardware_num),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccm_mcu_hardware_numReq(float ec_ccm_mcu_hardware_num) {
    auto req = mValueObjectPool->obtainFloat(ec_ccm_mcu_hardware_num);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_bms_batterysoc_virtualWatcher() {
  float ec_bms_batterysoc_virtual = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_batterysoc_virtual");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_batterysoc_virtual = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_bms_batterysoc_virtualReq(ec_bms_batterysoc_virtual),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_batterysoc_virtualReq(float ec_bms_batterysoc_virtual) {
    auto req = mValueObjectPool->obtainFloat(ec_bms_batterysoc_virtual);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_bms_livecounter_0x513Watcher() {
  float ec_bms_livecounter_0x513 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_livecounter_0x513");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_livecounter_0x513 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_bms_livecounter_0x513Req(ec_bms_livecounter_0x513),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_livecounter_0x513Req(float ec_bms_livecounter_0x513) {
    auto req = mValueObjectPool->obtainFloat(ec_bms_livecounter_0x513);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_bms_checksum_0x513Watcher() {
  float ec_bms_checksum_0x513 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_checksum_0x513");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_checksum_0x513 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_bms_checksum_0x513Req(ec_bms_checksum_0x513),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_checksum_0x513Req(float ec_bms_checksum_0x513) {
    auto req = mValueObjectPool->obtainFloat(ec_bms_checksum_0x513);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_tbox_cpu_temperature_lowWatcher() {
  float ec_tbox_cpu_temperature_low = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_tbox_cpu_temperature_low");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_tbox_cpu_temperature_low = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_tbox_cpu_temperature_lowReq(ec_tbox_cpu_temperature_low),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_tbox_cpu_temperature_lowReq(float ec_tbox_cpu_temperature_low) {
    auto req = mValueObjectPool->obtainFloat(ec_tbox_cpu_temperature_low);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_tbox_cpu_temperature_highWatcher() {
  float ec_tbox_cpu_temperature_high = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_tbox_cpu_temperature_high");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_tbox_cpu_temperature_high = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_tbox_cpu_temperature_highReq(ec_tbox_cpu_temperature_high),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_tbox_cpu_temperature_highReq(float ec_tbox_cpu_temperature_high) {
    auto req = mValueObjectPool->obtainFloat(ec_tbox_cpu_temperature_high);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_pcb_temperature_lowWatcher() {
  float ec_pcb_temperature_low = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_pcb_temperature_low");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_pcb_temperature_low = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_pcb_temperature_lowReq(ec_pcb_temperature_low),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_pcb_temperature_lowReq(float ec_pcb_temperature_low) {
    auto req = mValueObjectPool->obtainFloat(ec_pcb_temperature_low);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_pcb_temperature_highWatcher() {
  float ec_pcb_temperature_high = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_pcb_temperature_high");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_pcb_temperature_high = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_pcb_temperature_highReq(ec_pcb_temperature_high),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_pcb_temperature_highReq(float ec_pcb_temperature_high) {
    auto req = mValueObjectPool->obtainFloat(ec_pcb_temperature_high);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_main_power_supply_voltahe_lowWatcher() {
  float ec_main_power_supply_voltahe_low = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_main_power_supply_voltahe_low");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_main_power_supply_voltahe_low = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_main_power_supply_voltahe_lowReq(ec_main_power_supply_voltahe_low),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_main_power_supply_voltahe_lowReq(float ec_main_power_supply_voltahe_low) {
    auto req = mValueObjectPool->obtainFloat(ec_main_power_supply_voltahe_low);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_main_power_supply_voltahe_highWatcher() {
  float ec_main_power_supply_voltahe_high = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_main_power_supply_voltahe_high");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_main_power_supply_voltahe_high = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_main_power_supply_voltahe_highReq(ec_main_power_supply_voltahe_high),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_main_power_supply_voltahe_highReq(float ec_main_power_supply_voltahe_high) {
    auto req = mValueObjectPool->obtainFloat(ec_main_power_supply_voltahe_high);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_sim_card_not_presentWatcher() {
  float ec_sim_card_not_present = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_sim_card_not_present");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_sim_card_not_present = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_sim_card_not_presentReq(ec_sim_card_not_present),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_sim_card_not_presentReq(float ec_sim_card_not_present) {
    auto req = mValueObjectPool->obtainFloat(ec_sim_card_not_present);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_wifi_device_lostWatcher() {
  float ec_wifi_device_lost = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_wifi_device_lost");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_wifi_device_lost = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_wifi_device_lostReq(ec_wifi_device_lost),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_wifi_device_lostReq(float ec_wifi_device_lost) {
    auto req = mValueObjectPool->obtainFloat(ec_wifi_device_lost);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ccm_detects_eas_node_lossWatcher() {
  float ec_ccm_detects_eas_node_loss = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccm_detects_eas_node_loss");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ccm_detects_eas_node_loss = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ccm_detects_eas_node_lossReq(ec_ccm_detects_eas_node_loss),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccm_detects_eas_node_lossReq(float ec_ccm_detects_eas_node_loss) {
    auto req = mValueObjectPool->obtainFloat(ec_ccm_detects_eas_node_loss);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ccm_detects_bms_node_lossWatcher() {
  float ec_ccm_detects_bms_node_loss = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccm_detects_bms_node_loss");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ccm_detects_bms_node_loss = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ccm_detects_bms_node_lossReq(ec_ccm_detects_bms_node_loss),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccm_detects_bms_node_lossReq(float ec_ccm_detects_bms_node_loss) {
    auto req = mValueObjectPool->obtainFloat(ec_ccm_detects_bms_node_loss);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ccm_detects_ipu_node_lossWatcher() {
  float ec_ccm_detects_ipu_node_loss = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccm_detects_ipu_node_loss");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ccm_detects_ipu_node_loss = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ccm_detects_ipu_node_lossReq(ec_ccm_detects_ipu_node_loss),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccm_detects_ipu_node_lossReq(float ec_ccm_detects_ipu_node_loss) {
    auto req = mValueObjectPool->obtainFloat(ec_ccm_detects_ipu_node_loss);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ccm_detects_vcu_node_lossWatcher() {
  float ec_ccm_detects_vcu_node_loss = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccm_detects_vcu_node_loss");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ccm_detects_vcu_node_loss = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ccm_detects_vcu_node_lossReq(ec_ccm_detects_vcu_node_loss),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccm_detects_vcu_node_lossReq(float ec_ccm_detects_vcu_node_loss) {
    auto req = mValueObjectPool->obtainFloat(ec_ccm_detects_vcu_node_loss);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_private_can3_bus_offWatcher() {
  float ec_private_can3_bus_off = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_private_can3_bus_off");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_private_can3_bus_off = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_private_can3_bus_offReq(ec_private_can3_bus_off),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_private_can3_bus_offReq(float ec_private_can3_bus_off) {
    auto req = mValueObjectPool->obtainFloat(ec_private_can3_bus_off);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_private_can2_bus_offWatcher() {
  float ec_private_can2_bus_off = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_private_can2_bus_off");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_private_can2_bus_off = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_private_can2_bus_offReq(ec_private_can2_bus_off),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_private_can2_bus_offReq(float ec_private_can2_bus_off) {
    auto req = mValueObjectPool->obtainFloat(ec_private_can2_bus_off);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_private_can1_bus_offWatcher() {
  float ec_private_can1_bus_off = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_private_can1_bus_off");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_private_can1_bus_off = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_private_can1_bus_offReq(ec_private_can1_bus_off),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_private_can1_bus_offReq(float ec_private_can1_bus_off) {
    auto req = mValueObjectPool->obtainFloat(ec_private_can1_bus_off);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_detect_backup_battery_lostWatcher() {
  float ec_detect_backup_battery_lost = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_detect_backup_battery_lost");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_detect_backup_battery_lost = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_detect_backup_battery_lostReq(ec_detect_backup_battery_lost),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_detect_backup_battery_lostReq(float ec_detect_backup_battery_lost) {
    auto req = mValueObjectPool->obtainFloat(ec_detect_backup_battery_lost);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ccm_detects_acu_node_lossWatcher() {
  float ec_ccm_detects_acu_node_loss = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccm_detects_acu_node_loss");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ccm_detects_acu_node_loss = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ccm_detects_acu_node_lossReq(ec_ccm_detects_acu_node_loss),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccm_detects_acu_node_lossReq(float ec_ccm_detects_acu_node_loss) {
    auto req = mValueObjectPool->obtainFloat(ec_ccm_detects_acu_node_loss);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ccm_detects_bcm_node_lossWatcher() {
  float ec_ccm_detects_bcm_node_loss = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccm_detects_bcm_node_loss");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ccm_detects_bcm_node_loss = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ccm_detects_bcm_node_lossReq(ec_ccm_detects_bcm_node_loss),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccm_detects_bcm_node_lossReq(float ec_ccm_detects_bcm_node_loss) {
    auto req = mValueObjectPool->obtainFloat(ec_ccm_detects_bcm_node_loss);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ccm_detects_ac_node_lossWatcher() {
  float ec_ccm_detects_ac_node_loss = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccm_detects_ac_node_loss");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ccm_detects_ac_node_loss = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ccm_detects_ac_node_lossReq(ec_ccm_detects_ac_node_loss),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccm_detects_ac_node_lossReq(float ec_ccm_detects_ac_node_loss) {
    auto req = mValueObjectPool->obtainFloat(ec_ccm_detects_ac_node_loss);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_eas_motspdWatcher() {
  float bc_eas_motspd = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_eas_motspd");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_eas_motspd = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_eas_motspdReq(bc_eas_motspd),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_eas_motspdReq(float bc_eas_motspd) {
    auto req = mValueObjectPool->obtainFloat(bc_eas_motspd);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_eas_eashvil_staWatcher() {
  float bc_eas_eashvil_sta = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_eas_eashvil_sta");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_eas_eashvil_sta = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_eas_eashvil_staReq(bc_eas_eashvil_sta),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_eas_eashvil_staReq(float bc_eas_eashvil_sta) {
    auto req = mValueObjectPool->obtainFloat(bc_eas_eashvil_sta);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_eas_crtstsWatcher() {
  float bc_eas_crtsts = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_eas_crtsts");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_eas_crtsts = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_eas_crtstsReq(bc_eas_crtsts),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_eas_crtstsReq(float bc_eas_crtsts) {
    auto req = mValueObjectPool->obtainFloat(bc_eas_crtsts);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_eas_ip_mtempWatcher() {
  float bc_eas_ip_mtemp = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_eas_ip_mtemp");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_eas_ip_mtemp = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_eas_ip_mtempReq(bc_eas_ip_mtemp),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_eas_ip_mtempReq(float bc_eas_ip_mtemp) {
    auto req = mValueObjectPool->obtainFloat(bc_eas_ip_mtemp);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_eas_ctrlrstsWatcher() {
  float bc_eas_ctrlrsts = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_eas_ctrlrsts");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_eas_ctrlrsts = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_eas_ctrlrstsReq(bc_eas_ctrlrsts),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_eas_ctrlrstsReq(float bc_eas_ctrlrsts) {
    auto req = mValueObjectPool->obtainFloat(bc_eas_ctrlrsts);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_eas_ctrlrcrtWatcher() {
  float bc_eas_ctrlrcrt = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_eas_ctrlrcrt");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_eas_ctrlrcrt = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_eas_ctrlrcrtReq(bc_eas_ctrlrcrt),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_eas_ctrlrcrtReq(float bc_eas_ctrlrcrt) {
    auto req = mValueObjectPool->obtainFloat(bc_eas_ctrlrcrt);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_eas_ctrlrvoltWatcher() {
  float bc_eas_ctrlrvolt = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_eas_ctrlrvolt");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_eas_ctrlrvolt = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_eas_ctrlrvoltReq(bc_eas_ctrlrvolt),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_eas_ctrlrvoltReq(float bc_eas_ctrlrvolt) {
    auto req = mValueObjectPool->obtainFloat(bc_eas_ctrlrvolt);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ac_blower_levelWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_ac_blower_level = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ac_blower_level");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);

      bc_ac_blower_level = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_ac_blower_levelReq(bc_ac_blower_level),true);

  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ac_blower_levelReq(int32_t bc_ac_blower_level) {
    auto req = mValueObjectPool->obtainInt32(bc_ac_blower_level);
    req->prop = toInt(VehicleProperty::HVAC_FAN_SPEED);
    req->areaId = 117;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_ac_hybrid_eco_mode_staWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_ac_hybrid_eco_mode_sta = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ac_hybrid_eco_mode_sta");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ac_hybrid_eco_mode_sta = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_ac_hybrid_eco_mode_staReq(bc_ac_hybrid_eco_mode_sta),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ac_hybrid_eco_mode_staReq(int32_t bc_ac_hybrid_eco_mode_sta) {
    auto req = mValueObjectPool->obtainInt32(bc_ac_hybrid_eco_mode_sta);
    req->prop = toInt(VehicleProperty::GECKO_HVAC_HYBIRD_ECO_MODE);
    req->areaId = 117;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}



void GarageModeServerSideHandlerImpl::bc_ac_fan_reqWatcher() {
  float bc_ac_fan_req = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ac_fan_req");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ac_fan_req = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_ac_fan_reqReq(bc_ac_fan_req),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ac_fan_reqReq(float bc_ac_fan_req) {
    auto req = mValueObjectPool->obtainFloat(bc_ac_fan_req);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ac_fresh_reci_stateWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_ac_fresh_reci_state = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ac_fresh_reci_state");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ac_fresh_reci_state = static_cast<int32_t> (mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_bc_ac_fresh_reci_stateReq(bc_ac_fresh_reci_state),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ac_fresh_reci_stateReq(int32_t bc_ac_fresh_reci_state) {
    auto req = mValueObjectPool->obtainInt32(bc_ac_fresh_reci_state);
    ALOGW("dxy----Create_bc_ac_fresh_reci_stateReq bc_ac_fresh_reci_state=%d", bc_ac_fresh_reci_state);
    req->prop = toInt(VehicleProperty::HVAC_RECIRC_ON);
    req->areaId = 117;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ac_front_defrost_stateWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_ac_front_defrost_state = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ac_front_defrost_state");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ac_front_defrost_state = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_ac_front_defrost_stateReq(bc_ac_front_defrost_state, 1),true);
      mHal->onPropertyValue(*Create_bc_ac_front_defrost_stateReq(bc_ac_front_defrost_state, 2),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ac_front_defrost_stateReq(int32_t bc_ac_front_defrost_state, int32_t areaId) {
    auto req = mValueObjectPool->obtainInt32(bc_ac_front_defrost_state);
    ALOGW("dxy----Create_bc_ac_front_defrost_stateReq bc_ac_front_defrost_state=%d", bc_ac_front_defrost_state);
    req->prop = toInt(VehicleProperty::HVAC_DEFROSTER);
    req->areaId = areaId;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ac_heat_stateWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_ac_heat_state = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ac_heat_state");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ALOGW("zcy----bc_ac_heat_state mPropertyManager->getCProValue(mp) = %d", mPropertyManager->getCProValue(mp));

      bc_ac_heat_state = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_ac_heat_stateReq(bc_ac_heat_state),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ac_heat_stateReq(int32_t bc_ac_heat_state) {
    auto req = mValueObjectPool->obtainInt32(bc_ac_heat_state);
    req->prop = toInt(VehicleProperty::GECKO_HVAC_PTC_HEAT_ON);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}


void GarageModeServerSideHandlerImpl::bc_ac_havc_stateWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_ac_havc_state = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ac_havc_state");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ALOGW("dxy----bc_ac_heat_state mPropertyManager->getCProValue(mp) = %d", mPropertyManager->getCProValue(mp));
      bc_ac_havc_state = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_ac_havc_stateReq(bc_ac_havc_state),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ac_havc_stateReq(int32_t bc_ac_havc_state) {
    auto req = mValueObjectPool->obtainInt32(bc_ac_havc_state);
    ALOGW("dxy----Create_bc_ac_havc_stateReq bc_ac_havc_state = %d", bc_ac_havc_state);
    req->prop = toInt(VehicleProperty::HVAC_POWER_ON);
    req->areaId = 117;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ac_ai_rdistribution_modeWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_ac_ai_rdistribution_mode = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ac_ai_rdistribution_mode");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ac_ai_rdistribution_mode = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_ac_ai_rdistribution_modeReq(bc_ac_ai_rdistribution_mode),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ac_ai_rdistribution_modeReq(int32_t bc_ac_ai_rdistribution_mode) {
    auto req = mValueObjectPool->obtainInt32(bc_ac_ai_rdistribution_mode);
    ALOGW("zcy----Create_bc_ac_air_distribution_modeReq bc_ac_ai_rdistribution_mode=%d", bc_ac_ai_rdistribution_mode);
    req->prop = toInt(VehicleProperty::HVAC_FAN_DIRECTION);
    req->areaId = 117;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ac_a_cstateWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_ac_a_cstate = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ac_a_cstate");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ac_a_cstate = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_ac_a_cstateReq(bc_ac_a_cstate),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ac_a_cstateReq(int32_t bc_ac_a_cstate) {
    auto req = mValueObjectPool->obtainInt32(bc_ac_a_cstate);
    ALOGW("zcy----Create_bc_ac_a_cstateReq  bc_ac_a_cstate=%d", bc_ac_a_cstate);
    req->prop = toInt(VehicleProperty::HVAC_AC_ON);
    req->areaId = 117;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ac_left_set_temperatureWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  float bc_ac_left_set_temperature = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ac_left_set_temperature");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ac_left_set_temperature = getActualFloatValue(mPropertyManager->getCProValue(mp),1,0);
      mHal->onPropertyValue(*Create_bc_ac_left_set_temperatureReq(bc_ac_left_set_temperature, 49),true);
      mHal->onPropertyValue(*Create_bc_ac_left_set_temperatureReq(bc_ac_left_set_temperature, 68),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ac_left_set_temperatureReq(float bc_ac_left_set_temperature, int32_t areaId) {
    auto req = mValueObjectPool->obtainFloat(bc_ac_left_set_temperature);
    ALOGW("zcy----Create_bc_ac_left_set_temperatureReq  bc_ac_left_set_temperature=%f", bc_ac_left_set_temperature);
    req->prop = toInt(VehicleProperty::HVAC_TEMPERATURE_SET);
    req->areaId = areaId;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ac_fan_pwmWatcher() {
  float bc_ac_fan_pwm = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ac_fan_pwm");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ac_fan_pwm = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_ac_fan_pwmReq(bc_ac_fan_pwm),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ac_fan_pwmReq(float bc_ac_fan_pwm) {
    auto req = mValueObjectPool->obtainFloat(bc_ac_fan_pwm);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ac_fan_feed_back_voltageWatcher() {
  float bc_ac_fan_feed_back_voltage = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ac_fan_feed_back_voltage");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ac_fan_feed_back_voltage = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_ac_fan_feed_back_voltageReq(bc_ac_fan_feed_back_voltage),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ac_fan_feed_back_voltageReq(float bc_ac_fan_feed_back_voltage) {
    auto req = mValueObjectPool->obtainFloat(bc_ac_fan_feed_back_voltage);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ac_pt_ctempWatcher() {
  float bc_ac_pt_ctemp = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ac_pt_ctemp");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ac_pt_ctemp = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_ac_pt_ctempReq(bc_ac_pt_ctemp),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ac_pt_ctempReq(float bc_ac_pt_ctemp) {
    auto req = mValueObjectPool->obtainFloat(bc_ac_pt_ctemp);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_ac_fault_statusWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_ac_fault_status = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ac_fault_status");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ac_fault_status = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_bc_ac_fault_statusReq(bc_ac_fault_status),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ac_fault_statusReq(int32_t bc_ac_fault_status) {
    auto req = mValueObjectPool->obtainInt32(bc_ac_fault_status);
    req->prop = toInt(VehicleProperty::GECKO_HVAC_CONTROL_ERROR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ac_ptc_over_heatWatcher() {
  float bc_ac_ptc_over_heat = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ac_ptc_over_heat");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ac_ptc_over_heat = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_ac_ptc_over_heatReq(bc_ac_ptc_over_heat),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ac_ptc_over_heatReq(float bc_ac_ptc_over_heat) {
    auto req = mValueObjectPool->obtainFloat(bc_ac_ptc_over_heat);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ac_eas_speed_reqWatcher() {
  float bc_ac_eas_speed_req = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ac_eas_speed_req");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ac_eas_speed_req = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_ac_eas_speed_reqReq(bc_ac_eas_speed_req),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ac_eas_speed_reqReq(float bc_ac_eas_speed_req) {
    auto req = mValueObjectPool->obtainFloat(bc_ac_eas_speed_req);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ac_ptcp_power_reqWatcher() {
  float bc_ac_ptcp_power_req = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ac_ptcp_power_req");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ac_ptcp_power_req = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_ac_ptcp_power_reqReq(bc_ac_ptcp_power_req),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ac_ptcp_power_reqReq(float bc_ac_ptcp_power_req) {
    auto req = mValueObjectPool->obtainFloat(bc_ac_ptcp_power_req);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ac_press_swtich_stateWatcher() {
  float bc_ac_press_swtich_state = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ac_press_swtich_state");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ac_press_swtich_state = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_ac_press_swtich_stateReq(bc_ac_press_swtich_state),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ac_press_swtich_stateReq(float bc_ac_press_swtich_state) {
    auto req = mValueObjectPool->obtainFloat(bc_ac_press_swtich_state);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ac_livecounter_0x233Watcher() {
  float bc_ac_livecounter_0x233 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ac_livecounter_0x233");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ac_livecounter_0x233 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_ac_livecounter_0x233Req(bc_ac_livecounter_0x233),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ac_livecounter_0x233Req(float bc_ac_livecounter_0x233) {
    auto req = mValueObjectPool->obtainFloat(bc_ac_livecounter_0x233);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ac_checksum_0x233Watcher() {
  float bc_ac_checksum_0x233 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ac_checksum_0x233");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ac_checksum_0x233 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_ac_checksum_0x233Req(bc_ac_checksum_0x233),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ac_checksum_0x233Req(float bc_ac_checksum_0x233) {
    auto req = mValueObjectPool->obtainFloat(bc_ac_checksum_0x233);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ccm_fresh_reci_keyWatcher() {
  float bc_ccm_fresh_reci_key = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ccm_fresh_reci_key");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ccm_fresh_reci_key = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_ccm_fresh_reci_keyReq(bc_ccm_fresh_reci_key),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ccm_fresh_reci_keyReq(float bc_ccm_fresh_reci_key) {
    auto req = mValueObjectPool->obtainFloat(bc_ccm_fresh_reci_key);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ccm_front_defrost_keyWatcher() {
  float bc_ccm_front_defrost_key = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ccm_front_defrost_key");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ccm_front_defrost_key = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_ccm_front_defrost_keyReq(bc_ccm_front_defrost_key),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ccm_front_defrost_keyReq(float bc_ccm_front_defrost_key) {
    auto req = mValueObjectPool->obtainFloat(bc_ccm_front_defrost_key);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ccm_a_ckeyWatcher() {
  float bc_ccm_a_ckey = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ccm_a_ckey");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ccm_a_ckey = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_ccm_a_ckeyReq(bc_ccm_a_ckey),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ccm_a_ckeyReq(float bc_ccm_a_ckey) {
    auto req = mValueObjectPool->obtainFloat(bc_ccm_a_ckey);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ccm_blower_levelWatcher() {
  float bc_ccm_blower_level = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ccm_blower_level");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ccm_blower_level = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_ccm_blower_levelReq(bc_ccm_blower_level),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ccm_blower_levelReq(float bc_ccm_blower_level) {
    auto req = mValueObjectPool->obtainFloat(bc_ccm_blower_level);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ccm_ac_havc_stateWatcher() {
  float bc_ccm_ac_havc_state = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ccm_ac_havc_state");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ccm_ac_havc_state = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_ccm_ac_havc_stateReq(bc_ccm_ac_havc_state),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ccm_ac_havc_stateReq(float bc_ccm_ac_havc_state) {
    auto req = mValueObjectPool->obtainFloat(bc_ccm_ac_havc_state);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ccm_air_distribution_mode_reqWatcher() {
  float bc_ccm_air_distribution_mode_req = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ccm_air_distribution_mode_req");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ccm_air_distribution_mode_req = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_ccm_air_distribution_mode_reqReq(bc_ccm_air_distribution_mode_req),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ccm_air_distribution_mode_reqReq(float bc_ccm_air_distribution_mode_req) {
    auto req = mValueObjectPool->obtainFloat(bc_ccm_air_distribution_mode_req);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ccm_heat_keyWatcher() {
  float bc_ccm_heat_key = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ccm_heat_key");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ccm_heat_key = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_ccm_heat_keyReq(bc_ccm_heat_key),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ccm_heat_keyReq(float bc_ccm_heat_key) {
    auto req = mValueObjectPool->obtainFloat(bc_ccm_heat_key);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ccm_left_set_tempWatcher() {
  float bc_ccm_left_set_temp = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ccm_left_set_temp");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ccm_left_set_temp = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_ccm_left_set_tempReq(bc_ccm_left_set_temp),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ccm_left_set_tempReq(float bc_ccm_left_set_temp) {
    auto req = mValueObjectPool->obtainFloat(bc_ccm_left_set_temp);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ccm_avassetWatcher() {
  float bc_ccm_avasset = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ccm_avasset");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ccm_avasset = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_ccm_avassetReq(bc_ccm_avasset),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ccm_avassetReq(float bc_ccm_avasset) {
    auto req = mValueObjectPool->obtainFloat(bc_ccm_avasset);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ccm_livecounter_0x310Watcher() {
  float bc_ccm_livecounter_0x310 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ccm_livecounter_0x310");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ccm_livecounter_0x310 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_ccm_livecounter_0x310Req(bc_ccm_livecounter_0x310),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ccm_livecounter_0x310Req(float bc_ccm_livecounter_0x310) {
    auto req = mValueObjectPool->obtainFloat(bc_ccm_livecounter_0x310);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ccm_checksum_0x310Watcher() {
  float bc_ccm_checksum_0x310 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ccm_checksum_0x310");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ccm_checksum_0x310 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_ccm_checksum_0x310Req(bc_ccm_checksum_0x310),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ccm_checksum_0x310Req(float bc_ccm_checksum_0x310) {
    auto req = mValueObjectPool->obtainFloat(bc_ccm_checksum_0x310);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ccm_rear_fog_lamp_setWatcher() {
  float bc_ccm_rear_fog_lamp_set = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ccm_rear_fog_lamp_set");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ccm_rear_fog_lamp_set = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_ccm_rear_fog_lamp_setReq(bc_ccm_rear_fog_lamp_set),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ccm_rear_fog_lamp_setReq(float bc_ccm_rear_fog_lamp_set) {
    auto req = mValueObjectPool->obtainFloat(bc_ccm_rear_fog_lamp_set);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ccm_left_mirror_setWatcher() {
  float bc_ccm_left_mirror_set = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ccm_left_mirror_set");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ccm_left_mirror_set = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_ccm_left_mirror_setReq(bc_ccm_left_mirror_set),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ccm_left_mirror_setReq(float bc_ccm_left_mirror_set) {
    auto req = mValueObjectPool->obtainFloat(bc_ccm_left_mirror_set);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ccm_park_un_lock_reqWatcher() {
  float bc_ccm_park_un_lock_req = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ccm_park_un_lock_req");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ccm_park_un_lock_req = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_ccm_park_un_lock_reqReq(bc_ccm_park_un_lock_req),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ccm_park_un_lock_reqReq(float bc_ccm_park_un_lock_req) {
    auto req = mValueObjectPool->obtainFloat(bc_ccm_park_un_lock_req);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ccm_auto_lock_reqWatcher() {
  float bc_ccm_auto_lock_req = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ccm_auto_lock_req");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ccm_auto_lock_req = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_ccm_auto_lock_reqReq(bc_ccm_auto_lock_req),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ccm_auto_lock_reqReq(float bc_ccm_auto_lock_req) {
    auto req = mValueObjectPool->obtainFloat(bc_ccm_auto_lock_req);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ccm_auto_unlock_reqWatcher() {
  float bc_ccm_auto_unlock_req = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ccm_auto_unlock_req");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ccm_auto_unlock_req = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_ccm_auto_unlock_reqReq(bc_ccm_auto_unlock_req),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ccm_auto_unlock_reqReq(float bc_ccm_auto_unlock_req) {
    auto req = mValueObjectPool->obtainFloat(bc_ccm_auto_unlock_req);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ccm_remt_contr_lamp_ctr_cmdWatcher() {
  float bc_ccm_remt_contr_lamp_ctr_cmd = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ccm_remt_contr_lamp_ctr_cmd");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ccm_remt_contr_lamp_ctr_cmd = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_ccm_remt_contr_lamp_ctr_cmdReq(bc_ccm_remt_contr_lamp_ctr_cmd),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ccm_remt_contr_lamp_ctr_cmdReq(float bc_ccm_remt_contr_lamp_ctr_cmd) {
    auto req = mValueObjectPool->obtainFloat(bc_ccm_remt_contr_lamp_ctr_cmd);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ccu_remote_car_searchWatcher() {
  int32_t bc_ccu_remote_car_search = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ccu_remote_car_search");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ccu_remote_car_search = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_ccu_remote_car_searchReq(bc_ccu_remote_car_search),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ccu_remote_car_searchReq(int32_t bc_ccu_remote_car_search) {
    auto req = mValueObjectPool->obtainInt32(bc_ccu_remote_car_search);
    req->prop = toInt(VehicleProperty::GECKO_CCM_REMOTE_CAR_SEARCH);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ccu_remote_lockWatcher() {
  int32_t bc_ccu_remote_lock = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ccu_remote_lock");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ccu_remote_lock = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_ccu_remote_lockReq(bc_ccu_remote_lock),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ccu_remote_lockReq(int32_t bc_ccu_remote_lock) {
    auto req = mValueObjectPool->obtainInt32(bc_ccu_remote_lock);
    req->prop = toInt(VehicleProperty::GECKO_CCM_REMOTE_LOCK);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ccm_right_mirror_setWatcher() {
  float bc_ccm_right_mirror_set = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ccm_right_mirror_set");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ccm_right_mirror_set = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_ccm_right_mirror_setReq(bc_ccm_right_mirror_set),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ccm_right_mirror_setReq(float bc_ccm_right_mirror_set) {
    auto req = mValueObjectPool->obtainFloat(bc_ccm_right_mirror_set);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ccm_livecounter_0x311Watcher() {
  float bc_ccm_livecounter_0x311 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ccm_livecounter_0x311");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ccm_livecounter_0x311 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_ccm_livecounter_0x311Req(bc_ccm_livecounter_0x311),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ccm_livecounter_0x311Req(float bc_ccm_livecounter_0x311) {
    auto req = mValueObjectPool->obtainFloat(bc_ccm_livecounter_0x311);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ccm_checksum_0x311Watcher() {
  float bc_ccm_checksum_0x311 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ccm_checksum_0x311");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ccm_checksum_0x311 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_ccm_checksum_0x311Req(bc_ccm_checksum_0x311),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ccm_checksum_0x311Req(float bc_ccm_checksum_0x311) {
    auto req = mValueObjectPool->obtainFloat(bc_ccm_checksum_0x311);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_bcm_position_light_statusWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_position_light_status = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_position_light_status");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_position_light_status = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_bc_bcm_position_light_statusReq(bc_bcm_position_light_status),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_position_light_statusReq(int32_t bc_bcm_position_light_status) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_position_light_status);
    req->prop = toInt(VehicleProperty::CABIN_LIGHTS_STATE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_bcm_high_beam_statusWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_high_beam_status = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_high_beam_status");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_high_beam_status = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_bc_bcm_high_beam_statusReq(bc_bcm_high_beam_status),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_high_beam_statusReq(int32_t bc_bcm_high_beam_status) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_high_beam_status);
    req->prop = toInt(VehicleProperty::HIGH_BEAM_LIGHTS_STATE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_bcm_low_beam_statusWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_low_beam_status = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_low_beam_status");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_low_beam_status = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_bc_bcm_low_beam_statusReq(bc_bcm_low_beam_status),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_low_beam_statusReq(int32_t bc_bcm_low_beam_status) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_low_beam_status);
    req->prop = toInt(VehicleProperty::HEADLIGHTS_STATE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_bcm_turn_indcr_riWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_turn_indcr_ri = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_turn_indcr_ri");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_turn_indcr_ri = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      // ALOGW("dxy-- bc_bcm bc_bcm_turn_indcr_riWatcher value = %d", bc_bcm_turn_indcr_ri);
      if (bc_bcm_turn_indcr_ri != -1) {
          mHal->onPropertyValue(*Create_bc_bcm_turn_indcr_riReq(bc_bcm_turn_indcr_ri),true);
      }
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_turn_indcr_riReq(int32_t bc_bcm_turn_indcr_ri) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_turn_indcr_ri);
    ALOGW("dxy-- bc_bcm_turn_indcr_riReq value = %d", bc_bcm_turn_indcr_ri);
    req->prop = toInt(VehicleProperty::GECKO_RIGHT_TURN_SIGNAL_STATE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_bcm_turn_indcr_leWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_turn_indcr_le = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_turn_indcr_le");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_turn_indcr_le = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      // ALOGW("dxy-- bc_bcm going to set bc_bcm_turn_indcr_le value = %d", bc_bcm_turn_indcr_le);
      if (bc_bcm_turn_indcr_le != -1) {
          mHal->onPropertyValue(*Create_bc_bcm_turn_indcr_leReq(bc_bcm_turn_indcr_le),true);
      }
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_turn_indcr_leReq(int32_t bc_bcm_turn_indcr_le) {
    ALOGW("dxy-- bc_bcm_turn_indcr_leReq value = %d", bc_bcm_turn_indcr_le);
    auto req = mValueObjectPool->obtainInt32(bc_bcm_turn_indcr_le);
    req->prop = toInt(VehicleProperty::GECKO_LEFT_TURN_SIGNAL_STATE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_bcm_hazard_light_statusWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_hazard_light_status = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_hazard_light_status");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_hazard_light_status = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_bc_bcm_hazard_light_statusReq(bc_bcm_hazard_light_status),true);
  }
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_hazard_light_statusReq(int32_t bc_bcm_hazard_light_status) {
    ALOGW("dxy-- bc_bcm_hazard_light_statusReq value = %d", bc_bcm_hazard_light_status);
    auto req = mValueObjectPool->obtainInt32(bc_bcm_hazard_light_status);
    req->prop = toInt(VehicleProperty::HAZARD_LIGHTS_STATE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_position_light_warningWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_position_light_warning = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_position_light_warning");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_position_light_warning = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_bcm_position_light_warningReq(bc_bcm_position_light_warning),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_position_light_warningReq(int32_t bc_bcm_position_light_warning) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_position_light_warning);
    req->prop = toInt(VehicleProperty::GECKO_POSITION_LIGHT_WARNING);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_rl_door_ajar_statusWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_rl_door_ajar_status = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_rl_door_ajar_status");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_rl_door_ajar_status = static_cast<int32_t> (mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_bc_bcm_rl_door_ajar_statusReq(bc_bcm_rl_door_ajar_status),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_rl_door_ajar_statusReq(int32_t bc_bcm_rl_door_ajar_status) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_rl_door_ajar_status);
    req->prop = toInt(VehicleProperty::GECKO_RL_DOOR_STATE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_rr_door_ajar_statusWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_rr_door_ajar_status = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_rr_door_ajar_status");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_rr_door_ajar_status = static_cast<int32_t> (mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_bc_bcm_rr_door_ajar_statusReq(bc_bcm_rr_door_ajar_status),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_rr_door_ajar_statusReq(int32_t bc_bcm_rr_door_ajar_status) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_rr_door_ajar_status);
    req->prop = toInt(VehicleProperty::GECKO_RR_DOOR_STATE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_bcm_fr_door_ajar_statusWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_fr_door_ajar_status = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_fr_door_ajar_status");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_fr_door_ajar_status = static_cast<int32_t> (mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_bc_bcm_fr_door_ajar_statusReq(bc_bcm_fr_door_ajar_status),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_fr_door_ajar_statusReq(int32_t bc_bcm_fr_door_ajar_status) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_fr_door_ajar_status);
    req->prop = toInt(VehicleProperty::GECKO_FR_DOOR_STATE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_bcm_fl_door_ajar_statusWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_fl_door_ajar_status = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_fl_door_ajar_status");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_fl_door_ajar_status = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_bcm_fl_door_ajar_statusReq(bc_bcm_fl_door_ajar_status),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_fl_door_ajar_statusReq(int32_t bc_bcm_fl_door_ajar_status) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_fl_door_ajar_status);
    req->prop = toInt(VehicleProperty::GECKO_FL_DOOR_STATE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_bcm_rear_fog_light_statusWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_rear_fog_light_status = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_rear_fog_light_status");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_rear_fog_light_status = static_cast<int32_t> (mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_bc_bcm_rear_fog_light_statusReq(bc_bcm_rear_fog_light_status),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_rear_fog_light_statusReq(int32_t bc_bcm_rear_fog_light_status) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_rear_fog_light_status);
    req->prop = toInt(VehicleProperty::FOG_LIGHTS_STATE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_bcm_tr_cls_stWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_tr_cls_st = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_tr_cls_st");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_tr_cls_st = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_bcm_tr_cls_stReq(bc_bcm_tr_cls_st),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_tr_cls_stReq(int32_t bc_bcm_tr_cls_st) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_tr_cls_st);
    req->prop = toInt(VehicleProperty::GECKO_TR_CLS_ST);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_bcm_power_stsWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_power_sts = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_power_sts");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_power_sts = mPropertyManager->getCProValue(mp);

      //记录点火时间
      if((bc_bcm_power_sts == 1 || bc_bcm_power_sts == 2 || bc_bcm_power_sts == 3) &&  powerOnTimestamp == 0){
      //短期记忆数据计算放在mcu处理
          //ConfigDBC* odometer = mPropertyManager->findCProperty("ec_total_odometer");
          //beginTotalMileage = getActualFloatValue(mPropertyManager->getCProValue(odometer),1,0);
    
          //ConfigDBC* travel = mPropertyManager->findCProperty("mcu_short_mileage");
          //begintravelMileage = getActualFloatValue(mPropertyManager->getCProValue(travel), 0.1, 0);
    
          //std::chrono::milliseconds ms_start = std::chrono::duration_cast< std::chrono::milliseconds >(
          //std::chrono::system_clock::now().time_since_epoch());
    
          //travelBeginTimes = ms_start.count();
          //travelBeginTimes = gTimes;
          //travelBeginTimes = elapsedRealtime();
          //powerOnTimestamp = elapsedRealtime();
		  ALOGI("bc_bcm_power_stsWatcher 1 powerOnTimestamp:%jd", powerOnTimestamp);
          //battery_low_signal();
          //mHal->onPropertyValue(*Create_power_on_timeReq(0), true);       
      }

      #if 0 //短期记忆数据计算放在mcu处理
      if(bc_bcm_power_sts == 1 || bc_bcm_power_sts == 2 || bc_bcm_power_sts == 3) {
          energyConsumptionFlag = true;
          ConfigDBC* mp_average = mPropertyManager->findCProperty("ec_vcu_average_energy_consumption");
          totalEnergyConsumption = getActualFloatValue(mPropertyManager->getCProValue(mp_average),0.1,0);
          mHal->onPropertyValue(*Create_power_on_average_energy_consumptionReq(totalEnergyConsumption),true);
	  } 
      else if(bc_bcm_power_sts == 0) {
          energyConsumptionFlag = false;
      }
      #endif
      //记录上次电源状态
      lastPowerOnSts = powerOnSts;
      powerOnSts = bc_bcm_power_sts;

      //短期记忆
      //当BCM_PowerSts由0x2切换为0x0后清除计算数据。
      #if 0 //短期记忆数据计算放在mcu处理
      if(bc_bcm_power_sts == 0) {
        powerOnTimestamp = 0;
        powerOnMileage = 0.0;
	      totalEnergyConsumption = 0.0;
        travelTimes = 0;
        lastTravelTimes = 0;
        travelBeginTimes = 0;
        updateaverageEnergy = 0;
        //lastTimes = 0;

        averageEnergyConsumption = 0.0;
        energyCount = 0;

        updateAverageSpd = -1024;
        updatePowerOnMileage = -1024;

        ALOGI("bc_bcm_power_stsWatcher powerOnTimestamp:%jd, powerOnMileage:%f,totalEnergyConsumption:%f", powerOnTimestamp, powerOnMileage,totalEnergyConsumption);
        mHal->onPropertyValue(*Create_power_on_average_speedReq(-1024),true);
        mHal->onPropertyValue(*Create_power_on_milegeReq(-1024),true);
        mHal->onPropertyValue(*Create_power_on_average_energy_consumptionReq(-1024),true);
        mHal->onPropertyValue(*Create_power_on_timeReq(-1024), true);
      }
      #endif
      ALOGI("bc_bcm_power_stsWatcher powerOnTimestamp = %jd bc_bcm_power_sts:%d powerOnSts:%d lastPowerOnSts:%d", 
      powerOnTimestamp, bc_bcm_power_sts, powerOnSts, lastPowerOnSts);
      mHal->onPropertyValue(*Create_bc_bcm_power_stsReq(bc_bcm_power_sts),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_power_stsReq(int32_t bc_bcm_power_sts) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_power_sts);
    req->prop = toInt(VehicleProperty::IGNITION_STATE);
    ALOGW("cyzhao----bc_bcm_power_sts mPropertyManager->getCProValue(mp) = %d", bc_bcm_power_sts);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_bcm_dtc_fault_statusWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_dtc_fault_status = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_dtc_fault_status");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_dtc_fault_status = mPropertyManager->getCProValue(mp);
      LOG(INFO) << "bc_bcm_dtc_fault_status:"<<bc_bcm_dtc_fault_status;
      mHal->onPropertyValue(*Create_bc_bcm_dtc_fault_statusReq(bc_bcm_dtc_fault_status),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_dtc_fault_statusReq(int32_t bc_bcm_dtc_fault_status) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_dtc_fault_status);
    req->prop = toInt(VehicleProperty::GECKO_BCM_DTC_FAULT_STATUS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_drivelock_stWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_drivelock_st = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_drivelock_st");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_drivelock_st = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_bc_bcm_drivelock_stReq(bc_bcm_drivelock_st),true);
  }
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_drivelock_stReq(int32_t bc_bcm_drivelock_st) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_drivelock_st);
    req->prop = toInt(VehicleProperty::GECKO_BCM_DRIVELOCKST);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_bcm_reversinglight_stWatcher() {
  float bc_bcm_reversinglight_st = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_reversinglight_st");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_reversinglight_st = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_bcm_reversinglight_stReq(bc_bcm_reversinglight_st),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_reversinglight_stReq(float bc_bcm_reversinglight_st) {
    auto req = mValueObjectPool->obtainFloat(bc_bcm_reversinglight_st);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_brakelight_stWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_brakelight_st = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_brakelight_st");         //驻车状态
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_brakelight_st = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_bc_bcm_brakelight_stReq(bc_bcm_brakelight_st),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_brakelight_stReq(int32_t bc_bcm_brakelight_st) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_brakelight_st);
    req->prop = toInt(VehicleProperty::GECKO_BC_BCM_BREAKELIGHT_ST);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_bcm_interiorlight_stWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_interiorlight_st = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_interiorlight_st");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_interiorlight_st =static_cast<int32_t> (mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_bc_bcm_interiorlight_stReq(bc_bcm_interiorlight_st),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_interiorlight_stReq(int32_t bc_bcm_interiorlight_st) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_interiorlight_st);
    req->prop = toInt(VehicleProperty::READING_LIGHTS_STATE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_ccm_open_door_warn_feedWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_ccm_open_door_warn_feed = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_ccm_open_door_warn_feed");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_ccm_open_door_warn_feed =static_cast<int32_t> (mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_bc_bcm_ccm_open_door_warn_feedReq(bc_bcm_ccm_open_door_warn_feed),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_ccm_open_door_warn_feedReq(int32_t bc_bcm_ccm_open_door_warn_feed) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_ccm_open_door_warn_feed);
    req->prop = toInt(VehicleProperty::GECKO_CCM_BCM_OPENDOOR_WARN_SET);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_right_mirror_set_ackWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_right_mirror_set_ack = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_right_mirror_set_ack");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      if(mPropertyManager->getCProValue(mp) >=0 && mPropertyManager->getCProValue(mp) <=7) {
          bc_bcm_right_mirror_set_ack = static_cast<int32_t>(std::atoi(mp->valueMap[mPropertyManager->getCProValue(mp)].c_str()));
          mHal->onPropertyValue(*Create_bc_bcm_right_mirror_set_ackReq(bc_bcm_right_mirror_set_ack),true);
      }
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_right_mirror_set_ackReq(int32_t bc_bcm_right_mirror_set_ack) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_right_mirror_set_ack);
    req->prop = toInt(VehicleProperty::GECKO_RIGHT_MIRROR_SET);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_bcm_left_mirror_set_ackWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_left_mirror_set_ack = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_left_mirror_set_ack");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      if (mPropertyManager->getCProValue(mp) >=0 && mPropertyManager->getCProValue(mp) <=7) {
          bc_bcm_left_mirror_set_ack = static_cast<int32_t>(std::atoi(mp->valueMap[mPropertyManager->getCProValue(mp)].c_str()));
          mHal->onPropertyValue(*Create_bc_bcm_left_mirror_set_ackReq(bc_bcm_left_mirror_set_ack),true);
      }
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_left_mirror_set_ackReq(int32_t bc_bcm_left_mirror_set_ack) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_left_mirror_set_ack);
    req->prop = toInt(VehicleProperty::GECKO_LEFT_MIRROR_SET);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_bcm_park_un_lock_ackWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_park_un_lock_ack = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_park_un_lock_ack");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_park_un_lock_ack = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_bcm_park_un_lock_ackReq(bc_bcm_park_un_lock_ack),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_park_un_lock_ackReq(int32_t bc_bcm_park_un_lock_ack) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_park_un_lock_ack);
    req->prop = toInt(VehicleProperty::GECKO_PARK_UNLOCK_SET);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_bcm_auto_lock_ackWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_auto_lock_ack = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_auto_lock_ack");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      if (mPropertyManager->getCProValue(mp) >=0 && mPropertyManager->getCProValue(mp) <=1) {
          bc_bcm_auto_lock_ack = mPropertyManager->getCProValue(mp);
          mHal->onPropertyValue(*Create_bc_bcm_auto_lock_ackReq(bc_bcm_auto_lock_ack),true);
      }
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_auto_lock_ackReq(int32_t bc_bcm_auto_lock_ack) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_auto_lock_ack);
    req->prop = toInt(VehicleProperty::GECKO_AUTO_LOCK_SET);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_bcm_auto_unlock_ackWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_auto_unlock_ack = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_auto_unlock_ack");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_auto_unlock_ack = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_bcm_auto_unlock_ackReq(bc_bcm_auto_unlock_ack),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_auto_unlock_ackReq(int32_t bc_bcm_auto_unlock_ack) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_auto_unlock_ack);
    req->prop = toInt(VehicleProperty::GECKO_AUTO_UNLOCK_SET);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_bcm_livecounter_0x330Watcher() {
  float bc_bcm_livecounter_0x330 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_livecounter_0x330");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_livecounter_0x330 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_bcm_livecounter_0x330Req(bc_bcm_livecounter_0x330),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_livecounter_0x330Req(float bc_bcm_livecounter_0x330) {
    auto req = mValueObjectPool->obtainFloat(bc_bcm_livecounter_0x330);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_bcm_checksum_0x330Watcher() {
  float bc_bcm_checksum_0x330 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_checksum_0x330");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_checksum_0x330 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_bcm_checksum_0x330Req(bc_bcm_checksum_0x330),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_checksum_0x330Req(float bc_bcm_checksum_0x330) {
    auto req = mValueObjectPool->obtainFloat(bc_bcm_checksum_0x330);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_bcm_high_beam_rly_errWatcher() {
  float bc_bcm_high_beam_rly_err = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_high_beam_rly_err");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_high_beam_rly_err = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_bcm_high_beam_rly_errReq(bc_bcm_high_beam_rly_err),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_high_beam_rly_errReq(float bc_bcm_high_beam_rly_err) {
    auto req = mValueObjectPool->obtainFloat(bc_bcm_high_beam_rly_err);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_bcm_turn_indcr_ri_errWatcher() {
  float bc_bcm_turn_indcr_ri_err = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_turn_indcr_ri_err");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_turn_indcr_ri_err = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_bcm_turn_indcr_ri_errReq(bc_bcm_turn_indcr_ri_err),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_turn_indcr_ri_errReq(float bc_bcm_turn_indcr_ri_err) {
    auto req = mValueObjectPool->obtainFloat(bc_bcm_turn_indcr_ri_err);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_bcm_turn_indcr_le_errWatcher() {
  float bc_bcm_turn_indcr_le_err = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_turn_indcr_le_err");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_turn_indcr_le_err = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_bcm_turn_indcr_le_errReq(bc_bcm_turn_indcr_le_err),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_turn_indcr_le_errReq(float bc_bcm_turn_indcr_le_err) {
    auto req = mValueObjectPool->obtainFloat(bc_bcm_turn_indcr_le_err);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_daytime_running_light_errWatcher() {
  float bc_bcm_daytime_running_light_err = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_daytime_running_light_err");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_daytime_running_light_err = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_bcm_daytime_running_light_errReq(bc_bcm_daytime_running_light_err),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_daytime_running_light_errReq(float bc_bcm_daytime_running_light_err) {
    auto req = mValueObjectPool->obtainFloat(bc_bcm_daytime_running_light_err);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_bcm_brakelight_errWatcher() {
  float bc_bcm_brakelight_err = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_brakelight_err");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_brakelight_err = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_bcm_brakelight_errReq(bc_bcm_brakelight_err),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_brakelight_errReq(float bc_bcm_brakelight_err) {
    auto req = mValueObjectPool->obtainFloat(bc_bcm_brakelight_err);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_bcm_reversinglight_errWatcher() {
  float bc_bcm_reversinglight_err = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_reversinglight_err");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_reversinglight_err = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_bcm_reversinglight_errReq(bc_bcm_reversinglight_err),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_reversinglight_errReq(float bc_bcm_reversinglight_err) {
    auto req = mValueObjectPool->obtainFloat(bc_bcm_reversinglight_err);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_bcm_rear_fog_light_errWatcher() {
  float bc_bcm_rear_fog_light_err = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_rear_fog_light_err");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_rear_fog_light_err = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_bcm_rear_fog_light_errReq(bc_bcm_rear_fog_light_err),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_rear_fog_light_errReq(float bc_bcm_rear_fog_light_err) {
    auto req = mValueObjectPool->obtainFloat(bc_bcm_rear_fog_light_err);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

int32_t GarageModeServerSideHandlerImpl::getElectricErr(){
  int32_t value = mPropertyManager->getCProValue(mPropertyManager->findCProperty("bc_bcm_loss_com_with_acu"));
  if(value == 1) return 1;

  value = mPropertyManager->getCProValue(mPropertyManager->findCProperty("bc_bcm_loss_com_with_ccm"));
  if(value == 1) return 1;

  value = mPropertyManager->getCProValue(mPropertyManager->findCProperty("bc_bcm_loss_com_with_vcu"));
  if(value == 1) return 1;

  value = mPropertyManager->getCProValue(mPropertyManager->findCProperty("cc_acu_gsensor_fault"));
  if(value == 1) return 1;

  value = mPropertyManager->getCProValue(mPropertyManager->findCProperty("ec_vcu_lv_elec_sys_err"));
  if(value == 1) return 1;
  
  return 0;
}

void GarageModeServerSideHandlerImpl::bc_bcm_loss_com_with_acuWatcher() {
  int32_t bc_bcm_loss_com_with_acu = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_loss_com_with_acu");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_loss_com_with_acu = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_electric_errReq(getElectricErr()),true);
      LOG(INFO) << "bc_bcm_loss_com_with_acu: "<< bc_bcm_loss_com_with_acu;
  }
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_electric_errReq(int32_t value){
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_ELECTRIC_ERR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_loss_com_with_acuReq(float bc_bcm_loss_com_with_acu) {
    auto req = mValueObjectPool->obtainFloat(bc_bcm_loss_com_with_acu);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_bcm_loss_com_with_ccmWatcher() {
  int32_t bc_bcm_loss_com_with_ccm = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_loss_com_with_ccm");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_loss_com_with_ccm = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_electric_errReq(getElectricErr()),true);
      LOG(INFO) << "bc_bcm_loss_com_with_ccm: "<< bc_bcm_loss_com_with_ccm;
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_loss_com_with_ccmReq(float bc_bcm_loss_com_with_ccm) {
    auto req = mValueObjectPool->obtainFloat(bc_bcm_loss_com_with_ccm);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_bcm_loss_com_with_vcuWatcher() {
  int32_t bc_bcm_loss_com_with_vcu = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_loss_com_with_vcu");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_loss_com_with_vcu = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_electric_errReq(getElectricErr()),true);
      LOG(INFO) << "bc_bcm_loss_com_with_vcu: "<< bc_bcm_loss_com_with_vcu;
      
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_loss_com_with_vcuReq(float bc_bcm_loss_com_with_vcu) {
    auto req = mValueObjectPool->obtainFloat(bc_bcm_loss_com_with_vcu);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_bcm_lv_batt_over_voltWatcher() {
  float bc_bcm_lv_batt_over_volt = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_lv_batt_over_volt");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_lv_batt_over_volt = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_bcm_lv_batt_over_voltReq(bc_bcm_lv_batt_over_volt),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_lv_batt_over_voltReq(float bc_bcm_lv_batt_over_volt) {
    auto req = mValueObjectPool->obtainFloat(bc_bcm_lv_batt_over_volt);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_bcm_lv_batt_under_voltWatcher() {
  float bc_bcm_lv_batt_under_volt = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_lv_batt_under_volt");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_lv_batt_under_volt = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_bcm_lv_batt_under_voltReq(bc_bcm_lv_batt_under_volt),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_lv_batt_under_voltReq(float bc_bcm_lv_batt_under_volt) {
    auto req = mValueObjectPool->obtainFloat(bc_bcm_lv_batt_under_volt);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_bcm_horn_rly_errWatcher() {
  float bc_bcm_horn_rly_err = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_horn_rly_err");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_horn_rly_err = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_bcm_horn_rly_errReq(bc_bcm_horn_rly_err),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_horn_rly_errReq(float bc_bcm_horn_rly_err) {
    auto req = mValueObjectPool->obtainFloat(bc_bcm_horn_rly_err);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_bcm_low_beam_rly_errWatcher() {
  float bc_bcm_low_beam_rly_err = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_low_beam_rly_err");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_low_beam_rly_err = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_bcm_low_beam_rly_errReq(bc_bcm_low_beam_rly_err),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_low_beam_rly_errReq(float bc_bcm_low_beam_rly_err) {
    auto req = mValueObjectPool->obtainFloat(bc_bcm_low_beam_rly_err);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_bcm_livecounter_0x331Watcher() {
  float bc_bcm_livecounter_0x331 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_livecounter_0x331");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_livecounter_0x331 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_bcm_livecounter_0x331Req(bc_bcm_livecounter_0x331),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_livecounter_0x331Req(float bc_bcm_livecounter_0x331) {
    auto req = mValueObjectPool->obtainFloat(bc_bcm_livecounter_0x331);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_bcm_checksum_0x331Watcher() {
  float bc_bcm_checksum_0x331 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_checksum_0x331");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_checksum_0x331 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_bcm_checksum_0x331Req(bc_bcm_checksum_0x331),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_checksum_0x331Req(float bc_bcm_checksum_0x331) {
    auto req = mValueObjectPool->obtainFloat(bc_bcm_checksum_0x331);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_pdc1_button_pressWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_pdc1_button_press = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_pdc1_button_press");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_pdc1_button_press = static_cast<int32_t> (mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_bc_pdc1_button_pressReq(bc_pdc1_button_press),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_pdc1_button_pressReq(int32_t bc_pdc1_button_press) {
    auto req = mValueObjectPool->obtainInt32(bc_pdc1_button_press);
    req->prop = toInt(VehicleProperty::GECKO_BD_PDC1_BUTTON_PRESS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_pdc1_modeWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_pdc1_mode = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_pdc1_mode");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_pdc1_mode = static_cast<int32_t> (mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_bc_pdc1_modeReq(bc_pdc1_mode),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_pdc1_modeReq(int32_t bc_pdc1_mode) {
    auto req = mValueObjectPool->obtainInt32(bc_pdc1_mode);
    req->prop = toInt(VehicleProperty::GECKO_BD_PDC1_MODE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_pdc1_buzzer_alarm_patternWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_pdc1_buzzer_alarm_pattern = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_pdc1_buzzer_alarm_pattern");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_pdc1_buzzer_alarm_pattern = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_pdc1_buzzer_alarm_patternReq(bc_pdc1_buzzer_alarm_pattern),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_pdc1_buzzer_alarm_patternReq(int32_t bc_pdc1_buzzer_alarm_pattern) {
    auto req = mValueObjectPool->obtainInt32(bc_pdc1_buzzer_alarm_pattern);
    req->prop = toInt(VehicleProperty::GECKO_PDC1_BUZZER_ALARM_PATTERN);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_pdc1_distance_rmWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_pdc1_distance_rm = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_pdc1_distance_rm");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_pdc1_distance_rm = static_cast<int32_t> (mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_bc_pdc1_distance_rmReq(bc_pdc1_distance_rm),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_pdc1_distance_rmReq(int32_t bc_pdc1_distance_rm) {
    auto req = mValueObjectPool->obtainInt32(bc_pdc1_distance_rm);
    req->prop = toInt(VehicleProperty::GECKO_BD_PDC1_DISTANCE_RM);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_pdc1_distance_rrmWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_pdc1_distance_rrm = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_pdc1_distance_rrm");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_pdc1_distance_rrm = static_cast<int32_t> (mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_bc_pdc1_distance_rrmReq(bc_pdc1_distance_rrm),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_pdc1_distance_rrmReq(int32_t bc_pdc1_distance_rrm) {
    auto req = mValueObjectPool->obtainInt32(bc_pdc1_distance_rrm);
    req->prop = toInt(VehicleProperty::GECKO_BD_PDC1_DISTANCE_RRM);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_pdc1_distance_rlWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_pdc1_distance_rl = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_pdc1_distance_rl");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_pdc1_distance_rl = static_cast<int32_t> (mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_bc_pdc1_distance_rlReq(bc_pdc1_distance_rl),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_pdc1_distance_rlReq(int32_t bc_pdc1_distance_rl) {
    auto req = mValueObjectPool->obtainInt32(bc_pdc1_distance_rl);
    req->prop = toInt(VehicleProperty::GECKO_BD_PDC1_DISTANCE_RL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_pdc1_distance_rrWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_pdc1_distance_rr = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_pdc1_distance_rr");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_pdc1_distance_rr = static_cast<int32_t> (mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_bc_pdc1_distance_rrReq(bc_pdc1_distance_rr),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_pdc1_distance_rrReq(int32_t bc_pdc1_distance_rr) {
    auto req = mValueObjectPool->obtainInt32(bc_pdc1_distance_rr);
    req->prop = toInt(VehicleProperty::GECKO_BD_PDC1_DISTANCE_RR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_pdc_livecounter_0x165Watcher() {
  float bc_pdc_livecounter_0x165 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_pdc_livecounter_0x165");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_pdc_livecounter_0x165 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_pdc_livecounter_0x165Req(bc_pdc_livecounter_0x165),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_pdc_livecounter_0x165Req(float bc_pdc_livecounter_0x165) {
    auto req = mValueObjectPool->obtainFloat(bc_pdc_livecounter_0x165);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_pdc_checksum_0x165Watcher() {
  float bc_pdc_checksum_0x165 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_pdc_checksum_0x165");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_pdc_checksum_0x165 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_pdc_checksum_0x165Req(bc_pdc_checksum_0x165),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_pdc_checksum_0x165Req(float bc_pdc_checksum_0x165) {
    auto req = mValueObjectPool->obtainFloat(bc_pdc_checksum_0x165);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_bcm_work_reqWatcher() {
  float bc_bcm_work_req = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_work_req");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_work_req = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_bcm_work_reqReq(bc_bcm_work_req),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_work_reqReq(float bc_bcm_work_req) {
    auto req = mValueObjectPool->obtainFloat(bc_bcm_work_req);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_bcm_livecounter_0x669Watcher() {
  float bc_bcm_livecounter_0x669 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_livecounter_0x669");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_livecounter_0x669 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_bcm_livecounter_0x669Req(bc_bcm_livecounter_0x669),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_livecounter_0x669Req(float bc_bcm_livecounter_0x669) {
    auto req = mValueObjectPool->obtainFloat(bc_bcm_livecounter_0x669);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_bcm_checksum_0x669Watcher() {
  float bc_bcm_checksum_0x669 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_checksum_0x669");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_checksum_0x669 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_bcm_checksum_0x669Req(bc_bcm_checksum_0x669),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_checksum_0x669Req(float bc_bcm_checksum_0x669) {
    auto req = mValueObjectPool->obtainFloat(bc_bcm_checksum_0x669);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_str_work_reqWatcher() {
  float bc_str_work_req = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_str_work_req");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_str_work_req = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_str_work_reqReq(bc_str_work_req),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_str_work_reqReq(float bc_str_work_req) {
    auto req = mValueObjectPool->obtainFloat(bc_str_work_req);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ccm_nm_bitWatcher() {
  float bc_ccm_nm_bit = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ccm_nm_bit");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ccm_nm_bit = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_ccm_nm_bitReq(bc_ccm_nm_bit),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ccm_nm_bitReq(float bc_ccm_nm_bit) {
    auto req = mValueObjectPool->obtainFloat(bc_ccm_nm_bit);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ccm_livecounter_0x66_bWatcher() {
  float bc_ccm_livecounter_0x66_b = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ccm_livecounter_0x66_b");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ccm_livecounter_0x66_b = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_ccm_livecounter_0x66_bReq(bc_ccm_livecounter_0x66_b),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ccm_livecounter_0x66_bReq(float bc_ccm_livecounter_0x66_b) {
    auto req = mValueObjectPool->obtainFloat(bc_ccm_livecounter_0x66_b);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ccm_checksum_0x66_bWatcher() {
  float bc_ccm_checksum_0x66_b = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ccm_checksum_0x66_b");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ccm_checksum_0x66_b = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_ccm_checksum_0x66_bReq(bc_ccm_checksum_0x66_b),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ccm_checksum_0x66_bReq(float bc_ccm_checksum_0x66_b) {
    auto req = mValueObjectPool->obtainFloat(bc_ccm_checksum_0x66_b);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}



void GarageModeServerSideHandlerImpl::bc_avas_stateWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_avas_state = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_avas_state");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_avas_state = static_cast<int32_t>(mPropertyManager->getCProValue(mp));;
      mHal->onPropertyValue(*Create_bc_avas_stateReq(bc_avas_state),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_avas_stateReq(int32_t bc_avas_state) {
    auto req = mValueObjectPool->obtainInt32(bc_avas_state);
    req->prop = toInt(VehicleProperty::GECKO_LOW_SPEED_PEDESTRIAN_WARNING);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_avas_livecounter_0x411Watcher() {
  float bc_avas_livecounter_0x411 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_avas_livecounter_0x411");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_avas_livecounter_0x411 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_avas_livecounter_0x411Req(bc_avas_livecounter_0x411),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_avas_livecounter_0x411Req(float bc_avas_livecounter_0x411) {
    auto req = mValueObjectPool->obtainFloat(bc_avas_livecounter_0x411);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_avas_checksum_0x411Watcher() {
  float bc_avas_checksum_0x411 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_avas_checksum_0x411");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_avas_checksum_0x411 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_avas_checksum_0x411Req(bc_avas_checksum_0x411),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_avas_checksum_0x411Req(float bc_avas_checksum_0x411) {
    auto req = mValueObjectPool->obtainFloat(bc_avas_checksum_0x411);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_bcm_ccm_reset_stWatcher() {
  float bc_bcm_ccm_reset_st = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_ccm_reset_st");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_ccm_reset_st = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_bcm_ccm_reset_stReq(bc_bcm_ccm_reset_st),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_ccm_reset_stReq(float bc_bcm_ccm_reset_st) {
    auto req = mValueObjectPool->obtainFloat(bc_bcm_ccm_reset_st);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ota_modelWatcher() {
  float bc_ota_model = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ota_model");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ota_model = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_ota_modelReq(bc_ota_model),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ota_modelReq(float bc_ota_model) {
    auto req = mValueObjectPool->obtainFloat(bc_ota_model);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ccm_bcm_open_door_warn_setWatcher() {
  float bc_ccm_bcm_open_door_warn_set = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ccm_bcm_open_door_warn_set");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ccm_bcm_open_door_warn_set = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_ccm_bcm_open_door_warn_setReq(bc_ccm_bcm_open_door_warn_set),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ccm_bcm_open_door_warn_setReq(float bc_ccm_bcm_open_door_warn_set) {
    auto req = mValueObjectPool->obtainFloat(bc_ccm_bcm_open_door_warn_set);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ccm_livecounter_0x353Watcher() {
  float bc_ccm_livecounter_0x353 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ccm_livecounter_0x353");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ccm_livecounter_0x353 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_ccm_livecounter_0x353Req(bc_ccm_livecounter_0x353),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ccm_livecounter_0x353Req(float bc_ccm_livecounter_0x353) {
    auto req = mValueObjectPool->obtainFloat(bc_ccm_livecounter_0x353);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ccm_checksum_0x353Watcher() {
  float bc_ccm_checksum_0x353 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ccm_checksum_0x353");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ccm_checksum_0x353 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_ccm_checksum_0x353Req(bc_ccm_checksum_0x353),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ccm_checksum_0x353Req(float bc_ccm_checksum_0x353) {
    auto req = mValueObjectPool->obtainFloat(bc_ccm_checksum_0x353);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ccm_tpms_learning_validWatcher() {
  float bc_ccm_tpms_learning_valid = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ccm_tpms_learning_valid");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ccm_tpms_learning_valid = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_ccm_tpms_learning_validReq(bc_ccm_tpms_learning_valid),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ccm_tpms_learning_validReq(float bc_ccm_tpms_learning_valid) {
    auto req = mValueObjectPool->obtainFloat(bc_ccm_tpms_learning_valid);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ccm_remt_ctrl_flagWatcher() {
  float bc_ccm_remt_ctrl_flag = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ccm_remt_ctrl_flag");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ccm_remt_ctrl_flag = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_ccm_remt_ctrl_flagReq(bc_ccm_remt_ctrl_flag),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ccm_remt_ctrl_flagReq(float bc_ccm_remt_ctrl_flag) {
    auto req = mValueObjectPool->obtainFloat(bc_ccm_remt_ctrl_flag);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ccm_livecounter_0x354Watcher() {
  float bc_ccm_livecounter_0x354 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ccm_livecounter_0x354");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ccm_livecounter_0x354 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_ccm_livecounter_0x354Req(bc_ccm_livecounter_0x354),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ccm_livecounter_0x354Req(float bc_ccm_livecounter_0x354) {
    auto req = mValueObjectPool->obtainFloat(bc_ccm_livecounter_0x354);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ccm_checksum_0x354Watcher() {
  float bc_ccm_checksum_0x354 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ccm_checksum_0x354");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ccm_checksum_0x354 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_ccm_checksum_0x354Req(bc_ccm_checksum_0x354),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ccm_checksum_0x354Req(float bc_ccm_checksum_0x354) {
    auto req = mValueObjectPool->obtainFloat(bc_ccm_checksum_0x354);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_tpms_receiverstateWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_tpms_receiverstate = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_tpms_receiverstate");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_tpms_receiverstate = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_bc_tpms_receiverstateReq(bc_tpms_receiverstate),true);
  }
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_tpms_receiverstateReq(int32_t bc_tpms_receiverstate) {
    auto req = mValueObjectPool->obtainInt32(bc_tpms_receiverstate);
    req->prop = toInt(VehicleProperty::GECKO_TYRE_STATE);
    req->areaId = WHEEL_TYRE_RECEIVERSTATE;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_tpms_transducer_locationWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_tpms_transducer_location = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_tpms_transducer_location");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_tpms_transducer_location = static_cast<int32_t>(std::atoi(mp->valueMap[mPropertyManager->getCProValue(mp)].c_str()));
      mHal->onPropertyValue(*Create_bc_tpms_transducer_locationReq(bc_tpms_transducer_location),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_tpms_transducer_locationReq(int32_t bc_tpms_transducer_location) {
    auto req = mValueObjectPool->obtainInt32(bc_tpms_transducer_location);
    req->prop = toInt(VehicleProperty::GECKO_TRANSDUCER_LOCATION);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}


void GarageModeServerSideHandlerImpl::bc_tpms_tyrestate_frWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_tpms_tyrestate_fr = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_tpms_tyrestate_fr");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_tpms_tyrestate_fr = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_bc_tpms_tyrestate_frReq(bc_tpms_tyrestate_fr),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_tpms_tyrestate_frReq(int32_t bc_tpms_tyrestate_fr) {
    auto req = mValueObjectPool->obtainInt32(bc_tpms_tyrestate_fr);
    req->prop = toInt(VehicleProperty::GECKO_TYRE_STATE);
    req->areaId = WHEEL_FRONT_RIGHT;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}


void GarageModeServerSideHandlerImpl::bc_tpms_tyrestate_flWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_tpms_tyrestate_fl = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_tpms_tyrestate_fl");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_tpms_tyrestate_fl = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_bc_tpms_tyrestate_flReq(bc_tpms_tyrestate_fl),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_tpms_tyrestate_flReq(int32_t bc_tpms_tyrestate_fl) {
    auto req = mValueObjectPool->obtainInt32(bc_tpms_tyrestate_fl);
    req->prop = toInt(VehicleProperty::GECKO_TYRE_STATE);
    req->areaId = WHEEL_FRONT_LEFT;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_tpms_tyrestate_rlWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_tpms_tyrestate_rl = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_tpms_tyrestate_rl");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_tpms_tyrestate_rl = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_bc_tpms_tyrestate_rlReq(bc_tpms_tyrestate_rl),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_tpms_tyrestate_rlReq(int32_t bc_tpms_tyrestate_rl) {
    auto req = mValueObjectPool->obtainInt32(bc_tpms_tyrestate_rl);
    req->prop = toInt(VehicleProperty::GECKO_TYRE_STATE);
    req->areaId = WHEEL_REAR_LEFT;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_tpms_tyrestate_rrWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_tpms_tyrestate_rr = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_tpms_tyrestate_rr");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_tpms_tyrestate_rr = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_bc_tpms_tyrestate_rrReq(bc_tpms_tyrestate_rr),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_tpms_tyrestate_rrReq(int32_t bc_tpms_tyrestate_rr) {
    auto req = mValueObjectPool->obtainInt32(bc_tpms_tyrestate_rr);
    req->prop = toInt(VehicleProperty::GECKO_TYRE_STATE);
    req->areaId = WHEEL_REAR_RIGHT;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}


void GarageModeServerSideHandlerImpl::bc_tpms_tyretemperatureWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  float bc_tpms_tyretemperature = 0.0;
  int32_t current_tyre = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_tpms_tyretemperature");
  ConfigDBC* currentTyreCDBC = mPropertyManager->findCProperty("bc_tpms_transducer_location");
  // bc_tpms_transducer_location
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      // 获取到当前轮胎的ID 
      current_tyre = static_cast<int32_t> (std::atoi(currentTyreCDBC->valueMap[mPropertyManager->getCProValue(currentTyreCDBC)].c_str()));
      LOG(INFO) << "dxy-- handler 1 atoi bc_tpms_transducer_location: "<<current_tyre;
      // 获取胎压温度
      bc_tpms_tyretemperature = getActualFloatValue(static_cast<int32_t>(mPropertyManager->getCProValue(mp)),1,-40);
      LOG(INFO) << "dxy-- handler : bc_tpms_tyretemperature"<<bc_tpms_tyretemperature;
      mHal->onPropertyValue(*Create_bc_tpms_tyretemperatureReq(bc_tpms_tyretemperature,current_tyre),true);

      // std::unique_lock<std::mutex> lock(bcTpmsTyretemperatureMtx);
      // 使用条件变量等待1秒，如果在等待期间没有被唤醒，表示一秒钟没有执行
      // if (bcTpmsTyretemperatureCv.wait_for(lock, std::chrono::seconds(monitorTime)) == std::cv_status::timeout) {
      //       mHal->onPropertyValue(*Create_bc_tpms_tyretemperatureReq(invalidValueFloat,1),true);
      //       mHal->onPropertyValue(*Create_bc_tpms_tyretemperatureReq(invalidValueFloat,2),true);
      //       mHal->onPropertyValue(*Create_bc_tpms_tyretemperatureReq(invalidValueFloat,4),true);
      //       mHal->onPropertyValue(*Create_bc_tpms_tyretemperatureReq(invalidValueFloat,8),true);
      // }else {
      //        std::cout << "bc_tpms_tyretemperature have value.\n" << std::endl;
      // }
      
      // 监听各轮胎如果超出一秒没有收到信号，这将其赋值为-1024.0,在上层的表现为显示 --      
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_tpms_tyretemperatureReq(float bc_tpms_tyretemperature,int current_tyre) {
    auto req = mValueObjectPool->obtainInt32(static_cast<int32_t> (bc_tpms_tyretemperature));
    // LOG(INFO) << "dxy-- to insert  :areaId = "<< current_tyre << " bc_tpms_tyretemperature = "<<bc_tpms_tyretemperature << " id = " << toInt(VehicleProperty::GECKO_TYRE_TEMPERATURE);
    req->prop = toInt(VehicleProperty::GECKO_TYRE_TEMPERATURE);
    req->areaId = current_tyre;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}


void GarageModeServerSideHandlerImpl::bc_tpms_tyrepressure_flWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  float bc_tpms_tyrepressure_fl = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_tpms_tyrepressure_fl");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_tpms_tyrepressure_fl = getActualFloatValue(mPropertyManager->getCProValue(mp),0.03,0);
      mHal->onPropertyValue(*Create_bc_tpms_tyrepressure_flReq(bc_tpms_tyrepressure_fl),true);

  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_tpms_tyrepressure_flReq(float bc_tpms_tyrepressure_fl) {
    auto req = mValueObjectPool->obtainFloat(bc_tpms_tyrepressure_fl);
    req->prop = toInt(VehicleProperty::TIRE_PRESSURE);
    req->areaId = WHEEL_FRONT_LEFT;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_tpms_tyrepressure_frWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  float bc_tpms_tyrepressure_fr = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_tpms_tyrepressure_fr");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_tpms_tyrepressure_fr = getActualFloatValue(mPropertyManager->getCProValue(mp),0.03,0);
      mHal->onPropertyValue(*Create_bc_tpms_tyrepressure_frReq(bc_tpms_tyrepressure_fr),true);

  }
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_tpms_tyrepressure_frReq(float bc_tpms_tyrepressure_fr) {
    auto req = mValueObjectPool->obtainFloat(bc_tpms_tyrepressure_fr);
    req->prop = toInt(VehicleProperty::TIRE_PRESSURE);
    req->areaId = WHEEL_FRONT_RIGHT;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}


void GarageModeServerSideHandlerImpl::bc_tpms_tyrepressure_rrWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  float bc_tpms_tyrepressure_rr = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_tpms_tyrepressure_rr");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_tpms_tyrepressure_rr = getActualFloatValue(mPropertyManager->getCProValue(mp),0.03,0);
      mHal->onPropertyValue(*Create_bc_tpms_tyrepressure_rrReq(bc_tpms_tyrepressure_rr),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_tpms_tyrepressure_rrReq(float bc_tpms_tyrepressure_rr) {
    auto req = mValueObjectPool->obtainFloat(bc_tpms_tyrepressure_rr);
    req->prop = toInt(VehicleProperty::TIRE_PRESSURE);
    req->areaId = WHEEL_REAR_RIGHT;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_tpms_tyrepressure_rlWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  float bc_tpms_tyrepressure_rl = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_tpms_tyrepressure_rl");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_tpms_tyrepressure_rl = getActualFloatValue(mPropertyManager->getCProValue(mp),0.03,0);
      mHal->onPropertyValue(*Create_bc_tpms_tyrepressure_rlReq(bc_tpms_tyrepressure_rl),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_tpms_tyrepressure_rlReq(float bc_tpms_tyrepressure_rl) {
    auto req = mValueObjectPool->obtainFloat(bc_tpms_tyrepressure_rl);
    req->prop = toInt(VehicleProperty::TIRE_PRESSURE);
    req->areaId = WHEEL_REAR_LEFT;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_acu_gsensor_faultWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t cc_acu_gsensor_fault = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_acu_gsensor_fault");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_acu_gsensor_fault = mPropertyManager->getCProValue(mp);
      LOG(INFO) << "cc_acu_gsensor_fault:"<<cc_acu_gsensor_fault;
      mHal->onPropertyValue(*Create_cc_acu_gsensor_faultReq(cc_acu_gsensor_fault),true);
      mHal->onPropertyValue(*Create_electric_errReq(getElectricErr()),true);

  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_acu_gsensor_faultReq(int32_t cc_acu_gsensor_fault) {
    auto req = mValueObjectPool->obtainInt32(cc_acu_gsensor_fault);
    req->prop = toInt(VehicleProperty::GECKO_ACU_GSENSOR_FAULT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_acu_system_stsWatcher() {
  float cc_acu_system_sts = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_acu_system_sts");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_acu_system_sts = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_acu_system_stsReq(cc_acu_system_sts),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_acu_system_stsReq(float cc_acu_system_sts) {
    auto req = mValueObjectPool->obtainFloat(cc_acu_system_sts);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_acu_airb_warn_lamp_stWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t cc_acu_airb_warn_lamp_st = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_acu_airb_warn_lamp_st");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_acu_airb_warn_lamp_st = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_cc_acu_airb_warn_lamp_stReq(cc_acu_airb_warn_lamp_st),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_acu_airb_warn_lamp_stReq(int32_t cc_acu_airb_warn_lamp_st) {
    auto req = mValueObjectPool->obtainInt32(cc_acu_airb_warn_lamp_st);
    req->prop = toInt(VehicleProperty::GECKO_ACU_AIRB_WARN_LAMP_ST);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_acu_crash_outp_stsWatcher() {
  float cc_acu_crash_outp_sts = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_acu_crash_outp_sts");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_acu_crash_outp_sts = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_acu_crash_outp_stsReq(cc_acu_crash_outp_sts),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_acu_crash_outp_stsReq(float cc_acu_crash_outp_sts) {
    auto req = mValueObjectPool->obtainFloat(cc_acu_crash_outp_sts);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_acu_livecounter_0x133Watcher() {
  float cc_acu_livecounter_0x133 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_acu_livecounter_0x133");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_acu_livecounter_0x133 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_acu_livecounter_0x133Req(cc_acu_livecounter_0x133),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_acu_livecounter_0x133Req(float cc_acu_livecounter_0x133) {
    auto req = mValueObjectPool->obtainFloat(cc_acu_livecounter_0x133);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_acu_checksum_0x133Watcher() {
  float cc_acu_checksum_0x133 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_acu_checksum_0x133");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_acu_checksum_0x133 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_acu_checksum_0x133Req(cc_acu_checksum_0x133),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_acu_checksum_0x133Req(float cc_acu_checksum_0x133) {
    auto req = mValueObjectPool->obtainFloat(cc_acu_checksum_0x133);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::cc_abs_abs_fail_statusWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t cc_abs_abs_fail_status = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_abs_abs_fail_status");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_abs_abs_fail_status = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      LOG(INFO) << "dxy----cc_abs_abs_fail_status:"<<cc_abs_abs_fail_status;
      mHal->onPropertyValue(*Create_cc_abs_abs_fail_statusReq(cc_abs_abs_fail_status),true);
  }
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_abs_abs_fail_statusReq(int32_t cc_abs_abs_fail_status) {
    auto req = mValueObjectPool->obtainInt32(cc_abs_abs_fail_status);
    req->prop = toInt(VehicleProperty::GECKO_ABS_ABS_FAIL_STATUS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::cc_abs_llivecounter_0x171Watcher() {
  float cc_abs_llivecounter_0x171 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_abs_llivecounter_0x171");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_abs_llivecounter_0x171 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_abs_llivecounter_0x171Req(cc_abs_llivecounter_0x171),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_abs_llivecounter_0x171Req(float cc_abs_llivecounter_0x171) {
    auto req = mValueObjectPool->obtainFloat(cc_abs_llivecounter_0x171);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_abs_checksum_0x171Watcher() {
  float cc_abs_checksum_0x171 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_abs_checksum_0x171");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_abs_checksum_0x171 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_abs_checksum_0x171Req(cc_abs_checksum_0x171),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_abs_checksum_0x171Req(float cc_abs_checksum_0x171) {
    auto req = mValueObjectPool->obtainFloat(cc_abs_checksum_0x171);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_eps_run_stateWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t cc_eps_run_state = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_eps_run_state");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_eps_run_state = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_cc_eps_run_stateReq(cc_eps_run_state),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_eps_run_stateReq(int32_t cc_eps_run_state) {
    auto req = mValueObjectPool->obtainInt32(cc_eps_run_state);
    req->prop = toInt(VehicleProperty::GECKO_EPS_RUN_STATE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::cc_eps_livecounter_0x300Watcher() {
  float cc_eps_livecounter_0x300 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_eps_livecounter_0x300");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_eps_livecounter_0x300 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_eps_livecounter_0x300Req(cc_eps_livecounter_0x300),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_eps_livecounter_0x300Req(float cc_eps_livecounter_0x300) {
    auto req = mValueObjectPool->obtainFloat(cc_eps_livecounter_0x300);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_eps_checksum_0x300Watcher() {
  float cc_eps_checksum_0x300 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_eps_checksum_0x300");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_eps_checksum_0x300 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_eps_checksum_0x300Req(cc_eps_checksum_0x300),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_eps_checksum_0x300Req(float cc_eps_checksum_0x300) {
    auto req = mValueObjectPool->obtainFloat(cc_eps_checksum_0x300);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_eps_motor_curr_fltWatcher() {
  float cc_eps_motor_curr_flt = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_eps_motor_curr_flt");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_eps_motor_curr_flt = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_eps_motor_curr_fltReq(cc_eps_motor_curr_flt),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_eps_motor_curr_fltReq(float cc_eps_motor_curr_flt) {
    auto req = mValueObjectPool->obtainFloat(cc_eps_motor_curr_flt);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_eps_motor_volt_fltWatcher() {
  float cc_eps_motor_volt_flt = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_eps_motor_volt_flt");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_eps_motor_volt_flt = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_eps_motor_volt_fltReq(cc_eps_motor_volt_flt),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_eps_motor_volt_fltReq(float cc_eps_motor_volt_flt) {
    auto req = mValueObjectPool->obtainFloat(cc_eps_motor_volt_flt);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_eps_torq_snr_s_sig_out_rng_fltWatcher() {
  float cc_eps_torq_snr_s_sig_out_rng_flt = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_eps_torq_snr_s_sig_out_rng_flt");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_eps_torq_snr_s_sig_out_rng_flt = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_eps_torq_snr_s_sig_out_rng_fltReq(cc_eps_torq_snr_s_sig_out_rng_flt),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_eps_torq_snr_s_sig_out_rng_fltReq(float cc_eps_torq_snr_s_sig_out_rng_flt) {
    auto req = mValueObjectPool->obtainFloat(cc_eps_torq_snr_s_sig_out_rng_flt);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_eps_torq_snr_p_sig_out_rng_fltWatcher() {
  float cc_eps_torq_snr_p_sig_out_rng_flt = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_eps_torq_snr_p_sig_out_rng_flt");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_eps_torq_snr_p_sig_out_rng_flt = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_eps_torq_snr_p_sig_out_rng_fltReq(cc_eps_torq_snr_p_sig_out_rng_flt),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_eps_torq_snr_p_sig_out_rng_fltReq(float cc_eps_torq_snr_p_sig_out_rng_flt) {
    auto req = mValueObjectPool->obtainFloat(cc_eps_torq_snr_p_sig_out_rng_flt);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_eps_torq_snr_t1_t2_sig_sync_fltWatcher() {
  float cc_eps_torq_snr_t1_t2_sig_sync_flt = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_eps_torq_snr_t1_t2_sig_sync_flt");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_eps_torq_snr_t1_t2_sig_sync_flt = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_eps_torq_snr_t1_t2_sig_sync_fltReq(cc_eps_torq_snr_t1_t2_sig_sync_flt),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_eps_torq_snr_t1_t2_sig_sync_fltReq(float cc_eps_torq_snr_t1_t2_sig_sync_flt) {
    auto req = mValueObjectPool->obtainFloat(cc_eps_torq_snr_t1_t2_sig_sync_flt);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_eps_torq_snr_t1_sig_out_rng_fltWatcher() {
  float cc_eps_torq_snr_t1_sig_out_rng_flt = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_eps_torq_snr_t1_sig_out_rng_flt");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_eps_torq_snr_t1_sig_out_rng_flt = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_eps_torq_snr_t1_sig_out_rng_fltReq(cc_eps_torq_snr_t1_sig_out_rng_flt),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_eps_torq_snr_t1_sig_out_rng_fltReq(float cc_eps_torq_snr_t1_sig_out_rng_flt) {
    auto req = mValueObjectPool->obtainFloat(cc_eps_torq_snr_t1_sig_out_rng_flt);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_eps_torq_snr_t2_sig_out_rng_fltWatcher() {
  float cc_eps_torq_snr_t2_sig_out_rng_flt = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_eps_torq_snr_t2_sig_out_rng_flt");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_eps_torq_snr_t2_sig_out_rng_flt = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_eps_torq_snr_t2_sig_out_rng_fltReq(cc_eps_torq_snr_t2_sig_out_rng_flt),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_eps_torq_snr_t2_sig_out_rng_fltReq(float cc_eps_torq_snr_t2_sig_out_rng_flt) {
    auto req = mValueObjectPool->obtainFloat(cc_eps_torq_snr_t2_sig_out_rng_flt);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_eps_torq_snr5_v_fltWatcher() {
  float cc_eps_torq_snr5_v_flt = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_eps_torq_snr5_v_flt");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_eps_torq_snr5_v_flt = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_eps_torq_snr5_v_fltReq(cc_eps_torq_snr5_v_flt),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_eps_torq_snr5_v_fltReq(float cc_eps_torq_snr5_v_flt) {
    auto req = mValueObjectPool->obtainFloat(cc_eps_torq_snr5_v_flt);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_eps_can_bus_fltWatcher() {
  float cc_eps_can_bus_flt = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_eps_can_bus_flt");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_eps_can_bus_flt = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_eps_can_bus_fltReq(cc_eps_can_bus_flt),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_eps_can_bus_fltReq(float cc_eps_can_bus_flt) {
    auto req = mValueObjectPool->obtainFloat(cc_eps_can_bus_flt);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_eps_over_volt_fltWatcher() {
  float cc_eps_over_volt_flt = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_eps_over_volt_flt");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_eps_over_volt_flt = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_eps_over_volt_fltReq(cc_eps_over_volt_flt),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_eps_over_volt_fltReq(float cc_eps_over_volt_flt) {
    auto req = mValueObjectPool->obtainFloat(cc_eps_over_volt_flt);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_eps_under_volt_fltWatcher() {
  float cc_eps_under_volt_flt = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_eps_under_volt_flt");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_eps_under_volt_flt = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_eps_under_volt_fltReq(cc_eps_under_volt_flt),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_eps_under_volt_fltReq(float cc_eps_under_volt_flt) {
    auto req = mValueObjectPool->obtainFloat(cc_eps_under_volt_flt);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_eps_uncalibrated_angle_fltWatcher() {
  float cc_eps_uncalibrated_angle_flt = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_eps_uncalibrated_angle_flt");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_eps_uncalibrated_angle_flt = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_eps_uncalibrated_angle_fltReq(cc_eps_uncalibrated_angle_flt),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_eps_uncalibrated_angle_fltReq(float cc_eps_uncalibrated_angle_flt) {
    auto req = mValueObjectPool->obtainFloat(cc_eps_uncalibrated_angle_flt);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_eps_over_heat_fltWatcher() {
  float cc_eps_over_heat_flt = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_eps_over_heat_flt");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_eps_over_heat_flt = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_eps_over_heat_fltReq(cc_eps_over_heat_flt),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_eps_over_heat_fltReq(float cc_eps_over_heat_flt) {
    auto req = mValueObjectPool->obtainFloat(cc_eps_over_heat_flt);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_eps_relay_fltWatcher() {
  float cc_eps_relay_flt = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_eps_relay_flt");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_eps_relay_flt = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_eps_relay_fltReq(cc_eps_relay_flt),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_eps_relay_fltReq(float cc_eps_relay_flt) {
    auto req = mValueObjectPool->obtainFloat(cc_eps_relay_flt);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_eps_motor_curr_fellow_fltWatcher() {
  float cc_eps_motor_curr_fellow_flt = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_eps_motor_curr_fellow_flt");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_eps_motor_curr_fellow_flt = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_eps_motor_curr_fellow_fltReq(cc_eps_motor_curr_fellow_flt),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_eps_motor_curr_fellow_fltReq(float cc_eps_motor_curr_fellow_flt) {
    auto req = mValueObjectPool->obtainFloat(cc_eps_motor_curr_fellow_flt);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_eps_motor_drv_fltWatcher() {
  float cc_eps_motor_drv_flt = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_eps_motor_drv_flt");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_eps_motor_drv_flt = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_eps_motor_drv_fltReq(cc_eps_motor_drv_flt),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_eps_motor_drv_fltReq(float cc_eps_motor_drv_flt) {
    auto req = mValueObjectPool->obtainFloat(cc_eps_motor_drv_flt);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_eps_vcu_time_out_fltWatcher() {
  float cc_eps_vcu_time_out_flt = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_eps_vcu_time_out_flt");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_eps_vcu_time_out_flt = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_eps_vcu_time_out_fltReq(cc_eps_vcu_time_out_flt),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_eps_vcu_time_out_fltReq(float cc_eps_vcu_time_out_flt) {
    auto req = mValueObjectPool->obtainFloat(cc_eps_vcu_time_out_flt);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_eps_livecounter_0x301Watcher() {
  float cc_eps_livecounter_0x301 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_eps_livecounter_0x301");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_eps_livecounter_0x301 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_eps_livecounter_0x301Req(cc_eps_livecounter_0x301),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_eps_livecounter_0x301Req(float cc_eps_livecounter_0x301) {
    auto req = mValueObjectPool->obtainFloat(cc_eps_livecounter_0x301);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_eps_checksum_0x301Watcher() {
  float cc_eps_checksum_0x301 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_eps_checksum_0x301");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_eps_checksum_0x301 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_eps_checksum_0x301Req(cc_eps_checksum_0x301),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_eps_checksum_0x301Req(float cc_eps_checksum_0x301) {
    auto req = mValueObjectPool->obtainFloat(cc_eps_checksum_0x301);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_abs_wheel_speed_fr_no_signal_errWatcher() {
  float cc_abs_wheel_speed_fr_no_signal_err = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_abs_wheel_speed_fr_no_signal_err");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_abs_wheel_speed_fr_no_signal_err = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_abs_wheel_speed_fr_no_signal_errReq(cc_abs_wheel_speed_fr_no_signal_err),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_abs_wheel_speed_fr_no_signal_errReq(float cc_abs_wheel_speed_fr_no_signal_err) {
    auto req = mValueObjectPool->obtainFloat(cc_abs_wheel_speed_fr_no_signal_err);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_abs_wheel_speed_fr_interm_errWatcher() {
  float cc_abs_wheel_speed_fr_interm_err = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_abs_wheel_speed_fr_interm_err");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_abs_wheel_speed_fr_interm_err = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_abs_wheel_speed_fr_interm_errReq(cc_abs_wheel_speed_fr_interm_err),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_abs_wheel_speed_fr_interm_errReq(float cc_abs_wheel_speed_fr_interm_err) {
    auto req = mValueObjectPool->obtainFloat(cc_abs_wheel_speed_fr_interm_err);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_abs_wheel_speed_fr_open_short_errWatcher() {
  float cc_abs_wheel_speed_fr_open_short_err = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_abs_wheel_speed_fr_open_short_err");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_abs_wheel_speed_fr_open_short_err = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_abs_wheel_speed_fr_open_short_errReq(cc_abs_wheel_speed_fr_open_short_err),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_abs_wheel_speed_fr_open_short_errReq(float cc_abs_wheel_speed_fr_open_short_err) {
    auto req = mValueObjectPool->obtainFloat(cc_abs_wheel_speed_fr_open_short_err);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_abs_wheel_speed_fl_no_signal_errWatcher() {
  float cc_abs_wheel_speed_fl_no_signal_err = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_abs_wheel_speed_fl_no_signal_err");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_abs_wheel_speed_fl_no_signal_err = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_abs_wheel_speed_fl_no_signal_errReq(cc_abs_wheel_speed_fl_no_signal_err),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_abs_wheel_speed_fl_no_signal_errReq(float cc_abs_wheel_speed_fl_no_signal_err) {
    auto req = mValueObjectPool->obtainFloat(cc_abs_wheel_speed_fl_no_signal_err);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_abs_wheel_speed_fl_interm_errWatcher() {
  float cc_abs_wheel_speed_fl_interm_err = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_abs_wheel_speed_fl_interm_err");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_abs_wheel_speed_fl_interm_err = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_abs_wheel_speed_fl_interm_errReq(cc_abs_wheel_speed_fl_interm_err),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_abs_wheel_speed_fl_interm_errReq(float cc_abs_wheel_speed_fl_interm_err) {
    auto req = mValueObjectPool->obtainFloat(cc_abs_wheel_speed_fl_interm_err);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_abs_wheel_speed_fl_open_short_errWatcher() {
  float cc_abs_wheel_speed_fl_open_short_err = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_abs_wheel_speed_fl_open_short_err");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_abs_wheel_speed_fl_open_short_err = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_abs_wheel_speed_fl_open_short_errReq(cc_abs_wheel_speed_fl_open_short_err),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_abs_wheel_speed_fl_open_short_errReq(float cc_abs_wheel_speed_fl_open_short_err) {
    auto req = mValueObjectPool->obtainFloat(cc_abs_wheel_speed_fl_open_short_err);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_abs_power_undervoltWatcher() {
  float cc_abs_power_undervolt = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_abs_power_undervolt");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_abs_power_undervolt = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_abs_power_undervoltReq(cc_abs_power_undervolt),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_abs_power_undervoltReq(float cc_abs_power_undervolt) {
    auto req = mValueObjectPool->obtainFloat(cc_abs_power_undervolt);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_abs_power_overvoltWatcher() {
  float cc_abs_power_overvolt = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_abs_power_overvolt");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_abs_power_overvolt = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_abs_power_overvoltReq(cc_abs_power_overvolt),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_abs_power_overvoltReq(float cc_abs_power_overvolt) {
    auto req = mValueObjectPool->obtainFloat(cc_abs_power_overvolt);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_abs_valve_relay_errWatcher() {
  float cc_abs_valve_relay_err = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_abs_valve_relay_err");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_abs_valve_relay_err = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_abs_valve_relay_errReq(cc_abs_valve_relay_err),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_abs_valve_relay_errReq(float cc_abs_valve_relay_err) {
    auto req = mValueObjectPool->obtainFloat(cc_abs_valve_relay_err);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_abs_wheel_speed_freq_errWatcher() {
  float cc_abs_wheel_speed_freq_err = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_abs_wheel_speed_freq_err");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_abs_wheel_speed_freq_err = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_abs_wheel_speed_freq_errReq(cc_abs_wheel_speed_freq_err),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_abs_wheel_speed_freq_errReq(float cc_abs_wheel_speed_freq_err) {
    auto req = mValueObjectPool->obtainFloat(cc_abs_wheel_speed_freq_err);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_abs_wheel_speed_rr_no_signal_errWatcher() {
  float cc_abs_wheel_speed_rr_no_signal_err = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_abs_wheel_speed_rr_no_signal_err");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_abs_wheel_speed_rr_no_signal_err = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_abs_wheel_speed_rr_no_signal_errReq(cc_abs_wheel_speed_rr_no_signal_err),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_abs_wheel_speed_rr_no_signal_errReq(float cc_abs_wheel_speed_rr_no_signal_err) {
    auto req = mValueObjectPool->obtainFloat(cc_abs_wheel_speed_rr_no_signal_err);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_abs_wheel_speed_rr_interm_errWatcher() {
  float cc_abs_wheel_speed_rr_interm_err = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_abs_wheel_speed_rr_interm_err");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_abs_wheel_speed_rr_interm_err = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_abs_wheel_speed_rr_interm_errReq(cc_abs_wheel_speed_rr_interm_err),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_abs_wheel_speed_rr_interm_errReq(float cc_abs_wheel_speed_rr_interm_err) {
    auto req = mValueObjectPool->obtainFloat(cc_abs_wheel_speed_rr_interm_err);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_abs_wheel_speed_rr_open_short_errWatcher() {
  float cc_abs_wheel_speed_rr_open_short_err = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_abs_wheel_speed_rr_open_short_err");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_abs_wheel_speed_rr_open_short_err = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_abs_wheel_speed_rr_open_short_errReq(cc_abs_wheel_speed_rr_open_short_err),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_abs_wheel_speed_rr_open_short_errReq(float cc_abs_wheel_speed_rr_open_short_err) {
    auto req = mValueObjectPool->obtainFloat(cc_abs_wheel_speed_rr_open_short_err);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_abs_wheel_speed_rl_no_signal_errWatcher() {
  float cc_abs_wheel_speed_rl_no_signal_err = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_abs_wheel_speed_rl_no_signal_err");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_abs_wheel_speed_rl_no_signal_err = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_abs_wheel_speed_rl_no_signal_errReq(cc_abs_wheel_speed_rl_no_signal_err),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_abs_wheel_speed_rl_no_signal_errReq(float cc_abs_wheel_speed_rl_no_signal_err) {
    auto req = mValueObjectPool->obtainFloat(cc_abs_wheel_speed_rl_no_signal_err);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_abs_wheel_speed_rl_interm_errWatcher() {
  float cc_abs_wheel_speed_rl_interm_err = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_abs_wheel_speed_rl_interm_err");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_abs_wheel_speed_rl_interm_err = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_abs_wheel_speed_rl_interm_errReq(cc_abs_wheel_speed_rl_interm_err),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_abs_wheel_speed_rl_interm_errReq(float cc_abs_wheel_speed_rl_interm_err) {
    auto req = mValueObjectPool->obtainFloat(cc_abs_wheel_speed_rl_interm_err);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_abs_wheel_speed_rl_open_short_errWatcher() {
  float cc_abs_wheel_speed_rl_open_short_err = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_abs_wheel_speed_rl_open_short_err");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_abs_wheel_speed_rl_open_short_err = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_abs_wheel_speed_rl_open_short_errReq(cc_abs_wheel_speed_rl_open_short_err),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_abs_wheel_speed_rl_open_short_errReq(float cc_abs_wheel_speed_rl_open_short_err) {
    auto req = mValueObjectPool->obtainFloat(cc_abs_wheel_speed_rl_open_short_err);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_abs_outlet_valve_rr_errWatcher() {
  float cc_abs_outlet_valve_rr_err = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_abs_outlet_valve_rr_err");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_abs_outlet_valve_rr_err = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_abs_outlet_valve_rr_errReq(cc_abs_outlet_valve_rr_err),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_abs_outlet_valve_rr_errReq(float cc_abs_outlet_valve_rr_err) {
    auto req = mValueObjectPool->obtainFloat(cc_abs_outlet_valve_rr_err);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_abs_inlet_valve_rr_errWatcher() {
  float cc_abs_inlet_valve_rr_err = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_abs_inlet_valve_rr_err");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_abs_inlet_valve_rr_err = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_abs_inlet_valve_rr_errReq(cc_abs_inlet_valve_rr_err),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_abs_inlet_valve_rr_errReq(float cc_abs_inlet_valve_rr_err) {
    auto req = mValueObjectPool->obtainFloat(cc_abs_inlet_valve_rr_err);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_abs_outlet_valve_rl_errWatcher() {
  float cc_abs_outlet_valve_rl_err = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_abs_outlet_valve_rl_err");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_abs_outlet_valve_rl_err = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_abs_outlet_valve_rl_errReq(cc_abs_outlet_valve_rl_err),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_abs_outlet_valve_rl_errReq(float cc_abs_outlet_valve_rl_err) {
    auto req = mValueObjectPool->obtainFloat(cc_abs_outlet_valve_rl_err);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_abs_inlet_valve_rl_errWatcher() {
  float cc_abs_inlet_valve_rl_err = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_abs_inlet_valve_rl_err");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_abs_inlet_valve_rl_err = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_abs_inlet_valve_rl_errReq(cc_abs_inlet_valve_rl_err),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_abs_inlet_valve_rl_errReq(float cc_abs_inlet_valve_rl_err) {
    auto req = mValueObjectPool->obtainFloat(cc_abs_inlet_valve_rl_err);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_abs_outlet_valve_fr_errWatcher() {
  float cc_abs_outlet_valve_fr_err = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_abs_outlet_valve_fr_err");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_abs_outlet_valve_fr_err = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_abs_outlet_valve_fr_errReq(cc_abs_outlet_valve_fr_err),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_abs_outlet_valve_fr_errReq(float cc_abs_outlet_valve_fr_err) {
    auto req = mValueObjectPool->obtainFloat(cc_abs_outlet_valve_fr_err);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_abs_inlet_valve_fr_errWatcher() {
  float cc_abs_inlet_valve_fr_err = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_abs_inlet_valve_fr_err");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_abs_inlet_valve_fr_err = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_abs_inlet_valve_fr_errReq(cc_abs_inlet_valve_fr_err),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_abs_inlet_valve_fr_errReq(float cc_abs_inlet_valve_fr_err) {
    auto req = mValueObjectPool->obtainFloat(cc_abs_inlet_valve_fr_err);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_abs_outlet_valve_fl_errWatcher() {
  float cc_abs_outlet_valve_fl_err = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_abs_outlet_valve_fl_err");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_abs_outlet_valve_fl_err = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_abs_outlet_valve_fl_errReq(cc_abs_outlet_valve_fl_err),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_abs_outlet_valve_fl_errReq(float cc_abs_outlet_valve_fl_err) {
    auto req = mValueObjectPool->obtainFloat(cc_abs_outlet_valve_fl_err);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_abs_inlet_valve_fl_errWatcher() {
  float cc_abs_inlet_valve_fl_err = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_abs_inlet_valve_fl_err");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_abs_inlet_valve_fl_err = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_abs_inlet_valve_fl_errReq(cc_abs_inlet_valve_fl_err),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_abs_inlet_valve_fl_errReq(float cc_abs_inlet_valve_fl_err) {
    auto req = mValueObjectPool->obtainFloat(cc_abs_inlet_valve_fl_err);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_abs_current_max_fault_levelWatcher() {
  float cc_abs_current_max_fault_level = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_abs_current_max_fault_level");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_abs_current_max_fault_level = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_abs_current_max_fault_levelReq(cc_abs_current_max_fault_level),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_abs_current_max_fault_levelReq(float cc_abs_current_max_fault_level) {
    auto req = mValueObjectPool->obtainFloat(cc_abs_current_max_fault_level);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_abs_can_bus_off_errWatcher() {
  float cc_abs_can_bus_off_err = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_abs_can_bus_off_err");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_abs_can_bus_off_err = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_abs_can_bus_off_errReq(cc_abs_can_bus_off_err),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_abs_can_bus_off_errReq(float cc_abs_can_bus_off_err) {
    auto req = mValueObjectPool->obtainFloat(cc_abs_can_bus_off_err);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_abs_can_hardware_errWatcher() {
  float cc_abs_can_hardware_err = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_abs_can_hardware_err");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_abs_can_hardware_err = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_abs_can_hardware_errReq(cc_abs_can_hardware_err),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_abs_can_hardware_errReq(float cc_abs_can_hardware_err) {
    auto req = mValueObjectPool->obtainFloat(cc_abs_can_hardware_err);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_abs_ecu_hardware_errWatcher() {
  float cc_abs_ecu_hardware_err = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_abs_ecu_hardware_err");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_abs_ecu_hardware_err = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_abs_ecu_hardware_errReq(cc_abs_ecu_hardware_err),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_abs_ecu_hardware_errReq(float cc_abs_ecu_hardware_err) {
    auto req = mValueObjectPool->obtainFloat(cc_abs_ecu_hardware_err);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_abs_motor_relay_errWatcher() {
  float cc_abs_motor_relay_err = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_abs_motor_relay_err");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_abs_motor_relay_err = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_abs_motor_relay_errReq(cc_abs_motor_relay_err),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_abs_motor_relay_errReq(float cc_abs_motor_relay_err) {
    auto req = mValueObjectPool->obtainFloat(cc_abs_motor_relay_err);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_abs_motor_errWatcher() {
  float cc_abs_motor_err = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_abs_motor_err");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_abs_motor_err = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_abs_motor_errReq(cc_abs_motor_err),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_abs_motor_errReq(float cc_abs_motor_err) {
    auto req = mValueObjectPool->obtainFloat(cc_abs_motor_err);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_abs_valve_errWatcher() {
  float cc_abs_valve_err = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_abs_valve_err");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_abs_valve_err = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_abs_valve_errReq(cc_abs_valve_err),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_abs_valve_errReq(float cc_abs_valve_err) {
    auto req = mValueObjectPool->obtainFloat(cc_abs_valve_err);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_abs_livecounter_0x420Watcher() {
  float cc_abs_livecounter_0x420 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_abs_livecounter_0x420");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_abs_livecounter_0x420 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_abs_livecounter_0x420Req(cc_abs_livecounter_0x420),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_abs_livecounter_0x420Req(float cc_abs_livecounter_0x420) {
    auto req = mValueObjectPool->obtainFloat(cc_abs_livecounter_0x420);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_abs_checksum_0x420Watcher() {
  float cc_abs_checksum_0x420 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_abs_checksum_0x420");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_abs_checksum_0x420 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_abs_checksum_0x420Req(cc_abs_checksum_0x420),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_abs_checksum_0x420Req(float cc_abs_checksum_0x420) {
    auto req = mValueObjectPool->obtainFloat(cc_abs_checksum_0x420);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::mc_lamplet_statusWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t mc_lamplet_status = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("mc_lamplet_status");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      mc_lamplet_status = static_cast<int32_t> (mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_mc_lamplet_statusReq(mc_lamplet_status),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_mc_lamplet_statusReq(int32_t mc_lamplet_status) {
    auto req = mValueObjectPool->obtainInt32(mc_lamplet_status);
    req->prop = toInt(VehicleProperty::GECKO_LAMPLET_STATUS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::mc_main_seat_pressure_statusWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t mc_main_seat_pressure_status = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("mc_main_seat_pressure_status");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      mc_main_seat_pressure_status = static_cast<int32_t> (mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_mc_main_seat_pressure_statusReq(mc_main_seat_pressure_status),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_mc_main_seat_pressure_statusReq(int32_t mc_main_seat_pressure_status) {
    auto req = mValueObjectPool->obtainInt32(mc_main_seat_pressure_status);
    req->prop = toInt(VehicleProperty::GECKO_MAIN_SEAT_PRESSURE_STATUS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::mc_brake_level_alarm_statusWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t mc_brake_level_alarm_status = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("mc_brake_level_alarm_status");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      mc_brake_level_alarm_status = static_cast<int32_t> (mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_mc_brake_level_alarm_statusReq(mc_brake_level_alarm_status),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_mc_brake_level_alarm_statusReq(int32_t mc_brake_level_alarm_status) {
    auto req = mValueObjectPool->obtainInt32(mc_brake_level_alarm_status);
    req->prop = toInt(VehicleProperty::GECKO_BRAKE_LEVEL_ALARM_STATUS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::mc_main_seat_safety_belt_statusWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t mc_main_seat_safety_belt_status = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("mc_main_seat_safety_belt_status");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      mc_main_seat_safety_belt_status = static_cast<int32_t> (mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_mc_main_seat_safety_belt_statusReq(mc_main_seat_safety_belt_status),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_mc_main_seat_safety_belt_statusReq(int32_t mc_main_seat_safety_belt_status) {
    auto req = mValueObjectPool->obtainInt32(mc_main_seat_safety_belt_status);
    req->prop = toInt(VehicleProperty::GECKO_MAIN_SEAT_SAFETY_BELT_STATUS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_srs_drv_seatbelt_buckle_validWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_srs_drv_seatbelt_buckle_valid = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_srs_drv_seatbelt_buckle_valid");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_srs_drv_seatbelt_buckle_valid = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_srs_drv_seatbelt_buckle_validReq(ec_srs_drv_seatbelt_buckle_valid),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_srs_drv_seatbelt_buckle_validReq(int32_t ec_srs_drv_seatbelt_buckle_valid) {
    auto req = mValueObjectPool->obtainInt32(ec_srs_drv_seatbelt_buckle_valid);
    req->prop = toInt(VehicleProperty::GECKO_MAIN_SEAT_SAFETY_BELT_VD);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_srs_mid_seat_belt_bucklestatusWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_srs_mid_seat_belt_bucklestatus = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_srs_mid_seat_belt_bucklestatus");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_srs_mid_seat_belt_bucklestatus = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_srs_mid_seat_belt_bucklestatusReq(ec_srs_mid_seat_belt_bucklestatus),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_srs_mid_seat_belt_bucklestatusReq(int32_t ec_srs_mid_seat_belt_bucklestatus) {
    auto req = mValueObjectPool->obtainInt32(ec_srs_mid_seat_belt_bucklestatus);
    req->prop = toInt(VehicleProperty::GECKO_SRS_MIDSEATBELTBUCKLESTATUS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_srs_mid_seat_belt_buckle_validWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_srs_mid_seat_belt_buckle_valid = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_srs_mid_seat_belt_buckle_valid");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_srs_mid_seat_belt_buckle_valid = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_srs_mid_seat_belt_buckle_validReq(ec_srs_mid_seat_belt_buckle_valid),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_srs_mid_seat_belt_buckle_validReq(int32_t ec_srs_mid_seat_belt_buckle_valid) {
    auto req = mValueObjectPool->obtainInt32(ec_srs_mid_seat_belt_buckle_valid);
    req->prop = toInt(VehicleProperty::GECKO_SRS_MIDSEATBELTBUCKLEVALID);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_srs_mid_seat_occupant_sensor_stsWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_srs_mid_seat_occupant_sensor_sts = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_srs_mid_seat_occupant_sensor_sts");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_srs_mid_seat_occupant_sensor_sts = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_srs_mid_seat_occupant_sensor_stsReq(ec_srs_mid_seat_occupant_sensor_sts),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_srs_mid_seat_occupant_sensor_stsReq(int32_t ec_srs_mid_seat_occupant_sensor_sts) {
    auto req = mValueObjectPool->obtainInt32(ec_srs_mid_seat_occupant_sensor_sts);
    req->prop = toInt(VehicleProperty::GECKO_SRS_MIDSEATOCCUPANTSENSORSTS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::mc_engine_statusWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t mc_engine_status = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("mc_engine_status");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      mc_engine_status = static_cast<int32_t> (mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_mc_engine_statusReq(mc_engine_status),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_mc_engine_statusReq(int32_t mc_engine_status) {
    auto req = mValueObjectPool->obtainInt32(mc_engine_status);
    req->prop = toInt(VehicleProperty::GECKO_ENGINE_STATUS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::mc_low_vol_battery_volWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  float mc_low_vol_battery_vol = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("mc_low_vol_battery_vol");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      mc_low_vol_battery_vol = getActualFloatValue(mPropertyManager->getCProValue(mp), 0.1, 0);
      mHal->onPropertyValue(*Create_mc_low_vol_battery_volReq(mc_low_vol_battery_vol),true);
      if(mc_low_vol_battery_vol < 1.0) {
          mPropertyManager->updateCAPropertyValue("sc_ccm_rechrgn_lv_req", "1");
      }
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_mc_low_vol_battery_volReq(float mc_low_vol_battery_vol) {
    auto req = mValueObjectPool->obtainFloat(mc_low_vol_battery_vol);
    req->prop = toInt(VehicleProperty::GECKO_LOW_VOL_BATTERY_VOL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::sc_ec_ccm_batt_maintain_ctr_cmdWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t sc_ec_ccm_batt_maintain_ctr_cmd = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("sc_ec_ccm_batt_maintain_ctr_cmd");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      sc_ec_ccm_batt_maintain_ctr_cmd = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_sc_ec_ccm_batt_maintain_ctr_cmdReq(sc_ec_ccm_batt_maintain_ctr_cmd),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_sc_ec_ccm_batt_maintain_ctr_cmdReq(int32_t sc_ec_ccm_batt_maintain_ctr_cmd) {
    auto req = mValueObjectPool->obtainInt32(sc_ec_ccm_batt_maintain_ctr_cmd);
    req->prop = toInt(VehicleProperty::GECKO_CCM_BATTMAINTAIN_CTR_CMD);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::sc_ec_ccm_batt_maintain_stsWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t sc_ec_ccm_batt_maintain_sts = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("sc_ec_ccm_batt_maintain_sts");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      sc_ec_ccm_batt_maintain_sts = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_sc_ec_ccm_batt_maintain_stsReq(sc_ec_ccm_batt_maintain_sts),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_sc_ec_ccm_batt_maintain_stsReq(int32_t sc_ec_ccm_batt_maintain_sts) {
    auto req = mValueObjectPool->obtainInt32(sc_ec_ccm_batt_maintain_sts);
    req->prop = toInt(VehicleProperty::GECKO_CCM_BATTMAINTAIN_STS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}


void GarageModeServerSideHandlerImpl::sc_ec_ccm_versionWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t sc_ec_ccm_version = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("sc_ec_ccm_version");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      sc_ec_ccm_version = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_sc_ec_ccm_versionReq(sc_ec_ccm_version),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_sc_ec_ccm_versionReq(int32_t sc_ec_ccm_version) {
    auto req = mValueObjectPool->obtainInt32(sc_ec_ccm_version);
    req->prop = toInt(VehicleProperty::GECKO_CCM_VERSION);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}


void GarageModeServerSideHandlerImpl::sc_ec_ccm_soc_sofeware_numWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t sc_ec_ccm_soc_sofeware_num = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("sc_ec_ccm_soc_sofeware_num");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      sc_ec_ccm_soc_sofeware_num = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_sc_ec_ccm_soc_sofeware_numReq(sc_ec_ccm_soc_sofeware_num),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_sc_ec_ccm_soc_sofeware_numReq(int32_t sc_ec_ccm_soc_sofeware_num) {
    auto req = mValueObjectPool->obtainInt32(sc_ec_ccm_soc_sofeware_num);
    req->prop = toInt(VehicleProperty::GECKO_CCM_SOC_SOFTWARE_NUM);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}


void GarageModeServerSideHandlerImpl::sc_ec_ccm_soc_hardware_numWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t sc_ec_ccm_soc_hardware_num = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("sc_ec_ccm_soc_hardware_num");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      sc_ec_ccm_soc_hardware_num = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_sc_ec_ccm_soc_hardware_numReq(sc_ec_ccm_soc_hardware_num),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_sc_ec_ccm_soc_hardware_numReq(int32_t sc_ec_ccm_soc_hardware_num) {
    auto req = mValueObjectPool->obtainInt32(sc_ec_ccm_soc_hardware_num);
    req->prop = toInt(VehicleProperty::GECKO_CCM_SOC_HARDWARE_NUM);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::sc_ec_ccm_mcu_software_numWatcher() {
  int32_t sc_ec_ccm_mcu_software_num = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("sc_ec_ccm_mcu_software_num");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      sc_ec_ccm_mcu_software_num = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_sc_ec_ccm_mcu_software_numReq(sc_ec_ccm_mcu_software_num),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_sc_ec_ccm_mcu_software_numReq(int32_t sc_ec_ccm_mcu_software_num) {
    auto req = mValueObjectPool->obtainInt32(sc_ec_ccm_mcu_software_num);
    req->prop = toInt(VehicleProperty::GECKO_CCM_MCU_SOFTWARE_NUM);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::sc_ec_ccm_mcu_hardware_numWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  std::string value = "";
  ConfigDBC* mp = mPropertyManager->findCProperty("sc_ec_ccm_mcu_hardware_num");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      value = mPropertyManager->getCProStrValue(mp);
      LOG(INFO) << "mcu_hardware_num:"<<value;
      android::base::SetProperty("gecko.mcu.hardware.version", value);
      android::base::SetProperty("gecko.soc.hardware.version", value);
      //mHal->onPropertyValue(*Create_sc_ec_ccm_mcu_hardware_numReq(sc_ec_ccm_mcu_hardware_num),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_sc_ec_ccm_mcu_hardware_numReq(int32_t sc_ec_ccm_mcu_hardware_num) {
    auto req = mValueObjectPool->obtainInt32(sc_ec_ccm_mcu_hardware_num);
    req->prop = toInt(VehicleProperty::GECKO_CCM_MCU_HARDWARE_NUM);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::sc_ec_ccm_target_chrg_currWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t sc_ec_ccm_target_chrg_curr = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("sc_ec_ccm_target_chrg_curr");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      sc_ec_ccm_target_chrg_curr = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_sc_ec_ccm_target_chrg_currReq(sc_ec_ccm_target_chrg_curr),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_sc_ec_ccm_target_chrg_currReq(int32_t sc_ec_ccm_target_chrg_curr) {
    auto req = mValueObjectPool->obtainInt32(sc_ec_ccm_target_chrg_curr);
    req->prop = toInt(VehicleProperty::GECKO_CCM_TARGET_CHRG_CURR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::sc_ccm_remote_lockWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t sc_ccm_remote_lock = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("sc_ccm_remote_lock");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      sc_ccm_remote_lock = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_sc_ccm_remote_lockReq(sc_ccm_remote_lock),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_sc_ccm_remote_lockReq(int32_t sc_ccm_remote_lock) {
    auto req = mValueObjectPool->obtainInt32(sc_ccm_remote_lock);
    req->prop = toInt(VehicleProperty::GECKO_CCM_REMOTE_LOCK);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::sc_ccm_remote_car_searchWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t sc_ccm_remote_car_search = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("sc_ccm_remote_car_search");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      sc_ccm_remote_car_search = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_sc_ccm_remote_car_searchReq(sc_ccm_remote_car_search),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_sc_ccm_remote_car_searchReq(int32_t sc_ccm_remote_car_search) {
    auto req = mValueObjectPool->obtainInt32(sc_ccm_remote_car_search);
    req->prop = toInt(VehicleProperty::GECKO_CCM_REMOTE_CAR_SEARCH);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::sc_ccm_remt_ctrl_flagWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t sc_ccm_remt_ctrl_flag = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("sc_ccm_remt_ctrl_flag");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      sc_ccm_remt_ctrl_flag = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_sc_ccm_remt_ctrl_flagReq(sc_ccm_remt_ctrl_flag),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_sc_ccm_remt_ctrl_flagReq(int32_t sc_ccm_remt_ctrl_flag) {
    auto req = mValueObjectPool->obtainInt32(sc_ccm_remt_ctrl_flag);
    req->prop = toInt(VehicleProperty::GECKO_CCM_REMT_CTR_FLAG);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::sc_ec_ccm_operat_licenceWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t sc_ec_ccm_operat_licence = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("sc_ec_ccm_operat_licence");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      sc_ec_ccm_operat_licence = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_sc_ec_ccm_operat_licenceReq(sc_ec_ccm_operat_licence),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_sc_ec_ccm_operat_licenceReq(int32_t sc_ec_ccm_operat_licence) {
    auto req = mValueObjectPool->obtainInt32(sc_ec_ccm_operat_licence);
    req->prop = toInt(VehicleProperty::GECKO_CCM_OPERAT_LICENCE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_bms_realtimealowdischapowerWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bms_realtimealowdischapower = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_realtimealowdischapower");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_realtimealowdischapower = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_bms_realtimealowdischapowerReq(ec_bms_realtimealowdischapower),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_realtimealowdischapowerReq(int32_t ec_bms_realtimealowdischapower) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_realtimealowdischapower);
    req->prop = toInt(VehicleProperty::GECKO_BMS_REALTIMEALOWDISCHAPOWER);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ipu_ipuhvil_staWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_ipu_ipuhvil_sta = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_ipuhvil_sta");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ipu_ipuhvil_sta = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_ipu_ipuhvil_staReq(ec_ipu_ipuhvil_sta),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_ipuhvil_staReq(int32_t ec_ipu_ipuhvil_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_ipuhvil_sta);
    req->prop = toInt(VehicleProperty::GECKO_IPU_IPUHVILSTA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ipu_mainrelayposistatusWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int ec_ipu_mainrelayposistatus = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_mainrelayposistatus");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ipu_mainrelayposistatus = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_ipu_mainrelayposistatusReq(ec_ipu_mainrelayposistatus),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_mainrelayposistatusReq(int ec_ipu_mainrelayposistatus) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_mainrelayposistatus);
    req->prop = toInt(VehicleProperty::GECKO_IPU_MAINRELAYPOSISTATUS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ipu_workstatusWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int ec_ipu_workstatus = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_workstatus");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ipu_workstatus = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_ipu_workstatusReq(ec_ipu_workstatus),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_workstatusReq(int ec_ipu_workstatus) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_workstatus);
    req->prop = toInt(VehicleProperty::GECKO_IPU_WORKSTATUS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_tqreqWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int ec_vcu_tqreq = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_tqreq");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_tqreq = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_vcu_tqreqReq(ec_vcu_tqreq),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_tqreqReq(int ec_vcu_tqreq) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_tqreq);
    req->prop = toInt(VehicleProperty::GECKO_VCU_TQREQ);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_bms_softwareversionWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int ec_bms_softwareversion = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_softwareversion");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_softwareversion = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_bms_softwareversionReq(ec_bms_softwareversion),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_softwareversionReq(int ec_bms_softwareversion) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_softwareversion);
    req->prop = toInt(VehicleProperty::GECKO_BMS_SOFTWAREVERSION);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ipu_hardware_numWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int ec_ipu_hardware_num = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_hardware_num");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ipu_hardware_num = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_ipu_hardware_numReq(ec_ipu_hardware_num),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_hardware_numReq(int ec_ipu_hardware_num) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_hardware_num);
    req->prop = toInt(VehicleProperty::GECKO_IPU_HARDWARE_NUM);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ipu_sofeware_numWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int ec_ipu_sofeware_num = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_sofeware_num");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ipu_sofeware_num = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_ipu_sofeware_numReq(ec_ipu_sofeware_num),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_sofeware_numReq(int ec_ipu_sofeware_num) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_sofeware_num);
    req->prop = toInt(VehicleProperty::GECKO_IPU_SOFEWARE_NUM);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_faultlevelWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_faultlevel = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_faultlevel");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_faultlevel = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_vcu_faultlevelReq(ec_vcu_faultlevel),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_faultlevelReq(int32_t ec_vcu_faultlevel) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_faultlevel);
    req->prop = toInt(VehicleProperty::GECKO_VCU_FAULTLEVE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_brak_sys_warnWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_brak_sys_warn = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_brak_sys_warn");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_brak_sys_warn = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_vcu_brak_sys_warnReq(ec_vcu_brak_sys_warn),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_brak_sys_warnReq(int32_t ec_vcu_brak_sys_warn) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_brak_sys_warn);
    req->prop = toInt(VehicleProperty::GECKO_VCU_BRAKSYSWARN);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_versionWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_version = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_version");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_version = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_vcu_versionReq(ec_vcu_version),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_versionReq(int32_t ec_vcu_version) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_version);
    req->prop = toInt(VehicleProperty::GECKO_MCU_CCM_VERSION);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_operat_licenceWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_operat_licence = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_operat_licence");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_operat_licence = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_vcu_operat_licenceReq(ec_vcu_operat_licence),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_operat_licenceReq(int32_t ec_vcu_operat_licence) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_operat_licence);
    req->prop = toInt(VehicleProperty::GECKO_VCU_OPERATLICENCE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_mot_water_pump_statusWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_mot_water_pump_status = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_mot_water_pump_status");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_mot_water_pump_status = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_vcu_mot_water_pump_statusReq(ec_vcu_mot_water_pump_status),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_mot_water_pump_statusReq(int32_t ec_vcu_mot_water_pump_status) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_mot_water_pump_status);
    req->prop = toInt(VehicleProperty::GECKO_VCU_MOTWATERPUMPSTATUS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_vacum_pump_faultWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_vacum_pump_fault = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_vacum_pump_fault");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_vacum_pump_fault = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_vcu_vacum_pump_faultReq(ec_vcu_vacum_pump_fault),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_vacum_pump_faultReq(int32_t ec_vcu_vacum_pump_fault) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_vacum_pump_fault);
    req->prop = toInt(VehicleProperty::GECKO_VCU_VACUMPUMPFAULT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_dc_chrg_rly_stsWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_dc_chrg_rly_sts = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_dc_chrg_rly_sts");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_dc_chrg_rly_sts = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_vcu_dc_chrg_rly_stsReq(ec_vcu_dc_chrg_rly_sts),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_dc_chrg_rly_stsReq(int32_t ec_vcu_dc_chrg_rly_sts) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_dc_chrg_rly_sts);
    req->prop = toInt(VehicleProperty::GECKO_VCU_DCCHRGRLYSTS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_chrg_cnctr_stsWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_chrg_cnctr_sts = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_chrg_cnctr_sts");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_chrg_cnctr_sts = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      LOG(INFO)<<"VCU_ChrgCnctrSts:"<<ec_vcu_chrg_cnctr_sts;
      mHal->onPropertyValue(*Create_ec_vcu_chrg_cnctr_stsReq(ec_vcu_chrg_cnctr_sts),true);

      ConfigDBC* mp_park = mPropertyManager->findCProperty("ec_vcu_park_state");
      int32_t ec_vcu_park_state = mPropertyManager->getCProValue(mp_park);

      if(ec_vcu_chrg_cnctr_sts != 0){
        //未踩驻车制动插枪文本提示
        if(ec_vcu_park_state == 0){
          LOG(INFO)<<"VCU_ParkState = 0 and VCU_ChrgCnctrSts != 0";
          mHal->onPropertyValue(*Create_bc_park_chrg_cnctr_stsReq(1),true);
        }
      }else{
        LOG(INFO)<<"VCU_ParkState = 1 or 1 and VCU_ChrgCnctrSts = 0";
        mHal->onPropertyValue(*Create_bc_park_chrg_cnctr_stsReq(0),true);
      }
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_chrg_cnctr_stsReq(int32_t ec_vcu_chrg_cnctr_sts) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_chrg_cnctr_sts);
    req->prop = toInt(VehicleProperty::GECKO_VCU_CHRGCNCTRSTS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_chraging_mode_spWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_chraging_mode_sp = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_chraging_mode_sp");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_chraging_mode_sp = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_vcu_chraging_mode_spReq(ec_vcu_chraging_mode_sp),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_chraging_mode_spReq(int32_t ec_vcu_chraging_mode_sp) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_chraging_mode_sp);
    req->prop = toInt(VehicleProperty::GECKO_CHRAGINGMODESP);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_power_supply_voltagWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_power_supply_voltag = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_power_supply_voltag");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_power_supply_voltag = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_vcu_power_supply_voltagReq(ec_vcu_power_supply_voltag),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_power_supply_voltagReq(int32_t ec_vcu_power_supply_voltag) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_power_supply_voltag);
    req->prop = toInt(VehicleProperty::GECKO_VCU_POWERSUPPLYVOLTAG);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_ptc1_rel_staWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_ptc1_rel_sta = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_ptc1_rel_sta");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_ptc1_rel_sta = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_vcu_ptc1_rel_staReq(ec_vcu_ptc1_rel_sta),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_ptc1_rel_staReq(int32_t ec_vcu_ptc1_rel_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_ptc1_rel_sta);
    req->prop = toInt(VehicleProperty::GECKO_VCU_PTC1RELSTA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_ptc2_rel_staWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_ptc2_rel_sta = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_ptc2_rel_sta");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_ptc2_rel_sta = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_vcu_ptc2_rel_staReq(ec_vcu_ptc2_rel_sta),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_ptc2_rel_staReq(int32_t ec_vcu_ptc2_rel_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_ptc2_rel_sta);
    req->prop = toInt(VehicleProperty::GECKO_VCU_PTC2RELSTA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_water_pump_pwmWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_water_pump_pwm = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_water_pump_pwm");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_water_pump_pwm = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_vcu_water_pump_pwmReq(ec_vcu_water_pump_pwm),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_water_pump_pwmReq(int32_t ec_vcu_water_pump_pwm) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_water_pump_pwm);
    req->prop = toInt(VehicleProperty::GECKO_VCU_WATERPUMPPWM);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_fan_relay_pin_stsWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_fan_relay_pin_sts = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_fan_relay_pin_sts");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_fan_relay_pin_sts = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_vcu_fan_relay_pin_stsReq(ec_vcu_fan_relay_pin_sts),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_fan_relay_pin_stsReq(int32_t ec_vcu_fan_relay_pin_sts) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_fan_relay_pin_sts);
    req->prop = toInt(VehicleProperty::GECKO_VCU_FANRELAY_PINSTS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_mcu_err_codeWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_mcu_err_code = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_mcu_err_code");
  while(!mShuttingDownFlag.load()){
    mPropertyManager->getUpdateCState(mp);
    ec_mcu_err_code = mPropertyManager->getCProValue(mp);
    //LOG(INFO) << "ec_mcu_err_code:"<<ec_mcu_err_code;
    mHal->onPropertyValue(*Create_ec_mcu_err_codeReq(ec_mcu_err_code),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_mcu_err_codeReq(int32_t ec_mcu_err_code) {
    auto req = mValueObjectPool->obtainInt32(ec_mcu_err_code);
    req->prop = toInt(VehicleProperty::GECKO_MCU_ERR_CODE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_mcu_motoropermodeWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_mcu_motoropermode = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_mcu_motoropermode");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_mcu_motoropermode = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_mcu_motoropermodeReq(ec_mcu_motoropermode),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_mcu_motoropermodeReq(int32_t ec_mcu_motoropermode) {
    auto req = mValueObjectPool->obtainInt32(ec_mcu_motoropermode);
    req->prop = toInt(VehicleProperty::GECKO_MCU_MOTOROPERMODE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_mcu_igbt_overheat_warningWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_mcu_igbt_overheat_warning = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_mcu_igbt_overheat_warning");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_mcu_igbt_overheat_warning = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_mcu_igbt_overheat_warningReq(ec_mcu_igbt_overheat_warning),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_mcu_igbt_overheat_warningReq(int32_t ec_mcu_igbt_overheat_warning) {
    auto req = mValueObjectPool->obtainInt32(ec_mcu_igbt_overheat_warning);
    req->prop = toInt(VehicleProperty::GECKO_MCU_IGBT_OVERHEAT_WARNING);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_mcu_motor_overheat_warningWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_mcu_motor_overheat_warning = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_mcu_motor_overheat_warning");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_mcu_motor_overheat_warning = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_mcu_motor_overheat_warningReq(ec_mcu_motor_overheat_warning),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_mcu_motor_overheat_warningReq(int32_t ec_mcu_motor_overheat_warning) {
    auto req = mValueObjectPool->obtainInt32(ec_mcu_motor_overheat_warning);
    req->prop = toInt(VehicleProperty::GECKO_MCU_MOTOR_OVERHEAT_WARNING);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_mcu_motor_fault_total_numWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_mcu_motor_fault_total_num = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_mcu_motor_fault_total_num");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_mcu_motor_fault_total_num = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_mcu_motor_fault_total_numReq(ec_mcu_motor_fault_total_num),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_mcu_motor_fault_total_numReq(int32_t ec_mcu_motor_fault_total_num) {
    auto req = mValueObjectPool->obtainInt32(ec_mcu_motor_fault_total_num);
    req->prop = toInt(VehicleProperty::GECKO_MCU_MOTORFAULTTOTALNUM);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_ob_cinputvoltageWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_ipu_ob_cinputvoltage = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_ob_cinputvoltage");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ipu_ob_cinputvoltage = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_ipu_ob_cinputvoltageReq(ec_ipu_ob_cinputvoltage),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_ob_cinputvoltageReq(int32_t ec_ipu_ob_cinputvoltage) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_ob_cinputvoltage);
    req->prop = toInt(VehicleProperty::GECKO_IPU_OBCINPUTVOLTAGE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ipu_c_pdutycycleWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int ec_ipu_c_pdutycycle = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_c_pdutycycle");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ipu_c_pdutycycle = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_ipu_c_pdutycycleReq(ec_ipu_c_pdutycycle),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_c_pdutycycleReq(int ec_ipu_c_pdutycycle) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_c_pdutycycle);
    req->prop = toInt(VehicleProperty::GECKO_IPU_CPDUTYCYCLE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_ob_cinputcurrentWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_ipu_ob_cinputcurrent = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_ob_cinputcurrent");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ipu_ob_cinputcurrent = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_ipu_ob_cinputcurrentReq(ec_ipu_ob_cinputcurrent),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_ob_cinputcurrentReq(int32_t ec_ipu_ob_cinputcurrent) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_ob_cinputcurrent);
    req->prop = toInt(VehicleProperty::GECKO_IPU_OBCINPUTCURRENT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_dcdc_over_tempWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_ipu_dcdc_over_temp = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_dcdc_over_temp");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ipu_dcdc_over_temp = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_ipu_dcdc_over_tempReq(ec_ipu_dcdc_over_temp),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_dcdc_over_tempReq(int32_t ec_ipu_dcdc_over_temp) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_dcdc_over_temp);
    req->prop = toInt(VehicleProperty::GECKO_IPU_DCDC_OVER_TEMP);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_deltatempWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bms_deltatemp = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_deltatemp");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_deltatemp = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_bms_deltatempReq(ec_bms_deltatemp),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_deltatempReq(int32_t ec_bms_deltatemp) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_deltatemp);
    req->prop = toInt(VehicleProperty::GECKO_BMS_DELTATEMP);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_overtempWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bms_overtemp = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_overtemp");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_overtemp = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_bms_overtempReq(ec_bms_overtemp),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_overtempReq(int32_t ec_bms_overtemp) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_overtemp);
    req->prop = toInt(VehicleProperty::GECKO_BMS_OVERTEMP);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_packovervoltWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bms_packovervolt = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_packovervolt");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_packovervolt = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_bms_packovervoltReq(ec_bms_packovervolt),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_packovervoltReq(int32_t ec_bms_packovervolt) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_packovervolt);
    req->prop = toInt(VehicleProperty::GECKO_BMS_PACKOVERVOLT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_packudvoltWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bms_packudvolt = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_packudvolt");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_packudvolt = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_bms_packudvoltReq(ec_bms_packudvolt),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_packudvoltReq(int32_t ec_bms_packudvolt) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_packudvolt);
    req->prop = toInt(VehicleProperty::GECKO_BMS_PACKUDVOLT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_packlowsocWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bms_packlowsoc = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_packlowsoc");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_packlowsoc = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_bms_packlowsocReq(ec_bms_packlowsoc),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_packlowsocReq(int32_t ec_bms_packlowsoc) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_packlowsoc);
    req->prop = toInt(VehicleProperty::GECKO_BMS_PACKLOWSOC);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_cellovervoltWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bms_cellovervolt = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_cellovervolt");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_cellovervolt = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_bms_cellovervoltReq(ec_bms_cellovervolt),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_cellovervoltReq(int32_t ec_bms_cellovervolt) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_cellovervolt);
    req->prop = toInt(VehicleProperty::GECKO_BMS_CELLOVERVOLT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_celludvoltWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bms_celludvolt = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_celludvolt");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_celludvolt = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_bms_celludvoltReq(ec_bms_celludvolt),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_celludvoltReq(int32_t ec_bms_celludvolt) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_celludvolt);
    req->prop = toInt(VehicleProperty::GECKO_BMS_CELLUDVOLT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_packhighsocWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bms_packhighsoc = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_packhighsoc");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_packhighsoc = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_bms_packhighsocReq(ec_bms_packhighsoc),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_packhighsocReq(int32_t ec_bms_packhighsoc) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_packhighsoc);
    req->prop = toInt(VehicleProperty::GECKO_BMS_PACKHIGHSOC);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_packfastchgsocWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bms_packfastchgsoc = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_packfastchgsoc");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_packfastchgsoc = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_bms_packfastchgsocReq(ec_bms_packfastchgsoc),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_packfastchgsocReq(int32_t ec_bms_packfastchgsoc) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_packfastchgsoc);
    req->prop = toInt(VehicleProperty::GECKO_BMS_PACKFASTCHGSOC);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_batsysnotmtcWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bms_batsysnotmtc = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_batsysnotmtc");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_batsysnotmtc = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_bms_batsysnotmtcReq(ec_bms_batsysnotmtc),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_batsysnotmtcReq(int32_t ec_bms_batsysnotmtc) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_batsysnotmtc);
    req->prop = toInt(VehicleProperty::GECKO_BMS_BATSYSNOTMTC);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_ucellinconWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bms_ucellincon = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_ucellincon");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_ucellincon = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_bms_ucellinconReq(ec_bms_ucellincon),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_ucellinconReq(int32_t ec_bms_ucellincon) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_ucellincon);
    req->prop = toInt(VehicleProperty::GECKO_BMS_UCELLINCON);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_lowinsresWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bms_lowinsres = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_lowinsres");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_lowinsres = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_bms_lowinsresReq(ec_bms_lowinsres),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_lowinsresReq(int32_t ec_bms_lowinsres) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_lowinsres);
    req->prop = toInt(VehicleProperty::GECKO_BMS_LOWINSRES);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_h_vilfaultWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bms_h_vilfault = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_h_vilfault");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_h_vilfault = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_bms_h_vilfaultReq(ec_bms_h_vilfault),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_h_vilfaultReq(int32_t ec_bms_h_vilfault) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_h_vilfault);
    req->prop = toInt(VehicleProperty::GECKO_BMS_HVILFAULT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_packoverchargeWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bms_packovercharge = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_packovercharge");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_packovercharge = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_bms_packoverchargeReq(ec_bms_packovercharge),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_packoverchargeReq(int32_t ec_bms_packovercharge) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_packovercharge);
    req->prop = toInt(VehicleProperty::GECKO_BMS_PACKOVERCHARGE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_batt_fault_total_numWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bms_batt_fault_total_num = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_batt_fault_total_num");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_batt_fault_total_num = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_bms_batt_fault_total_numReq(ec_bms_batt_fault_total_num),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_batt_fault_total_numReq(int32_t ec_bms_batt_fault_total_num) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_batt_fault_total_num);
    req->prop = toInt(VehicleProperty::GECKO_BMS_BATTFAULTTOTALNUM);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_fault_codeWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bms_fault_code = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_fault_code");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_fault_code = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_bms_fault_codeReq(ec_bms_fault_code),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_fault_codeReq(int32_t ec_bms_fault_code) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_fault_code);
    req->prop = toInt(VehicleProperty::GECKO_BMS_FAULTCODE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_b2_v_v_frame_noWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_b2_v_v_frame_no = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_b2_v_v_frame_no");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_b2_v_v_frame_no = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_b2_v_v_frame_noReq(ec_b2_v_v_frame_no),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_b2_v_v_frame_noReq(int32_t ec_b2_v_v_frame_no) {
    auto req = mValueObjectPool->obtainInt32(ec_b2_v_v_frame_no);
    req->prop = toInt(VehicleProperty::GECKO_B2V_V_FRAMENO);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_b2_v_v_cell_volt_n1Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_b2_v_v_cell_volt_n1 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_b2_v_v_cell_volt_n1");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_b2_v_v_cell_volt_n1 = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_b2_v_v_cell_volt_n1Req(ec_b2_v_v_cell_volt_n1),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_b2_v_v_cell_volt_n1Req(int32_t ec_b2_v_v_cell_volt_n1) {
    auto req = mValueObjectPool->obtainInt32(ec_b2_v_v_cell_volt_n1);
    req->prop = toInt(VehicleProperty::GECKO_B2V_V_CELL_VOLTN1);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_b2_v_v_cell_volt_n2Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_b2_v_v_cell_volt_n2 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_b2_v_v_cell_volt_n2");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_b2_v_v_cell_volt_n2 = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_b2_v_v_cell_volt_n2Req(ec_b2_v_v_cell_volt_n2),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_b2_v_v_cell_volt_n2Req(int32_t ec_b2_v_v_cell_volt_n2) {
    auto req = mValueObjectPool->obtainInt32(ec_b2_v_v_cell_volt_n2);
    req->prop = toInt(VehicleProperty::GECKO_B2V_V_CELL_VOLTN2);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_b2_v_v_cell_volt_n3Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_b2_v_v_cell_volt_n3 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_b2_v_v_cell_volt_n3");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_b2_v_v_cell_volt_n3 = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_b2_v_v_cell_volt_n3Req(ec_b2_v_v_cell_volt_n3),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_b2_v_v_cell_volt_n3Req(int32_t ec_b2_v_v_cell_volt_n3) {
    auto req = mValueObjectPool->obtainInt32(ec_b2_v_v_cell_volt_n3);
    req->prop = toInt(VehicleProperty::GECKO_B2V_V_CELL_VOLTN3);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_b2_v_t_frame_noWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_b2_v_t_frame_no = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_b2_v_t_frame_no");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_b2_v_t_frame_no = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_b2_v_t_frame_noReq(ec_b2_v_t_frame_no),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_b2_v_t_frame_noReq(int32_t ec_b2_v_t_frame_no) {
    auto req = mValueObjectPool->obtainInt32(ec_b2_v_t_frame_no);
    req->prop = toInt(VehicleProperty::GECKO_B2V_T_FRAMENO);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_b2_v_t_cell_temp_n1Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_b2_v_t_cell_temp_n1 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_b2_v_t_cell_temp_n1");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_b2_v_t_cell_temp_n1 = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_b2_v_t_cell_temp_n1Req(ec_b2_v_t_cell_temp_n1),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_b2_v_t_cell_temp_n1Req(int32_t ec_b2_v_t_cell_temp_n1) {
    auto req = mValueObjectPool->obtainInt32(ec_b2_v_t_cell_temp_n1);
    req->prop = toInt(VehicleProperty::GECKO_B2V_T_CELL_TEMPN1);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_b2_v_t_cell_temp_n2Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_b2_v_t_cell_temp_n2 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_b2_v_t_cell_temp_n2");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_b2_v_t_cell_temp_n2 = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_b2_v_t_cell_temp_n2Req(ec_b2_v_t_cell_temp_n2),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_b2_v_t_cell_temp_n2Req(int32_t ec_b2_v_t_cell_temp_n2) {
    auto req = mValueObjectPool->obtainInt32(ec_b2_v_t_cell_temp_n2);
    req->prop = toInt(VehicleProperty::GECKO_B2V_T_CELL_TEMPN2);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_b2_v_t_cell_temp_n3Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_b2_v_t_cell_temp_n3 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_b2_v_t_cell_temp_n3");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_b2_v_t_cell_temp_n3 = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_b2_v_t_cell_temp_n3Req(ec_b2_v_t_cell_temp_n3),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_b2_v_t_cell_temp_n3Req(int32_t ec_b2_v_t_cell_temp_n3) {
    auto req = mValueObjectPool->obtainInt32(ec_b2_v_t_cell_temp_n3);
    req->prop = toInt(VehicleProperty::GECKO_B2V_T_CELL_TEMPN3);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_b2_v_t_cell_temp_n4Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_b2_v_t_cell_temp_n4 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_b2_v_t_cell_temp_n4");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_b2_v_t_cell_temp_n4 = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_b2_v_t_cell_temp_n4Req(ec_b2_v_t_cell_temp_n4),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_b2_v_t_cell_temp_n4Req(int32_t ec_b2_v_t_cell_temp_n4) {
    auto req = mValueObjectPool->obtainInt32(ec_b2_v_t_cell_temp_n4);
    req->prop = toInt(VehicleProperty::GECKO_B2V_T_CELL_TEMPN4);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_b2_v_t_cell_temp_n5Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_b2_v_t_cell_temp_n5 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_b2_v_t_cell_temp_n5");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_b2_v_t_cell_temp_n5 = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_b2_v_t_cell_temp_n5Req(ec_b2_v_t_cell_temp_n5),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_b2_v_t_cell_temp_n5Req(int32_t ec_b2_v_t_cell_temp_n5) {
    auto req = mValueObjectPool->obtainInt32(ec_b2_v_t_cell_temp_n5);
    req->prop = toInt(VehicleProperty::GECKO_B2V_T_CELL_TEMPN5);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_b2_v_t_cell_temp_n6Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_b2_v_t_cell_temp_n6 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_b2_v_t_cell_temp_n6");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_b2_v_t_cell_temp_n6 = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_b2_v_t_cell_temp_n6Req(ec_b2_v_t_cell_temp_n6),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_b2_v_t_cell_temp_n6Req(int32_t ec_b2_v_t_cell_temp_n6) {
    auto req = mValueObjectPool->obtainInt32(ec_b2_v_t_cell_temp_n6);
    req->prop = toInt(VehicleProperty::GECKO_B2V_T_CELL_TEMPN6);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_b2_v_t_cell_temp_n7Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_b2_v_t_cell_temp_n7 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_b2_v_t_cell_temp_n7");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_b2_v_t_cell_temp_n7 = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_b2_v_t_cell_temp_n7Req(ec_b2_v_t_cell_temp_n7),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_b2_v_t_cell_temp_n7Req(int32_t ec_b2_v_t_cell_temp_n7) {
    auto req = mValueObjectPool->obtainInt32(ec_b2_v_t_cell_temp_n7);
    req->prop = toInt(VehicleProperty::GECKO_B2V_T_CELL_TEMPN7);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_hardware_numWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_hardware_num = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_hardware_num");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_hardware_num = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_vcu_hardware_numReq(ec_vcu_hardware_num),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_hardware_numReq(int32_t ec_vcu_hardware_num) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_hardware_num);
    req->prop = toInt(VehicleProperty::GECKO_VCU_HARDWARE_NUM);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_sofeware_numWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_sofeware_num = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_sofeware_num");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_sofeware_num = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_vcu_sofeware_numReq(ec_vcu_sofeware_num),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_sofeware_numReq(int32_t sc_ec_ccm_operat_licence) {
    auto req = mValueObjectPool->obtainInt32(sc_ec_ccm_operat_licence);
    req->prop = toInt(VehicleProperty::GECKO_VCU_SOFEWARE_NUM);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_igonWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_igon = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_igon");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_igon = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_vcu_igonReq(ec_vcu_igon),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_igonReq(int32_t ec_vcu_igon) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_igon);
    req->prop = toInt(VehicleProperty::GECKO_VCU_IGON);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_hvpowerWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_hvpower = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_hvpower");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_hvpower = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_vcu_hvpowerReq(ec_vcu_hvpower),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_hvpowerReq(int32_t ec_vcu_hvpower) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_hvpower);
    req->prop = toInt(VehicleProperty::GECKO_VCU_HVPOWER);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_heatrelaystatusWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bms_heatrelaystatus = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_heatrelaystatus");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_heatrelaystatus = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_bms_heatrelaystatusReq(ec_bms_heatrelaystatus),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_heatrelaystatusReq(int32_t ec_bms_heatrelaystatus) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_heatrelaystatus);
    req->prop = toInt(VehicleProperty::GECKO_BMS_HEATRELAYSTATUS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_single_chrg_energyWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bms_single_chrg_energy = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_single_chrg_energy");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_single_chrg_energy = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_bms_single_chrg_energyReq(ec_bms_single_chrg_energy),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_single_chrg_energyReq(int32_t ec_bms_single_chrg_energy) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_single_chrg_energy);
    req->prop = toInt(VehicleProperty::GECKO_BMS_SINGLECHRGENERGY);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_batt_info4_dc_charg_req_currWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bms_batt_info4_dc_charg_req_curr = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_batt_info4_dc_charg_req_curr");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_batt_info4_dc_charg_req_curr = getActualFloatValue(mPropertyManager->getCProValue(mp), 0.1, 0);
      mHal->onPropertyValue(*Create_ec_bms_batt_info4_dc_charg_req_currReq(ec_bms_batt_info4_dc_charg_req_curr),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_batt_info4_dc_charg_req_currReq(float ec_bms_batt_info4_dc_charg_req_curr) {
    auto req = mValueObjectPool->obtainFloat(ec_bms_batt_info4_dc_charg_req_curr);
    req->prop = toInt(VehicleProperty::GECKO_BMS_BATTINFO4_DCCHARGREQCURR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_batt_info4_dc_charg_req_volWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bms_batt_info4_dc_charg_req_vol = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_batt_info4_dc_charg_req_vol");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_batt_info4_dc_charg_req_vol = getActualFloatValue(mPropertyManager->getCProValue(mp), 0.1, 0);
      mHal->onPropertyValue(*Create_ec_bms_batt_info4_dc_charg_req_volReq(ec_bms_batt_info4_dc_charg_req_vol),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_batt_info4_dc_charg_req_volReq(float ec_bms_batt_info4_dc_charg_req_vol) {
    auto req = mValueObjectPool->obtainFloat(ec_bms_batt_info4_dc_charg_req_vol);
    req->prop = toInt(VehicleProperty::GECKO_BMS_BATTINFO4_DCCHARGREQVOL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_batt_info4_mach_put_currWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bms_batt_info4_mach_put_curr = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_batt_info4_mach_put_curr");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_batt_info4_mach_put_curr = getActualFloatValue(mPropertyManager->getCProValue(mp), 0.1, 0);
      mHal->onPropertyValue(*Create_ec_bms_batt_info4_mach_put_currReq(ec_bms_batt_info4_mach_put_curr),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_batt_info4_mach_put_currReq(float ec_bms_batt_info4_mach_put_curr) {
    auto req = mValueObjectPool->obtainFloat(ec_bms_batt_info4_mach_put_curr);
    req->prop = toInt(VehicleProperty::GECKO_BMS_BATTINFO4_MACHPUTCURR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_batt_info4_mach_put_voltWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bms_batt_info4_mach_put_volt = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_batt_info4_mach_put_volt");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_batt_info4_mach_put_volt = getActualFloatValue(mPropertyManager->getCProValue(mp), 0.1, 0);
      mHal->onPropertyValue(*Create_ec_bms_batt_info4_mach_put_voltReq(ec_bms_batt_info4_mach_put_volt),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_batt_info4_mach_put_voltReq(float ec_bms_batt_info4_mach_put_volt) {
    auto req = mValueObjectPool->obtainFloat(ec_bms_batt_info4_mach_put_volt);
    req->prop = toInt(VehicleProperty::GECKO_BMS_BATTINFO4_MACHPUTVOLT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_eas_crtpwrWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_eas_crtpwr = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_eas_crtpwr");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_eas_crtpwr = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_bc_eas_crtpwrReq(bc_eas_crtpwr),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_eas_crtpwrReq(int32_t bc_eas_crtpwr) {
    auto req = mValueObjectPool->obtainInt32(bc_eas_crtpwr);
    req->prop = toInt(VehicleProperty::GECKO_EAS_CRTPWR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_veh_alrm_sys_stWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_veh_alrm_sys_st = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_veh_alrm_sys_st");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_veh_alrm_sys_st = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_bc_bcm_veh_alrm_sys_stReq(bc_bcm_veh_alrm_sys_st),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_veh_alrm_sys_stReq(int32_t bc_bcm_veh_alrm_sys_st) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_veh_alrm_sys_st);
    req->prop = toInt(VehicleProperty::GECKO_BCM_VEHALRMSYSST);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::mc_key_previous_songWatcher(){
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t mc_key_previous_song = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("mc_key_previous_song");
  while(!mShuttingDownFlag.load()){
    mPropertyManager->getUpdateCState(mp);
    // mc_key_previous_song = mPropertyManager->getCProValue(mp);
    // LOG(INFO) << "mc_key_previous_song:"<<mc_key_previous_song;
    // mHal->onPropertyValue(*Create_mcu_steering_002_customWatcher(mc_key_previous_song, CustomInputType::key_previous_song),true);

    mc_key_previous_song = mPropertyManager->getCProValue(mp);
    LOG(INFO) << "mc_key_previous_song:"<<mc_key_previous_song;
    mHal->onPropertyValue(*Create_mcu_steering_002_keyWatcher(mc_key_previous_song, KeyCodeType::KEYCODE_MEDIA_PREVIOUS),true);
  }
}

void GarageModeServerSideHandlerImpl::mc_key_next_songWatcher(){
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t mc_key_next_song = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("mc_key_next_song");
  while(!mShuttingDownFlag.load()){
    mPropertyManager->getUpdateCState(mp);
    mc_key_next_song = mPropertyManager->getCProValue(mp);
    LOG(INFO) << "mc_key_next_song:"<<mc_key_next_song;
    mHal->onPropertyValue(*Create_mcu_steering_002_keyWatcher(mc_key_next_song, KeyCodeType::KEYCODE_MEDIA_NEXT),true);
  }
}


void GarageModeServerSideHandlerImpl::mc_key_volume_upWatcher(){
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
     int32_t mc_key_volume_up = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("mc_key_volume_up");
  while(!mShuttingDownFlag.load()){
    mPropertyManager->getUpdateCState(mp);
    mc_key_volume_up = mPropertyManager->getCProValue(mp);
    LOG(INFO) << "mc_key_volume_up:"<<mc_key_volume_up;
    mHal->onPropertyValue(*Create_mcu_steering_002_keyWatcher(mc_key_volume_up, KeyCodeType::KEYCODE_VOLUME_UP),true);
  }
}

void GarageModeServerSideHandlerImpl::mc_key_volume_dowmWatcher(){
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
     int32_t mc_key_volume_dowm = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("mc_key_volume_dowm");
  while(!mShuttingDownFlag.load()){
    mPropertyManager->getUpdateCState(mp);
    mc_key_volume_dowm = mPropertyManager->getCProValue(mp);
    LOG(INFO) << "mc_key_volume_dowm:"<<mc_key_volume_dowm;
    mHal->onPropertyValue(*Create_mcu_steering_002_keyWatcher(mc_key_volume_dowm, KeyCodeType::KEYCODE_VOLUME_DOWN),true);
  }
}

void GarageModeServerSideHandlerImpl::mc_key_mode_muteWatcher(){
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
     int32_t mc_key_mode_mute = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("mc_key_mode_mute");
  while(!mShuttingDownFlag.load()){
    mPropertyManager->getUpdateCState(mp);
    mc_key_mode_mute = mPropertyManager->getCProValue(mp);
    LOG(INFO) << "mc_key_mode_mute:"<<mc_key_mode_mute;
    mHal->onPropertyValue(*Create_mcu_steering_002_keyWatcher(mc_key_mode_mute, KeyCodeType::KEYCODE_VOLUME_MUTE),true);
  }
}

void GarageModeServerSideHandlerImpl::mc_key_telephoneWatcher(){
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
     int32_t mc_key_telephone = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("mc_key_telephone");
  while(!mShuttingDownFlag.load()){
    mPropertyManager->getUpdateCState(mp);
    mc_key_telephone = mPropertyManager->getCProValue(mp);
    LOG(INFO) << "mc_key_telephone:"<<mc_key_telephone;
    mHal->onPropertyValue(*Create_mcu_steering_002_keyWatcher(mc_key_telephone, KeyCodeType::KEYCODE_CALL),true);
  }
}

void GarageModeServerSideHandlerImpl::mc_key_voiceWatcher(){
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
     int32_t mc_key_voice = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("mc_key_voice");
  while(!mShuttingDownFlag.load()){
    mPropertyManager->getUpdateCState(mp);
    mc_key_voice = mPropertyManager->getCProValue(mp);
    LOG(INFO) << "mc_key_voice:"<<mc_key_voice;
    mHal->onPropertyValue(*Create_mcu_steering_002_keyWatcher(mc_key_voice, KeyCodeType::KEYCODE_0),true);
  }
}

void GarageModeServerSideHandlerImpl::mc_key_homeWatcher(){
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
     int32_t mc_key_home = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("mc_key_home");
  while(!mShuttingDownFlag.load()){
    mPropertyManager->getUpdateCState(mp);
    mc_key_home = mPropertyManager->getCProValue(mp);
    LOG(INFO) << "mc_key_home:"<<mc_key_home;
    mHal->onPropertyValue(*Create_mcu_steering_002_keyWatcher(mc_key_home, KeyCodeType::KEYCODE_HOME),true);
  }
}

void GarageModeServerSideHandlerImpl::mc_key_distanceWatcher(){
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
     int32_t mc_key_distance = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("mc_key_distance");
  while(!mShuttingDownFlag.load()){
    mPropertyManager->getUpdateCState(mp);
    mc_key_distance = mPropertyManager->getCProValue(mp);
    LOG(INFO) << "mc_key_distance:"<<mc_key_distance;
    mHal->onPropertyValue(*Create_mcu_steering_002_keyWatcher(mc_key_distance, KeyCodeType::KEYCODE_DISTANCE),true);
  }
}


void GarageModeServerSideHandlerImpl::mc_key_speedupWatcher(){
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
     int32_t mc_key_speedup = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("mc_key_speedup");
  while(!mShuttingDownFlag.load()){
    mPropertyManager->getUpdateCState(mp);
    mc_key_speedup = mPropertyManager->getCProValue(mp);
    LOG(INFO) << "mc_key_speedup:"<<mc_key_speedup;
    mHal->onPropertyValue(*Create_mcu_steering_002_keyWatcher(mc_key_speedup, KeyCodeType::KEYCODE_SPEED_UP),true);
  }
}

void GarageModeServerSideHandlerImpl::mc_key_speeddownWatcher(){
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
     int32_t mc_key_speeddown = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("mc_key_speeddown");
  while(!mShuttingDownFlag.load()){
    mPropertyManager->getUpdateCState(mp);
    mc_key_speeddown = mPropertyManager->getCProValue(mp);
    LOG(INFO) << "mc_key_speeddown:"<<mc_key_speeddown;
    mHal->onPropertyValue(*Create_mcu_steering_002_keyWatcher(mc_key_speeddown, KeyCodeType::KEYCODE_SPEED_DOWN),true);
  }
}

void GarageModeServerSideHandlerImpl::mc_key_pagedownWatcher(){
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
     int32_t mc_key_pagedown = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("mc_key_pagedown");
  while(!mShuttingDownFlag.load()){
    mPropertyManager->getUpdateCState(mp);
    mc_key_pagedown = mPropertyManager->getCProValue(mp);
    LOG(INFO) << "mc_key_pagedown:"<<mc_key_pagedown;
    mHal->onPropertyValue(*Create_mcu_steering_002_keyWatcher(mc_key_pagedown, KeyCodeType::KEYCODE_PAGE_DOWN),true);
  }
}

void GarageModeServerSideHandlerImpl::mc_key_pageupWatcher(){
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
     int32_t mc_key_pageup = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("mc_key_pageup");
  while(!mShuttingDownFlag.load()){
    mPropertyManager->getUpdateCState(mp);
    mc_key_pageup = mPropertyManager->getCProValue(mp);
    LOG(INFO) << "mc_key_pageup:"<<mc_key_pageup;
    mHal->onPropertyValue(*Create_mcu_steering_002_keyWatcher(mc_key_pageup, KeyCodeType::KEYCODE_PAGE_UP),true);
  }
}

void GarageModeServerSideHandlerImpl::mc_key_okayWatcher(){
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
     int32_t mc_key_okay = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("mc_key_okay");
  while(!mShuttingDownFlag.load()){
    mPropertyManager->getUpdateCState(mp);
    mc_key_okay = mPropertyManager->getCProValue(mp);
    LOG(INFO) << "mc_key_okay:"<<mc_key_okay;
    mHal->onPropertyValue(*Create_mcu_steering_002_keyWatcher(mc_key_okay, KeyCodeType::KEYCODE_OKAY),true);
  }
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_mcu_steering_002_keyWatcher(int32_t mcu_steering_002_action, KeyCodeType mcu_steering_002_keycode){
    auto keyEvent = mValueObjectPool->obtain(VehiclePropertyType::INT32_VEC, 3);
    int32_t targetDisplay = 0;
    keyEvent->prop = toInt(VehicleProperty::HW_KEY_INPUT);
    keyEvent->areaId = 0;
    keyEvent->timestamp = elapsedRealtimeNano();
    keyEvent->status = VehiclePropertyStatus::AVAILABLE;
    keyEvent->value.int32Values[0] = mcu_steering_002_action;
    keyEvent->value.int32Values[1] = static_cast<int32_t>(mcu_steering_002_keycode);
    keyEvent->value.int32Values[2] = targetDisplay;
    return keyEvent;
}

void GarageModeServerSideHandlerImpl::mc_key_customWatcher(){
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t mc_key_custom = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("mc_key_custom");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        mc_key_custom = mPropertyManager->getCProValue(mp);
        LOG(INFO) << "mc_key_custom:"<<mc_key_custom;
        mHal->onPropertyValue(*Create_mcu_steering_002_keyWatcher(mc_key_custom, KeyCodeType::KEYCODE_MENU),true);
    }
}

void GarageModeServerSideHandlerImpl::mc_key_long_volume_upWatcher(){
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t mc_key_long_volume_up = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("mc_key_long_volume_up");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        mc_key_long_volume_up = mPropertyManager->getCProValue(mp);
        LOG(INFO) << "mc_key_long_volume_up:"<<mc_key_long_volume_up;
        mHal->onPropertyValue(*Create_mcu_steering_002_customWatcher(mc_key_long_volume_up, CustomInputType::key_long_volume_up),true);
    }
}

void GarageModeServerSideHandlerImpl::mc_key_long_volume_dowmWatcher(){
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t mc_key_long_volume_dowm = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("mc_key_long_volume_dowm");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        mc_key_long_volume_dowm = mPropertyManager->getCProValue(mp);
        LOG(INFO) << "mc_key_long_volume_dowm:"<<mc_key_long_volume_dowm;
        mHal->onPropertyValue(*Create_mcu_steering_002_customWatcher(mc_key_long_volume_dowm, CustomInputType::key_long_volume_dowm),true);
    }
}

void GarageModeServerSideHandlerImpl::mc_key_long_telephoneWatcher(){
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t mc_key_long_telephone = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("mc_key_long_telephone");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        mc_key_long_telephone = mPropertyManager->getCProValue(mp);
        LOG(INFO) << "mc_key_long_telephone:"<<mc_key_long_telephone;
        mHal->onPropertyValue(*Create_mcu_steering_002_customWatcher(mc_key_long_telephone, CustomInputType::key_long_telephone),true);
    }
}

void GarageModeServerSideHandlerImpl::mc_key_long_customWatcher(){
    int32_t mc_key_long_custom = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("mc_key_long_custom");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        mc_key_long_custom = mPropertyManager->getCProValue(mp);
        LOG(INFO) << "mc_key_long_custom:"<<mc_key_long_custom;
        mHal->onPropertyValue(*Create_mcu_steering_002_customWatcher(mc_key_long_custom, CustomInputType::key_long_custom),true);
    }
}

void GarageModeServerSideHandlerImpl::mc_key_long_previous_songWatcher(){
    int32_t mc_key_long_previous_song = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("mc_key_long_previous_song");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        mc_key_long_previous_song = mPropertyManager->getCProValue(mp);
        LOG(INFO) << "mc_key_long_previous_song:"<<mc_key_long_previous_song;
        mHal->onPropertyValue(*Create_mcu_steering_002_customWatcher(mc_key_long_previous_song, CustomInputType::key_long_previous_song),true);
    }
}
void GarageModeServerSideHandlerImpl::mc_key_long_next_songWatcher(){
    int32_t mc_key_long_next_song = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("mc_key_long_next_song");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        mc_key_long_next_song = mPropertyManager->getCProValue(mp);
        LOG(INFO) << "mc_key_long_next_song:"<<mc_key_long_next_song;
        mHal->onPropertyValue(*Create_mcu_steering_002_customWatcher(mc_key_long_next_song, CustomInputType::key_long_next_song),true);
    }
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_mcu_steering_002_customWatcher(int32_t mcu_steering_002_action, CustomInputType mcu_steering_002_keycode){
    auto keyEvent = mValueObjectPool->obtain(VehiclePropertyType::INT32_VEC, 3);
    int32_t targetDisplay = 0;
    keyEvent->prop = toInt(VehicleProperty::HW_CUSTOM_INPUT);
    keyEvent->areaId = 0;
    keyEvent->timestamp = elapsedRealtimeNano();
    keyEvent->status = VehiclePropertyStatus::AVAILABLE;
    keyEvent->value.int32Values[0] = static_cast<int32_t>(mcu_steering_002_keycode);
    keyEvent->value.int32Values[1] = targetDisplay;
    keyEvent->value.int32Values[2] = 0;
    LOG(INFO) << "mcu_steering_002_action:"<<mcu_steering_002_action;
    return keyEvent;
}

void GarageModeServerSideHandlerImpl::mc_light_levelWatcher(){
    int32_t mc_light_level = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("mc_light_level");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        mc_light_level = mPropertyManager->getCProValue(mp);
        LOG(INFO) << "mc_light_level:"<<mc_light_level;
        mHal->onPropertyValue(*Create_mc_light_levelReq(mc_light_level),true);
    }
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_mc_light_levelReq(int32_t mc_light_level){
    auto req = mValueObjectPool->obtainInt32(mc_light_level);
    req->prop = toInt(VehicleProperty::GECKO_CCM_SCREEN_BRIGHTNESS_ADJUST);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

std::unique_ptr<GarageModeServerSideHandler> makeGarageModeServerSideHandler(
        VehiclePropValuePool* valueObjectPool,PropertyManager* pm, EmulatedVehicleHalIface* hal) {
    return std::make_unique<GarageModeServerSideHandlerImpl>(valueObjectPool, pm, hal);
}

void GarageModeServerSideHandlerImpl::ccm_appointment_mode(){
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t appointment_mode_type = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("appointment_mode");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        appointment_mode_type = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
        LOG(INFO) << "appointment_mode:"<<appointment_mode_type;
        mHal->onPropertyValue(*Create_appointment_modeReq(appointment_mode_type),true);
    }
}
void GarageModeServerSideHandlerImpl::ccm_chraging_begin_time_hour(){
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t chraging_begin_time_hour = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("chraging_begin_time_hour");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        chraging_begin_time_hour = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
        LOG(INFO) << "chraging_begin_time_hour:"<<chraging_begin_time_hour;
        mHal->onPropertyValue(*Create_chraging_begin_time_hourReq(chraging_begin_time_hour),true);
    }
}

void GarageModeServerSideHandlerImpl::ccm_chraging_begin_time_minute()
{
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t chraging_begin_time_minute = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("chraging_begin_time_minute");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        chraging_begin_time_minute = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
        LOG(INFO) << "chraging_begin_time_minute:"<<chraging_begin_time_minute;
        mHal->onPropertyValue(*Create_chraging_begin_time_minuteReq(chraging_begin_time_minute),true);
    }
}

void GarageModeServerSideHandlerImpl::ccm_chraging_end_time_hour()
{
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t chraging_end_time_hour = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("chraging_end_time_hour");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        chraging_end_time_hour = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
        LOG(INFO) << "chraging_end_time_hour:"<<chraging_end_time_hour;
        mHal->onPropertyValue(*Create_chraging_end_time_hourReq(chraging_end_time_hour),true);
    }
}

void GarageModeServerSideHandlerImpl::ccm_chraging_end_time_minute()
{
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t chraging_end_time_minute = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("chraging_end_time_minute");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        chraging_end_time_minute = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
        LOG(INFO) << "chraging_end_time_minute:"<<chraging_end_time_minute;
        mHal->onPropertyValue(*Create_chraging_end_time_minuteReq(chraging_end_time_minute),true);
    }
}

void GarageModeServerSideHandlerImpl::ccm_chraging_sunday_loop()
{
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    ConfigDBC* mp = mPropertyManager->findCProperty("sunday_loop");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        chraging_sunday_loop = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
        LOG(INFO) << "chraging_sunday_loop:"<<chraging_sunday_loop;
        mHal->onPropertyValue(*Create_chraging_loopReq(),true);
    }
}

void GarageModeServerSideHandlerImpl::ccm_chraging_monday_loop()
{   
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    ConfigDBC* mp = mPropertyManager->findCProperty("monday_loop");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        chraging_monday_loop = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
        LOG(INFO) << "chraging_monday_loop:"<<chraging_monday_loop;
        mHal->onPropertyValue(*Create_chraging_loopReq(),true);
    }
}

void GarageModeServerSideHandlerImpl::ccm_chraging_tuesday_loop()
{ 
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    ConfigDBC* mp = mPropertyManager->findCProperty("tuesday_loop");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        chraging_tuesday_loop = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
        LOG(INFO) << "chraging_tuesday_loop:"<<chraging_tuesday_loop;
        mHal->onPropertyValue(*Create_chraging_loopReq(),true);
    }
}

void GarageModeServerSideHandlerImpl::ccm_chraging_wednesday_loop()
{   
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    ConfigDBC* mp = mPropertyManager->findCProperty("wednesday_loop");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        chraging_wednesday_loop = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
        LOG(INFO) << "chraging_wednesday_loop:"<<chraging_wednesday_loop;
        mHal->onPropertyValue(*Create_chraging_loopReq(),true);
    }
}

void GarageModeServerSideHandlerImpl::ccm_chraging_thursday_loop()
{
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    ConfigDBC* mp = mPropertyManager->findCProperty("thursday_loop");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        chraging_thursday_loop = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
        LOG(INFO) << "chraging_thursday_loop:"<<chraging_thursday_loop;
        mHal->onPropertyValue(*Create_chraging_loopReq(),true);
    }
}

void GarageModeServerSideHandlerImpl::ccm_chraging_friday_loop()
{   
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    ConfigDBC* mp = mPropertyManager->findCProperty("friday_loop");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        chraging_friday_loop = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
        LOG(INFO) << "chraging_friday_loop:"<<chraging_friday_loop;
        mHal->onPropertyValue(*Create_chraging_loopReq(),true);
    }
}

void GarageModeServerSideHandlerImpl::ccm_chraging_saturday_loop()
{
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    ConfigDBC* mp = mPropertyManager->findCProperty("saturday_loop");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        chraging_saturday_loop = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
        LOG(INFO) << "chraging_saturday_loop:"<<chraging_saturday_loop;
        mHal->onPropertyValue(*Create_chraging_loopReq(),true);
    }
}

void GarageModeServerSideHandlerImpl::ccm_chraging_target_soc()
{
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t chraging_target_soc = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("chraging_target_soc");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        chraging_target_soc = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
        LOG(INFO) << "chraging_target_soc:"<<chraging_target_soc;
        mHal->onPropertyValue(*Create_chraging_target_socReq(chraging_target_soc),true);
    }
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_appointment_modeReq(int32_t appointment_mode_type){
    auto req = mValueObjectPool->obtainInt32(appointment_mode_type);
    req->prop = toInt(VehicleProperty::GECKO_CCM_APPOINTMENT_MODE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_chraging_begin_time_hourReq(int32_t chraging_begin_time_hour){
    auto req = mValueObjectPool->obtainInt32(chraging_begin_time_hour);
    req->prop = toInt(VehicleProperty::GECKO_CCM_CHRAGING_BEGIN_TIME_HOUR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_chraging_begin_time_minuteReq(int32_t chraging_begin_time_minute){
    auto req = mValueObjectPool->obtainInt32(chraging_begin_time_minute);
    req->prop = toInt(VehicleProperty::GECKO_CCM_CHRAGING_BEGIN_TIME_MINUTE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_chraging_end_time_hourReq(int32_t chraging_end_time_hour){
    auto req = mValueObjectPool->obtainInt32(chraging_end_time_hour);
    req->prop = toInt(VehicleProperty::GECKO_CCM_CHRAGING_END_TIME_HOUR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_chraging_end_time_minuteReq(int32_t chraging_end_time_minute){
    auto req = mValueObjectPool->obtainInt32(chraging_end_time_minute);
    req->prop = toInt(VehicleProperty::GECKO_CCM_CHRAGING_END_TIME_MINUTE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_chraging_loopReq(){
    auto req = mValueObjectPool->obtain(VehiclePropertyType::INT32_VEC, 7);
    req->prop = toInt(VehicleProperty::GECKO_CCM_CHRAGING_LOOP);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    req->value.int32Values[0] = chraging_sunday_loop;
    req->value.int32Values[1] = chraging_monday_loop;
    req->value.int32Values[2] = chraging_tuesday_loop;
    req->value.int32Values[3] = chraging_wednesday_loop;
    req->value.int32Values[4] = chraging_thursday_loop;
    req->value.int32Values[5] = chraging_friday_loop;
    req->value.int32Values[6] = chraging_saturday_loop;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_chraging_target_socReq(int32_t chraging_target_soc){
    auto req = mValueObjectPool->obtainInt32(chraging_target_soc);
    req->prop = toInt(VehicleProperty::GECKO_CCM_CHRAGING_TARGET_SOC);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_obc_output_voltageWatcher()
{
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ipu_obc_output_voltage = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_obc_output_voltage");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ipu_obc_output_voltage = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
        //LOG(INFO) << "ipu_obc_output_voltage:"<<ipu_obc_output_voltage;
        mHal->onPropertyValue(*Create_ec_ipu_obc_output_voltageReq(ipu_obc_output_voltage),true);
    }
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_obc_output_voltageReq(int32_t ipu_obc_output_voltage){
    auto req = mValueObjectPool->obtainInt32(ipu_obc_output_voltage);
    req->prop = toInt(VehicleProperty::GECKO_IPU_OBC_OUTPUT_VOLTAGE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}


void GarageModeServerSideHandlerImpl::ec_bms_mainrelaynega_statusWatcher()
{
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_mainrelaynega_status = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_mainrelaynega_status");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_mainrelaynega_status = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
        //LOG(INFO) << "ec_bms_mainrelaynega_status:"<<ec_bms_mainrelaynega_status;
        mHal->onPropertyValue(*Create_ec_bms_mainrelaynega_statusReq(ec_bms_mainrelaynega_status),true);
    }
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_mainrelaynega_statusReq(int32_t ec_bms_mainrelaynega_status)
{
    auto req = mValueObjectPool->obtainInt32(ec_bms_mainrelaynega_status);
    req->prop = toInt(VehicleProperty::GECKO_BMS_MAINRELAYNEGA_STATUS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_obc_output_currentWatcher()
{
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ipu_obc_output_current = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_obc_output_current");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ipu_obc_output_current = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
        //LOG(INFO) << "ec_ipu_obc_output_current:"<<ec_ipu_obc_output_current;
        mHal->onPropertyValue(*Create_ec_ipu_obc_output_currentReq(ec_ipu_obc_output_current),true);
    }
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_obc_output_currentReq(int32_t ec_ipu_obc_output_current)
{
    auto req = mValueObjectPool->obtainInt32(ec_ipu_obc_output_current);
    req->prop = toInt(VehicleProperty::GECKO_IPU_OBC_OUTPUT_CURRENT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_batterysohWatcher()
{
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_batterysoh = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_batterysoh");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        // ec_bms_batterysoh = static_cast<int32_t>(getActualFloatValue(mPropertyManager->getCProValue(mp), 0.1, 0));
        ec_bms_batterysoh = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
        LOG(INFO) << "ec_bms_batterysoh:"<<ec_bms_batterysoh;
        mHal->onPropertyValue(*Create_ec_bms_batterysohReq(ec_bms_batterysoh),true);
    }
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_batterysohReq(int32_t ec_bms_batterysoh)
{
    auto req = mValueObjectPool->obtainInt32(ec_bms_batterysoh);
    req->prop = toInt(VehicleProperty::GECKO_BMS_BATTERYSOH);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_soeWatcher()
{
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_soe = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_soe");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        // ec_bms_soe = static_cast<int32_t>(getActualFloatValue(mPropertyManager->getCProValue(mp), 0.1, 0));
        ec_bms_soe = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
        //LOG(INFO) << "ec_bms_soe:"<<ec_bms_soe;
        mHal->onPropertyValue(*Create_ec_bms_soeReq(ec_bms_soe),true);
    }
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_soeReq(int32_t ec_bms_soe)
{
    auto req = mValueObjectPool->obtainInt32(ec_bms_soe);
    req->prop = toInt(VehicleProperty::GECKO_BMS_SOE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_hv_batt_stWatcher()
{
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_hv_batt_st = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_hv_batt_st");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_hv_batt_st = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
        //LOG(INFO) << "ec_bms_hv_batt_st:"<<ec_bms_hv_batt_st;
        mHal->onPropertyValue(*Create_ec_bms_hv_batt_stReq(ec_bms_hv_batt_st),true);
    }
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_hv_batt_stReq(int32_t ec_bms_hv_batt_st)
{
    auto req = mValueObjectPool->obtainInt32(ec_bms_hv_batt_st);
    req->prop = toInt(VehicleProperty::GECKO_BMS_HVBATTST);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_initstatusWatcher()
{   std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_initstatus = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_initstatus");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_initstatus = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
        //LOG(INFO) << "ec_bms_initstatus:"<<ec_bms_initstatus;
        mHal->onPropertyValue(*Create_ec_bms_initstatusReq(ec_bms_initstatus),true);
    }
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_initstatusReq(int32_t ec_bms_initstatus)
{
    auto req = mValueObjectPool->obtainInt32(ec_bms_initstatus);
    req->prop = toInt(VehicleProperty::GECKO_BMS_INITSTATUS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bcm_rear_fog_light_errWatcher()
{   
    int32_t bc_bcm_rear_fog_light_err = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_rear_fog_light_err");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        bc_bcm_rear_fog_light_err = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
        LOG(INFO) << "bc_bcm_rear_fog_light_err:"<<bc_bcm_rear_fog_light_err;
        mHal->onPropertyValue(*Create_bc_bcm_rear_fog_light_errReq(bc_bcm_rear_fog_light_err),true);
    }
}  
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_rear_fog_light_errReq(int32_t value)  
{
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_BCM_REAR_FOG_LIGHT_ERR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
} 

void GarageModeServerSideHandlerImpl::bcm_reversinglight_errWatcher()
{   
    int32_t bcm_reversinglight_err = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_reversinglight_err");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        bcm_reversinglight_err = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
        LOG(INFO) << "bcm_reversinglight_err:"<<bcm_reversinglight_err;
        mHal->onPropertyValue(*Create_bc_bcm_reversinglight_errReq(bcm_reversinglight_err),true);
    }
}      
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_reversinglight_errReq(int32_t value)
{
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_BCM_REVERSINGLIGHT_ERR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}    

void GarageModeServerSideHandlerImpl::bcm_brakelight_errWatcher()
{   
    int32_t bcm_brakelight_err = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_brakelight_err");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        bcm_brakelight_err = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
        LOG(INFO) << "bcm_brakelight_err:"<<bcm_brakelight_err;
        mHal->onPropertyValue(*Create_bc_bcm_brakelight_errReq(bcm_brakelight_err),true);
    }
}        
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_brakelight_errReq(int32_t value)
{
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_BCM_BRAKELIGHT_ERR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}    

void GarageModeServerSideHandlerImpl::bcm_daytime_running_light_errWatcher()
{   
    int32_t bcm_daytime_running_light_err = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_daytime_running_light_err");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        bcm_daytime_running_light_err = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
        LOG(INFO) << "bcm_daytime_running_light_err:"<<bcm_daytime_running_light_err;
        mHal->onPropertyValue(*Create_bc_bcm_daytime_running_light_errReq(bcm_daytime_running_light_err),true);
    }
}  
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_daytime_running_light_errReq(int32_t value)
{
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_BCM_DAYTIME_RUNNING_LIGHT_ERR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
} 

void GarageModeServerSideHandlerImpl::bcm_position_light_errWatcher()
{   
    int32_t bcm_position_light_err = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_position_light_err");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        bcm_position_light_err = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
        LOG(INFO) << "bcm_position_light_err:"<<bcm_position_light_err;
        mHal->onPropertyValue(*Create_bc_bcm_position_light_errReq(bcm_position_light_err),true);
    }
}      
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_position_light_errReq(int32_t value)
{
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_BCM_POSITION_LIGHT_ERR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}    

void GarageModeServerSideHandlerImpl::bcm_turn_indcr_le_errWatcher()
{   
    int32_t bcm_turn_indcr_le_err = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_turn_indcr_le_err");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        bcm_turn_indcr_le_err = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
        LOG(INFO) << "bcm_turn_indcr_le_err:"<<bcm_turn_indcr_le_err;
        mHal->onPropertyValue(*Create_bc_bcm_turn_indcr_le_errReq(bcm_turn_indcr_le_err),true);
    }
}        
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_turn_indcr_le_errReq(int32_t value)
{
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_BCM_TURN_INDCR_LE_ERR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}   

void GarageModeServerSideHandlerImpl::bcm_turn_indcr_ri_errWatcher()
{   
    int32_t bcm_turn_indcr_ri_err = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_turn_indcr_ri_err");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        bcm_turn_indcr_ri_err = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
        LOG(INFO) << "bcm_turn_indcr_ri_err:"<<bcm_turn_indcr_ri_err;
        mHal->onPropertyValue(*Create_bc_bcm_turn_indcr_ri_errReq(bcm_turn_indcr_ri_err),true);
    }
}     
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_turn_indcr_ri_errReq(int32_t value)
{
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_BCM_TURN_INDCR_RI_ERR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}  

void GarageModeServerSideHandlerImpl::bcm_high_beam_rly_errWatcher()
{   
    int32_t bcm_high_beam_rly_err = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_high_beam_rly_err");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        bcm_high_beam_rly_err = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
        LOG(INFO) << "bcm_high_beam_rly_err:"<<bcm_high_beam_rly_err;
        mHal->onPropertyValue(*Create_bc_bcm_high_beam_rly_errReq(bcm_high_beam_rly_err),true);
    }
}   
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_high_beam_rly_errReq(int32_t value)
{
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_BCM_HIGH_BEAM_RLY_ERR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}    

void GarageModeServerSideHandlerImpl::bcm_low_beam_rly_errWatcher()
{   
    int32_t bcm_low_beam_rly_err = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_low_beam_rly_err");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        bcm_low_beam_rly_err = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
        LOG(INFO) << "bcm_low_beam_rly_err:"<<bcm_low_beam_rly_err;
        mHal->onPropertyValue(*Create_bc_bcm_low_beam_rly_errReq(bcm_low_beam_rly_err),true);
    }
}      
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_low_beam_rly_errReq(int32_t value)
{
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_BCM_LOW_BEAM_RLY_ERR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}  

   
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_motion_park_stateReq(int32_t value)
{
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_MOTION_PARK_STATE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}   

 
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_park_chrg_cnctr_stsReq(int32_t value)
{
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_PARK_CHRG_CNCTR_STS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
} 

void GarageModeServerSideHandlerImpl::mcu_voiume_navigationWatcher()
{   
    int32_t value = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("gecko_mcu_voiume_navigation");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        value = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
        LOG(INFO) << "gecko_mcu_voiume_navigation:"<<value;
        mHal->onPropertyValue(*Create_mcu_voiume_navigationReq(value),true);
    }
} 
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_mcu_voiume_navigationReq(int32_t value)
{
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_MCU_VOIUME_NAVIGATION);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
} 
void GarageModeServerSideHandlerImpl::mcu_voiume_voicWatcher()
{   
    int32_t value = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("gecko_mcu_voiume_voic");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        value = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
        LOG(INFO) << "gecko_mcu_voiume_voic:"<<value;
        mHal->onPropertyValue(*Create_mcu_voiume_voicReq(value),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_mcu_voiume_voicReq(int32_t value)
{
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_MCU_VOIUME_VOIC);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
} 
void GarageModeServerSideHandlerImpl::mcu_voiume_multimediaWatcher()
{   
    int32_t value = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("gecko_mcu_voiume_multimedia");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        value = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
        LOG(INFO) << "gecko_mcu_voiume_multimedia:"<<value;
        mHal->onPropertyValue(*Create_mcu_voiume_multimediaReq(value),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_mcu_voiume_multimediaReq(int32_t value)
{
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_MCU_VOIUME_MULTIMEDIA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
} 
void GarageModeServerSideHandlerImpl::mcu_voiume_phoneWatcher()
{   
    int32_t value = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("gecko_mcu_voiume_phone");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        value = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
        LOG(INFO) << "gecko_mcu_voiume_phone:"<<value;
        mHal->onPropertyValue(*Create_mcu_voiume_phoneReq(value),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_mcu_voiume_phoneReq(int32_t value)
{
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_MCU_VOIUME_PHONE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
} 
void GarageModeServerSideHandlerImpl::mcu_voiume_alarmWatcher()
{   
    int32_t value = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("gecko_mcu_voiume_alarm");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        value = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
        LOG(INFO) << "gecko_mcu_voiume_alarm:"<<value;
        mHal->onPropertyValue(*Create_mcu_voiume_alarmReq(value),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_mcu_voiume_alarmReq(int32_t value)
{
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_MCU_VOIUME_ALARM);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
} 
void GarageModeServerSideHandlerImpl::mcu_voiume_keyWatcher()
{   
    int32_t value = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("gecko_mcu_voiume_key");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        value = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
        LOG(INFO) << "gecko_mcu_voiume_key:"<<value;
        mHal->onPropertyValue(*Create_mcu_voiume_keyReq(value),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_mcu_voiume_keyReq(int32_t value)
{
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_MCU_VOIUME_KEY);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
} 

void GarageModeServerSideHandlerImpl::mcu_info_vin1Watcher()
{
    std::string value = "";
    Property*mp = mPropertyManager->findProperty("mc_mcu_info_vin1");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateState(mp);
        value = mPropertyManager->getProValue(mp);
        LOG(INFO) << "mc_mcu_info_vin1:"<<value;
        mHal->onPropertyValue(*Create_mcu_info_vin1Req(value),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_mcu_info_vin1Req(std::string value)
{
    memcpy(mVehicleInfoVin, value.c_str(), value.length());
    const char* mInfoVin = mVehicleInfoVin;
    auto req = mValueObjectPool->obtainString(mInfoVin);
    req->prop = toInt(VehicleProperty::INFO_VIN);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::mcu_info_vin2Watcher()
{
    std::string value = "";
    Property*mp = mPropertyManager->findProperty("mc_mcu_info_vin2");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateState(mp);
        value = mPropertyManager->getProValue(mp);
        LOG(INFO) << "mc_mcu_info_vin2:"<<value;
        mHal->onPropertyValue(*Create_mcu_info_vin2Req(value),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_mcu_info_vin2Req(std::string value)
{
    memcpy(mVehicleInfoVin+7, value.c_str(), value.length());
    const char* mInfoVin = mVehicleInfoVin;
    auto req = mValueObjectPool->obtainString(mInfoVin);
    req->prop = toInt(VehicleProperty::INFO_VIN);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::mcu_info_vin3Watcher()
{
    std::string value = "";
    Property*mp = mPropertyManager->findProperty("mc_mcu_info_vin3");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateState(mp);
        value = mPropertyManager->getProValue(mp);
        LOG(INFO) << "mc_mcu_info_vin3:"<<value;
        mHal->onPropertyValue(*Create_mcu_info_vin3Req(value),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_mcu_info_vin3Req(std::string value)
{
    memcpy(mVehicleInfoVin+14, value.c_str(), value.length() -5);
    const char* mInfoVin = mVehicleInfoVin;
    auto req = mValueObjectPool->obtainString(mInfoVin);
    req->prop = toInt(VehicleProperty::INFO_VIN);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::mcu_info_vinWatcher()
{
    std::string value = "";
    ConfigDBC*mp = mPropertyManager->findCProperty("gecko_vin");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        value = mPropertyManager->getCProStrValue(mp);
        LOG(INFO) << "mc_mcu_info_vin:"<<value;
        android::base::SetProperty("gecko.vin", value);    //目前向属性去传递字符串数据会dump，暂时属性的值通过prop来传递
//        mHal->onPropertyValue(*Create_mcu_info_vinReq(value),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_mcu_info_vinReq(std::string value)
{
    auto req = mValueObjectPool->obtainString(value.c_str());
    req->prop = toInt(VehicleProperty::INFO_VIN);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::rangeModeSet()
{
    int32_t value = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("sc_rema_range_display_mode");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        value = std::stoi(mPropertyManager->getCProStrValue(mp).c_str());
        mHal->onPropertyValue(*Creat_range_modeReq(value),true);
    }
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Creat_range_modeReq(int32_t value)
{
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_REMA_RANGE_DISPLAY_MODE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::gecko_headlighthSet()
{
    int32_t headlighth = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("gecko_headlighth");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        headlighth = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
        LOG(INFO) << "dxy-- gecko_headlighthSet value = "<< headlighth;
        mHal->onPropertyValue(*Creat_gecko_headlighthReq(headlighth),true);
    }
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Creat_gecko_headlighthReq(int32_t value)
{
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_HIGH_BEAM_LIGHTS_LEVEL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::mcu_info_sn1Watcher()
{
    std::string value = "";
    Property*mp = mPropertyManager->findProperty("mc_mcu_info_sn1");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateState(mp);
        value = mPropertyManager->getProValue(mp);
        LOG(INFO) << "mc_mcu_info_sn1:"<<value;
        mHal->onPropertyValue(*Create_mcu_info_sn1Req(value),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_mcu_info_sn1Req(std::string value)
{
    memcpy(mVehicleInfoSn, value.c_str(), value.length());
    int size = sizeof(mVehicleInfoSn) / sizeof(char);
    std::string str(mVehicleInfoSn, size);
    android::base::SetProperty("gecko.serial.number", str);
    const char* mInfoSn = mVehicleInfoSn;
    auto req = mValueObjectPool->obtainString(mInfoSn);
    req->prop = toInt(VehicleProperty::GECKO_VEHICLE_INFO_SN);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::mcu_info_sn2Watcher()
{
    std::string value = "";
    Property*mp = mPropertyManager->findProperty("mc_mcu_info_sn2");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateState(mp);
        value = mPropertyManager->getProValue(mp);
        LOG(INFO) << "mc_mcu_info_sn2:"<<value;
        mHal->onPropertyValue(*Create_mcu_info_sn2Req(value),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_mcu_info_sn2Req(std::string value)
{
    memcpy(mVehicleInfoSn+7, value.c_str(), value.length());
    int size = sizeof(mVehicleInfoSn) / sizeof(char);
    std::string str(mVehicleInfoSn, size);
    android::base::SetProperty("gecko.serial.number", str);
    const char* mInfoSn = mVehicleInfoSn;
    auto req = mValueObjectPool->obtainString(mInfoSn);
    req->prop = toInt(VehicleProperty::GECKO_VEHICLE_INFO_SN);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::mcu_info_sn3Watcher()
{
    std::string value = "";
    Property*mp = mPropertyManager->findProperty("mc_mcu_info_sn3");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateState(mp);
        value = mPropertyManager->getProValue(mp);
        LOG(INFO) << "mc_mcu_info_sn3:"<<value;
        mHal->onPropertyValue(*Create_mcu_info_sn3Req(value),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_mcu_info_sn3Req(std::string value)
{
    memcpy(mVehicleInfoSn+14, value.c_str(), value.length() - 2);
    int size = sizeof(mVehicleInfoSn) / sizeof(char);
    std::string str(mVehicleInfoSn, size);
    android::base::SetProperty("gecko.serial.number", str);
    const char* mInfoSn = mVehicleInfoSn;
    auto req = mValueObjectPool->obtainString(mInfoSn);
    req->prop = toInt(VehicleProperty::GECKO_VEHICLE_INFO_SN);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::mcu_info_versionWatcher()
{
    std::string value = "";
    ConfigDBC*mp = mPropertyManager->findCProperty("gecko_mcu_version");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        value = mPropertyManager->getCProStrValue(mp);
        LOG(INFO) << "mc_mcu_info_version:"<<value;
        android::base::SetProperty("gecko.mcu.version", value);
        //mHal->onPropertyValue(*Create_mcu_info_versionReq(value),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_mcu_info_versionReq(std::string value)
{
    memcpy(mVehicleInfoVersion, value.c_str(), value.length());
    int size = sizeof(mVehicleInfoVersion) / sizeof(char);
    std::string str(mVehicleInfoVersion, size);
    android::base::SetProperty("gecko.mcu.version", str);
    const char* mInfoVersion = mVehicleInfoVersion;
    auto req = mValueObjectPool->obtainString(mInfoVersion);
    req->prop = toInt(VehicleProperty::GECKO_VEHICLE_INFO_VERSION);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::mc_travel_rangeWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  float mc_travel_range = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("mc_travel_range");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      mc_travel_range = getActualFloatValue(mPropertyManager->getCProValue(mp), 0.1, 0);
      LOG(INFO) << "mc_travel_range:"<< mc_travel_range;
      mHal->onPropertyValue(*Create_mc_travel_rangeReq(mc_travel_range),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_mc_travel_rangeReq(float mc_travel_range) {
    auto req = mValueObjectPool->obtainFloat(mc_travel_range);
    req->prop = toInt(VehicleProperty::GECKO_MCU_TRAVEL_RANGE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::mc_travel_timeWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t mc_travel_time = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("mc_travel_time");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      mc_travel_time = mPropertyManager->getCProValue(mp);
      LOG(INFO) << "mc_travel_time:"<< mc_travel_time;
      mHal->onPropertyValue(*Create_mc_travel_timeReq(mc_travel_time),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_mc_travel_timeReq(int32_t mc_travel_time) {
    auto req = mValueObjectPool->obtainInt32(mc_travel_time);
    req->prop = toInt(VehicleProperty::GECKO_MCU_TRAVEL_TIME);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::mc_average_energy_consumptionWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  float mc_average_energy_consumption = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("mc_average_energy_consumption");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      mc_average_energy_consumption = getActualFloatValue(static_cast<int32_t>(mPropertyManager->getCProValue(mp)),0.1,0);
      mHal->onPropertyValue(*Create_mc_average_energy_consumptionReq(mc_average_energy_consumption),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_mc_average_energy_consumptionReq(float mc_average_energy_consumption) {
    auto req = mValueObjectPool->obtainFloat(mc_average_energy_consumption);
    req->prop = toInt(VehicleProperty::GECKO_MCU_AVERAGE_ENERGY_CONSUMPTION);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_wipr_intl_time_set_fbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_wipr_intl_time_set_fb = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_wipr_intl_time_set_fb");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_wipr_intl_time_set_fb = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_bcm_wipr_intl_time_set_fbReq(bc_bcm_wipr_intl_time_set_fb),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_wipr_intl_time_set_fbReq(int32_t bc_bcm_wipr_intl_time_set_fb) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_wipr_intl_time_set_fb);
    req->prop = toInt(VehicleProperty::GECKO_WIPER_INTERVAL_TIME);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_flwr_me_hm_ctrl_fbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_flwr_me_hm_ctrl_fb = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_flwr_me_hm_ctrl_fb");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_flwr_me_hm_ctrl_fb = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_bcm_flwr_me_hm_ctrl_fbReq(bc_bcm_flwr_me_hm_ctrl_fb),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_flwr_me_hm_ctrl_fbReq(int32_t bc_bcm_flwr_me_hm_ctrl_fb) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_flwr_me_hm_ctrl_fb);
    req->prop = toInt(VehicleProperty::GECKO_ACCOMPANY_BACK_HOME_DURATION);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_illmnd_unlock_sts_fbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_illmnd_unlock_sts_fb = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_illmnd_unlock_sts_fb");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_illmnd_unlock_sts_fb = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_bcm_illmnd_unlock_sts_fbReq(bc_bcm_illmnd_unlock_sts_fb),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_illmnd_unlock_sts_fbReq(int32_t bc_bcm_illmnd_unlock_sts_fb) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_illmnd_unlock_sts_fb);
    req->prop = toInt(VehicleProperty::GECKO_WELCOME_UNLOCK_STATUS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_illmnd_lock_sts_fbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_illmnd_lock_sts_fb = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_illmnd_lock_sts_fb");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_illmnd_lock_sts_fb = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_bcm_illmnd_lock_sts_fbReq(bc_bcm_illmnd_lock_sts_fb),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_illmnd_lock_sts_fbReq(int32_t bc_bcm_illmnd_lock_sts_fb) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_illmnd_lock_sts_fb);
    req->prop = toInt(VehicleProperty::GECKO_ILLMND_LOCK_STATUS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_lock_horn_on_st_fbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_lock_horn_on_st_fb = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_lock_horn_on_st_fb");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_lock_horn_on_st_fb = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_bcm_lock_horn_on_st_fbReq(bc_bcm_lock_horn_on_st_fb),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_lock_horn_on_st_fbReq(int32_t bc_bcm_lock_horn_on_st_fb) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_lock_horn_on_st_fb);
    req->prop = toInt(VehicleProperty::GECKO_LOCK_HORN_ENABLE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_esc_disableWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_esc_esc_disable = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_esc_disable");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_esc_esc_disable = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_esc_esc_disableReq(ec_esc_esc_disable),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_esc_disableReq(int32_t ec_esc_esc_disable) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_esc_disable);
    req->prop = toInt(VehicleProperty::GECKO_VEHICLE_STABILITY_ON);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ehb_avh_appld_stWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_ehb_avh_appld_st = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ehb_avh_appld_st");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ehb_avh_appld_st = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_ehb_avh_appld_stReq(ec_ehb_avh_appld_st),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ehb_avh_appld_stReq(int32_t ec_ehb_avh_appld_st) {
    auto req = mValueObjectPool->obtainInt32(ec_ehb_avh_appld_st);
    req->prop = toInt(VehicleProperty::GECKO_AUTO_PARKING_ON);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ehb_epb_system_stateWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_ehb_epb_system_state = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ehb_epb_system_state");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ehb_epb_system_state = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_ehb_epb_system_stateReq(ec_ehb_epb_system_state),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ehb_epb_system_stateReq(int32_t ec_ehb_epb_system_state) {
    auto req = mValueObjectPool->obtainInt32(ec_ehb_epb_system_state);
    req->prop = toInt(VehicleProperty::GECKO_ELECTRONIC_PARKING_MODE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ehb_brk_dis_wip_acWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_ehb_brk_dis_wip_ac = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ehb_brk_dis_wip_ac");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ehb_brk_dis_wip_ac = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_ehb_brk_dis_wip_acReq(ec_ehb_brk_dis_wip_ac),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ehb_brk_dis_wip_acReq(int32_t ec_ehb_brk_dis_wip_ac) {
    auto req = mValueObjectPool->obtainInt32(ec_ehb_brk_dis_wip_ac);
    req->prop = toInt(VehicleProperty::GECKO_BRAKE_DISC_WIPING_ON);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_elec_steer_mode_staWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_elec_steer_mode_sta = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_elec_steer_mode_sta");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_elec_steer_mode_sta = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_elec_steer_mode_staReq(ec_elec_steer_mode_sta),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_elec_steer_mode_staReq(int32_t ec_elec_steer_mode_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_elec_steer_mode_sta);
    req->prop = toInt(VehicleProperty::GECKO_POWER_STEERING_MODE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_veh_act_recuperate_pwrWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_veh_act_recuperate_pwr = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_veh_act_recuperate_pwr");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_veh_act_recuperate_pwr = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_veh_act_recuperate_pwrReq(bc_veh_act_recuperate_pwr),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_veh_act_recuperate_pwrReq(int32_t bc_veh_act_recuperate_pwr) {
    auto req = mValueObjectPool->obtainInt32(bc_veh_act_recuperate_pwr);
    req->prop = toInt(VehicleProperty::GECKO_CCM_ENERGY_RECOV_LEVEL_CMD);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vehicle_driving_pwrWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vehicle_driving_pwr = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vehicle_driving_pwr");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vehicle_driving_pwr = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_vehicle_driving_pwrReq(ec_vehicle_driving_pwr),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vehicle_driving_pwrReq(int32_t ec_vehicle_driving_pwr) {
    auto req = mValueObjectPool->obtainInt32(ec_vehicle_driving_pwr);
    req->prop = toInt(VehicleProperty::GECKO_DRIVING_POWER_ST);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_srs_passenger_airbag_sta_rsvrWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_srs_passenger_airbag_sta_rsvr = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_srs_passenger_airbag_sta_rsvr");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_srs_passenger_airbag_sta_rsvr = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_srs_passenger_airbag_sta_rsvrReq(ec_srs_passenger_airbag_sta_rsvr),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_srs_passenger_airbag_sta_rsvrReq(int32_t ec_srs_passenger_airbag_sta_rsvr) {
    auto req = mValueObjectPool->obtainInt32(ec_srs_passenger_airbag_sta_rsvr);
    req->prop = toInt(VehicleProperty::GECKO_SRS_PASSENGER_AIRBAG_STATUS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_front_fog_light_statusWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_front_fog_light_status = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_front_fog_light_status");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_front_fog_light_status = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_bc_bcm_front_fog_light_statusReq(bc_bcm_front_fog_light_status),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_front_fog_light_statusReq(int32_t bc_bcm_front_fog_light_status) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_front_fog_light_status);
    req->prop = toInt(VehicleProperty::GECKO_FRONT_FOG_LIGHT_STATUS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_key_lo_batt_lvl_warnWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_key_lo_batt_lvl_warn = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_key_lo_batt_lvl_warn");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_key_lo_batt_lvl_warn = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_bc_bcm_key_lo_batt_lvl_warnReq(bc_bcm_key_lo_batt_lvl_warn),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_key_lo_batt_lvl_warnReq(int32_t bc_bcm_key_lo_batt_lvl_warn) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_key_lo_batt_lvl_warn);
    req->prop = toInt(VehicleProperty::GECKO_KEY_LOW_BATT_LVL_WARN);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_warn_no_key_foundWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_warn_no_key_found = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_warn_no_key_found");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_warn_no_key_found = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_bc_bcm_warn_no_key_foundReq(bc_bcm_warn_no_key_found),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_warn_no_key_foundReq(int32_t bc_bcm_warn_no_key_found) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_warn_no_key_found);
    req->prop = toInt(VehicleProperty::GECKO_WARN_NO_KEY_FOUND);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_auto_lamp_statusWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_auto_lamp_status = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_auto_lamp_status");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_auto_lamp_status = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_bc_bcm_auto_lamp_statusReq(bc_bcm_auto_lamp_status),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_auto_lamp_statusReq(int32_t bc_bcm_auto_lamp_status) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_auto_lamp_status);
    req->prop = toInt(VehicleProperty::GECKO_AUTO_LAMP_STATUS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_indication_shiftto_neutralWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_indication_shiftto_neutral = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_indication_shiftto_neutral");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_indication_shiftto_neutral = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_bc_bcm_indication_shiftto_neutralReq(bc_bcm_indication_shiftto_neutral),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_indication_shiftto_neutralReq(int32_t bc_bcm_indication_shiftto_neutral) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_indication_shiftto_neutral);
    req->prop = toInt(VehicleProperty::GECKO_INDICATION_SHIFTTO_NEUTRAL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_12_v_bat_low_vol_staWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_12_v_bat_low_vol_sta = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_12_v_bat_low_vol_sta");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_12_v_bat_low_vol_sta = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_vcu_12_v_bat_low_vol_staReq(ec_vcu_12_v_bat_low_vol_sta),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_12_v_bat_low_vol_staReq(int32_t ec_vcu_12_v_bat_low_vol_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_12_v_bat_low_vol_sta);
    req->prop = toInt(VehicleProperty::GECKO_12V_BAT_LOW_VOL_STA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_sibs_kl30_voltageWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_sibs_kl30_voltage = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_sibs_kl30_voltage");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_sibs_kl30_voltage = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_vcu_sibs_kl30_voltageReq(ec_vcu_sibs_kl30_voltage),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_sibs_kl30_voltageReq(int32_t ec_vcu_sibs_kl30_voltage) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_sibs_kl30_voltage);
    req->prop = toInt(VehicleProperty::GECKO_SIBS_KL30_VOLTAGE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_srs_airbag_warning_lamp_stsWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_srs_airbag_warning_lamp_sts = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_srs_airbag_warning_lamp_sts");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_srs_airbag_warning_lamp_sts = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_srs_airbag_warning_lamp_stsReq(ec_srs_airbag_warning_lamp_sts),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_srs_airbag_warning_lamp_stsReq(int32_t ec_srs_airbag_warning_lamp_sts) {
    auto req = mValueObjectPool->obtainInt32(ec_srs_airbag_warning_lamp_sts);
    req->prop = toInt(VehicleProperty::GECKO_SRS_AIRBAG_WARNING_LAMP_STATUS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_obc_inlet_connect_staWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_ipu_obc_inlet_connect_sta = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_obc_inlet_connect_sta");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ipu_obc_inlet_connect_sta = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_ipu_obc_inlet_connect_staReq(ec_ipu_obc_inlet_connect_sta),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_obc_inlet_connect_staReq(int32_t ec_ipu_obc_inlet_connect_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_obc_inlet_connect_sta);
    req->prop = toInt(VehicleProperty::GECKO_IPU_OBC_INLET_CONNECT_STA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_dcs_inlet_connect_staWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bms_dcs_inlet_connect_sta = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_dcs_inlet_connect_sta");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_dcs_inlet_connect_sta = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_bms_dcs_inlet_connect_staReq(ec_bms_dcs_inlet_connect_sta),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_dcs_inlet_connect_staReq(int32_t ec_bms_dcs_inlet_connect_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_dcs_inlet_connect_sta);
    req->prop = toInt(VehicleProperty::GECKO_BMS_DCS_INLET_CONNECT_STA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}


void GarageModeServerSideHandlerImpl::ec_bms_pwr_train_connect_staWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bms_pwr_train_connect_sta = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_pwr_train_connect_sta");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_pwr_train_connect_sta = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_bms_pwr_train_connect_staReq(ec_bms_pwr_train_connect_sta),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_pwr_train_connect_staReq(int32_t ec_bms_pwr_train_connect_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_pwr_train_connect_sta);
    req->prop = toInt(VehicleProperty::GECKO_BMS_PWR_TRAIN_CONNECT_STA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ehb_brake_liquid_level_warnWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_ehb_brake_liquid_level_warn = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ehb_brake_liquid_level_warn");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ehb_brake_liquid_level_warn = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_ehb_brake_liquid_level_warnReq(ec_ehb_brake_liquid_level_warn),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ehb_brake_liquid_level_warnReq(int32_t ec_ehb_brake_liquid_level_warn) {
    auto req = mValueObjectPool->obtainInt32(ec_ehb_brake_liquid_level_warn);
    req->prop = toInt(VehicleProperty::GECKO_EHB_BRAKE_LIQUID_LEVEL_WARN);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_ebd_failedWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_esc_ebd_failed = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_ebd_failed");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_esc_ebd_failed = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_esc_ebd_failedReq(ec_esc_ebd_failed),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_ebd_failedReq(int32_t ec_esc_ebd_failed) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_ebd_failed);
    req->prop = toInt(VehicleProperty::GECKO_ESC_EBD_FAILED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_vhcl_p_gear_errorWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_vhcl_p_gear_error = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_vhcl_p_gear_error");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_vhcl_p_gear_error = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_vcu_vhcl_p_gear_errorReq(ec_vcu_vhcl_p_gear_error),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_vhcl_p_gear_errorReq(int32_t ec_vcu_vhcl_p_gear_error) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_vhcl_p_gear_error);
    req->prop = toInt(VehicleProperty::GECKO_VCU_VHCL_P_GEAR_ERROR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_motor_high_temp_wrningWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_motor_high_temp_wrning = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_motor_high_temp_wrning");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_motor_high_temp_wrning = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_vcu_motor_high_temp_wrningReq(ec_vcu_motor_high_temp_wrning),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_motor_high_temp_wrningReq(int32_t ec_vcu_motor_high_temp_wrning) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_motor_high_temp_wrning);
    req->prop = toInt(VehicleProperty::GECKO_VCU_MOTOR_HIGH_TEMP_WRNING);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_mcu_high_temp_wrningWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_mcu_high_temp_wrning = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_mcu_high_temp_wrning");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_mcu_high_temp_wrning = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_vcu_mcu_high_temp_wrningReq(ec_vcu_mcu_high_temp_wrning),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_mcu_high_temp_wrningReq(int32_t ec_vcu_mcu_high_temp_wrning) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_mcu_high_temp_wrning);
    req->prop = toInt(VehicleProperty::GECKO_VCU_MCU_HIGH_TEMP_WRNING);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_pcu_fail_staWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_pcu_fail_sta = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_pcu_fail_sta");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_pcu_fail_sta = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_vcu_pcu_fail_staReq(ec_vcu_pcu_fail_sta),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_pcu_fail_staReq(int32_t ec_vcu_pcu_fail_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_pcu_fail_sta);
    req->prop = toInt(VehicleProperty::GECKO_VCU_PCU_FAIL_STA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ehb_epb_warn_lamp_staWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_ehb_epb_warn_lamp_sta = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ehb_epb_warn_lamp_sta");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ehb_epb_warn_lamp_sta = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_ehb_epb_warn_lamp_staReq(ec_ehb_epb_warn_lamp_sta),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ehb_epb_warn_lamp_staReq(int32_t ec_ehb_epb_warn_lamp_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_ehb_epb_warn_lamp_sta);
    req->prop = toInt(VehicleProperty::GECKO_EHB_EPB_WARN_LAMP_STA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ehb_avh_disp_msgWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_ehb_avh_disp_msg = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ehb_avh_disp_msg");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ehb_avh_disp_msg = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_ehb_avh_disp_msgReq(ec_ehb_avh_disp_msg),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ehb_avh_disp_msgReq(int32_t ec_ehb_avh_disp_msg) {
    auto req = mValueObjectPool->obtainInt32(ec_ehb_avh_disp_msg);
    req->prop = toInt(VehicleProperty::GECKO_EHB_AVH_DISP_MSG);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ehb_epb_display_msg_idWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_ehb_epb_display_msg_id = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ehb_epb_display_msg_id");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ehb_epb_display_msg_id = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_ehb_epb_display_msg_idReq(ec_ehb_epb_display_msg_id),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ehb_epb_display_msg_idReq(int32_t ec_ehb_epb_display_msg_id) {
    auto req = mValueObjectPool->obtainInt32(ec_ehb_epb_display_msg_id);
    req->prop = toInt(VehicleProperty::GECKO_EHB_EPB_DISPLAY_MSGID);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ehb_avh_lamp_reqWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_ehb_avh_lamp_req = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ehb_avh_lamp_req");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ehb_avh_lamp_req = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_ehb_avh_lamp_reqReq(ec_ehb_avh_lamp_req),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ehb_avh_lamp_reqReq(int32_t ec_ehb_avh_lamp_req) {
    auto req = mValueObjectPool->obtainInt32(ec_ehb_avh_lamp_req);
    req->prop = toInt(VehicleProperty::GECKO_EHB_AVH_LAMP_REQ);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_esp_active_staWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_esc_esp_active_sta = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_esp_active_sta");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_esc_esp_active_sta = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_esc_esp_active_staReq(ec_esc_esp_active_sta),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_esp_active_staReq(int32_t ec_esc_esp_active_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_esp_active_sta);
    req->prop = toInt(VehicleProperty::GECKO_ESC_ESP_ACTIVE_STA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_tcs_active_staWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_esc_tcs_active_sta = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_tcs_active_sta");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_esc_tcs_active_sta = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_esc_tcs_active_staReq(ec_esc_tcs_active_sta),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_tcs_active_staReq(int32_t ec_esc_tcs_active_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_tcs_active_sta);
    req->prop = toInt(VehicleProperty::GECKO_ESC_TCS_ACTIVE_STA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_es_cor_tcs_failedWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_esc_es_cor_tcs_failed = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_es_cor_tcs_failed");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_esc_es_cor_tcs_failed = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_esc_es_cor_tcs_failedReq(ec_esc_es_cor_tcs_failed),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_es_cor_tcs_failedReq(int32_t ec_esc_es_cor_tcs_failed) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_es_cor_tcs_failed);
    req->prop = toInt(VehicleProperty::GECKO_ESC_ES_COR_TCS_FAILED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_hdc_statusWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_hdc_status = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_hdc_status");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_hdc_status = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_vcu_hdc_statusReq(ec_vcu_hdc_status),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_hdc_statusReq(int32_t ec_vcu_hdc_status) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_hdc_status);
    req->prop = toInt(VehicleProperty::GECKO_VCU_HDC_STATUS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_motor_actual_power_typeWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_motor_actual_power_type = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_motor_actual_power_type");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_motor_actual_power_type = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_vcu_motor_actual_power_typeReq(ec_vcu_motor_actual_power_type),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_motor_actual_power_typeReq(int32_t ec_vcu_motor_actual_power_type) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_motor_actual_power_type);
    req->prop = toInt(VehicleProperty::GECKO_VCU_MOTOR_ACTUAL_POWER_TYPE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_motor_actual_powerWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_motor_actual_power = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_motor_actual_power");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_motor_actual_power = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_vcu_motor_actual_powerReq(ec_vcu_motor_actual_power),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_motor_actual_powerReq(int32_t ec_vcu_motor_actual_power) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_motor_actual_power);
    req->prop = toInt(VehicleProperty::GECKO_VCU_MOTOR_ACTUAL_POWER);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_reserve_powerWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_reserve_power = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_reserve_power");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_reserve_power = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_vcu_reserve_powerReq(ec_vcu_reserve_power),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_reserve_powerReq(int32_t ec_vcu_reserve_power) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_reserve_power);
    req->prop = toInt(VehicleProperty::GECKO_VCU_RESERVE_POWER);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_dcs_act_oprt_modeWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bms_dcs_act_oprt_mode = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_dcs_act_oprt_mode");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_dcs_act_oprt_mode = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_bms_dcs_act_oprt_modeReq(ec_bms_dcs_act_oprt_mode),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_dcs_act_oprt_modeReq(int32_t ec_bms_dcs_act_oprt_mode) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_dcs_act_oprt_mode);
    req->prop = toInt(VehicleProperty::GECKO_BMS_DCS_ACT_OPRT_MODE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_obc_actl_oprt_modeWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_ipu_obc_actl_oprt_mode = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_obc_actl_oprt_mode");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ipu_obc_actl_oprt_mode = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_ipu_obc_actl_oprt_modeReq(ec_ipu_obc_actl_oprt_mode),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_obc_actl_oprt_modeReq(int32_t ec_ipu_obc_actl_oprt_mode) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_obc_actl_oprt_mode);
    req->prop = toInt(VehicleProperty::GECKO_IPU_OBC_ACTL_OPRT_MODE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_obc_oprt_cmd_to_icuWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_obc_oprt_cmd_to_icu = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_obc_oprt_cmd_to_icu");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_obc_oprt_cmd_to_icu = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_vcu_obc_oprt_cmd_to_icuReq(ec_vcu_obc_oprt_cmd_to_icu),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_obc_oprt_cmd_to_icuReq(int32_t ec_vcu_obc_oprt_cmd_to_icu) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_obc_oprt_cmd_to_icu);
    req->prop = toInt(VehicleProperty::GECKO_VCU_OBC_OPRT_CMD_TO_ICU);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_srs_pass_seat_occupant_sensor_stsWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_srs_pass_seat_occupant_sensor_sts = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_srs_pass_seat_occupant_sensor_sts");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_srs_pass_seat_occupant_sensor_sts = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_srs_pass_seat_occupant_sensor_stsReq(ec_srs_pass_seat_occupant_sensor_sts),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_srs_pass_seat_occupant_sensor_stsReq(int32_t ec_srs_pass_seat_occupant_sensor_sts) {
    auto req = mValueObjectPool->obtainInt32(ec_srs_pass_seat_occupant_sensor_sts);
    req->prop = toInt(VehicleProperty::GECKO_SRS_PASS_SEAT_OCCUPANT_SENSOR_STS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_srs_pass_seatbelt_buckle_validWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_srs_pass_seatbelt_buckle_valid = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_srs_pass_seatbelt_buckle_valid");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_srs_pass_seatbelt_buckle_valid = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_srs_pass_seatbelt_buckle_validReq(ec_srs_pass_seatbelt_buckle_valid),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_srs_pass_seatbelt_buckle_validReq(int32_t ec_srs_pass_seatbelt_buckle_valid) {
    auto req = mValueObjectPool->obtainInt32(ec_srs_pass_seatbelt_buckle_valid);
    req->prop = toInt(VehicleProperty::GECKO_SRS_PASS_SEATBELT_BUCKLE_VALID);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_srs_pass_seatbelt_bucklestatusWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_srs_pass_seatbelt_bucklestatus = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_srs_pass_seatbelt_bucklestatus");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_srs_pass_seatbelt_bucklestatus = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_srs_pass_seatbelt_bucklestatusReq(ec_srs_pass_seatbelt_bucklestatus),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_srs_pass_seatbelt_bucklestatusReq(int32_t ec_srs_pass_seatbelt_bucklestatus) {
    auto req = mValueObjectPool->obtainInt32(ec_srs_pass_seatbelt_bucklestatus);
    req->prop = toInt(VehicleProperty::GECKO_SRS_PASS_SEATBELT_BUCKLE_STATUS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_indication_key_closerWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_indication_key_closer = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_indication_key_closer");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_indication_key_closer = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_bc_bcm_indication_key_closerReq(bc_bcm_indication_key_closer),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_indication_key_closerReq(int32_t bc_bcm_indication_key_closer) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_indication_key_closer);
    req->prop = toInt(VehicleProperty::GECKO_BCM_INDICATION_KEY_CLOSER);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_warn_key_out_reminderWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_warn_key_out_reminder = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_warn_key_out_reminder");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_warn_key_out_reminder = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_bc_bcm_warn_key_out_reminderReq(bc_bcm_warn_key_out_reminder),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_warn_key_out_reminderReq(int32_t bc_bcm_warn_key_out_reminder) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_warn_key_out_reminder);
    req->prop = toInt(VehicleProperty::GECKO_BCM_WARN_KEY_OUT_REMINDER);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_light_intensityWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_light_intensity = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_light_intensity");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_light_intensity = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_bc_bcm_light_intensityReq(bc_bcm_light_intensity),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_light_intensityReq(int32_t bc_bcm_light_intensity) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_light_intensity);
    req->prop = toInt(VehicleProperty::GECKO_BCM_LIGHT_INTENSITY);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_ac_envir_temp_vWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_ac_envir_temp_v = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ac_envir_temp_v");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ac_envir_temp_v = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_bc_ac_envir_temp_vReq(bc_ac_envir_temp_v),true);
  }
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ac_envir_temp_vReq(int32_t bc_ac_envir_temp_v) {
    auto req = mValueObjectPool->obtainInt32(bc_ac_envir_temp_v);
    req->prop = toInt(VehicleProperty::GECKO_AC_ENVIR_TEMPV);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_ac_envir_tempWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  float bc_ac_envir_temp = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ac_envir_temp");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ac_envir_temp = getActualFloatValue(mPropertyManager->getCProValue(mp), 0.5, -40);
      mHal->onPropertyValue(*Create_bc_ac_envir_tempReq(bc_ac_envir_temp),true);
  }
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ac_envir_tempReq(float bc_ac_envir_temp) {
    auto req = mValueObjectPool->obtainFloat(bc_ac_envir_temp);
    req->prop = toInt(VehicleProperty::GECKO_AC_ENVIR_TEMP);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::config_query_sim_cardWatcher()
{
  std::this_thread::sleep_for(std::chrono::milliseconds(8000));
  int32_t value = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("config_query_sim_card");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      value = mPropertyManager->getCProValue(mp);
      LOG(INFO) << "config_query_sim_card:"<< value;
      mHal->onPropertyValue(*Create_config_queryReq(1),true);
  }
}

void GarageModeServerSideHandlerImpl::config_query_4g_strengthWatcher()
{
  std::this_thread::sleep_for(std::chrono::milliseconds(8000));
  int32_t value = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("config_query_4g_strength");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      value = mPropertyManager->getCProValue(mp);
      LOG(INFO) << "config_query_4g_strength:"<< value;
      mHal->onPropertyValue(*Create_config_queryReq(3),true);
  }
}

void GarageModeServerSideHandlerImpl::config_query_wifi_strengthWatcher()
{
  std::this_thread::sleep_for(std::chrono::milliseconds(8000));
  int32_t value = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("config_query_wifi_strength");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      value = mPropertyManager->getCProValue(mp);
      LOG(INFO) << "config_query_wifi_strength:"<< value;
      mHal->onPropertyValue(*Create_config_queryReq(4),true);
  }
}

void GarageModeServerSideHandlerImpl::config_query_wifi_statusWatcher()
{
  std::this_thread::sleep_for(std::chrono::milliseconds(8000));
  int32_t value = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("config_query_wifi_status");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      value = mPropertyManager->getCProValue(mp);
      LOG(INFO) << "config_query_wifi_status:"<< value;
      mHal->onPropertyValue(*Create_config_queryReq(5),true);
  }
}

void GarageModeServerSideHandlerImpl::config_query_gps_lonWatcher()
{
  std::this_thread::sleep_for(std::chrono::milliseconds(8000));
  int32_t value = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("config_query_gps_lon");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      value = mPropertyManager->getCProValue(mp);
      LOG(INFO) << "config_query_gps_lon:"<< value;
      mHal->onPropertyValue(*Create_config_queryReq(6),true);
  }
}

void GarageModeServerSideHandlerImpl::config_query_gps_latWatcher()
{
  std::this_thread::sleep_for(std::chrono::milliseconds(8000));
  int32_t value = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("config_query_gps_lat");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      value = mPropertyManager->getCProValue(mp);
      LOG(INFO) << "config_query_gps_lat:"<< value;
      mHal->onPropertyValue(*Create_config_queryReq(7),true);
  }
}


recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_config_queryReq(int32_t value)
{
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_CONFIG_QUERY);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::vcu_chraging_mode_sp_reqWatcher()
{
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t value = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("vcu_chraging_mode_sp_req");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      value = mPropertyManager->getCProValue(mp);
      LOG(INFO) << "vcu_chraging_mode_sp_req:"<< value;
      mHal->onPropertyValue(*Create_vcu_chraging_mode_sp_reqReq(value),true);

      mPropertyManager->updateCPropertyValue("ec_vcu_chraging_mode_sp", value - 1);
  }
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_vcu_chraging_mode_sp_reqReq(int32_t value)
{
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_VCU_CHRAGING_MODE_SP_REQ);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_rmi_active_staWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_esc_rmi_active_sta = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_rmi_active_sta");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_esc_rmi_active_sta = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_esc_rmi_active_staReq(ec_esc_rmi_active_sta),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_rmi_active_staReq(int32_t ec_esc_rmi_active_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_rmi_active_sta);
    req->prop = toInt(VehicleProperty::GECKO_ESC_RMIACTIVESTA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_slope_percent_vWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_esc_slope_percent_v = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_slope_percent_v");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_esc_slope_percent_v = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_esc_slope_percent_vReq(ec_esc_slope_percent_v),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_slope_percent_vReq(int32_t ec_esc_slope_percent_v) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_slope_percent_v);
    req->prop = toInt(VehicleProperty::GECKO_ESC_SLOPEPERCENTV);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_slope_percentWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_esc_slope_percent = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_slope_percent");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_esc_slope_percent = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_esc_slope_percentReq(ec_esc_slope_percent),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_slope_percentReq(int32_t ec_esc_slope_percent) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_slope_percent);
    req->prop = toInt(VehicleProperty::GECKO_ESC_SLOPEPERCENT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ehb_epb_flt_stsWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_ehb_epb_flt_sts = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ehb_epb_flt_sts");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ehb_epb_flt_sts = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_ehb_epb_flt_stsReq(ec_ehb_epb_flt_sts),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ehb_epb_flt_stsReq(int32_t ec_ehb_epb_flt_sts) {
    auto req = mValueObjectPool->obtainInt32(ec_ehb_epb_flt_sts);
    req->prop = toInt(VehicleProperty::GECKO_EHB_EPB_FLTSTS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ehb_epb_switch_stsWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_ehb_epb_switch_sts = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ehb_epb_switch_sts");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ehb_epb_switch_sts = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_ehb_epb_switch_stsReq(ec_ehb_epb_switch_sts),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ehb_epb_switch_stsReq(int32_t ec_ehb_epb_switch_sts) {
    auto req = mValueObjectPool->obtainInt32(ec_ehb_epb_switch_sts);
    req->prop = toInt(VehicleProperty::GECKO_EHB_EPB_SWITCHSTS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ehb_failure_stsWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_ehb_failure_sts = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ehb_failure_sts");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ehb_failure_sts = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_ehb_failure_stsReq(ec_ehb_failure_sts),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ehb_failure_stsReq(int32_t ec_ehb_failure_sts) {
    auto req = mValueObjectPool->obtainInt32(ec_ehb_failure_sts);
    req->prop = toInt(VehicleProperty::GECKO_EHB_FAILURESTS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_vhcl_actl_gear_pos_vWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_vhcl_actl_gear_pos_v = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_vhcl_actl_gear_pos_v");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_vhcl_actl_gear_pos_v = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_vcu_vhcl_actl_gear_pos_vReq(ec_vcu_vhcl_actl_gear_pos_v),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_vhcl_actl_gear_pos_vReq(int32_t ec_vcu_vhcl_actl_gear_pos_v) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_vhcl_actl_gear_pos_v);
    req->prop = toInt(VehicleProperty::GECKO_VCU_VHCLACTLGEARPOSV);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bcm_sys_pwr_mode_vWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bcm_sys_pwr_mode_v = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bcm_sys_pwr_mode_v");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bcm_sys_pwr_mode_v = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_bcm_sys_pwr_mode_vReq(ec_bcm_sys_pwr_mode_v),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bcm_sys_pwr_mode_vReq(int32_t ec_bcm_sys_pwr_mode_v) {
    auto req = mValueObjectPool->obtainInt32(ec_bcm_sys_pwr_mode_v);
    req->prop = toInt(VehicleProperty::GECKO_BCM_SYSPWRMODEV);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bcm_sys_pwr_modeWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bcm_sys_pwr_mode = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bcm_sys_pwr_mode");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bcm_sys_pwr_mode = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_bcm_sys_pwr_modeReq(ec_bcm_sys_pwr_mode),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bcm_sys_pwr_modeReq(int32_t ec_bcm_sys_pwr_mode) {
    auto req = mValueObjectPool->obtainInt32(ec_bcm_sys_pwr_mode);
    req->prop = toInt(VehicleProperty::GECKO_BCM_SYSPWRMODE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bcm_sys_power_stsWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bcm_sys_power_sts = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bcm_sys_power_sts");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bcm_sys_power_sts = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_bcm_sys_power_stsReq(ec_bcm_sys_power_sts),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bcm_sys_power_stsReq(int32_t ec_bcm_sys_power_sts) {
    auto req = mValueObjectPool->obtainInt32(ec_bcm_sys_power_sts);
    req->prop = toInt(VehicleProperty::GECKO_BCM_SYSPOWERSTS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bcm_central_lock_stsWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bcm_central_lock_sts = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bcm_central_lock_sts");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bcm_central_lock_sts = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_bcm_central_lock_stsReq(ec_bcm_central_lock_sts),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bcm_central_lock_stsReq(int32_t ec_bcm_central_lock_sts) {
    auto req = mValueObjectPool->obtainInt32(ec_bcm_central_lock_sts);
    req->prop = toInt(VehicleProperty::GECKO_BCM_CENTRALLOCKSTS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bcm_door_lock_sta_flWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bcm_door_lock_sta_fl = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bcm_door_lock_sta_fl");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bcm_door_lock_sta_fl = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_bcm_door_lock_sta_flReq(ec_bcm_door_lock_sta_fl),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bcm_door_lock_sta_flReq(int32_t ec_bcm_door_lock_sta_fl) {
    auto req = mValueObjectPool->obtainInt32(ec_bcm_door_lock_sta_fl);
    req->prop = toInt(VehicleProperty::GECKO_BCM_DOORLOCKSTA_FL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_pwr_recup_intensityWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_pwr_recup_intensity = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_pwr_recup_intensity");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_pwr_recup_intensity = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_vcu_pwr_recup_intensityReq(ec_vcu_pwr_recup_intensity),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_pwr_recup_intensityReq(int32_t ec_vcu_pwr_recup_intensity) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_pwr_recup_intensity);
    req->prop = toInt(VehicleProperty::GECKO_VCU_PWRRECUPINTENSITY);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}


void GarageModeServerSideHandlerImpl::ec_ccu_diag_tester_onlineWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_ccu_diag_tester_online = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccu_diag_tester_online");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ccu_diag_tester_online = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_ccu_diag_tester_onlineReq(ec_ccu_diag_tester_online),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccu_diag_tester_onlineReq(int32_t ec_ccu_diag_tester_online) {
    auto req = mValueObjectPool->obtainInt32(ec_ccu_diag_tester_online);
    req->prop = toInt(VehicleProperty::GECKO_CCU_DIAGTESTERONLINE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bcm_back_ladjval_fbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bcm_back_ladjval_fb = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bcm_back_ladjval_fb");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bcm_back_ladjval_fb = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_bcm_back_ladjval_fbReq(ec_bcm_back_ladjval_fb),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bcm_back_ladjval_fbReq(int32_t ec_bcm_back_ladjval_fb) {
    auto req = mValueObjectPool->obtainInt32(ec_bcm_back_ladjval_fb);
    req->prop = toInt(VehicleProperty::GECKO_BCM_BACKLADJVALLFB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_day_run_li_fault_fbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_day_run_li_fault_fb = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_day_run_li_fault_fb");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_day_run_li_fault_fb = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_bcm_day_run_li_fault_fbReq(bc_bcm_day_run_li_fault_fb),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_day_run_li_fault_fbReq(int32_t bc_bcm_day_run_li_fault_fb) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_day_run_li_fault_fb);
    req->prop = toInt(VehicleProperty::GECKO_BCM_DAYRUNLIFAULTFB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_reverse_li_fault_fbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_reverse_li_fault_fb = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_reverse_li_fault_fb");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_reverse_li_fault_fb = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_bcm_reverse_li_fault_fbReq(bc_bcm_reverse_li_fault_fb),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_reverse_li_fault_fbReq(int32_t bc_bcm_reverse_li_fault_fb) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_reverse_li_fault_fb);
    req->prop = toInt(VehicleProperty::GECKO_BCM_REVERSELIFAULTFB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_brake_li_fault_fbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_brake_li_fault_fb = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_brake_li_fault_fb");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_brake_li_fault_fb = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_bcm_brake_li_fault_fbReq(bc_bcm_brake_li_fault_fb),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_brake_li_fault_fbReq(int32_t bc_bcm_brake_li_fault_fb) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_brake_li_fault_fb);
    req->prop = toInt(VehicleProperty::GECKO_BCM_BRAKELIFAULTFB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_back_li_fault_fbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_back_li_fault_fb = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_back_li_fault_fb");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_back_li_fault_fb = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_bcm_back_li_fault_fbReq(bc_bcm_back_li_fault_fb),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_back_li_fault_fbReq(int32_t bc_bcm_back_li_fault_fb) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_back_li_fault_fb);
    req->prop = toInt(VehicleProperty::GECKO_BCM_BACKLIFAULTFB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_pos_li_fault_fbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_pos_li_fault_fb = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_pos_li_fault_fb");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_pos_li_fault_fb = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_bcm_pos_li_fault_fbReq(bc_bcm_pos_li_fault_fb),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_pos_li_fault_fbReq(int32_t bc_bcm_pos_li_fault_fb) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_pos_li_fault_fb);
    req->prop = toInt(VehicleProperty::GECKO_BCM_POSLIFAULTFB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_front_fog_li_fault_fbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_front_fog_li_fault_fb = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_front_fog_li_fault_fb");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_front_fog_li_fault_fb = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_bcm_front_fog_li_fault_fbReq(bc_bcm_front_fog_li_fault_fb),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_front_fog_li_fault_fbReq(int32_t bc_bcm_front_fog_li_fault_fb) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_front_fog_li_fault_fb);
    req->prop = toInt(VehicleProperty::GECKO_BCM_FRONTFOGLIFAULTFB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_rear_fog_li_fault_fbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_rear_fog_li_fault_fb = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_rear_fog_li_fault_fb");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_rear_fog_li_fault_fb = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_bcm_rear_fog_li_fault_fbReq(bc_bcm_rear_fog_li_fault_fb),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_rear_fog_li_fault_fbReq(int32_t bc_bcm_rear_fog_li_fault_fb) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_rear_fog_li_fault_fb);
    req->prop = toInt(VehicleProperty::GECKO_BCM_REARFOGLIFAULTFB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_rf_init_staWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_rf_init_sta = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_rf_init_sta");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_rf_init_sta = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_bcm_rf_init_staReq(bc_bcm_rf_init_sta),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_rf_init_staReq(int32_t bc_bcm_rf_init_sta) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_rf_init_sta);
    req->prop = toInt(VehicleProperty::GECKO_BCM_RFINITSTA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_logo_active_flagWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_logo_active_flag = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_logo_active_flag");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_logo_active_flag = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_bcm_logo_active_flagReq(bc_bcm_logo_active_flag),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_logo_active_flagReq(int32_t bc_bcm_logo_active_flag) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_logo_active_flag);
    req->prop = toInt(VehicleProperty::GECKO_BCM_LOGOACTIVEFLAG);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_mai_drvr_seat_stsWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_mai_drvr_seat_sts = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_mai_drvr_seat_sts");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_mai_drvr_seat_sts = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_bcm_mai_drvr_seat_stsReq(bc_bcm_mai_drvr_seat_sts),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_mai_drvr_seat_stsReq(int32_t bc_bcm_mai_drvr_seat_sts) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_mai_drvr_seat_sts);
    req->prop = toInt(VehicleProperty::GECKO_BCM_MAIDRVARSEATSTS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_mai_drvr_seat_tempWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_mai_drvr_seat_temp = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_mai_drvr_seat_temp");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_mai_drvr_seat_temp = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_bcm_mai_drvr_seat_tempReq(bc_bcm_mai_drvr_seat_temp),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_mai_drvr_seat_tempReq(int32_t bc_bcm_mai_drvr_seat_temp) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_mai_drvr_seat_temp);
    req->prop = toInt(VehicleProperty::GECKO_BCM_MAIDRVARSEATTEMP);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_rear_mirror_heat_stsWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_rear_mirror_heat_sts = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_rear_mirror_heat_sts");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_rear_mirror_heat_sts = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_bcm_rear_mirror_heat_stsReq(bc_bcm_rear_mirror_heat_sts),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_rear_mirror_heat_stsReq(int32_t bc_bcm_rear_mirror_heat_sts) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_rear_mirror_heat_sts);
    req->prop = toInt(VehicleProperty::GECKO_BCM_REARMIRRORHEATSTS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_steer_whl_heat_stsWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_steer_whl_heat_sts = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_steer_whl_heat_sts");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_steer_whl_heat_sts = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_bcm_steer_whl_heat_stsReq(bc_bcm_steer_whl_heat_sts),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_steer_whl_heat_stsReq(int32_t bc_bcm_steer_whl_heat_sts) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_steer_whl_heat_sts);
    req->prop = toInt(VehicleProperty::GECKO_BCM_STEERWHLHEATSTS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_steer_whl_tempWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_steer_whl_temp = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_steer_whl_temp");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_steer_whl_temp = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_bcm_steer_whl_tempReq(bc_bcm_steer_whl_temp),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_steer_whl_tempReq(int32_t bc_bcm_steer_whl_temp) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_steer_whl_temp);
    req->prop = toInt(VehicleProperty::GECKO_BCM_STEERWHLTEMP);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_illmnd_entry_sts_fbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_illmnd_entry_sts_fb = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_illmnd_entry_sts_fb");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_illmnd_entry_sts_fb = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_bcm_illmnd_entry_sts_fbReq(bc_bcm_illmnd_entry_sts_fb),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_illmnd_entry_sts_fbReq(int32_t bc_bcm_illmnd_entry_sts_fb) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_illmnd_entry_sts_fb);
    req->prop = toInt(VehicleProperty::GECKO_BCM_ILLMNDENTRYSTSF);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_pass_lf_ant_diag_statusWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_pass_lf_ant_diag_status = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_pass_lf_ant_diag_status");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_pass_lf_ant_diag_status = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_pass_lf_ant_diag_statusReq(bc_pass_lf_ant_diag_status),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_pass_lf_ant_diag_statusReq(int32_t bc_pass_lf_ant_diag_status) {
    auto req = mValueObjectPool->obtainInt32(bc_pass_lf_ant_diag_status);
    req->prop = toInt(VehicleProperty::GECKO_PASSLFANT_DIAGSTATUS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_int_lf_ant_diag_statusWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_int_lf_ant_diag_status = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_int_lf_ant_diag_status");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_int_lf_ant_diag_status = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_int_lf_ant_diag_statusReq(bc_int_lf_ant_diag_status),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_int_lf_ant_diag_statusReq(int32_t bc_int_lf_ant_diag_status) {
    auto req = mValueObjectPool->obtainInt32(bc_int_lf_ant_diag_status);
    req->prop = toInt(VehicleProperty::GECKO_INTLFANT_DIAGSTATUS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_lf_init_staWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_lf_init_sta = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_lf_init_sta");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_lf_init_sta = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_bcm_lf_init_staReq(bc_bcm_lf_init_sta),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_lf_init_staReq(int32_t bc_bcm_lf_init_sta) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_lf_init_sta);
    req->prop = toInt(VehicleProperty::GECKO_BCM_LFINITSTA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_drv_lf_ant_diag_statusWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_drv_lf_ant_diag_status = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_drv_lf_ant_diag_status");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_drv_lf_ant_diag_status = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_drv_lf_ant_diag_statusReq(bc_drv_lf_ant_diag_status),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_drv_lf_ant_diag_statusReq(int32_t bc_drv_lf_ant_diag_status) {
    auto req = mValueObjectPool->obtainInt32(bc_drv_lf_ant_diag_status);
    req->prop = toInt(VehicleProperty::GECKO_DRVLFANT_DIAGSTATUS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_chg_wiper_mt_md_sw_set_fbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_chg_wiper_mt_md_sw_set_fb = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_chg_wiper_mt_md_sw_set_fb");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_chg_wiper_mt_md_sw_set_fb = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_bcm_chg_wiper_mt_md_sw_set_fbReq(bc_bcm_chg_wiper_mt_md_sw_set_fb),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_chg_wiper_mt_md_sw_set_fbReq(int32_t bc_bcm_chg_wiper_mt_md_sw_set_fb) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_chg_wiper_mt_md_sw_set_fb);
    req->prop = toInt(VehicleProperty::GECKO_BCM_CHGWIPERMTRMDSWSETF);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_park_auto_unlock_set_fbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_park_auto_unlock_set_fb = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_park_auto_unlock_set_fb");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_park_auto_unlock_set_fb = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_bcm_park_auto_unlock_set_fbReq(bc_bcm_park_auto_unlock_set_fb),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_park_auto_unlock_set_fbReq(int32_t bc_bcm_park_auto_unlock_set_fb) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_park_auto_unlock_set_fb);
    req->prop = toInt(VehicleProperty::GECKO_BCM_PARKAUTOUNLOCKSETFB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_overspd_cntrl_lock_set_fbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_overspd_cntrl_lock_set_fb = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_overspd_cntrl_lock_set_fb");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_overspd_cntrl_lock_set_fb = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_bcm_overspd_cntrl_lock_set_fbReq(bc_bcm_overspd_cntrl_lock_set_fb),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_overspd_cntrl_lock_set_fbReq(int32_t bc_bcm_overspd_cntrl_lock_set_fb) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_overspd_cntrl_lock_set_fb);
    req->prop = toInt(VehicleProperty::GECKO_BCM_OVERSPDCNTRLLOCKSETF);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_trunk_lock_staWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_trunk_lock_sta = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_trunk_lock_sta");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_trunk_lock_sta = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_bcm_trunk_lock_staReq(bc_bcm_trunk_lock_sta),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_trunk_lock_staReq(int32_t bc_bcm_trunk_lock_sta) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_trunk_lock_sta);
    req->prop = toInt(VehicleProperty::GECKO_BCM_TRUNKLOCKSTA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_trunk_lock_sw_ctrl_fbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_trunk_lock_sw_ctrl_fb = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_trunk_lock_sw_ctrl_fb");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_trunk_lock_sw_ctrl_fb = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_bcm_trunk_lock_sw_ctrl_fbReq(bc_bcm_trunk_lock_sw_ctrl_fb),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_trunk_lock_sw_ctrl_fbReq(int32_t bc_bcm_trunk_lock_sw_ctrl_fb) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_trunk_lock_sw_ctrl_fb);
    req->prop = toInt(VehicleProperty::GECKO_BCM_TRUNKLOCKSWCTRLF);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_ps_authent_resWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_ps_authent_res = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_ps_authent_res");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_ps_authent_res = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_bcm_ps_authent_resReq(bc_bcm_ps_authent_res),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_ps_authent_resReq(int32_t bc_bcm_ps_authent_res) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_ps_authent_res);
    req->prop = toInt(VehicleProperty::GECKO_BCM_PSAUTHENTRES);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_key_in_car_staWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_key_in_car_sta = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_key_in_car_sta");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_key_in_car_sta = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_bcm_key_in_car_staReq(bc_bcm_key_in_car_sta),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_key_in_car_staReq(int32_t bc_bcm_key_in_car_sta) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_key_in_car_sta);
    req->prop = toInt(VehicleProperty::GECKO_BCM_KEYINCARSTA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}


void GarageModeServerSideHandlerImpl::bc_bcm_body_warn_stsWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_body_warn_sts = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_body_warn_sts");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_body_warn_sts = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_bcm_body_warn_stsReq(bc_bcm_body_warn_sts),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_body_warn_stsReq(int32_t bc_bcm_body_warn_sts) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_body_warn_sts);
    req->prop = toInt(VehicleProperty::GECKO_BCM_BODYWARNSTS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_drv_pass_win_sw_sigWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_drv_pass_win_sw_sig = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_drv_pass_win_sw_sig");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_drv_pass_win_sw_sig = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_bcm_drv_pass_win_sw_sigReq(bc_bcm_drv_pass_win_sw_sig),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_drv_pass_win_sw_sigReq(int32_t bc_bcm_drv_pass_win_sw_sig) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_drv_pass_win_sw_sig);
    req->prop = toInt(VehicleProperty::GECKO_BCM_DRVPASSWINSWSIG);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_pas_wdw_initWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_pas_wdw_init = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_pas_wdw_init");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_pas_wdw_init = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_bcm_pas_wdw_initReq(bc_bcm_pas_wdw_init),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_pas_wdw_initReq(int32_t bc_bcm_pas_wdw_init) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_pas_wdw_init);
    req->prop = toInt(VehicleProperty::GECKO_BCM_PAS_WDW_INIT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_front_wash_stsWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_front_wash_sts = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_front_wash_sts");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_front_wash_sts = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_bcm_front_wash_stsReq(bc_bcm_front_wash_sts),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_front_wash_stsReq(int32_t bc_bcm_front_wash_sts) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_front_wash_sts);
    req->prop = toInt(VehicleProperty::GECKO_BCM_FRONTWASHSTS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_wash_liquid_level_warnWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_wash_liquid_level_warn = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_wash_liquid_level_warn");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_wash_liquid_level_warn = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_bcm_wash_liquid_level_warnReq(bc_bcm_wash_liquid_level_warn),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_wash_liquid_level_warnReq(int32_t bc_bcm_wash_liquid_level_warn) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_wash_liquid_level_warn);
    req->prop = toInt(VehicleProperty::GECKO_BCM_WASHLIQUIDLEVELWARN);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_fl_windowmotor_flagsWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_fl_windowmotor_flags = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_fl_windowmotor_flags");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_fl_windowmotor_flags = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_bcm_fl_windowmotor_flagsReq(bc_bcm_fl_windowmotor_flags),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_fl_windowmotor_flagsReq(int32_t bc_bcm_fl_windowmotor_flags) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_fl_windowmotor_flags);
    req->prop = toInt(VehicleProperty::GECKO_BCM_FLWINDOWMOTORFLAGS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_fr_windowmotor_flagsWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_fr_windowmotor_flags = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_fr_windowmotor_flags");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_fr_windowmotor_flags = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_bcm_fr_windowmotor_flagsReq(bc_bcm_fr_windowmotor_flags),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_fr_windowmotor_flagsReq(int32_t bc_bcm_fr_windowmotor_flags) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_fr_windowmotor_flags);
    req->prop = toInt(VehicleProperty::GECKO_BCM_FRWINDOWMOTORFLAGS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_tpms_reset_stsWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_tpms_reset_sts = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_tpms_reset_sts");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_tpms_reset_sts = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_bcm_tpms_reset_stsReq(bc_bcm_tpms_reset_sts),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_tpms_reset_stsReq(int32_t bc_bcm_tpms_reset_sts) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_tpms_reset_sts);
    req->prop = toInt(VehicleProperty::GECKO_BCM_TPMSRESETSTS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_ajar_sta_hoodWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_ajar_sta_hood = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_ajar_sta_hood");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_ajar_sta_hood = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_bcm_ajar_sta_hoodReq(bc_bcm_ajar_sta_hood),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_ajar_sta_hoodReq(int32_t bc_bcm_ajar_sta_hood) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_ajar_sta_hood);
    req->prop = toInt(VehicleProperty::GECKO_BCM_AJARSTA_HOOD);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_light_sw_sigWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_light_sw_sig = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_light_sw_sig");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_light_sw_sig = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_bcm_light_sw_sigReq(bc_bcm_light_sw_sig),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_light_sw_sigReq(int32_t bc_bcm_light_sw_sig) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_light_sw_sig);
    req->prop = toInt(VehicleProperty::GECKO_BCM_LIGHTSWSIG);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_vcu_cruise_ctr_tgt_spd_for_bacWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_vcu_cruise_ctr_tgt_spd_for_bac = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_vcu_cruise_ctr_tgt_spd_for_bac");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_vcu_cruise_ctr_tgt_spd_for_bac = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_vcu_cruise_ctr_tgt_spd_for_bacReq(bc_vcu_cruise_ctr_tgt_spd_for_bac),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_vcu_cruise_ctr_tgt_spd_for_bacReq(int32_t bc_vcu_cruise_ctr_tgt_spd_for_bac) {
    auto req = mValueObjectPool->obtainInt32(bc_vcu_cruise_ctr_tgt_spd_for_bac);
    req->prop = toInt(VehicleProperty::GECKO_VCU_CRUISECTRGTSPD_FORBAC);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_vcu_cruise_ctrl_sta_for_bacWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_vcu_cruise_ctrl_sta_for_bac = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_vcu_cruise_ctrl_sta_for_bac");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_vcu_cruise_ctrl_sta_for_bac = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_vcu_cruise_ctrl_sta_for_bacReq(bc_vcu_cruise_ctrl_sta_for_bac),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_vcu_cruise_ctrl_sta_for_bacReq(int32_t bc_vcu_cruise_ctrl_sta_for_bac) {
    auto req = mValueObjectPool->obtainInt32(bc_vcu_cruise_ctrl_sta_for_bac);
    req->prop = toInt(VehicleProperty::GECKO_VCU_CRUISECTRLSTA_FORBAC);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_vcu_wgh_distbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_vcu_wgh_distb = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_vcu_wgh_distb");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_vcu_wgh_distb = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_vcu_wgh_distbReq(bc_vcu_wgh_distb),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_vcu_wgh_distbReq(int32_t bc_vcu_wgh_distb) {
    auto req = mValueObjectPool->obtainInt32(bc_vcu_wgh_distb);
    req->prop = toInt(VehicleProperty::GECKO_VCU_WGHDISTB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_vcu_wgh_estWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_vcu_wgh_est = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_vcu_wgh_est");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_vcu_wgh_est = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_vcu_wgh_estReq(bc_vcu_wgh_est),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_vcu_wgh_estReq(int32_t bc_vcu_wgh_est) {
    auto req = mValueObjectPool->obtainInt32(bc_vcu_wgh_est);
    req->prop = toInt(VehicleProperty::GECKO_VCU_WGHEST);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_vcu_wgh_confdenceWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_vcu_wgh_confdence = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_vcu_wgh_confdence");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_vcu_wgh_confdence = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_vcu_wgh_confdenceReq(bc_vcu_wgh_confdence),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_vcu_wgh_confdenceReq(int32_t bc_vcu_wgh_confdence) {
    auto req = mValueObjectPool->obtainInt32(bc_vcu_wgh_confdence);
    req->prop = toInt(VehicleProperty::GECKO_VCU_WGHCONFIDENCE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_vcu_vesion_set_fbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_vcu_vesion_set_fb = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_vcu_vesion_set_fb");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_vcu_vesion_set_fb = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_vcu_vesion_set_fbReq(bc_vcu_vesion_set_fb),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_vcu_vesion_set_fbReq(int32_t bc_vcu_vesion_set_fb) {
    auto req = mValueObjectPool->obtainInt32(bc_vcu_vesion_set_fb);
    req->prop = toInt(VehicleProperty::GECKO_VCU_VERSIONSETFB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_vcu_version_fbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_vcu_version_fb = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_vcu_version_fb");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_vcu_version_fb = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_vcu_version_fbReq(bc_vcu_version_fb),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_vcu_version_fbReq(int32_t bc_vcu_version_fb) {
    auto req = mValueObjectPool->obtainInt32(bc_vcu_version_fb);
    req->prop = toInt(VehicleProperty::GECKO_VCU_VERSIONFB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_vcu_operat_licence_fbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_vcu_operat_licence_fb = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_vcu_operat_licence_fb");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_vcu_operat_licence_fb = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_vcu_operat_licence_fbReq(bc_vcu_operat_licence_fb),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_vcu_operat_licence_fbReq(int32_t bc_vcu_operat_licence_fb) {
    auto req = mValueObjectPool->obtainInt32(bc_vcu_operat_licence_fb);
    req->prop = toInt(VehicleProperty::GECKO_VCU_OPERATLICENCEFB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_vcu_speed_limit_level_fbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_vcu_speed_limit_level_fb = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_vcu_speed_limit_level_fb");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_vcu_speed_limit_level_fb = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_vcu_speed_limit_level_fbReq(bc_vcu_speed_limit_level_fb),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_vcu_speed_limit_level_fbReq(int32_t bc_vcu_speed_limit_level_fb) {
    auto req = mValueObjectPool->obtainInt32(bc_vcu_speed_limit_level_fb);
    req->prop = toInt(VehicleProperty::GECKO_CCM_SPEED_LIMIT_LEVEL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_ccu_remote_power_lock_fbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_ccu_remote_power_lock_fb = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ccu_remote_power_lock_fb");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ccu_remote_power_lock_fb = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_ccu_remote_power_lock_fbReq(bc_ccu_remote_power_lock_fb),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ccu_remote_power_lock_fbReq(int32_t bc_ccu_remote_power_lock_fb) {
    auto req = mValueObjectPool->obtainInt32(bc_ccu_remote_power_lock_fb);
    req->prop = toInt(VehicleProperty::GECKO_CCU_REMOTEPOWERLOCKFB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_ac_remt_ctrl_fbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_ac_remt_ctrl_fb = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ac_remt_ctrl_fb");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ac_remt_ctrl_fb = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_ac_remt_ctrl_fbReq(bc_ac_remt_ctrl_fb),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ac_remt_ctrl_fbReq(int32_t bc_ac_remt_ctrl_fb) {
    auto req = mValueObjectPool->obtainInt32(bc_ac_remt_ctrl_fb);
    req->prop = toInt(VehicleProperty::GECKO_AC_REMTCNTLFB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_ac_temp_set_fbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_ac_temp_set_fb = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ac_temp_set_fb");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ac_temp_set_fb = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_ac_temp_set_fbReq(bc_ac_temp_set_fb),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ac_temp_set_fbReq(int32_t bc_ac_temp_set_fb) {
    auto req = mValueObjectPool->obtainInt32(bc_ac_temp_set_fb);
    req->prop = toInt(VehicleProperty::GECKO_AC_TEMPSETFB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_ac_remote_defrost_ctl_fbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_ac_remote_defrost_ctl_fb = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ac_remote_defrost_ctl_fb");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ac_remote_defrost_ctl_fb = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_ac_remote_defrost_ctl_fbReq(bc_ac_remote_defrost_ctl_fb),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ac_remote_defrost_ctl_fbReq(int32_t bc_ac_remote_defrost_ctl_fb) {
    auto req = mValueObjectPool->obtainInt32(bc_ac_remote_defrost_ctl_fb);
    req->prop = toInt(VehicleProperty::GECKO_AC_REMOTEDFROSTCTLFB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_ac_ac_unlock_vent_set_fbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_ac_ac_unlock_vent_set_fb = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ac_ac_unlock_vent_set_fb");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ac_ac_unlock_vent_set_fb = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_ac_ac_unlock_vent_set_fbReq(bc_ac_ac_unlock_vent_set_fb),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ac_ac_unlock_vent_set_fbReq(int32_t bc_ac_ac_unlock_vent_set_fb) {
    auto req = mValueObjectPool->obtainInt32(bc_ac_ac_unlock_vent_set_fb);
    req->prop = toInt(VehicleProperty::GECKO_AC_ACUNLOCKVENTSETFB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_ccu_open_ventilation_fbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_ccu_open_ventilation_fb = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ccu_open_ventilation_fb");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ccu_open_ventilation_fb = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_ccu_open_ventilation_fbReq(bc_ccu_open_ventilation_fb),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ccu_open_ventilation_fbReq(int32_t bc_ccu_open_ventilation_fb) {
    auto req = mValueObjectPool->obtainInt32(bc_ccu_open_ventilation_fb);
    req->prop = toInt(VehicleProperty::GECKO_CCU_OPENVENTILATIONFB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_vcu_ac_chrg_modeWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_vcu_ac_chrg_mode = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_vcu_ac_chrg_mode");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_vcu_ac_chrg_mode = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_vcu_ac_chrg_modeReq(bc_vcu_ac_chrg_mode),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_vcu_ac_chrg_modeReq(int32_t bc_vcu_ac_chrg_mode) {
    auto req = mValueObjectPool->obtainInt32(bc_vcu_ac_chrg_mode);
    req->prop = toInt(VehicleProperty::GECKO_VCU_ACCHRGMODE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_vcu_ac_chrg_max_currWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_vcu_ac_chrg_max_curr = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_vcu_ac_chrg_max_curr");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_vcu_ac_chrg_max_curr = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_vcu_ac_chrg_max_currReq(bc_vcu_ac_chrg_max_curr),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_vcu_ac_chrg_max_currReq(int32_t bc_vcu_ac_chrg_max_curr) {
    auto req = mValueObjectPool->obtainInt32(bc_vcu_ac_chrg_max_curr);
    req->prop = toInt(VehicleProperty::GECKO_VCU_ACCHRGMAXCURR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_vcu_sibs_fb_rtc_wup_flgWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_vcu_sibs_fb_rtc_wup_flg = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_vcu_sibs_fb_rtc_wup_flg");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_vcu_sibs_fb_rtc_wup_flg = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_vcu_sibs_fb_rtc_wup_flgReq(bc_vcu_sibs_fb_rtc_wup_flg),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_vcu_sibs_fb_rtc_wup_flgReq(int32_t bc_vcu_sibs_fb_rtc_wup_flg) {
    auto req = mValueObjectPool->obtainInt32(bc_vcu_sibs_fb_rtc_wup_flg);
    req->prop = toInt(VehicleProperty::GECKO_VCU_SIBS_FBRTCWUPFLG);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_vcu_sibs_bms_bat_soc_allowWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_vcu_sibs_bms_bat_soc_allow = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_vcu_sibs_bms_bat_soc_allow");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_vcu_sibs_bms_bat_soc_allow = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_vcu_sibs_bms_bat_soc_allowReq(bc_vcu_sibs_bms_bat_soc_allow),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_vcu_sibs_bms_bat_soc_allowReq(int32_t bc_vcu_sibs_bms_bat_soc_allow) {
    auto req = mValueObjectPool->obtainInt32(bc_vcu_sibs_bms_bat_soc_allow);
    req->prop = toInt(VehicleProperty::GECKO_VCU_SIBS_BMSBATSOCALLOW);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_vcu_sibs_wup_volt_allowWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_vcu_sibs_wup_volt_allow = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_vcu_sibs_wup_volt_allow");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_vcu_sibs_wup_volt_allow = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_vcu_sibs_wup_volt_allowReq(bc_vcu_sibs_wup_volt_allow),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_vcu_sibs_wup_volt_allowReq(int32_t bc_vcu_sibs_wup_volt_allow) {
    auto req = mValueObjectPool->obtainInt32(bc_vcu_sibs_wup_volt_allow);
    req->prop = toInt(VehicleProperty::GECKO_VCU_SIBS_WUPVOLTALLOW);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_vcu_sibs_rtc_chrg_stWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_vcu_sibs_rtc_chrg_st = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_vcu_sibs_rtc_chrg_st");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_vcu_sibs_rtc_chrg_st = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_vcu_sibs_rtc_chrg_stReq(bc_vcu_sibs_rtc_chrg_st),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_vcu_sibs_rtc_chrg_stReq(int32_t bc_vcu_sibs_rtc_chrg_st) {
    auto req = mValueObjectPool->obtainInt32(bc_vcu_sibs_rtc_chrg_st);
    req->prop = toInt(VehicleProperty::GECKO_VCU_SIBS_RTCCHRGST);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_vcu_sibs_rtcwu_chg_fail_numWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_vcu_sibs_rtcwu_chg_fail_num = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_vcu_sibs_rtcwu_chg_fail_num");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_vcu_sibs_rtcwu_chg_fail_num = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_vcu_sibs_rtcwu_chg_fail_numReq(bc_vcu_sibs_rtcwu_chg_fail_num),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_vcu_sibs_rtcwu_chg_fail_numReq(int32_t bc_vcu_sibs_rtcwu_chg_fail_num) {
    auto req = mValueObjectPool->obtainInt32(bc_vcu_sibs_rtcwu_chg_fail_num);
    req->prop = toInt(VehicleProperty::GECKO_VCU_SIBS_RTCWUCHGFAILNUM);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_vcu_sibs_chg_num_allowWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_vcu_sibs_chg_num_allow = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_vcu_sibs_chg_num_allow");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_vcu_sibs_chg_num_allow = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_vcu_sibs_chg_num_allowReq(bc_vcu_sibs_chg_num_allow),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_vcu_sibs_chg_num_allowReq(int32_t bc_vcu_sibs_chg_num_allow) {
    auto req = mValueObjectPool->obtainInt32(bc_vcu_sibs_chg_num_allow);
    req->prop = toInt(VehicleProperty::GECKO_VCU_SIBS_CHGNUMALLOW);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_vcu_sibs_rtcwu_chg_numWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_vcu_sibs_rtcwu_chg_num = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_vcu_sibs_rtcwu_chg_num");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_vcu_sibs_rtcwu_chg_num = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_vcu_sibs_rtcwu_chg_numReq(bc_vcu_sibs_rtcwu_chg_num),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_vcu_sibs_rtcwu_chg_numReq(int32_t bc_vcu_sibs_rtcwu_chg_num) {
    auto req = mValueObjectPool->obtainInt32(bc_vcu_sibs_rtcwu_chg_num);
    req->prop = toInt(VehicleProperty::GECKO_VCU_SIBS_RTCWUCHGNUM);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_vcu_sibs_kl30_voltageWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  float bc_vcu_sibs_kl30_voltage = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_vcu_sibs_kl30_voltage");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_vcu_sibs_kl30_voltage = getActualFloatValue(mPropertyManager->getCProValue(mp),0.1,0);
      mHal->onPropertyValue(*Create_bc_vcu_sibs_kl30_voltageReq(bc_vcu_sibs_kl30_voltage),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_vcu_sibs_kl30_voltageReq(float bc_vcu_sibs_kl30_voltage) {
    auto req = mValueObjectPool->obtainFloat(bc_vcu_sibs_kl30_voltage);
    req->prop = toInt(VehicleProperty::GECKO_VCU_SIBS_KL30VOLTAGE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_vcu_lock_veh_warmWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_vcu_lock_veh_warm = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_vcu_lock_veh_warm");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_vcu_lock_veh_warm = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_vcu_lock_veh_warmReq(bc_vcu_lock_veh_warm),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_vcu_lock_veh_warmReq(int32_t bc_vcu_lock_veh_warm) {
    auto req = mValueObjectPool->obtainInt32(bc_vcu_lock_veh_warm);
    req->prop = toInt(VehicleProperty::GECKO_VCU_LOCKVEHWARM);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_vcu_shift_key_stagnationWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_vcu_shift_key_stagnation = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_vcu_shift_key_stagnation");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_vcu_shift_key_stagnation = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_vcu_shift_key_stagnationReq(bc_vcu_shift_key_stagnation),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_vcu_shift_key_stagnationReq(int32_t bc_vcu_shift_key_stagnation) {
    auto req = mValueObjectPool->obtainInt32(bc_vcu_shift_key_stagnation);
    req->prop = toInt(VehicleProperty::GECKO_VCU_SHIFTKYSTAGNATION);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_vcu_cc_key_stagnationWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_vcu_cc_key_stagnation = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_vcu_cc_key_stagnation");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_vcu_cc_key_stagnation = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_vcu_cc_key_stagnationReq(bc_vcu_cc_key_stagnation),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_vcu_cc_key_stagnationReq(int32_t bc_vcu_cc_key_stagnation) {
    auto req = mValueObjectPool->obtainInt32(bc_vcu_cc_key_stagnation);
    req->prop = toInt(VehicleProperty::GECKO_VCU_CCKYSTAGNATION);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_vcu_drive_mode_key_stagnationWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_vcu_drive_mode_key_stagnation = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_vcu_drive_mode_key_stagnation");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_vcu_drive_mode_key_stagnation = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_vcu_drive_mode_key_stagnationReq(bc_vcu_drive_mode_key_stagnation),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_vcu_drive_mode_key_stagnationReq(int32_t bc_vcu_drive_mode_key_stagnation) {
    auto req = mValueObjectPool->obtainInt32(bc_vcu_drive_mode_key_stagnation);
    req->prop = toInt(VehicleProperty::GECKO_VCU_DRIVEMODEKYSTAGNATION);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_vcu_vhcl_speed_fast_warnWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_vcu_vhcl_speed_fast_warn = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_vcu_vhcl_speed_fast_warn");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_vcu_vhcl_speed_fast_warn = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_vcu_vhcl_speed_fast_warnReq(bc_vcu_vhcl_speed_fast_warn),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_vcu_vhcl_speed_fast_warnReq(int32_t bc_vcu_vhcl_speed_fast_warn) {
    auto req = mValueObjectPool->obtainInt32(bc_vcu_vhcl_speed_fast_warn);
    req->prop = toInt(VehicleProperty::GECKO_VCU_VHCLSPEEDFASTWARN);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_vcu_info_dispWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_vcu_info_disp = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_vcu_info_disp");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_vcu_info_disp = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_vcu_info_dispReq(bc_vcu_info_disp),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_vcu_info_dispReq(int32_t bc_vcu_info_disp) {
    auto req = mValueObjectPool->obtainInt32(bc_vcu_info_disp);
    req->prop = toInt(VehicleProperty::GECKO_VCU_INFODISP);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::cc_eps_sws_hod_hands_off_stsWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t cc_eps_sws_hod_hands_off_sts = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_eps_sws_hod_hands_off_sts");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_eps_sws_hod_hands_off_sts = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_cc_eps_sws_hod_hands_off_stsReq(cc_eps_sws_hod_hands_off_sts),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_eps_sws_hod_hands_off_stsReq(int32_t cc_eps_sws_hod_hands_off_sts) {
    auto req = mValueObjectPool->obtainInt32(cc_eps_sws_hod_hands_off_sts);
    req->prop = toInt(VehicleProperty::GECKO_EPS_SWS_HODHANDSOFFSTS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::cc_eps_mode_set_inhibit_fbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t cc_eps_mode_set_inhibit_fb = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_eps_mode_set_inhibit_fb");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_eps_mode_set_inhibit_fb = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_cc_eps_mode_set_inhibit_fbReq(cc_eps_mode_set_inhibit_fb),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_eps_mode_set_inhibit_fbReq(int32_t cc_eps_mode_set_inhibit_fb) {
    auto req = mValueObjectPool->obtainInt32(cc_eps_mode_set_inhibit_fb);
    req->prop = toInt(VehicleProperty::GECKO_EPS_MODESETINHIBITFB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::cc_eps_basic_elec_steer_failedWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t cc_eps_basic_elec_steer_failed = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_eps_basic_elec_steer_failed");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_eps_basic_elec_steer_failed = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_cc_eps_basic_elec_steer_failedReq(cc_eps_basic_elec_steer_failed),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_eps_basic_elec_steer_failedReq(int32_t cc_eps_basic_elec_steer_failed) {
    auto req = mValueObjectPool->obtainInt32(cc_eps_basic_elec_steer_failed);
    req->prop = toInt(VehicleProperty::GECKO_EPS_BASICELECSTEERFAILED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_icu_icu_trip_b_odometerWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_icu_icu_trip_b_odometer = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_icu_icu_trip_b_odometer");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_icu_icu_trip_b_odometer = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_icu_icu_trip_b_odometerReq(ec_icu_icu_trip_b_odometer),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_icu_icu_trip_b_odometerReq(int32_t ec_icu_icu_trip_b_odometer) {
    auto req = mValueObjectPool->obtainInt32(ec_icu_icu_trip_b_odometer);
    req->prop = toInt(VehicleProperty::GECKO_ICU_ICUTRIPBODOMETER);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_icu_icu_trip_a_odometerWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_icu_icu_trip_a_odometer = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_icu_icu_trip_a_odometer");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_icu_icu_trip_a_odometer = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_icu_icu_trip_a_odometerReq(ec_icu_icu_trip_a_odometer),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_icu_icu_trip_a_odometerReq(int32_t ec_icu_icu_trip_a_odometer) {
    auto req = mValueObjectPool->obtainInt32(ec_icu_icu_trip_a_odometer);
    req->prop = toInt(VehicleProperty::GECKO_ICU_ICUTRIPAODOMETER);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_icu_vehicle_speed_displayed_vWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_icu_vehicle_speed_displayed_v = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_icu_vehicle_speed_displayed_v");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_icu_vehicle_speed_displayed_v = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_icu_vehicle_speed_displayed_vReq(ec_icu_vehicle_speed_displayed_v),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_icu_vehicle_speed_displayed_vReq(int32_t ec_icu_vehicle_speed_displayed_v) {
    auto req = mValueObjectPool->obtainInt32(ec_icu_vehicle_speed_displayed_v);
    req->prop = toInt(VehicleProperty::GECKO_ICU_VEHICLESPEEDDISPLAYEDV);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_dcs_actl_chrg_voltageWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bms_dcs_actl_chrg_voltage = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_dcs_actl_chrg_voltage");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_dcs_actl_chrg_voltage = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_bms_dcs_actl_chrg_voltageReq(ec_bms_dcs_actl_chrg_voltage),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_dcs_actl_chrg_voltageReq(int32_t ec_bms_dcs_actl_chrg_voltage) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_dcs_actl_chrg_voltage);
    req->prop = toInt(VehicleProperty::GECKO_BMS_DCS_ACTLCHRGVOLTAGE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_thermalrunaway_wrnWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bms_thermalrunaway_wrn = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_thermalrunaway_wrn");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_thermalrunaway_wrn = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_bms_thermalrunaway_wrnReq(ec_bms_thermalrunaway_wrn),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_thermalrunaway_wrnReq(int32_t ec_bms_thermalrunaway_wrn) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_thermalrunaway_wrn);
    req->prop = toInt(VehicleProperty::GECKO_BMS_THERMALRUNAWAYWRN);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_insulation_wrning_distgshWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bms_insulation_wrning_distgsh = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_insulation_wrning_distgsh");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_insulation_wrning_distgsh = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_bms_insulation_wrning_distgshReq(ec_bms_insulation_wrning_distgsh),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_insulation_wrning_distgshReq(int32_t ec_bms_insulation_wrning_distgsh) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_insulation_wrning_distgsh);
    req->prop = toInt(VehicleProperty::GECKO_BMS_INSULATION_WRNING_DISTGSH);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_srs_crash_output_stsWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_srs_crash_output_sts = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_srs_crash_output_sts");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_srs_crash_output_sts = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_srs_crash_output_stsReq(ec_srs_crash_output_sts),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_srs_crash_output_stsReq(int32_t ec_srs_crash_output_sts) {
    auto req = mValueObjectPool->obtainInt32(ec_srs_crash_output_sts);
    req->prop = toInt(VehicleProperty::GECKO_SRS_CRASHOUTPUTSTS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_obc_inlelt_actl_powerWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_ipu_obc_inlelt_actl_power = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_obc_inlelt_actl_power");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ipu_obc_inlelt_actl_power = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_ipu_obc_inlelt_actl_powerReq(ec_ipu_obc_inlelt_actl_power),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_obc_inlelt_actl_powerReq(int32_t ec_ipu_obc_inlelt_actl_power) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_obc_inlelt_actl_power);
    req->prop = toInt(VehicleProperty::GECKO_IPU_OBC_INLELTACTLPOWER);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_pp_fmr_distWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_pp_fmr_dist = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_pp_fmr_dist");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_pp_fmr_dist = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_pp_fmr_distReq(bc_pp_fmr_dist),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_pp_fmr_distReq(int32_t bc_pp_fmr_dist) {
    auto req = mValueObjectPool->obtainInt32(bc_pp_fmr_dist);
    req->prop = toInt(VehicleProperty::GECKO_PP_FMRDIST);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_fcm_laterallimitWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_fcm_laterallimit = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_laterallimit");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_fcm_laterallimit = mPropertyManager->getCProValue(mp);
      LOG(INFO)<<"bc_fcm_laterallimit: "<<bc_fcm_laterallimit;
      mHal->onPropertyValue(*Create_bc_fcm_laterallimitReq(bc_fcm_laterallimit),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_laterallimitReq(int32_t bc_fcm_laterallimit) {
    auto req = mValueObjectPool->obtainInt32(bc_fcm_laterallimit);
    req->prop = toInt(VehicleProperty::GECKO_FCM_LATERALLIMIT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_fcm_ldw_audio_warnWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_fcm_ldw_audio_warn = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_ldw_audio_warn");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_fcm_ldw_audio_warn = mPropertyManager->getCProValue(mp);
      LOG(INFO)<<"bc_fcm_ldw_audio_warn: "<<bc_fcm_ldw_audio_warn;
      mHal->onPropertyValue(*Create_bc_fcm_ldw_audio_warnReq(bc_fcm_ldw_audio_warn),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_ldw_audio_warnReq(int32_t bc_fcm_ldw_audio_warn) {
    auto req = mValueObjectPool->obtainInt32(bc_fcm_ldw_audio_warn);
    req->prop = toInt(VehicleProperty::GECKO_FCM_LDWAUDIOWARN);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_fcm_raeb_work_stsWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_fcm_raeb_work_sts = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_raeb_work_sts");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_fcm_raeb_work_sts = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_fcm_raeb_work_stsReq(bc_fcm_raeb_work_sts),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_raeb_work_stsReq(int32_t bc_fcm_raeb_work_sts) {
    auto req = mValueObjectPool->obtainInt32(bc_fcm_raeb_work_sts);
    req->prop = toInt(VehicleProperty::GECKO_FCM_RAEB_WORKSTS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_fcm_aeb_obj_idWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_fcm_aeb_obj_id = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_aeb_obj_id");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_fcm_aeb_obj_id = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_fcm_aeb_obj_idReq(bc_fcm_aeb_obj_id),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_aeb_obj_idReq(int32_t bc_fcm_aeb_obj_id) {
    auto req = mValueObjectPool->obtainInt32(bc_fcm_aeb_obj_id);
    req->prop = toInt(VehicleProperty::GECKO_FCM_AEBOBJID);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_fcm_v_set_disWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_fcm_v_set_dis = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_v_set_dis");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_fcm_v_set_dis = mPropertyManager->getCProValue(mp);
      LOG(INFO)<<"bc_fcm_v_set_dis: "<<bc_fcm_v_set_dis;
      mHal->onPropertyValue(*Create_bc_fcm_v_set_disReq(bc_fcm_v_set_dis),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_v_set_disReq(int32_t bc_fcm_v_set_dis) {
    auto req = mValueObjectPool->obtainInt32(bc_fcm_v_set_dis);
    req->prop = toInt(VehicleProperty::GECKO_FCM_VSETDIS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_fcm_ldw_alert_method_set_fbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_fcm_ldw_alert_method_set_fb = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_ldw_alert_method_set_fb");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_fcm_ldw_alert_method_set_fb = mPropertyManager->getCProValue(mp);
      LOG(INFO)<<"bc_fcm_ldw_alert_method_set_fb: "<<bc_fcm_ldw_alert_method_set_fb;
      mHal->onPropertyValue(*Create_bc_fcm_ldw_alert_method_set_fbReq(bc_fcm_ldw_alert_method_set_fb),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_ldw_alert_method_set_fbReq(int32_t bc_fcm_ldw_alert_method_set_fb) {
    auto req = mValueObjectPool->obtainInt32(bc_fcm_ldw_alert_method_set_fb);
    req->prop = toInt(VehicleProperty::GECKO_FCM_LDWALERTMETHODSETFB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_fcm_ri_line_color_fctWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_fcm_ri_line_color_fct = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_ri_line_color_fct");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_fcm_ri_line_color_fct = mPropertyManager->getCProValue(mp);
      LOG(INFO) << "bc_fcm_ri_line_color_fct: " << bc_fcm_ri_line_color_fct;
      mHal->onPropertyValue(*Create_bc_fcm_ri_line_color_fctReq(bc_fcm_ri_line_color_fct),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_ri_line_color_fctReq(int32_t bc_fcm_ri_line_color_fct) {
    auto req = mValueObjectPool->obtainInt32(bc_fcm_ri_line_color_fct);
    req->prop = toInt(VehicleProperty::GECKO_FCM_RILINECOLORFCT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_fcm_lka_set_fbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_fcm_lka_set_fb = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_lka_set_fb");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_fcm_lka_set_fb = mPropertyManager->getCProValue(mp);
      LOG(INFO)<<"bc_fcm_lka_set_fb: "<<bc_fcm_lka_set_fb;
      mHal->onPropertyValue(*Create_bc_fcm_lka_set_fbReq(bc_fcm_lka_set_fb),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_lka_set_fbReq(int32_t bc_fcm_lka_set_fb) {
    auto req = mValueObjectPool->obtainInt32(bc_fcm_lka_set_fb);
    req->prop = toInt(VehicleProperty::GECKO_FCM_LKASETFB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_fcm_le_line_color_fctWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_fcm_le_line_color_fct = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_le_line_color_fct");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_fcm_le_line_color_fct = mPropertyManager->getCProValue(mp);
      LOG(INFO)<<"bc_fcm_le_line_color_fct: "<<bc_fcm_le_line_color_fct;
      mHal->onPropertyValue(*Create_bc_fcm_le_line_color_fctReq(bc_fcm_le_line_color_fct),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_le_line_color_fctReq(int32_t bc_fcm_le_line_color_fct) {
    auto req = mValueObjectPool->obtainInt32(bc_fcm_le_line_color_fct);
    req->prop = toInt(VehicleProperty::GECKO_FCM_LELINECOLORFCT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_fcm_lka_stsWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_fcm_lka_sts = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_lka_sts");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_fcm_lka_sts = mPropertyManager->getCProValue(mp);
      LOG(INFO)<<"bc_fcm_lka_sts: "<<bc_fcm_lka_sts;
      mHal->onPropertyValue(*Create_bc_fcm_lka_stsReq(bc_fcm_lka_sts),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_lka_stsReq(int32_t bc_fcm_lka_sts) {
    auto req = mValueObjectPool->obtainInt32(bc_fcm_lka_sts);
    req->prop = toInt(VehicleProperty::GECKO_FCM_LKASTS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_fcm_ldw_set_fbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_fcm_ldw_set_fb = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_ldw_set_fb");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_fcm_ldw_set_fb = mPropertyManager->getCProValue(mp);
      LOG(INFO)<<"bc_fcm_ldw_set_fb = " << bc_fcm_ldw_set_fb;
      mHal->onPropertyValue(*Create_bc_fcm_ldw_set_fbReq(bc_fcm_ldw_set_fb),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_ldw_set_fbReq(int32_t bc_fcm_ldw_set_fb) {
    auto req = mValueObjectPool->obtainInt32(bc_fcm_ldw_set_fb);
    req->prop = toInt(VehicleProperty::GECKO_FCM_LDWSETFB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_fcm_ldw_stsWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_fcm_ldw_sts = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_ldw_sts");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_fcm_ldw_sts = mPropertyManager->getCProValue(mp);
      LOG(INFO) << "bc_fcm_ldw_sts: " << bc_fcm_ldw_sts;
      mHal->onPropertyValue(*Create_bc_fcm_ldw_stsReq(bc_fcm_ldw_sts),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_ldw_stsReq(int32_t bc_fcm_ldw_sts) {
    auto req = mValueObjectPool->obtainInt32(bc_fcm_ldw_sts);
    req->prop = toInt(VehicleProperty::GECKO_FCM_LDWSTS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_fcm_text_info_lka1Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_fcm_text_info_lka1 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_text_info_lka1");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_fcm_text_info_lka1 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_fcm_text_info_lka1Req(bc_fcm_text_info_lka1),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_text_info_lka1Req(int32_t bc_fcm_text_info_lka1) {
    auto req = mValueObjectPool->obtainInt32(bc_fcm_text_info_lka1);
    req->prop = toInt(VehicleProperty::GECKO_FCM_TEXTINFOLKA1);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_fcm_pcw_latent_warnWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_fcm_pcw_latent_warn = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_pcw_latent_warn");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_fcm_pcw_latent_warn = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_fcm_pcw_latent_warnReq(bc_fcm_pcw_latent_warn),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_pcw_latent_warnReq(int32_t bc_fcm_pcw_latent_warn) {
    auto req = mValueObjectPool->obtainInt32(bc_fcm_pcw_latent_warn);
    req->prop = toInt(VehicleProperty::GECKO_FCM_PCWLATENTWARN);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_fcm_pcw_pre_warnWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_fcm_pcw_pre_warn = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_pcw_pre_warn");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_fcm_pcw_pre_warn = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_fcm_pcw_pre_warnReq(bc_fcm_pcw_pre_warn),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_pcw_pre_warnReq(int32_t bc_fcm_pcw_pre_warn) {
    auto req = mValueObjectPool->obtainInt32(bc_fcm_pcw_pre_warn);
    req->prop = toInt(VehicleProperty::GECKO_FCM_PCWPREWARN);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_fcm_acc_mode_hmiWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_fcm_acc_mode_hmi = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_acc_mode_hmi");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_fcm_acc_mode_hmi = mPropertyManager->getCProValue(mp);
      LOG(INFO)<<"bc_fcm_acc_mode_hmi: "<<bc_fcm_acc_mode_hmi;
      mHal->onPropertyValue(*Create_bc_fcm_acc_mode_hmiReq(bc_fcm_acc_mode_hmi),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_acc_mode_hmiReq(int32_t bc_fcm_acc_mode_hmi) {
    auto req = mValueObjectPool->obtainInt32(bc_fcm_acc_mode_hmi);
    req->prop = toInt(VehicleProperty::GECKO_FCM_ACCMODEHMI);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_fcm_adas_quit_reasWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_fcm_adas_quit_reas = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_adas_quit_reas");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_fcm_adas_quit_reas = mPropertyManager->getCProValue(mp);
      LOG(INFO)<<"bc_fcm_adas_quit_reas: "<<bc_fcm_adas_quit_reas;
      mHal->onPropertyValue(*Create_bc_fcm_adas_quit_reasReq(bc_fcm_adas_quit_reas),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_adas_quit_reasReq(int32_t bc_fcm_adas_quit_reas) {
    auto req = mValueObjectPool->obtainInt32(bc_fcm_adas_quit_reas);
    req->prop = toInt(VehicleProperty::GECKO_FCM_ADASQUITREAS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_fcm_ica_set_fbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_fcm_ica_set_fb = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_ica_set_fb");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_fcm_ica_set_fb = mPropertyManager->getCProValue(mp);
      LOG(INFO)<<"bc_fcm_ica_set_fb: "<<bc_fcm_ica_set_fb;
      mHal->onPropertyValue(*Create_bc_fcm_ica_set_fbReq(bc_fcm_ica_set_fb),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_ica_set_fbReq(int32_t bc_fcm_ica_set_fb) {
    auto req = mValueObjectPool->obtainInt32(bc_fcm_ica_set_fb);
    req->prop = toInt(VehicleProperty::GECKO_FCM_ICASETFB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}


void GarageModeServerSideHandlerImpl::bc_fcm_ica_truck_set_fbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_fcm_ica_truck_set_fb = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_ica_truck_set_fb");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_fcm_ica_truck_set_fb = mPropertyManager->getCProValue(mp);
      LOG(INFO)<<"bc_fcm_ica_truck_set_fb: "<<bc_fcm_ica_truck_set_fb;
      mHal->onPropertyValue(*Create_bc_fcm_ica_truck_set_fbReq(bc_fcm_ica_truck_set_fb),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_ica_truck_set_fbReq(int32_t bc_fcm_ica_truck_set_fb) {
    auto req = mValueObjectPool->obtainInt32(bc_fcm_ica_truck_set_fb);
    req->prop = toInt(VehicleProperty::GECKO_FCM_ICATRUCKSETFB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_fcm_acc_startWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_fcm_acc_start = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_acc_start");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_fcm_acc_start = mPropertyManager->getCProValue(mp);
      LOG(INFO)<<"bc_fcm_acc_start: " << bc_fcm_acc_start;
      mHal->onPropertyValue(*Create_bc_fcm_acc_startReq(bc_fcm_acc_start),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_acc_startReq(int32_t bc_fcm_acc_start) {
    auto req = mValueObjectPool->obtainInt32(bc_fcm_acc_start);
    req->prop = toInt(VehicleProperty::GECKO_FCM_ACCSTART);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_fcm_adas_not_avl_reasWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_fcm_adas_not_avl_reas = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_adas_not_avl_reas");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_fcm_adas_not_avl_reas = mPropertyManager->getCProValue(mp);
      LOG(INFO)<<"bc_fcm_adas_not_avl_reas: "<<bc_fcm_adas_not_avl_reas;
      mHal->onPropertyValue(*Create_bc_fcm_adas_not_avl_reasReq(bc_fcm_adas_not_avl_reas),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_adas_not_avl_reasReq(int32_t bc_fcm_adas_not_avl_reas) {
    auto req = mValueObjectPool->obtainInt32(bc_fcm_adas_not_avl_reas);
    req->prop = toInt(VehicleProperty::GECKO_FCM_ADASNOTAVLREAS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_fcm_tar_obj_accWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_fcm_tar_obj_acc = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_tar_obj_acc");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_fcm_tar_obj_acc = mPropertyManager->getCProValue(mp);
      LOG(INFO)<<"bc_fcm_tar_obj_acc: "<<bc_fcm_tar_obj_acc;
      mHal->onPropertyValue(*Create_bc_fcm_tar_obj_accReq(bc_fcm_tar_obj_acc),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_tar_obj_accReq(int32_t bc_fcm_tar_obj_acc) {
    auto req = mValueObjectPool->obtainInt32(bc_fcm_tar_obj_acc);
    req->prop = toInt(VehicleProperty::GECKO_FCM_TAROBJACC);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_fcm_act_drv_asst_sts_hmiWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_fcm_act_drv_asst_sts_hmi = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_act_drv_asst_sts_hmi");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_fcm_act_drv_asst_sts_hmi = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_fcm_act_drv_asst_sts_hmiReq(bc_fcm_act_drv_asst_sts_hmi),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_act_drv_asst_sts_hmiReq(int32_t bc_fcm_act_drv_asst_sts_hmi) {
    auto req = mValueObjectPool->obtainInt32(bc_fcm_act_drv_asst_sts_hmi);
    req->prop = toInt(VehicleProperty::GECKO_FCM_ACTDRVASSTSTSHMI);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_fcm_lka_audio_warningWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_fcm_lka_audio_warning = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_lka_audio_warning");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_fcm_lka_audio_warning = mPropertyManager->getCProValue(mp);
      LOG(INFO) << "bc_fcm_lka_audio_warningWatcher: " << bc_fcm_lka_audio_warning;
      mHal->onPropertyValue(*Create_bc_fcm_lka_audio_warningReq(bc_fcm_lka_audio_warning),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_lka_audio_warningReq(int32_t bc_fcm_lka_audio_warning) {
    auto req = mValueObjectPool->obtainInt32(bc_fcm_lka_audio_warning);
    req->prop = toInt(VehicleProperty::GECKO_FCM_LKA_AUDIOWARNING);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_fcm_fault_text_infoWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_fcm_fault_text_info = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_fault_text_info");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_fcm_fault_text_info = mPropertyManager->getCProValue(mp);
      LOG(INFO)<<"bc_fcm_fault_text_info = " << bc_fcm_fault_text_info;
      mHal->onPropertyValue(*Create_bc_fcm_fault_text_infoReq(bc_fcm_fault_text_info),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_fault_text_infoReq(int32_t bc_fcm_fault_text_info) {
    auto req = mValueObjectPool->obtainInt32(bc_fcm_fault_text_info);
    req->prop = toInt(VehicleProperty::GECKO_FCM_FAULTTEXTINFO);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_fcm_audio_warn_hands_offWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_fcm_audio_warn_hands_off = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_audio_warn_hands_off");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_fcm_audio_warn_hands_off = mPropertyManager->getCProValue(mp);
      LOG(INFO)<<"bc_fcm_audio_warn_hands_off: " << bc_fcm_audio_warn_hands_off;
      mHal->onPropertyValue(*Create_bc_fcm_audio_warn_hands_offReq(bc_fcm_audio_warn_hands_off),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_audio_warn_hands_offReq(int32_t bc_fcm_audio_warn_hands_off) {
    auto req = mValueObjectPool->obtainInt32(bc_fcm_audio_warn_hands_off);
    req->prop = toInt(VehicleProperty::GECKO_FCM_AUDIOWARNHANDSOFF);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_fcm_slif_oper_stsWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_fcm_slif_oper_sts = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_slif_oper_sts");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_fcm_slif_oper_sts = mPropertyManager->getCProValue(mp);
      LOG(INFO)<<"bc_fcm_slif_oper_sts: " << bc_fcm_slif_oper_sts;
      mHal->onPropertyValue(*Create_bc_fcm_slif_oper_stsReq(bc_fcm_slif_oper_sts),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_slif_oper_stsReq(int32_t bc_fcm_slif_oper_sts) {
    auto req = mValueObjectPool->obtainInt32(bc_fcm_slif_oper_sts);
    req->prop = toInt(VehicleProperty::GECKO_FCM_SLIFOPERSTS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_fcm_tsr_spd_limWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_fcm_tsr_spd_lim = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_tsr_spd_lim");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_fcm_tsr_spd_lim = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_fcm_tsr_spd_limReq(bc_fcm_tsr_spd_lim),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_tsr_spd_limReq(int32_t bc_fcm_tsr_spd_lim) {
    auto req = mValueObjectPool->obtainInt32(bc_fcm_tsr_spd_lim);
    req->prop = toInt(VehicleProperty::GECKO_FCM_TSRSPDLIM);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_fcm_tsr_set_fbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_fcm_tsr_set_fb = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_tsr_set_fb");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_fcm_tsr_set_fb = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_fcm_tsr_set_fbReq(bc_fcm_tsr_set_fb),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_tsr_set_fbReq(int32_t bc_fcm_tsr_set_fb) {
    auto req = mValueObjectPool->obtainInt32(bc_fcm_tsr_set_fb);
    req->prop = toInt(VehicleProperty::GECKO_FCM_TSR_SETFB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_fcm_tsr_lat_dstWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_fcm_tsr_lat_dst = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_tsr_lat_dst");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_fcm_tsr_lat_dst = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_fcm_tsr_lat_dstReq(bc_fcm_tsr_lat_dst),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_tsr_lat_dstReq(int32_t bc_fcm_tsr_lat_dst) {
    auto req = mValueObjectPool->obtainInt32(bc_fcm_tsr_lat_dst);
    req->prop = toInt(VehicleProperty::GECKO_FCM_TSR_LATDST);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_fcm_tsr_lgt_dstWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_fcm_tsr_lgt_dst = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_tsr_lgt_dst");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_fcm_tsr_lgt_dst = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_fcm_tsr_lgt_dstReq(bc_fcm_tsr_lgt_dst),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_tsr_lgt_dstReq(int32_t bc_fcm_tsr_lgt_dst) {
    auto req = mValueObjectPool->obtainInt32(bc_fcm_tsr_lgt_dst);
    req->prop = toInt(VehicleProperty::GECKO_FCM_TSRLGTDST);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_fcm_trfc_signWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_fcm_trfc_sign = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_trfc_sign");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_fcm_trfc_sign = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_fcm_trfc_signReq(bc_fcm_trfc_sign),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_trfc_signReq(int32_t bc_fcm_trfc_sign) {
    auto req = mValueObjectPool->obtainInt32(bc_fcm_trfc_sign);
    req->prop = toInt(VehicleProperty::GECKO_FCM_TRFCSIGN);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_fcm_slif_set_fbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_fcm_slif_set_fb = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_slif_set_fb");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_fcm_slif_set_fb = mPropertyManager->getCProValue(mp);
      LOG(INFO) << "bc_fcm_slif_set_fb = " << bc_fcm_slif_set_fb;
      mHal->onPropertyValue(*Create_bc_fcm_slif_set_fbReq(bc_fcm_slif_set_fb),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_slif_set_fbReq(int32_t bc_fcm_slif_set_fb) {
    auto req = mValueObjectPool->obtainInt32(bc_fcm_slif_set_fb);
    req->prop = toInt(VehicleProperty::GECKO_FCM_SLIFSETFB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_fcm_elk_right_modeWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_fcm_elk_right_mode = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_elk_right_mode");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_fcm_elk_right_mode = mPropertyManager->getCProValue(mp);
      LOG(INFO) << "bc_fcm_elk_right_mode = " << bc_fcm_elk_right_mode;
      mHal->onPropertyValue(*Create_bc_fcm_elk_right_modeReq(bc_fcm_elk_right_mode),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_elk_right_modeReq(int32_t bc_fcm_elk_right_mode) {
    auto req = mValueObjectPool->obtainInt32(bc_fcm_elk_right_mode);
    req->prop = toInt(VehicleProperty::GECKO_FCM_ELKRIGHTMODE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_fcm_elk_left_modeWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_fcm_elk_left_mode = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_elk_left_mode");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_fcm_elk_left_mode = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_fcm_elk_left_modeReq(bc_fcm_elk_left_mode),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_elk_left_modeReq(int32_t bc_fcm_elk_left_mode) {
    auto req = mValueObjectPool->obtainInt32(bc_fcm_elk_left_mode);
    req->prop = toInt(VehicleProperty::GECKO_FCM_ELKLEFTMODE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_fcm_fcm_intializationWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_fcm_fcm_intialization = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_fcm_intialization");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_fcm_fcm_intialization = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_fcm_fcm_intializationReq(bc_fcm_fcm_intialization),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_fcm_intializationReq(int32_t bc_fcm_fcm_intialization) {
    auto req = mValueObjectPool->obtainInt32(bc_fcm_fcm_intialization);
    req->prop = toInt(VehicleProperty::GECKO_FCM_FCM_INITIALIZATION);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_fcm_slwf_set_fbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_fcm_slwf_set_fb = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_slwf_set_fb");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_fcm_slwf_set_fb = mPropertyManager->getCProValue(mp);
      LOG(INFO)<<"bc_fcm_slwf_set_fb = " << bc_fcm_slwf_set_fb;
      mHal->onPropertyValue(*Create_bc_fcm_slwf_set_fbReq(bc_fcm_slwf_set_fb),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_slwf_set_fbReq(int32_t bc_fcm_slwf_set_fb) {
    auto req = mValueObjectPool->obtainInt32(bc_fcm_slwf_set_fb);
    req->prop = toInt(VehicleProperty::GECKO_FCM_SLWFSETFB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_fcm_tsr_spd_lim_stsWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_fcm_tsr_spd_lim_sts = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_tsr_spd_lim_sts");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_fcm_tsr_spd_lim_sts = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_fcm_tsr_spd_lim_stsReq(bc_fcm_tsr_spd_lim_sts),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_tsr_spd_lim_stsReq(int32_t bc_fcm_tsr_spd_lim_sts) {
    auto req = mValueObjectPool->obtainInt32(bc_fcm_tsr_spd_lim_sts);
    req->prop = toInt(VehicleProperty::GECKO_FCM_TSRSPDLIMSTS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_fcm_tsr_spd_lim_warn_auWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_fcm_tsr_spd_lim_warn_au = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_tsr_spd_lim_warn_au");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_fcm_tsr_spd_lim_warn_au = mPropertyManager->getCProValue(mp);
      LOG(INFO)<<"bc_fcm_tsr_spd_lim_warn_au: "<<bc_fcm_tsr_spd_lim_warn_au;
      mHal->onPropertyValue(*Create_bc_fcm_tsr_spd_lim_warn_auReq(bc_fcm_tsr_spd_lim_warn_au),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_tsr_spd_lim_warn_auReq(int32_t bc_fcm_tsr_spd_lim_warn_au) {
    auto req = mValueObjectPool->obtainInt32(bc_fcm_tsr_spd_lim_warn_au);
    req->prop = toInt(VehicleProperty::GECKO_FCM_TSRSPDLIMWARNAU);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_fcm_tsr_spd_lim_warnWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_fcm_tsr_spd_lim_warn = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_tsr_spd_lim_warn");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_fcm_tsr_spd_lim_warn = mPropertyManager->getCProValue(mp);
      LOG(INFO)<<"bc_fcm_tsr_spd_lim_warn: "<<bc_fcm_tsr_spd_lim_warn;
      mHal->onPropertyValue(*Create_bc_fcm_tsr_spd_lim_warnReq(bc_fcm_tsr_spd_lim_warn),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_tsr_spd_lim_warnReq(int32_t bc_fcm_tsr_spd_lim_warn) {
    auto req = mValueObjectPool->obtainInt32(bc_fcm_tsr_spd_lim_warn);
    req->prop = toInt(VehicleProperty::GECKO_FCM_TSRSPDLIMWARN);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_fcm_hma_set_fbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_fcm_hma_set_fb = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_hma_set_fb");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_fcm_hma_set_fb = mPropertyManager->getCProValue(mp);
      LOG(INFO)<<"bc_fcm_hma_set_fb: " << bc_fcm_hma_set_fb;
      mHal->onPropertyValue(*Create_bc_fcm_hma_set_fbReq(bc_fcm_hma_set_fb),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_hma_set_fbReq(int32_t bc_fcm_hma_set_fb) {
    auto req = mValueObjectPool->obtainInt32(bc_fcm_hma_set_fb);
    req->prop = toInt(VehicleProperty::GECKO_FCM_HMASETFB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_fcm_aeb_set_fbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_fcm_aeb_set_fb = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_aeb_set_fb");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_fcm_aeb_set_fb = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_fcm_aeb_set_fbReq(bc_fcm_aeb_set_fb),true);
      mHal->onPropertyValue(*Create_bc_fcm_aeb_and_fcw_fbReq(GetFcwAebValue()),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_aeb_set_fbReq(int32_t bc_fcm_aeb_set_fb) {
    auto req = mValueObjectPool->obtainInt32(bc_fcm_aeb_set_fb);
    req->prop = toInt(VehicleProperty::GECKO_FCM_AEBSETFB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_fcm_elk_set_fbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_fcm_elk_set_fb = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_elk_set_fb");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_fcm_elk_set_fb = mPropertyManager->getCProValue(mp);
      LOG(INFO)<<"bc_fcm_elk_set_fb: "<<bc_fcm_elk_set_fb;
      mHal->onPropertyValue(*Create_bc_fcm_elk_set_fbReq(bc_fcm_elk_set_fb),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_elk_set_fbReq(int32_t bc_fcm_elk_set_fb) {
    auto req = mValueObjectPool->obtainInt32(bc_fcm_elk_set_fb);
    req->prop = toInt(VehicleProperty::GECKO_FCM_ELKSETFB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_pp_sw_fdbkWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_pp_sw_fdbk = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_pp_sw_fdbk");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_pp_sw_fdbk = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_pp_sw_fdbkReq(bc_pp_sw_fdbk),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_pp_sw_fdbkReq(int32_t bc_pp_sw_fdbk) {
    auto req = mValueObjectPool->obtainInt32(bc_pp_sw_fdbk);
    req->prop = toInt(VehicleProperty::GECKO_PP_SWFDBK);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_pp_staWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_pp_sta = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_pp_sta");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_pp_sta = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_pp_staReq(bc_pp_sta),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_pp_staReq(int32_t bc_pp_sta) {
    auto req = mValueObjectPool->obtainInt32(bc_pp_sta);
    req->prop = toInt(VehicleProperty::GECKO_PP_STA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_pp_sdwrsr_distWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_pp_sdwrsr_dist = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_pp_sdwrsr_dist");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_pp_sdwrsr_dist = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_pp_sdwrsr_distReq(bc_pp_sdwrsr_dist),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_pp_sdwrsr_distReq(int32_t bc_pp_sdwrsr_dist) {
    auto req = mValueObjectPool->obtainInt32(bc_pp_sdwrsr_dist);
    req->prop = toInt(VehicleProperty::GECKO_PP_SDWRSRDIST);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_pp_sensor_fault_sts_frWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_pp_sensor_fault_sts_fr = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_pp_sensor_fault_sts_fr");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_pp_sensor_fault_sts_fr = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_pp_sensor_fault_sts_frReq(bc_pp_sensor_fault_sts_fr),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_pp_sensor_fault_sts_frReq(int32_t bc_pp_sensor_fault_sts_fr) {
    auto req = mValueObjectPool->obtainInt32(bc_pp_sensor_fault_sts_fr);
    req->prop = toInt(VehicleProperty::GECKO_PP_SENSORFAULTSTSFR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_pp_sensor_fault_sts_frmWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_pp_sensor_fault_sts_frm = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_pp_sensor_fault_sts_frm");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_pp_sensor_fault_sts_frm = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_pp_sensor_fault_sts_frmReq(bc_pp_sensor_fault_sts_frm),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_pp_sensor_fault_sts_frmReq(int32_t bc_pp_sensor_fault_sts_frm) {
    auto req = mValueObjectPool->obtainInt32(bc_pp_sensor_fault_sts_frm);
    req->prop = toInt(VehicleProperty::GECKO_PP_SENSORFAULTSTSFRM);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_pp_sdwfsr_mid_distWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_pp_sdwfsr_mid_dist = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_pp_sdwfsr_mid_dist");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_pp_sdwfsr_mid_dist = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_pp_sdwfsr_mid_distReq(bc_pp_sdwfsr_mid_dist),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_pp_sdwfsr_mid_distReq(int32_t bc_pp_sdwfsr_mid_dist) {
    auto req = mValueObjectPool->obtainInt32(bc_pp_sdwfsr_mid_dist);
    req->prop = toInt(VehicleProperty::GECKO_PP_SDWFSRMIDDIST);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_pp_sdwfsl_mid_distWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_pp_sdwfsl_mid_dist = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_pp_sdwfsl_mid_dist");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_pp_sdwfsl_mid_dist = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_pp_sdwfsl_mid_distReq(bc_pp_sdwfsl_mid_dist),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_pp_sdwfsl_mid_distReq(int32_t bc_pp_sdwfsl_mid_dist) {
    auto req = mValueObjectPool->obtainInt32(bc_pp_sdwfsl_mid_dist);
    req->prop = toInt(VehicleProperty::GECKO_PP_SDWFSLMIDDIST);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_pp_sdwfsl_distWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_pp_sdwfsl_dist = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_pp_sdwfsl_dist");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_pp_sdwfsl_dist = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_pp_sdwfsl_distReq(bc_pp_sdwfsl_dist),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_pp_sdwfsl_distReq(int32_t bc_pp_sdwfsl_dist) {
    auto req = mValueObjectPool->obtainInt32(bc_pp_sdwfsl_dist);
    req->prop = toInt(VehicleProperty::GECKO_PP_SDWFSLDIST);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_door_lock_operation_recordWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_door_lock_operation_record = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_door_lock_operation_record");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_door_lock_operation_record = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_bcm_door_lock_operation_recordReq(bc_bcm_door_lock_operation_record),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_door_lock_operation_recordReq(int32_t bc_bcm_door_lock_operation_record) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_door_lock_operation_record);
    req->prop = toInt(VehicleProperty::GECKO_BCM_DOORLOCKOPERATIONRECORD);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_tmps_abnm_prsr_warnWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_tmps_abnm_prsr_warn = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_tmps_abnm_prsr_warn");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_tmps_abnm_prsr_warn = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_tmps_abnm_prsr_warnReq(bc_tmps_abnm_prsr_warn),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_tmps_abnm_prsr_warnReq(int32_t bc_tmps_abnm_prsr_warn) {
    auto req = mValueObjectPool->obtainInt32(bc_tmps_abnm_prsr_warn);
    req->prop = toInt(VehicleProperty::GECKO_TMPS_ABNMPRSRWARN);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_ac_indoor_tempWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_ac_indoor_temp = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ac_indoor_temp");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ac_indoor_temp = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_ac_indoor_tempReq(bc_ac_indoor_temp),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ac_indoor_tempReq(int32_t bc_ac_indoor_temp) {
    auto req = mValueObjectPool->obtainInt32(bc_ac_indoor_temp);
    req->prop = toInt(VehicleProperty::GECKO_AC_INDOORTEMP);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_pp_fl_distWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_pp_fl_dist = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_pp_fl_dist");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_pp_fl_dist = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_pp_fl_distReq(bc_pp_fl_dist),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_pp_fl_distReq(int32_t bc_pp_fl_dist) {
    auto req = mValueObjectPool->obtainInt32(bc_pp_fl_dist);
    req->prop = toInt(VehicleProperty::GECKO_PP_FLDIST);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_pp_fr_distWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_pp_fr_dist = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_pp_fr_dist");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_pp_fr_dist = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_pp_fr_distReq(bc_pp_fr_dist),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_pp_fr_distReq(int32_t bc_pp_fr_dist) {
    auto req = mValueObjectPool->obtainInt32(bc_pp_fr_dist);
    req->prop = toInt(VehicleProperty::GECKO_PP_FRDIST);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_pp_fml_distWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_pp_fml_dist = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_pp_fml_dist");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_pp_fml_dist = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_pp_fml_distReq(bc_pp_fml_dist),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_pp_fml_distReq(int32_t bc_pp_fml_dist) {
    auto req = mValueObjectPool->obtainInt32(bc_pp_fml_dist);
    req->prop = toInt(VehicleProperty::GECKO_PP_FMLDIST);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_inv_antithft_auth_rsltWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_inv_antithft_auth_rslt = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_inv_antithft_auth_rslt");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_inv_antithft_auth_rslt = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_inv_antithft_auth_rsltReq(ec_inv_antithft_auth_rslt),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_inv_antithft_auth_rsltReq(int32_t ec_inv_antithft_auth_rslt) {
    auto req = mValueObjectPool->obtainInt32(ec_inv_antithft_auth_rslt);
    req->prop = toInt(VehicleProperty::GECKO_INV_ANTITHFTAUTHRSLT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_ac_auto_blower_mode_staWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_ac_auto_blower_mode_sta = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ac_auto_blower_mode_sta");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ac_auto_blower_mode_sta = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_ac_auto_blower_mode_staReq(bc_ac_auto_blower_mode_sta),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ac_auto_blower_mode_staReq(int32_t bc_ac_auto_blower_mode_sta) {
    auto req = mValueObjectPool->obtainInt32(bc_ac_auto_blower_mode_sta);
    req->prop = toInt(VehicleProperty::GECKO_AC_AUTOBLOWERMODESTA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

int GarageModeServerSideHandlerImpl::GetFcwAebValue() {
  int ret =0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_fcw_set_fb");
  int32_t fcw_set_fb = mPropertyManager->getCProValue(mp);

  ConfigDBC* mp_aeb = mPropertyManager->findCProperty("bc_fcm_aeb_set_fb");
  int32_t aeb_set_fb = mPropertyManager->getCProValue(mp_aeb);

  if(fcw_set_fb == 1 && aeb_set_fb == 0){
    ret = 0;
  }else if(fcw_set_fb == 2 && aeb_set_fb == 0){
    ret = 1;
  }else if(fcw_set_fb == 1 && aeb_set_fb == 1){
    ret = 2;
  }else if(fcw_set_fb == 2 && aeb_set_fb == 1){
    ret = 3;
  }else if(fcw_set_fb == 0 && aeb_set_fb == 0){
    ret = 4;
  }else if(fcw_set_fb == 0 && aeb_set_fb == 1){
    ret = 5;
  }else if(fcw_set_fb == 3 && aeb_set_fb == 0){
    ret = 6;
  }else if(fcw_set_fb == 3 && aeb_set_fb == 1){
    ret = 7;
  }else if(fcw_set_fb == -1024 || aeb_set_fb == -1024) {
    ret = -1024;
  } 

  LOG(INFO) << "bc_fcm_fcw_set_fb:" << fcw_set_fb<<"  bc_fcm_aeb_set_fb:"<< aeb_set_fb<<"  ret:"<<ret;
  return ret;
}

void GarageModeServerSideHandlerImpl::bc_fcm_fcw_set_fbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_fcw_set_fb");
  int32_t bc_fcm_fcw_set_fb = 0;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_fcm_fcw_set_fb = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_fcm_fcw_set_fbReq(bc_fcm_fcw_set_fb),true);
      mHal->onPropertyValue(*Create_bc_fcm_aeb_and_fcw_fbReq(GetFcwAebValue()),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_fcw_set_fbReq(int32_t bc_fcm_fcw_set_fb) {
    auto req = mValueObjectPool->obtainInt32(bc_fcm_fcw_set_fb);
    req->prop = toInt(VehicleProperty::GECKO_FCM_FCWSETFB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_aeb_and_fcw_fbReq(int32_t value) {
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_FCM_AEBFCW_SETFB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_ac_extd_defrost_actv_reqWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_ac_extd_defrost_actv_req = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ac_extd_defrost_actv_req");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ac_extd_defrost_actv_req = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_ac_extd_defrost_actv_reqReq(bc_ac_extd_defrost_actv_req),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ac_extd_defrost_actv_reqReq(int32_t bc_ac_extd_defrost_actv_req) {
    auto req = mValueObjectPool->obtainInt32(bc_ac_extd_defrost_actv_req);
    req->prop = toInt(VehicleProperty::GECKO_AC_EXTDDEFROSTACTVREQ);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_scs_left_swt_vdWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_scs_left_swt_vd = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_scs_left_swt_vd");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_scs_left_swt_vd = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_scs_left_swt_vdReq(ec_scs_left_swt_vd),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_scs_left_swt_vdReq(int32_t ec_scs_left_swt_vd) {
    auto req = mValueObjectPool->obtainInt32(ec_scs_left_swt_vd);
    req->prop = toInt(VehicleProperty::GECKO_SCS_LEFTSWTVD);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_scs_left_1_swtWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_scs_left_1_swt = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_scs_left_1_swt");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_scs_left_1_swt = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_scs_left_1_swtReq(ec_scs_left_1_swt),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_scs_left_1_swtReq(int32_t ec_scs_left_1_swt) {
    auto req = mValueObjectPool->obtainInt32(ec_scs_left_1_swt);
    req->prop = toInt(VehicleProperty::GECKO_SCS_LEFT_1SWT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_scs_left_2_swtWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_scs_left_2_swt = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_scs_left_2_swt");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_scs_left_2_swt = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_scs_left_1_swtReq(ec_scs_left_2_swt),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_scs_left_2_swtReq(int32_t ec_scs_left_2_swt) {
    auto req = mValueObjectPool->obtainInt32(ec_scs_left_2_swt);
    req->prop = toInt(VehicleProperty::GECKO_SCS_LEFT_2SWT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_scs_left_3_swtWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_scs_left_3_swt = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_scs_left_3_swt");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_scs_left_3_swt = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_scs_left_3_swtReq(ec_scs_left_3_swt),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_scs_left_3_swtReq(int32_t ec_scs_left_3_swt) {
    auto req = mValueObjectPool->obtainInt32(ec_scs_left_3_swt);
    req->prop = toInt(VehicleProperty::GECKO_SCS_LEFT_3SWT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_scs_left_4_swtWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_scs_left_4_swt = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_scs_left_4_swt");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_scs_left_4_swt = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_scs_left_4_swtReq(ec_scs_left_4_swt),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_scs_left_4_swtReq(int32_t ec_scs_left_4_swt) {
    auto req = mValueObjectPool->obtainInt32(ec_scs_left_4_swt);
    req->prop = toInt(VehicleProperty::GECKO_SCS_LEFT_4SWT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_scs_left_5_swtWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_scs_left_5_swt = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_scs_left_5_swt");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_scs_left_5_swt = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_scs_left_5_swtReq(ec_scs_left_5_swt),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_scs_left_5_swtReq(int32_t ec_scs_left_5_swt) {
    auto req = mValueObjectPool->obtainInt32(ec_scs_left_5_swt);
    req->prop = toInt(VehicleProperty::GECKO_SCS_LEFT_5SWT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_scs_left_6_swtWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_scs_left_6_swt = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_scs_left_6_swt");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_scs_left_6_swt = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_scs_left_6_swtReq(ec_scs_left_6_swt),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_scs_left_6_swtReq(int32_t ec_scs_left_6_swt) {
    auto req = mValueObjectPool->obtainInt32(ec_scs_left_6_swt);
    req->prop = toInt(VehicleProperty::GECKO_SCS_LEFT_6SWT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_scs_left_7_swtWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_scs_left_7_swt = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_scs_left_7_swt");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_scs_left_7_swt = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_scs_left_7_swtReq(ec_scs_left_7_swt),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_scs_left_7_swtReq(int32_t ec_scs_left_7_swt) {
    auto req = mValueObjectPool->obtainInt32(ec_scs_left_7_swt);
    req->prop = toInt(VehicleProperty::GECKO_SCS_LEFT_7SWT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_scs_left_8_swtWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_scs_left_8_swt = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_scs_left_8_swt");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_scs_left_8_swt = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_scs_left_8_swtReq(ec_scs_left_8_swt),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_scs_left_8_swtReq(int32_t ec_scs_left_8_swt) {
    auto req = mValueObjectPool->obtainInt32(ec_scs_left_8_swt);
    req->prop = toInt(VehicleProperty::GECKO_SCS_LEFT_8SWT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_avas_state_rolling_counterWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_avas_state_rolling_counter = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_avas_state_rolling_counter");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_avas_state_rolling_counter = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_avas_state_rolling_counterReq(ec_avas_state_rolling_counter),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_avas_state_rolling_counterReq(int32_t ec_avas_state_rolling_counter) {
    auto req = mValueObjectPool->obtainInt32(ec_avas_state_rolling_counter);
    req->prop = toInt(VehicleProperty::GECKO_AVAS_STATE_ROLLINGCOUNTER);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_current_over_wrningWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bms_current_over_wrning = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_current_over_wrning");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_current_over_wrning = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_bms_current_over_wrningReq(ec_bms_current_over_wrning),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_current_over_wrningReq(int32_t ec_bms_current_over_wrning) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_current_over_wrning);
    req->prop = toInt(VehicleProperty::GECKO_BMS_CURRENTOVERWRNING);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_battery_sub_sys_numWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bms_battery_sub_sys_num = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_battery_sub_sys_num");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_battery_sub_sys_num = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_bms_battery_sub_sys_numReq(ec_bms_battery_sub_sys_num),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_battery_sub_sys_numReq(int32_t ec_bms_battery_sub_sys_num) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_battery_sub_sys_num);
    req->prop = toInt(VehicleProperty::GECKO_BMS_BATTERYSUBSYSNUM);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_battery_sub_sys_codWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bms_battery_sub_sys_cod = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_battery_sub_sys_cod");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_battery_sub_sys_cod = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_bms_battery_sub_sys_codReq(ec_bms_battery_sub_sys_cod),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_battery_sub_sys_codReq(int32_t ec_bms_battery_sub_sys_cod) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_battery_sub_sys_cod);
    req->prop = toInt(VehicleProperty::GECKO_BMS_BATTERYSUBSYSCOD);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_battery_dtc_numWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bms_battery_dtc_num = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_battery_dtc_num");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_battery_dtc_num = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_bms_battery_dtc_numReq(ec_bms_battery_dtc_num),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_battery_dtc_numReq(int32_t ec_bms_battery_dtc_num) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_battery_dtc_num);
    req->prop = toInt(VehicleProperty::GECKO_BMS_BATTERYDTC_NUM);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_battery_dtc_listWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bms_battery_dtc_list = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_battery_dtc_list");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_battery_dtc_list = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_bms_battery_dtc_listReq(ec_bms_battery_dtc_list),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_battery_dtc_listReq(int32_t ec_bms_battery_dtc_list) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_battery_dtc_list);
    req->prop = toInt(VehicleProperty::GECKO_BMS_BATTERYDTC_LIST);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_battery_dtc_indexWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bms_battery_dtc_index = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_battery_dtc_index");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_battery_dtc_index = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_bms_battery_dtc_indexReq(ec_bms_battery_dtc_index),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_battery_dtc_indexReq(int32_t ec_bms_battery_dtc_index) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_battery_dtc_index);
    req->prop = toInt(VehicleProperty::GECKO_BMS_BATTERYDTC_INDEX);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_inv_1_rolling_counterWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_inv_1_rolling_counter = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_inv_1_rolling_counter");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_inv_1_rolling_counter = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_inv_1_rolling_counterReq(ec_inv_1_rolling_counter),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_inv_1_rolling_counterReq(int32_t ec_inv_1_rolling_counter) {
    auto req = mValueObjectPool->obtainInt32(ec_inv_1_rolling_counter);
    req->prop = toInt(VehicleProperty::GECKO_INV_1_ROLLINGCOUNTER);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_inv_4_err_bitsWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_inv_4_err_bits = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_inv_4_err_bits");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_inv_4_err_bits = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_inv_4_err_bitsReq(ec_inv_4_err_bits),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_inv_4_err_bitsReq(int32_t ec_inv_4_err_bits) {
    auto req = mValueObjectPool->obtainInt32(ec_inv_4_err_bits);
    req->prop = toInt(VehicleProperty::GECKO_INV_4_ERRBITS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_inv_4_rolling_counterWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_inv_4_rolling_counter = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_inv_4_rolling_counter");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_inv_4_rolling_counter = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_inv_4_rolling_counterReq(ec_inv_4_rolling_counter),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_inv_4_rolling_counterReq(int32_t ec_inv_4_rolling_counter) {
    auto req = mValueObjectPool->obtainInt32(ec_inv_4_rolling_counter);
    req->prop = toInt(VehicleProperty::GECKO_INV_4_ROLLINGCOUNTER);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_scs_right_swt_vdWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_scs_right_swt_vd = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_scs_right_swt_vd");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_scs_right_swt_vd = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_scs_right_swt_vdReq(ec_scs_right_swt_vd),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_scs_right_swt_vdReq(int32_t ec_scs_right_swt_vd) {
    auto req = mValueObjectPool->obtainInt32(ec_scs_right_swt_vd);
    req->prop = toInt(VehicleProperty::GECKO_SCS_RIGHTSWTVD);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_scs_right_14_swtWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_scs_right_14_swt = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_scs_right_14_swt");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_scs_right_14_swt = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_scs_right_14_swtReq(ec_scs_right_14_swt),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_scs_right_14_swtReq(int32_t ec_scs_right_14_swt) {
    auto req = mValueObjectPool->obtainInt32(ec_scs_right_14_swt);
    req->prop = toInt(VehicleProperty::GECKO_SCS_RIGHT_14SWT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_scs_right_15_swtWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_scs_right_15_swt = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_scs_right_15_swt");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_scs_right_15_swt = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_scs_right_15_swtReq(ec_scs_right_15_swt),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_scs_right_15_swtReq(int32_t ec_scs_right_15_swt) {
    auto req = mValueObjectPool->obtainInt32(ec_scs_right_15_swt);
    req->prop = toInt(VehicleProperty::GECKO_SCS_RIGHT_15SWT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_scs_right_16_swtWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_scs_right_16_swt = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_scs_right_16_swt");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_scs_right_16_swt = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_scs_right_16_swtReq(ec_scs_right_16_swt),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_scs_right_16_swtReq(int32_t ec_scs_right_16_swt) {
    auto req = mValueObjectPool->obtainInt32(ec_scs_right_16_swt);
    req->prop = toInt(VehicleProperty::GECKO_SCS_RIGHT_16SWT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_crrr_bsd_warn_rightWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_crrr_bsd_warn_right = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_crrr_bsd_warn_right");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_crrr_bsd_warn_right = mPropertyManager->getCProValue(mp);
      LOG(INFO) << "ec_crrr_bsd_warn_right: " << ec_crrr_bsd_warn_right;
      mHal->onPropertyValue(*Create_ec_crrr_bsd_warn_rightReq(ec_crrr_bsd_warn_right),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_crrr_bsd_warn_rightReq(int32_t ec_crrr_bsd_warn_right) {
    auto req = mValueObjectPool->obtainInt32(ec_crrr_bsd_warn_right);
    req->prop = toInt(VehicleProperty::GECKO_CRRR_BSD_WARN_RIGHT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_crrr_bsd_warn_leftWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_crrr_bsd_warn_left = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_crrr_bsd_warn_left");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_crrr_bsd_warn_left = mPropertyManager->getCProValue(mp);
      LOG(INFO) << "ec_crrr_bsd_warn_left: " << ec_crrr_bsd_warn_left;
      mHal->onPropertyValue(*Create_ec_crrr_bsd_warn_leftReq(ec_crrr_bsd_warn_left),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_crrr_bsd_warn_leftReq(int32_t ec_crrr_bsd_warn_left) {
    auto req = mValueObjectPool->obtainInt32(ec_crrr_bsd_warn_left);
    req->prop = toInt(VehicleProperty::GECKO_CRRR_BSD_WARN_LEFT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_crrr_bsd_set_fbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_crrr_bsd_set_fb = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_crrr_bsd_set_fb");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_crrr_bsd_set_fb = mPropertyManager->getCProValue(mp);
      LOG(INFO)<<"ec_crrr_bsd_set_fb = " << ec_crrr_bsd_set_fb;
      mHal->onPropertyValue(*Create_ec_crrr_bsd_set_fbReq(ec_crrr_bsd_set_fb),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_crrr_bsd_set_fbReq(int32_t ec_crrr_bsd_set_fb) {
    auto req = mValueObjectPool->obtainInt32(ec_crrr_bsd_set_fb);
    req->prop = toInt(VehicleProperty::GECKO_CRRR_BSD_SETFB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_crrr_rcta_warn_rightWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_crrr_rcta_warn_right = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_crrr_rcta_warn_right");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_crrr_rcta_warn_right = mPropertyManager->getCProValue(mp);
      LOG(INFO)<<"ec_crrr_rcta_warn_right = " << ec_crrr_rcta_warn_right;
      mHal->onPropertyValue(*Create_ec_crrr_rcta_warn_rightReq(ec_crrr_rcta_warn_right),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_crrr_rcta_warn_rightReq(int32_t ec_crrr_rcta_warn_right) {
    auto req = mValueObjectPool->obtainInt32(ec_crrr_rcta_warn_right);
    req->prop = toInt(VehicleProperty::GECKO_CRRR_RCTA_WARN_RIGHT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_crrr_rcta_warn_leftWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_crrr_rcta_warn_left = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_crrr_rcta_warn_left");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_crrr_rcta_warn_left = mPropertyManager->getCProValue(mp);
      LOG(INFO)<<"ec_crrr_rcta_warn_left = " << ec_crrr_rcta_warn_left;
      mHal->onPropertyValue(*Create_ec_crrr_rcta_warn_leftReq(ec_crrr_rcta_warn_left),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_crrr_rcta_warn_leftReq(int32_t ec_crrr_rcta_warn_left) {
    auto req = mValueObjectPool->obtainInt32(ec_crrr_rcta_warn_left);
    req->prop = toInt(VehicleProperty::GECKO_CRRR_RCTA_WARN_LEFT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_crrr_rcta_set_fbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_crrr_rcta_set_fb = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_crrr_rcta_set_fb");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_crrr_rcta_set_fb = mPropertyManager->getCProValue(mp);
      LOG(INFO)<< "ec_crrr_rcta_set_fbWatcher: " << ec_crrr_rcta_set_fb;
      mHal->onPropertyValue(*Create_ec_crrr_rcta_set_fbReq(ec_crrr_rcta_set_fb),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_crrr_rcta_set_fbReq(int32_t ec_crrr_rcta_set_fb) {
    auto req = mValueObjectPool->obtainInt32(ec_crrr_rcta_set_fb);
    req->prop = toInt(VehicleProperty::GECKO_CRRR_RCTA_SETFB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_crrr_rcw_warningWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_crrr_rcw_warning = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_crrr_rcw_warning");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_crrr_rcw_warning = mPropertyManager->getCProValue(mp);
      LOG(INFO)<< "ec_crrr_rcw_warning: " << ec_crrr_rcw_warning;
      mHal->onPropertyValue(*Create_ec_crrr_rcw_warningReq(ec_crrr_rcw_warning),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_crrr_rcw_warningReq(int32_t ec_crrr_rcw_warning) {
    auto req = mValueObjectPool->obtainInt32(ec_crrr_rcw_warning);
    req->prop = toInt(VehicleProperty::GECKO_CRRR_RCW_WARNING);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_crrr_rcw_set_fbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_crrr_rcw_set_fb = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_crrr_rcw_set_fb");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_crrr_rcw_set_fb = mPropertyManager->getCProValue(mp);
      LOG(INFO)<<"ec_crrr_rcw_set_fb: " << ec_crrr_rcw_set_fb;
      mHal->onPropertyValue(*Create_ec_crrr_rcw_set_fbReq(ec_crrr_rcw_set_fb),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_crrr_rcw_set_fbReq(int32_t ec_crrr_rcw_set_fb) {
    auto req = mValueObjectPool->obtainInt32(ec_crrr_rcw_set_fb);
    req->prop = toInt(VehicleProperty::GECKO_CRRR_RCW_SETFB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_crrr_rear_corner_failureWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_crrr_rear_corner_failure = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_crrr_rear_corner_failure");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_crrr_rear_corner_failure = mPropertyManager->getCProValue(mp);
      LOG(INFO)<<"ec_crrr_rear_corner_failure: " << ec_crrr_rear_corner_failure;
      mHal->onPropertyValue(*Create_ec_crrr_rear_corner_failureReq(ec_crrr_rear_corner_failure),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_crrr_rear_corner_failureReq(int32_t ec_crrr_rear_corner_failure) {
    auto req = mValueObjectPool->obtainInt32(ec_crrr_rear_corner_failure);
    req->prop = toInt(VehicleProperty::GECKO_CRRR_REARCORNERFAILURE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_crrr_rear_corner_blindnessWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_crrr_rear_corner_blindness = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_crrr_rear_corner_blindness");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_crrr_rear_corner_blindness = mPropertyManager->getCProValue(mp);
      LOG(INFO)<<"ec_crrr_rear_corner_blindness = " << ec_crrr_rear_corner_blindness;
      mHal->onPropertyValue(*Create_ec_crrr_rear_corner_blindnessReq(ec_crrr_rear_corner_blindness),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_crrr_rear_corner_blindnessReq(int32_t ec_crrr_rear_corner_blindness) {
    auto req = mValueObjectPool->obtainInt32(ec_crrr_rear_corner_blindness);
    req->prop = toInt(VehicleProperty::GECKO_CRRR_REARCORNERBLINDNESS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_crrr_dow_set_fbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_crrr_dow_set_fb = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_crrr_dow_set_fb");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_crrr_dow_set_fb = mPropertyManager->getCProValue(mp);
      LOG(INFO)<<"ec_crrr_dow_set_fb: " << ec_crrr_dow_set_fb;
      mHal->onPropertyValue(*Create_ec_crrr_dow_set_fbReq(ec_crrr_dow_set_fb),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_crrr_dow_set_fbReq(int32_t ec_crrr_dow_set_fb) {
    auto req = mValueObjectPool->obtainInt32(ec_crrr_dow_set_fb);
    req->prop = toInt(VehicleProperty::GECKO_CRRR_DOWSETFB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_crrr_dow_warn_frWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_crrr_dow_warn_fr = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_crrr_dow_warn_fr");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_crrr_dow_warn_fr = mPropertyManager->getCProValue(mp);
      LOG(INFO)<<"ec_crrr_dow_warn_fr: " << ec_crrr_dow_warn_fr;
      mHal->onPropertyValue(*Create_ec_crrr_dow_warn_frReq(ec_crrr_dow_warn_fr),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_crrr_dow_warn_frReq(int32_t ec_crrr_dow_warn_fr) {
    auto req = mValueObjectPool->obtainInt32(ec_crrr_dow_warn_fr);
    req->prop = toInt(VehicleProperty::GECKO_CRRR_DOWWARNFR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_crrr_dow_warn_flWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_crrr_dow_warn_fl = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_crrr_dow_warn_fl");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_crrr_dow_warn_fl = mPropertyManager->getCProValue(mp);
      LOG(INFO) << "ec_crrr_dow_warn_fl = " << ec_crrr_dow_warn_fl;
      mHal->onPropertyValue(*Create_ec_crrr_dow_warn_flReq(ec_crrr_dow_warn_fl),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_crrr_dow_warn_flReq(int32_t ec_crrr_dow_warn_fl) {
    auto req = mValueObjectPool->obtainInt32(ec_crrr_dow_warn_fl);
    req->prop = toInt(VehicleProperty::GECKO_CRRR_DOWWARNFL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_crrr_dow_warn_rrWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_crrr_dow_warn_rr = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_crrr_dow_warn_rr");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_crrr_dow_warn_rr = mPropertyManager->getCProValue(mp);
      LOG(INFO) << "ec_crrr_dow_warn_rr = " << ec_crrr_dow_warn_rr;
      mHal->onPropertyValue(*Create_ec_crrr_dow_warn_rrReq(ec_crrr_dow_warn_rr),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_crrr_dow_warn_rrReq(int32_t ec_crrr_dow_warn_rr) {
    auto req = mValueObjectPool->obtainInt32(ec_crrr_dow_warn_rr);
    req->prop = toInt(VehicleProperty::GECKO_CRRR_DOWWARNRR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_crrr_dow_warn_rlWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_crrr_dow_warn_rl = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_crrr_dow_warn_rl");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_crrr_dow_warn_rl = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_crrr_dow_warn_rlReq(ec_crrr_dow_warn_rl),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_crrr_dow_warn_rlReq(int32_t ec_crrr_dow_warn_rl) {
    auto req = mValueObjectPool->obtainInt32(ec_crrr_dow_warn_rl);
    req->prop = toInt(VehicleProperty::GECKO_CRRR_DOWWARNRL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_crrr_dow_warn_rightWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_crrr_dow_warn_right = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_crrr_dow_warn_right");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_crrr_dow_warn_right = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_crrr_dow_warn_rightReq(ec_crrr_dow_warn_right),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_crrr_dow_warn_rightReq(int32_t ec_crrr_dow_warn_right) {
    auto req = mValueObjectPool->obtainInt32(ec_crrr_dow_warn_right);
    req->prop = toInt(VehicleProperty::GECKO_CRRR_DOW_WARN_RIGHT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_crrr_dow_warn_leftWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_crrr_dow_warn_left = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_crrr_dow_warn_left");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_crrr_dow_warn_left = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_crrr_dow_warn_leftReq(ec_crrr_dow_warn_left),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_crrr_dow_warn_leftReq(int32_t ec_crrr_dow_warn_left) {
    auto req = mValueObjectPool->obtainInt32(ec_crrr_dow_warn_left);
    req->prop = toInt(VehicleProperty::GECKO_CRRR_DOW_WARN_LEFT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_typ1Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_typ1 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_typ1");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_typ1 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_typ1Req(ec_fcm_obj_typ1),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_typ1Req(int32_t ec_fcm_obj_typ1) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_typ1);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJTYP1);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_lat_dst1Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_lat_dst1 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_lat_dst1");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_lat_dst1 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.1, -6.4));
      LOG(INFO) << "ec_fcm_obj_lat_dst1: " << ec_fcm_obj_lat_dst1;
      mHal->onPropertyValue(*Create_ec_fcm_obj_lat_dst1Req(ec_fcm_obj_lat_dst1),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_lat_dst1Req(int32_t ec_fcm_obj_lat_dst1) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_lat_dst1);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJLATDST1);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_lgt_dst1Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_lgt_dst1 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_lgt_dst1");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_lgt_dst1 = round(getActualFloatValue(mPropertyManager->getCProValue(mp), 0.5, -100));
      LOG(INFO)<<"ec_fcm_obj_lgt_dst1: "<<ec_fcm_obj_lgt_dst1;
      mHal->onPropertyValue(*Create_ec_fcm_obj_lgt_dst1Req(ec_fcm_obj_lgt_dst1),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_lgt_dst1Req(int32_t ec_fcm_obj_lgt_dst1) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_lgt_dst1);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJLGTDST1);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_lgt_rel_spd1Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_lgt_rel_spd1 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_lgt_rel_spd1");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_lgt_rel_spd1 = round(getActualFloatValue(mPropertyManager->getCProValue(mp), 5, -130));
      mHal->onPropertyValue(*Create_ec_fcm_lgt_rel_spd1Req(ec_fcm_lgt_rel_spd1),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_lgt_rel_spd1Req(int32_t ec_fcm_lgt_rel_spd1) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_lgt_rel_spd1);
    req->prop = toInt(VehicleProperty::GECKO_FCM_LGTRELSPD1);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_posn_agl1Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_posn_agl1 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_posn_agl1");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_posn_agl1 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.01, -3.14));
      mHal->onPropertyValue(*Create_ec_fcm_obj_posn_agl1Req(ec_fcm_obj_posn_agl1),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_posn_agl1Req(int32_t ec_fcm_obj_posn_agl1) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_posn_agl1);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJPOSNAGL1);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_dir1Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_movmt_dir1 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_movmt_dir1");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_movmt_dir1 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_movmt_dir1Req(ec_fcm_obj_movmt_dir1),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_movmt_dir1Req(int32_t ec_fcm_obj_movmt_dir1) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_movmt_dir1);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJMOVMTDIR1);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_sta1Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_movmt_sta1 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_movmt_sta1");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_movmt_sta1 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_movmt_sta1Req(ec_fcm_obj_movmt_sta1),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_movmt_sta1Req(int32_t ec_fcm_obj_movmt_sta1) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_movmt_sta1);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJMOVMTSTA1);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_fcm_obj_typ2Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_typ2 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_typ2");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_typ2 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_typ2Req(ec_fcm_obj_typ2),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_typ2Req(int32_t ec_fcm_obj_typ2) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_typ2);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJTYP2);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_lat_dst2Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_lat_dst2 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_lat_dst2");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_lat_dst2 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.1, -6.4));
      mHal->onPropertyValue(*Create_ec_fcm_obj_lat_dst2Req(ec_fcm_obj_lat_dst2),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_lat_dst2Req(int32_t ec_fcm_obj_lat_dst2) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_lat_dst2);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJLATDST2);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_lgt_dst2Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_lgt_dst2 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_lgt_dst2");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_lgt_dst2 = round(getActualFloatValue(mPropertyManager->getCProValue(mp), 0.5, -100));
      mHal->onPropertyValue(*Create_ec_fcm_obj_lgt_dst2Req(ec_fcm_obj_lgt_dst2),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_lgt_dst2Req(int32_t ec_fcm_obj_lgt_dst2) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_lgt_dst2);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJLGTDST2);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_lgt_rel_spd2Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_lgt_rel_spd2 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_lgt_rel_spd2");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_lgt_rel_spd2 = round(getActualFloatValue(mPropertyManager->getCProValue(mp), 5, -130));
      mHal->onPropertyValue(*Create_ec_fcm_lgt_rel_spd2Req(ec_fcm_lgt_rel_spd2),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_lgt_rel_spd2Req(int32_t ec_fcm_lgt_rel_spd2) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_lgt_rel_spd2);
    req->prop = toInt(VehicleProperty::GECKO_FCM_LGTRELSPD2);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_posn_agl2Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_posn_agl2 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_posn_agl2");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_posn_agl2 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.01, -3.14));
      mHal->onPropertyValue(*Create_ec_fcm_obj_posn_agl2Req(ec_fcm_obj_posn_agl2),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_posn_agl2Req(int32_t ec_fcm_obj_posn_agl2) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_posn_agl2);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJPOSNAGL2);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_dir2Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_movmt_dir2 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_movmt_dir2");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_movmt_dir2 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_movmt_dir2Req(ec_fcm_obj_movmt_dir2),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_movmt_dir2Req(int32_t ec_fcm_obj_movmt_dir2) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_movmt_dir2);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJMOVMTDIR2);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_sta2Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_movmt_sta2 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_movmt_sta2");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_movmt_sta2 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_movmt_sta2Req(ec_fcm_obj_movmt_sta2),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_movmt_sta2Req(int32_t ec_fcm_obj_movmt_sta2) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_movmt_sta2);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJMOVMTSTA2);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_typ3Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_typ3 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_typ3");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_typ3 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_typ3Req(ec_fcm_obj_typ3),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_typ3Req(int32_t ec_fcm_obj_typ3) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_typ3);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJTYP3);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_lat_dst3Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_lat_dst3 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_lat_dst3");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_lat_dst3 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.1, -6.4));
      mHal->onPropertyValue(*Create_ec_fcm_obj_lat_dst3Req(ec_fcm_obj_lat_dst3),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_lat_dst3Req(int32_t ec_fcm_obj_lat_dst3) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_lat_dst3);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJLATDST3);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_lgt_dst3Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_lgt_dst3 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_lgt_dst3");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_lgt_dst3 = round(getActualFloatValue(mPropertyManager->getCProValue(mp), 0.5, -100));
      mHal->onPropertyValue(*Create_ec_fcm_obj_lgt_dst3Req(ec_fcm_obj_lgt_dst3),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_lgt_dst3Req(int32_t ec_fcm_obj_lgt_dst3) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_lgt_dst3);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJLGTDST3);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_lgt_rel_spd3Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_lgt_rel_spd3 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_lgt_rel_spd3");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_lgt_rel_spd3 = round(getActualFloatValue(mPropertyManager->getCProValue(mp), 5, -130));
      mHal->onPropertyValue(*Create_ec_fcm_lgt_rel_spd3Req(ec_fcm_lgt_rel_spd3),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_lgt_rel_spd3Req(int32_t ec_fcm_lgt_rel_spd3) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_lgt_rel_spd3);
    req->prop = toInt(VehicleProperty::GECKO_FCM_LGTRELSPD3);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_posn_agl3Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_posn_agl3 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_posn_agl3");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_posn_agl3 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.01, -3.14));
      mHal->onPropertyValue(*Create_ec_fcm_obj_posn_agl3Req(ec_fcm_obj_posn_agl3),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_posn_agl3Req(int32_t ec_fcm_obj_posn_agl3) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_posn_agl3);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJPOSNAGL3);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_dir3Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_movmt_dir3 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_movmt_dir3");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_movmt_dir3 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_movmt_dir3Req(ec_fcm_obj_movmt_dir3),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_movmt_dir3Req(int32_t ec_fcm_obj_movmt_dir3) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_movmt_dir3);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJMOVMTDIR3);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_sta3Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_movmt_sta3 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_movmt_sta3");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_movmt_sta3 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_movmt_sta3Req(ec_fcm_obj_movmt_sta3),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_movmt_sta3Req(int32_t ec_fcm_obj_movmt_sta3) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_movmt_sta3);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJMOVMTSTA3);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_typ4Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_typ4 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_typ4");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_typ4 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_typ4Req(ec_fcm_obj_typ4),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_typ4Req(int32_t ec_fcm_obj_typ4) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_typ4);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJTYP4);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_lat_dst4Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_lat_dst4 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_lat_dst4");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_lat_dst4 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.1, -6.4));
      mHal->onPropertyValue(*Create_ec_fcm_obj_lat_dst4Req(ec_fcm_obj_lat_dst4),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_lat_dst4Req(int32_t ec_fcm_obj_lat_dst4) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_lat_dst4);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJLATDST4);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_lgt_dst4Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_lgt_dst4 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_lgt_dst4");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_lgt_dst4 = round(getActualFloatValue(mPropertyManager->getCProValue(mp), 0.5, -100));
      mHal->onPropertyValue(*Create_ec_fcm_obj_lgt_dst4Req(ec_fcm_obj_lgt_dst4),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_lgt_dst4Req(int32_t ec_fcm_obj_lgt_dst4) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_lgt_dst4);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJLGTDST4);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_lgt_rel_spd4Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_lgt_rel_spd4 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_lgt_rel_spd4");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_lgt_rel_spd4 = round(getActualFloatValue(mPropertyManager->getCProValue(mp), 5, -130));
      mHal->onPropertyValue(*Create_ec_fcm_lgt_rel_spd4Req(ec_fcm_lgt_rel_spd4),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_lgt_rel_spd4Req(int32_t ec_fcm_lgt_rel_spd4) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_lgt_rel_spd4);
    req->prop = toInt(VehicleProperty::GECKO_FCM_LGTRELSPD4);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_posn_agl4Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_posn_agl4 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_posn_agl4");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_posn_agl4 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.01, -3.14));
      mHal->onPropertyValue(*Create_ec_fcm_obj_posn_agl4Req(ec_fcm_obj_posn_agl4),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_posn_agl4Req(int32_t ec_fcm_obj_posn_agl4) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_posn_agl4);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJPOSNAGL4);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_dir4Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_movmt_dir4 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_movmt_dir4");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_movmt_dir4 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_movmt_dir4Req(ec_fcm_obj_movmt_dir4),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_movmt_dir4Req(int32_t ec_fcm_obj_movmt_dir4) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_movmt_dir4);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJMOVMTDIR4);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_sta4Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_movmt_sta4 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_movmt_sta4");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_movmt_sta4 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_movmt_sta4Req(ec_fcm_obj_movmt_sta4),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_movmt_sta4Req(int32_t ec_fcm_obj_movmt_sta4) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_movmt_sta4);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJMOVMTSTA4);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_typ5Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_typ5 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_typ5");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_typ5 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_typ5Req(ec_fcm_obj_typ5),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_typ5Req(int32_t ec_fcm_obj_typ5) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_typ5);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJTYP5);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_lat_dst5Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_lat_dst5 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_lat_dst5");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_lat_dst5 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.1, -6.4));
      mHal->onPropertyValue(*Create_ec_fcm_obj_lat_dst5Req(ec_fcm_obj_lat_dst5),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_lat_dst5Req(int32_t ec_fcm_obj_lat_dst5) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_lat_dst5);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJLATDST5);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_lgt_dst5Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_lgt_dst5 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_lgt_dst5");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_lgt_dst5 = round(getActualFloatValue(mPropertyManager->getCProValue(mp), 0.5, -100));
      mHal->onPropertyValue(*Create_ec_fcm_obj_lgt_dst5Req(ec_fcm_obj_lgt_dst5),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_lgt_dst5Req(int32_t ec_fcm_obj_lgt_dst5) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_lgt_dst5);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJLGTDST5);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_lgt_rel_spd5Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_lgt_rel_spd5 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_lgt_rel_spd5");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_lgt_rel_spd5 = round(getActualFloatValue(mPropertyManager->getCProValue(mp), 5, -130));
      mHal->onPropertyValue(*Create_ec_fcm_lgt_rel_spd5Req(ec_fcm_lgt_rel_spd5),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_lgt_rel_spd5Req(int32_t ec_fcm_lgt_rel_spd5) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_lgt_rel_spd5);
    req->prop = toInt(VehicleProperty::GECKO_FCM_LGTRELSPD5);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_posn_agl5Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_posn_agl5 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_posn_agl5");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_posn_agl5 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.01, -3.14));
      mHal->onPropertyValue(*Create_ec_fcm_obj_posn_agl5Req(ec_fcm_obj_posn_agl5),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_posn_agl5Req(int32_t ec_fcm_obj_posn_agl5) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_posn_agl5);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJPOSNAGL5);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_dir5Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_movmt_dir5 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_movmt_dir5");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_movmt_dir5 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_movmt_dir5Req(ec_fcm_obj_movmt_dir5),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_movmt_dir5Req(int32_t ec_fcm_obj_movmt_dir5) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_movmt_dir5);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJMOVMTDIR5);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_sta5Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_movmt_sta5 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_movmt_sta5");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_movmt_sta5 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_movmt_sta5Req(ec_fcm_obj_movmt_sta5),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_movmt_sta5Req(int32_t ec_fcm_obj_movmt_sta5) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_movmt_sta5);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJMOVMTSTA5);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_typ6Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_typ6 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_typ6");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_typ6 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_typ6Req(ec_fcm_obj_typ6),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_typ6Req(int32_t ec_fcm_obj_typ6) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_typ6);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJTYP6);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_lat_dst6Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_lat_dst6 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_lat_dst6");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_lat_dst6 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.1, -6.4));
      mHal->onPropertyValue(*Create_ec_fcm_obj_lat_dst6Req(ec_fcm_obj_lat_dst6),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_lat_dst6Req(int32_t ec_fcm_obj_lat_dst6) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_lat_dst6);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJLATDST6);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_lgt_dst6Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_lgt_dst6 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_lgt_dst6");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_lgt_dst6 = round(getActualFloatValue(mPropertyManager->getCProValue(mp), 0.5, -100));
      mHal->onPropertyValue(*Create_ec_fcm_obj_lgt_dst6Req(ec_fcm_obj_lgt_dst6),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_lgt_dst6Req(int32_t ec_fcm_obj_lgt_dst6) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_lgt_dst6);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJLGTDST6);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_lgt_rel_spd6Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_lgt_rel_spd6 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_lgt_rel_spd6");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_lgt_rel_spd6 = round(getActualFloatValue(mPropertyManager->getCProValue(mp), 5, -130));
      mHal->onPropertyValue(*Create_ec_fcm_lgt_rel_spd6Req(ec_fcm_lgt_rel_spd6),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_lgt_rel_spd6Req(int32_t ec_fcm_lgt_rel_spd6) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_lgt_rel_spd6);
    req->prop = toInt(VehicleProperty::GECKO_FCM_LGTRELSPD6);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_posn_agl6Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_posn_agl6 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_posn_agl6");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_posn_agl6 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.01, -3.14));
      mHal->onPropertyValue(*Create_ec_fcm_obj_posn_agl6Req(ec_fcm_obj_posn_agl6),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_posn_agl6Req(int32_t ec_fcm_obj_posn_agl6) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_posn_agl6);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJPOSNAGL6);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_dir6Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_movmt_dir6 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_movmt_dir6");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_movmt_dir6 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_movmt_dir6Req(ec_fcm_obj_movmt_dir6),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_movmt_dir6Req(int32_t ec_fcm_obj_movmt_dir6) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_movmt_dir6);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJMOVMTDIR6);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_sta6Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_movmt_sta6 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_movmt_sta6");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_movmt_sta6 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_movmt_sta6Req(ec_fcm_obj_movmt_sta6),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_movmt_sta6Req(int32_t ec_fcm_obj_movmt_sta6) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_movmt_sta6);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJMOVMTSTA6);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_typ7Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_typ7 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_typ7");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_typ7 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_typ7Req(ec_fcm_obj_typ7),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_typ7Req(int32_t ec_fcm_obj_typ7) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_typ7);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJTYP7);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_lat_dst7Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_lat_dst7 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_lat_dst7");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_lat_dst7 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.1, -6.4));
      mHal->onPropertyValue(*Create_ec_fcm_obj_lat_dst7Req(ec_fcm_obj_lat_dst7),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_lat_dst7Req(int32_t ec_fcm_obj_lat_dst7) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_lat_dst7);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJLATDST7);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_lgt_dst7Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_lgt_dst7 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_lgt_dst7");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_lgt_dst7 = round(getActualFloatValue(mPropertyManager->getCProValue(mp), 0.5, -100));
      mHal->onPropertyValue(*Create_ec_fcm_obj_lgt_dst7Req(ec_fcm_obj_lgt_dst7),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_lgt_dst7Req(int32_t ec_fcm_obj_lgt_dst7) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_lgt_dst7);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJLGTDST7);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_lgt_rel_spd7Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_lgt_rel_spd7 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_lgt_rel_spd7");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_lgt_rel_spd7 = round(getActualFloatValue(mPropertyManager->getCProValue(mp), 5, -130));
      mHal->onPropertyValue(*Create_ec_fcm_lgt_rel_spd7Req(ec_fcm_lgt_rel_spd7),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_lgt_rel_spd7Req(int32_t ec_fcm_lgt_rel_spd7) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_lgt_rel_spd7);
    req->prop = toInt(VehicleProperty::GECKO_FCM_LGTRELSPD7);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_posn_agl7Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_posn_agl7 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_posn_agl7");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_posn_agl7 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.01, -3.14));
      mHal->onPropertyValue(*Create_ec_fcm_obj_posn_agl7Req(ec_fcm_obj_posn_agl7),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_posn_agl7Req(int32_t ec_fcm_obj_posn_agl7) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_posn_agl7);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJPOSNAGL7);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_dir7Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_movmt_dir7 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_movmt_dir7");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_movmt_dir7 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_movmt_dir7Req(ec_fcm_obj_movmt_dir7),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_movmt_dir7Req(int32_t ec_fcm_obj_movmt_dir7) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_movmt_dir7);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJMOVMTDIR7);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_sta7Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_movmt_sta7 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_movmt_sta7");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_movmt_sta7 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_movmt_sta7Req(ec_fcm_obj_movmt_sta7),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_movmt_sta7Req(int32_t ec_fcm_obj_movmt_sta7) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_movmt_sta7);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJMOVMTSTA7);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_fcm_obj_typ8Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_typ8 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_typ8");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_typ8 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_typ8Req(ec_fcm_obj_typ8),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_typ8Req(int32_t ec_fcm_obj_typ8) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_typ8);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJTYP8);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_lat_dst8Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_lat_dst8 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_lat_dst8");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_lat_dst8 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.1, -6.4));
      mHal->onPropertyValue(*Create_ec_fcm_obj_lat_dst8Req(ec_fcm_obj_lat_dst8),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_lat_dst8Req(int32_t ec_fcm_obj_lat_dst8) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_lat_dst8);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJLATDST8);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_lgt_dst8Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_lgt_dst8 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_lgt_dst8");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_lgt_dst8 = round(getActualFloatValue(mPropertyManager->getCProValue(mp), 0.5, -100));
      mHal->onPropertyValue(*Create_ec_fcm_obj_lgt_dst8Req(ec_fcm_obj_lgt_dst8),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_lgt_dst8Req(int32_t ec_fcm_obj_lgt_dst8) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_lgt_dst8);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJLGTDST8);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_lgt_rel_spd8Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_lgt_rel_spd8 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_lgt_rel_spd8");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_lgt_rel_spd8 = round(getActualFloatValue(mPropertyManager->getCProValue(mp), 5, -130));
      mHal->onPropertyValue(*Create_ec_fcm_lgt_rel_spd8Req(ec_fcm_lgt_rel_spd8),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_lgt_rel_spd8Req(int32_t ec_fcm_lgt_rel_spd8) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_lgt_rel_spd8);
    req->prop = toInt(VehicleProperty::GECKO_FCM_LGTRELSPD8);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_posn_agl8Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_posn_agl8 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_posn_agl8");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_posn_agl8 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.01, -3.14));
      mHal->onPropertyValue(*Create_ec_fcm_obj_posn_agl8Req(ec_fcm_obj_posn_agl8),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_posn_agl8Req(int32_t ec_fcm_obj_posn_agl8) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_posn_agl8);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJPOSNAGL8);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_dir8Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_movmt_dir8 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_movmt_dir8");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_movmt_dir8 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_movmt_dir8Req(ec_fcm_obj_movmt_dir8),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_movmt_dir8Req(int32_t ec_fcm_obj_movmt_dir8) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_movmt_dir8);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJMOVMTDIR8);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_sta8Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_movmt_sta8 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_movmt_sta8");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_movmt_sta8 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_movmt_sta8Req(ec_fcm_obj_movmt_sta8),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_movmt_sta8Req(int32_t ec_fcm_obj_movmt_sta8) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_movmt_sta8);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJMOVMTSTA8);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_typ9Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_typ9 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_typ9");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_typ9 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_typ9Req(ec_fcm_obj_typ9),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_typ9Req(int32_t ec_fcm_obj_typ9) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_typ9);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJTYP9);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_lat_dst9Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_lat_dst9 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_lat_dst9");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_lat_dst9 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.1, -6.4));
      mHal->onPropertyValue(*Create_ec_fcm_obj_lat_dst9Req(ec_fcm_obj_lat_dst9),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_lat_dst9Req(int32_t ec_fcm_obj_lat_dst9) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_lat_dst9);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJLATDST9);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_lgt_dst9Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_lgt_dst9 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_lgt_dst9");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_lgt_dst9 = round(getActualFloatValue(mPropertyManager->getCProValue(mp), 0.5, -100));
      mHal->onPropertyValue(*Create_ec_fcm_obj_lgt_dst9Req(ec_fcm_obj_lgt_dst9),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_lgt_dst9Req(int32_t ec_fcm_obj_lgt_dst9) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_lgt_dst9);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJLGTDST9);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_lgt_rel_spd9Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_lgt_rel_spd9 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_lgt_rel_spd9");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_lgt_rel_spd9 = round(getActualFloatValue(mPropertyManager->getCProValue(mp), 5, -130));
      mHal->onPropertyValue(*Create_ec_fcm_lgt_rel_spd9Req(ec_fcm_lgt_rel_spd9),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_lgt_rel_spd9Req(int32_t ec_fcm_lgt_rel_spd9) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_lgt_rel_spd9);
    req->prop = toInt(VehicleProperty::GECKO_FCM_LGTRELSPD9);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_posn_agl9Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_posn_agl9 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_posn_agl9");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_posn_agl9 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.01, -3.14));
      mHal->onPropertyValue(*Create_ec_fcm_obj_posn_agl9Req(ec_fcm_obj_posn_agl9),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_posn_agl9Req(int32_t ec_fcm_obj_posn_agl9) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_posn_agl9);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJPOSNAGL9);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_dir9Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_movmt_dir9 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_movmt_dir9");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_movmt_dir9 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_movmt_dir9Req(ec_fcm_obj_movmt_dir9),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_movmt_dir9Req(int32_t ec_fcm_obj_movmt_dir9) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_movmt_dir9);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJMOVMTDIR9);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_sta9Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_movmt_sta9 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_movmt_sta9");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_movmt_sta9 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_movmt_sta9Req(ec_fcm_obj_movmt_sta9),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_movmt_sta9Req(int32_t ec_fcm_obj_movmt_sta9) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_movmt_sta9);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJMOVMTSTA9);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_typ10Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_typ10 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_typ10");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_typ10 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_typ10Req(ec_fcm_obj_typ10),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_typ10Req(int32_t ec_fcm_obj_typ10) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_typ10);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJTYP10);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_lat_dst10Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_lat_dst10 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_lat_dst10");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_lat_dst10 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.1, -6.4));
      mHal->onPropertyValue(*Create_ec_fcm_obj_lat_dst10Req(ec_fcm_obj_lat_dst10),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_lat_dst10Req(int32_t ec_fcm_obj_lat_dst10) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_lat_dst10);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJLATDST10);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_lgt_dst10Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_lgt_dst10 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_lgt_dst10");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_lgt_dst10 = round(getActualFloatValue(mPropertyManager->getCProValue(mp), 0.5, -100));
      mHal->onPropertyValue(*Create_ec_fcm_obj_lgt_dst10Req(ec_fcm_obj_lgt_dst10),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_lgt_dst10Req(int32_t ec_fcm_obj_lgt_dst10) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_lgt_dst10);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJLGTDST10);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_lgt_rel_spd10Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_lgt_rel_spd10 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_lgt_rel_spd10");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_lgt_rel_spd10 = round(getActualFloatValue(mPropertyManager->getCProValue(mp), 5, -130));
      mHal->onPropertyValue(*Create_ec_fcm_lgt_rel_spd10Req(ec_fcm_lgt_rel_spd10),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_lgt_rel_spd10Req(int32_t ec_fcm_lgt_rel_spd10) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_lgt_rel_spd10);
    req->prop = toInt(VehicleProperty::GECKO_FCM_LGTRELSPD10);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_posn_agl10Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_posn_agl10 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_posn_agl10");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_posn_agl10 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.01, -3.14));
      mHal->onPropertyValue(*Create_ec_fcm_obj_posn_agl10Req(ec_fcm_obj_posn_agl10),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_posn_agl10Req(int32_t ec_fcm_obj_posn_agl10) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_posn_agl10);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJPOSNAGL10);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_dir10Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_movmt_dir10 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_movmt_dir10");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_movmt_dir10 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_movmt_dir10Req(ec_fcm_obj_movmt_dir10),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_movmt_dir10Req(int32_t ec_fcm_obj_movmt_dir10) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_movmt_dir10);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJMOVMTDIR10);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_sta10Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_movmt_sta10 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_movmt_sta10");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_movmt_sta10 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_movmt_sta10Req(ec_fcm_obj_movmt_sta10),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_movmt_sta10Req(int32_t ec_fcm_obj_movmt_sta10) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_movmt_sta10);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJMOVMTSTA10);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_typ11Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_typ11 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_typ11");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_typ11 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_typ11Req(ec_fcm_obj_typ11),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_typ11Req(int32_t ec_fcm_obj_typ11) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_typ11);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJTYP11);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_lat_dst11Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_lat_dst11 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_lat_dst11");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_lat_dst11 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.1, -6.4));
      mHal->onPropertyValue(*Create_ec_fcm_obj_lat_dst11Req(ec_fcm_obj_lat_dst11),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_lat_dst11Req(int32_t ec_fcm_obj_lat_dst11) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_lat_dst11);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJLATDST11);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_lgt_dst11Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_lgt_dst11 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_lgt_dst11");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_lgt_dst11 = round(getActualFloatValue(mPropertyManager->getCProValue(mp), 0.5, -100));
      mHal->onPropertyValue(*Create_ec_fcm_obj_lgt_dst11Req(ec_fcm_obj_lgt_dst11),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_lgt_dst11Req(int32_t ec_fcm_obj_lgt_dst11) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_lgt_dst11);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJLGTDST11);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_lgt_rel_spd11Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_lgt_rel_spd11 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_lgt_rel_spd11");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_lgt_rel_spd11 = round(getActualFloatValue(mPropertyManager->getCProValue(mp), 5, -130));
      mHal->onPropertyValue(*Create_ec_fcm_lgt_rel_spd11Req(ec_fcm_lgt_rel_spd11),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_lgt_rel_spd11Req(int32_t ec_fcm_lgt_rel_spd11) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_lgt_rel_spd11);
    req->prop = toInt(VehicleProperty::GECKO_FCM_LGTRELSPD11);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_posn_agl11Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_posn_agl11 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_posn_agl11");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_posn_agl11 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.01, -3.14));
      mHal->onPropertyValue(*Create_ec_fcm_obj_posn_agl11Req(ec_fcm_obj_posn_agl11),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_posn_agl11Req(int32_t ec_fcm_obj_posn_agl11) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_posn_agl11);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJPOSNAGL11);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_dir11Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_movmt_dir11 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_movmt_dir11");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_movmt_dir11 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_movmt_dir11Req(ec_fcm_obj_movmt_dir11),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_movmt_dir11Req(int32_t ec_fcm_obj_movmt_dir11) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_movmt_dir11);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJMOVMTDIR11);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_sta11Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_movmt_sta11 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_movmt_sta11");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_movmt_sta11 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_movmt_sta11Req(ec_fcm_obj_movmt_sta11),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_movmt_sta11Req(int32_t ec_fcm_obj_movmt_sta11) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_movmt_sta11);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJMOVMTSTA11);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_typ12Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_typ12 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_typ12");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_typ12 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_typ12Req(ec_fcm_obj_typ12),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_typ12Req(int32_t ec_fcm_obj_typ12) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_typ12);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJTYP12);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_lat_dst12Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_lat_dst12 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_lat_dst12");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_lat_dst12 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.1, -6.4));
      mHal->onPropertyValue(*Create_ec_fcm_obj_lat_dst12Req(ec_fcm_obj_lat_dst12),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_lat_dst12Req(int32_t ec_fcm_obj_lat_dst12) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_lat_dst12);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJLATDST12);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_lgt_dst12Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_lgt_dst12 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_lgt_dst12");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_lgt_dst12 = round(getActualFloatValue(mPropertyManager->getCProValue(mp), 0.5, -100));
      mHal->onPropertyValue(*Create_ec_fcm_obj_lgt_dst12Req(ec_fcm_obj_lgt_dst12),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_lgt_dst12Req(int32_t ec_fcm_obj_lgt_dst12) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_lgt_dst12);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJLGTDST12);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_lgt_rel_spd12Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_lgt_rel_spd12 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_lgt_rel_spd12");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_lgt_rel_spd12 = round(getActualFloatValue(mPropertyManager->getCProValue(mp), 5, -130));
      mHal->onPropertyValue(*Create_ec_fcm_lgt_rel_spd12Req(ec_fcm_lgt_rel_spd12),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_lgt_rel_spd12Req(int32_t ec_fcm_lgt_rel_spd12) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_lgt_rel_spd12);
    req->prop = toInt(VehicleProperty::GECKO_FCM_LGTRELSPD12);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_posn_agl12Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_posn_agl12 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_posn_agl12");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_posn_agl12 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.01, -3.14));
      mHal->onPropertyValue(*Create_ec_fcm_obj_posn_agl12Req(ec_fcm_obj_posn_agl12),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_posn_agl12Req(int32_t ec_fcm_obj_posn_agl12) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_posn_agl12);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJPOSNAGL12);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_dir12Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_movmt_dir12 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_movmt_dir12");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_movmt_dir12 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_movmt_dir12Req(ec_fcm_obj_movmt_dir12),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_movmt_dir12Req(int32_t ec_fcm_obj_movmt_dir12) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_movmt_dir12);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJMOVMTDIR12);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_sta12Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_movmt_sta12 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_movmt_sta12");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_movmt_sta12 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_movmt_sta12Req(ec_fcm_obj_movmt_sta12),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_movmt_sta12Req(int32_t ec_fcm_obj_movmt_sta12) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_movmt_sta12);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJMOVMTSTA12);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_typ13Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_typ13 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_typ13");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_typ13 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_typ13Req(ec_fcm_obj_typ13),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_typ13Req(int32_t ec_fcm_obj_typ13) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_typ13);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJTYP13);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_lat_dst13Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_lat_dst13 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_lat_dst13");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_lat_dst13 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.1, -6.4));
      mHal->onPropertyValue(*Create_ec_fcm_obj_lat_dst13Req(ec_fcm_obj_lat_dst13),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_lat_dst13Req(int32_t ec_fcm_obj_lat_dst13) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_lat_dst13);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJLATDST13);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_lgt_dst13Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_lgt_dst13 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_lgt_dst13");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_lgt_dst13 = round(getActualFloatValue(mPropertyManager->getCProValue(mp), 0.5, -100));
      mHal->onPropertyValue(*Create_ec_fcm_obj_lgt_dst13Req(ec_fcm_obj_lgt_dst13),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_lgt_dst13Req(int32_t ec_fcm_obj_lgt_dst13) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_lgt_dst13);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJLGTDST13);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_lgt_rel_spd13Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_lgt_rel_spd13 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_lgt_rel_spd13");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_lgt_rel_spd13 = round(getActualFloatValue(mPropertyManager->getCProValue(mp), 5, -130));
      mHal->onPropertyValue(*Create_ec_fcm_lgt_rel_spd13Req(ec_fcm_lgt_rel_spd13),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_lgt_rel_spd13Req(int32_t ec_fcm_lgt_rel_spd13) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_lgt_rel_spd13);
    req->prop = toInt(VehicleProperty::GECKO_FCM_LGTRELSPD13);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_posn_agl13Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_posn_agl13 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_posn_agl13");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_posn_agl13 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.01, -3.14));
      mHal->onPropertyValue(*Create_ec_fcm_obj_posn_agl13Req(ec_fcm_obj_posn_agl13),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_posn_agl13Req(int32_t ec_fcm_obj_posn_agl13) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_posn_agl13);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJPOSNAGL13);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_dir13Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_movmt_dir13 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_movmt_dir13");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_movmt_dir13 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_movmt_dir13Req(ec_fcm_obj_movmt_dir13),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_movmt_dir13Req(int32_t ec_fcm_obj_movmt_dir13) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_movmt_dir13);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJMOVMTDIR13);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_sta13Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_movmt_sta13 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_movmt_sta13");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_movmt_sta13 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_movmt_sta13Req(ec_fcm_obj_movmt_sta13),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_movmt_sta13Req(int32_t ec_fcm_obj_movmt_sta13) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_movmt_sta13);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJMOVMTSTA13);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_typ14Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_typ14 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_typ14");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_typ14 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_typ14Req(ec_fcm_obj_typ14),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_typ14Req(int32_t ec_fcm_obj_typ14) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_typ14);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJTYP14);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_lat_dst14Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_lat_dst14 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_lat_dst14");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_lat_dst14 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.1, -6.4));
      mHal->onPropertyValue(*Create_ec_fcm_obj_lat_dst14Req(ec_fcm_obj_lat_dst14),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_lat_dst14Req(int32_t ec_fcm_obj_lat_dst14) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_lat_dst14);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJLATDST14);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_lgt_dst14Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_lgt_dst14 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_lgt_dst14");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_lgt_dst14 = round(getActualFloatValue(mPropertyManager->getCProValue(mp), 0.5, -100));
      mHal->onPropertyValue(*Create_ec_fcm_obj_lgt_dst14Req(ec_fcm_obj_lgt_dst14),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_lgt_dst14Req(int32_t ec_fcm_obj_lgt_dst14) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_lgt_dst14);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJLGTDST14);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_lgt_rel_spd14Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_lgt_rel_spd14 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_lgt_rel_spd14");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_lgt_rel_spd14 = round(getActualFloatValue(mPropertyManager->getCProValue(mp), 5, -130));
      mHal->onPropertyValue(*Create_ec_fcm_lgt_rel_spd14Req(ec_fcm_lgt_rel_spd14),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_lgt_rel_spd14Req(int32_t ec_fcm_lgt_rel_spd14) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_lgt_rel_spd14);
    req->prop = toInt(VehicleProperty::GECKO_FCM_LGTRELSPD14);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_posn_agl14Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_posn_agl14 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_posn_agl14");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_posn_agl14 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.01, -3.14));
      mHal->onPropertyValue(*Create_ec_fcm_obj_posn_agl14Req(ec_fcm_obj_posn_agl14),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_posn_agl14Req(int32_t ec_fcm_obj_posn_agl14) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_posn_agl14);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJPOSNAGL14);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_dir14Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_movmt_dir14 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_movmt_dir14");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_movmt_dir14 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_movmt_dir14Req(ec_fcm_obj_movmt_dir14),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_movmt_dir14Req(int32_t ec_fcm_obj_movmt_dir14) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_movmt_dir14);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJMOVMTDIR14);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_sta14Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_movmt_sta14 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_movmt_sta14");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_movmt_sta14 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_movmt_sta14Req(ec_fcm_obj_movmt_sta14),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_movmt_sta14Req(int32_t ec_fcm_obj_movmt_sta14) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_movmt_sta14);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJMOVMTSTA14);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_typ15Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_typ15 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_typ15");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_typ15 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_typ15Req(ec_fcm_obj_typ15),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_typ15Req(int32_t ec_fcm_obj_typ15) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_typ15);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJTYP15);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_lat_dst15Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_lat_dst15 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_lat_dst15");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_lat_dst15 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.1, -6.4));
      mHal->onPropertyValue(*Create_ec_fcm_obj_lat_dst15Req(ec_fcm_obj_lat_dst15),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_lat_dst15Req(int32_t ec_fcm_obj_lat_dst15) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_lat_dst15);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJLATDST15);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_lgt_dst15Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_lgt_dst15 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_lgt_dst15");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_lgt_dst15 = round(getActualFloatValue(mPropertyManager->getCProValue(mp), 0.5, -100));
      mHal->onPropertyValue(*Create_ec_fcm_obj_lgt_dst15Req(ec_fcm_obj_lgt_dst15),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_lgt_dst15Req(int32_t ec_fcm_obj_lgt_dst15) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_lgt_dst15);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJLGTDST15);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_lgt_rel_spd15Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_lgt_rel_spd15 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_lgt_rel_spd15");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_lgt_rel_spd15 = round(getActualFloatValue(mPropertyManager->getCProValue(mp), 5, -130));
      mHal->onPropertyValue(*Create_ec_fcm_lgt_rel_spd15Req(ec_fcm_lgt_rel_spd15),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_lgt_rel_spd15Req(int32_t ec_fcm_lgt_rel_spd15) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_lgt_rel_spd15);
    req->prop = toInt(VehicleProperty::GECKO_FCM_LGTRELSPD15);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_posn_agl15Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_posn_agl15 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_posn_agl15");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_posn_agl15 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.01, -3.14));
      mHal->onPropertyValue(*Create_ec_fcm_obj_posn_agl15Req(ec_fcm_obj_posn_agl15),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_posn_agl15Req(int32_t ec_fcm_obj_posn_agl15) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_posn_agl15);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJPOSNAGL15);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_dir15Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_movmt_dir15 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_movmt_dir15");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_movmt_dir15 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_movmt_dir15Req(ec_fcm_obj_movmt_dir15),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_movmt_dir15Req(int32_t ec_fcm_obj_movmt_dir15) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_movmt_dir15);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJMOVMTDIR15);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_sta15Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_movmt_sta15 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_movmt_sta15");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_movmt_sta15 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_movmt_sta15Req(ec_fcm_obj_movmt_sta15),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_movmt_sta15Req(int32_t ec_fcm_obj_movmt_sta15) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_movmt_sta15);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJMOVMTSTA15);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_typ16Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_typ16 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_typ16");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_typ16 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_typ16Req(ec_fcm_obj_typ16),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_typ16Req(int32_t ec_fcm_obj_typ16) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_typ16);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJTYP16);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_lat_dst16Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_lat_dst16 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_lat_dst16");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_lat_dst16 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.1, -6.4));
      mHal->onPropertyValue(*Create_ec_fcm_obj_lat_dst16Req(ec_fcm_obj_lat_dst16),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_lat_dst16Req(int32_t ec_fcm_obj_lat_dst16) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_lat_dst16);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJLATDST16);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_lgt_dst16Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_lgt_dst16 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_lgt_dst16");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_lgt_dst16 = round(getActualFloatValue(mPropertyManager->getCProValue(mp), 0.5, -100));
      mHal->onPropertyValue(*Create_ec_fcm_obj_lgt_dst16Req(ec_fcm_obj_lgt_dst16),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_lgt_dst16Req(int32_t ec_fcm_obj_lgt_dst16) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_lgt_dst16);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJLGTDST16);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_lgt_rel_spd16Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_lgt_rel_spd16 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_lgt_rel_spd16");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_lgt_rel_spd16 = round(getActualFloatValue(mPropertyManager->getCProValue(mp), 5, -130));
      mHal->onPropertyValue(*Create_ec_fcm_lgt_rel_spd16Req(ec_fcm_lgt_rel_spd16),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_lgt_rel_spd16Req(int32_t ec_fcm_lgt_rel_spd16) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_lgt_rel_spd16);
    req->prop = toInt(VehicleProperty::GECKO_FCM_LGTRELSPD16);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_posn_agl16Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_posn_agl16 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_posn_agl16");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_posn_agl16 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.01, -3.14));
      mHal->onPropertyValue(*Create_ec_fcm_obj_posn_agl16Req(ec_fcm_obj_posn_agl16),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_posn_agl16Req(int32_t ec_fcm_obj_posn_agl16) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_posn_agl16);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJPOSNAGL16);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_dir16Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_movmt_dir16 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_movmt_dir16");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_movmt_dir16 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_movmt_dir16Req(ec_fcm_obj_movmt_dir16),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_movmt_dir16Req(int32_t ec_fcm_obj_movmt_dir16) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_movmt_dir16);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJMOVMTDIR16);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_sta16Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_movmt_sta16 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_movmt_sta16");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_movmt_sta16 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_movmt_sta16Req(ec_fcm_obj_movmt_sta16),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_movmt_sta16Req(int32_t ec_fcm_obj_movmt_sta16) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_movmt_sta16);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJMOVMTSTA16);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_typ17Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_typ17 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_typ17");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_typ17 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_typ17Req(ec_fcm_obj_typ17),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_typ17Req(int32_t ec_fcm_obj_typ17) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_typ17);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJTYP17);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_lat_dst17Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_lat_dst17 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_lat_dst17");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_lat_dst17 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.1, -6.4));
      mHal->onPropertyValue(*Create_ec_fcm_obj_lat_dst17Req(ec_fcm_obj_lat_dst17),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_lat_dst17Req(int32_t ec_fcm_obj_lat_dst17) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_lat_dst17);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJLATDST17);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_lgt_dst17Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_lgt_dst17 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_lgt_dst17");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_lgt_dst17 = round(getActualFloatValue(mPropertyManager->getCProValue(mp), 0.5, -100));
      mHal->onPropertyValue(*Create_ec_fcm_obj_lgt_dst17Req(ec_fcm_obj_lgt_dst17),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_lgt_dst17Req(int32_t ec_fcm_obj_lgt_dst17) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_lgt_dst17);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJLGTDST17);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_lgt_rel_spd17Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_lgt_rel_spd17 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_lgt_rel_spd17");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_lgt_rel_spd17 = round(getActualFloatValue(mPropertyManager->getCProValue(mp), 5, -130));
      mHal->onPropertyValue(*Create_ec_fcm_lgt_rel_spd17Req(ec_fcm_lgt_rel_spd17),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_lgt_rel_spd17Req(int32_t ec_fcm_lgt_rel_spd17) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_lgt_rel_spd17);
    req->prop = toInt(VehicleProperty::GECKO_FCM_LGTRELSPD17);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_posn_agl17Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_posn_agl17 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_posn_agl17");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_posn_agl17 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.01, -3.14));
      mHal->onPropertyValue(*Create_ec_fcm_obj_posn_agl17Req(ec_fcm_obj_posn_agl17),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_posn_agl17Req(int32_t ec_fcm_obj_posn_agl17) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_posn_agl17);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJPOSNAGL17);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_dir17Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_movmt_dir17 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_movmt_dir17");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_movmt_dir17 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_movmt_dir17Req(ec_fcm_obj_movmt_dir17),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_movmt_dir17Req(int32_t ec_fcm_obj_movmt_dir17) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_movmt_dir17);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJMOVMTDIR17);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_sta17Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_movmt_sta17 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_movmt_sta17");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_movmt_sta17 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_movmt_sta17Req(ec_fcm_obj_movmt_sta17),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_movmt_sta17Req(int32_t ec_fcm_obj_movmt_sta17) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_movmt_sta17);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJMOVMTSTA17);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_typ18Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_typ18 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_typ18");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_typ18 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_typ18Req(ec_fcm_obj_typ18),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_typ18Req(int32_t ec_fcm_obj_typ18) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_typ18);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJTYP18);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_lat_dst18Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_lat_dst18 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_lat_dst18");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_lat_dst18 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.1, -6.4));
      mHal->onPropertyValue(*Create_ec_fcm_obj_lat_dst18Req(ec_fcm_obj_lat_dst18),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_lat_dst18Req(int32_t ec_fcm_obj_lat_dst18) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_lat_dst18);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJLATDST18);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_lgt_dst18Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_lgt_dst18 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_lgt_dst18");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_lgt_dst18 = round(getActualFloatValue(mPropertyManager->getCProValue(mp), 0.5, -100));
      mHal->onPropertyValue(*Create_ec_fcm_obj_lgt_dst18Req(ec_fcm_obj_lgt_dst18),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_lgt_dst18Req(int32_t ec_fcm_obj_lgt_dst18) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_lgt_dst18);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJLGTDST18);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_lgt_rel_spd18Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_lgt_rel_spd18 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_lgt_rel_spd18");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_lgt_rel_spd18 = round(getActualFloatValue(mPropertyManager->getCProValue(mp), 5, -130));
      mHal->onPropertyValue(*Create_ec_fcm_lgt_rel_spd18Req(ec_fcm_lgt_rel_spd18),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_lgt_rel_spd18Req(int32_t ec_fcm_lgt_rel_spd18) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_lgt_rel_spd18);
    req->prop = toInt(VehicleProperty::GECKO_FCM_LGTRELSPD18);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_posn_agl18Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_posn_agl18 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_posn_agl18");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_posn_agl18 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.01, -3.14));
      mHal->onPropertyValue(*Create_ec_fcm_obj_posn_agl18Req(ec_fcm_obj_posn_agl18),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_posn_agl18Req(int32_t ec_fcm_obj_posn_agl18) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_posn_agl18);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJPOSNAGL18);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_dir18Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_movmt_dir18 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_movmt_dir18");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_movmt_dir18 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_movmt_dir18Req(ec_fcm_obj_movmt_dir18),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_movmt_dir18Req(int32_t ec_fcm_obj_movmt_dir18) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_movmt_dir18);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJMOVMTDIR18);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_sta18Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_movmt_sta18 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_movmt_sta18");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_movmt_sta18 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_movmt_sta18Req(ec_fcm_obj_movmt_sta18),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_movmt_sta18Req(int32_t ec_fcm_obj_movmt_sta18) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_movmt_sta18);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJMOVMTSTA18);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_fcm_nr_of_lineWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_nr_of_line = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_nr_of_line");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_nr_of_line = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_nr_of_lineReq(ec_fcm_nr_of_line),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_nr_of_lineReq(int32_t ec_fcm_nr_of_line) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_nr_of_line);
    req->prop = toInt(VehicleProperty::GECKO_FCM_NROFLINE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_le_line_typWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_le_line_typ = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_le_line_typ");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_le_line_typ = mPropertyManager->getCProValue(mp);
      LOG(INFO)<<"ec_fcm_le_line_typ"<<ec_fcm_le_line_typ;
      mHal->onPropertyValue(*Create_ec_fcm_le_line_typReq(ec_fcm_le_line_typ),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_le_line_typReq(int32_t ec_fcm_le_line_typ) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_le_line_typ);
    req->prop = toInt(VehicleProperty::GECKO_FCM_LELINETYP);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_le_line_rdWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_le_line_rd = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_le_line_rd");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_le_line_rd = round(getActualFloatValue(mPropertyManager->getCProValue(mp), 50, -3150));
      mHal->onPropertyValue(*Create_ec_fcm_le_line_rdReq(ec_fcm_le_line_rd),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_le_line_rdReq(int32_t ec_fcm_le_line_rd) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_le_line_rd);
    req->prop = toInt(VehicleProperty::GECKO_FCM_LELINERD);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_le_line_dstWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_le_line_dst = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_le_line_dst");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_le_line_dst = round(getActualFloatValue(mPropertyManager->getCProValue(mp), 0.1, 0));
      mHal->onPropertyValue(*Create_ec_fcm_le_line_dstReq(ec_fcm_le_line_dst),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_le_line_dstReq(int32_t ec_fcm_le_line_dst) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_le_line_dst);
    req->prop = toInt(VehicleProperty::GECKO_FCM_LELINEDST);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_le_line_c1Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_le_line_c1 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_le_line_c1");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_le_line_c1 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.001, -1.6));
      mHal->onPropertyValue(*Create_ec_fcm_le_line_c1Req(ec_fcm_le_line_c1),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_le_line_c1Req(int32_t ec_fcm_le_line_c1) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_le_line_c1);
    req->prop = toInt(VehicleProperty::GECKO_FCM_LELINEC1);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_le_line_c2Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_le_line_c2 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_le_line_c2");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_le_line_c2 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.0001, -0.025));
      mHal->onPropertyValue(*Create_ec_fcm_le_line_c2Req(ec_fcm_le_line_c2),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_le_line_c2Req(int32_t ec_fcm_le_line_c2) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_le_line_c2);
    req->prop = toInt(VehicleProperty::GECKO_FCM_LELINEC2);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_le_line_c3Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_le_line_c3 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_le_line_c3");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_le_line_c3 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.0000038147, -0.0078125));
      mHal->onPropertyValue(*Create_ec_fcm_le_line_c3Req(ec_fcm_le_line_c3),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_le_line_c3Req(int32_t ec_fcm_le_line_c3) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_le_line_c3);
    req->prop = toInt(VehicleProperty::GECKO_FCM_LELINEC3);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_ri_line_typWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_ri_line_typ = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_ri_line_typ");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_ri_line_typ = mPropertyManager->getCProValue(mp);
      LOG(INFO)<<"ec_fcm_ri_line_typ = " << ec_fcm_ri_line_typ;
      mHal->onPropertyValue(*Create_ec_fcm_ri_line_typReq(ec_fcm_ri_line_typ),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_ri_line_typReq(int32_t ec_fcm_ri_line_typ) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_ri_line_typ);
    req->prop = toInt(VehicleProperty::GECKO_FCM_RILINETYP);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_ri_line_rdWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_ri_line_rd = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_ri_line_rd");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_ri_line_rd = round(getActualFloatValue(mPropertyManager->getCProValue(mp), 50, -3150));
      mHal->onPropertyValue(*Create_ec_fcm_ri_line_rdReq(ec_fcm_ri_line_rd),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_ri_line_rdReq(int32_t ec_fcm_ri_line_rd) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_ri_line_rd);
    req->prop = toInt(VehicleProperty::GECKO_FCM_RILINERD);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_ri_line_dstWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_ri_line_dst = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_ri_line_dst");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_ri_line_dst = round(getActualFloatValue(mPropertyManager->getCProValue(mp), 0.1, 0));
      mHal->onPropertyValue(*Create_ec_fcm_ri_line_dstReq(ec_fcm_ri_line_dst),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_ri_line_dstReq(int32_t ec_fcm_ri_line_dst) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_ri_line_dst);
    req->prop = toInt(VehicleProperty::GECKO_FCM_RILINEDST);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_ri_line_c1Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_ri_line_c1 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_ri_line_c1");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_ri_line_c1 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.001, -1.6));
      mHal->onPropertyValue(*Create_ec_fcm_ri_line_c1Req(ec_fcm_ri_line_c1),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_ri_line_c1Req(int32_t ec_fcm_ri_line_c1) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_ri_line_c1);
    req->prop = toInt(VehicleProperty::GECKO_FCM_RILINEC1);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_ri_line_c2Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_ri_line_c2 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_ri_line_c2");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_ri_line_c2 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.0001, -0.025));
      mHal->onPropertyValue(*Create_ec_fcm_ri_line_c2Req(ec_fcm_ri_line_c2),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_ri_line_c2Req(int32_t ec_fcm_ri_line_c2) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_ri_line_c2);
    req->prop = toInt(VehicleProperty::GECKO_FCM_RILINEC2);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_ri_line_c3Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_ri_line_c3 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_ri_line_c3");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_ri_line_c3 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.0000038147, -0.0078125));
      mHal->onPropertyValue(*Create_ec_fcm_ri_line_c3Req(ec_fcm_ri_line_c3),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_ri_line_c3Req(int32_t ec_fcm_ri_line_c3) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_ri_line_c3);
    req->prop = toInt(VehicleProperty::GECKO_FCM_RILINEC3);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_le_le_line_typWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_le_le_line_typ = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_le_le_line_typ");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_le_le_line_typ = mPropertyManager->getCProValue(mp);
      LOG(INFO)<<"ec_fcm_le_le_line_typ = " << ec_fcm_le_le_line_typ;
      mHal->onPropertyValue(*Create_ec_fcm_le_le_line_typReq(ec_fcm_le_le_line_typ),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_le_le_line_typReq(int32_t ec_fcm_le_le_line_typ) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_le_le_line_typ);
    req->prop = toInt(VehicleProperty::GECKO_FCM_LELELINETYP);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_le_le_line_rdWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_le_le_line_rd = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_le_le_line_rd");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_le_le_line_rd = round(getActualFloatValue(mPropertyManager->getCProValue(mp), 50, -3150));
      mHal->onPropertyValue(*Create_ec_fcm_le_le_line_rdReq(ec_fcm_le_le_line_rd),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_le_le_line_rdReq(int32_t ec_fcm_le_le_line_rd) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_le_le_line_rd);
    req->prop = toInt(VehicleProperty::GECKO_FCM_LELELINERD);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_le_le_line_dstWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_le_le_line_dst = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_le_le_line_dst");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_le_le_line_dst = round(getActualFloatValue(mPropertyManager->getCProValue(mp), 0.1, 0));
      mHal->onPropertyValue(*Create_ec_fcm_le_le_line_dstReq(ec_fcm_le_le_line_dst),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_le_le_line_dstReq(int32_t ec_fcm_le_le_line_dst) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_le_le_line_dst);
    req->prop = toInt(VehicleProperty::GECKO_FCM_LELELINEDST);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_le_le_line_c1Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_le_le_line_c1 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_le_le_line_c1");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_le_le_line_c1 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.001, -1.6));
      mHal->onPropertyValue(*Create_ec_fcm_le_le_line_c1Req(ec_fcm_le_le_line_c1),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_le_le_line_c1Req(int32_t ec_fcm_le_le_line_c1) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_le_le_line_c1);
    req->prop = toInt(VehicleProperty::GECKO_FCM_LELELINEC1);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_le_le_line_c2Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_le_le_line_c2 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_le_le_line_c2");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_le_le_line_c2 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.0001, -0.025));
      mHal->onPropertyValue(*Create_ec_fcm_le_le_line_c2Req(ec_fcm_le_le_line_c2),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_le_le_line_c2Req(int32_t ec_fcm_le_le_line_c2) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_le_le_line_c2);
    req->prop = toInt(VehicleProperty::GECKO_FCM_LELELINEC2);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_le_le_line_c3Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_le_le_line_c3 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_le_le_line_c3");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_le_le_line_c3 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.0000038147, -0.0078125));
      mHal->onPropertyValue(*Create_ec_fcm_le_le_line_c3Req(ec_fcm_le_le_line_c3),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_le_le_line_c3Req(int32_t ec_fcm_le_le_line_c3) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_le_le_line_c3);
    req->prop = toInt(VehicleProperty::GECKO_FCM_LELELINEC3);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_ri_ri_line_typWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_ri_ri_line_typ = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_ri_ri_line_typ");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_ri_ri_line_typ = mPropertyManager->getCProValue(mp);
      LOG(INFO)<<"ec_fcm_ri_ri_line_typ = " << ec_fcm_ri_ri_line_typ;
      mHal->onPropertyValue(*Create_ec_fcm_ri_ri_line_typReq(ec_fcm_ri_ri_line_typ),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_ri_ri_line_typReq(int32_t ec_fcm_ri_ri_line_typ) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_ri_ri_line_typ);
    req->prop = toInt(VehicleProperty::GECKO_FCM_RIRILINETYP);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_ri_ri_line_rdWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_ri_ri_line_rd = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_ri_ri_line_rd");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_ri_ri_line_rd = round(getActualFloatValue(mPropertyManager->getCProValue(mp), 50, -3150));
      mHal->onPropertyValue(*Create_ec_fcm_ri_ri_line_rdReq(ec_fcm_ri_ri_line_rd),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_ri_ri_line_rdReq(int32_t ec_fcm_ri_ri_line_rd) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_ri_ri_line_rd);
    req->prop = toInt(VehicleProperty::GECKO_FCM_RIRILINERD);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_ri_ri_line_dstWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_ri_ri_line_dst = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_ri_ri_line_dst");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_ri_ri_line_dst = round(getActualFloatValue(mPropertyManager->getCProValue(mp), 0.1, 0));
      mHal->onPropertyValue(*Create_ec_fcm_ri_ri_line_dstReq(ec_fcm_ri_ri_line_dst),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_ri_ri_line_dstReq(int32_t ec_fcm_ri_ri_line_dst) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_ri_ri_line_dst);
    req->prop = toInt(VehicleProperty::GECKO_FCM_RIRILINEDST);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_ri_ri_line_c1Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_ri_ri_line_c1 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_ri_ri_line_c1");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_ri_ri_line_c1 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.001, -1.6));
      mHal->onPropertyValue(*Create_ec_fcm_ri_ri_line_c1Req(ec_fcm_ri_ri_line_c1),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_ri_ri_line_c1Req(int32_t ec_fcm_ri_ri_line_c1) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_ri_ri_line_c1);
    req->prop = toInt(VehicleProperty::GECKO_FCM_RIRILINEC1);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_ri_ri_line_c2Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_ri_ri_line_c2 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_ri_ri_line_c2");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_ri_ri_line_c2 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.0001, -0.025));
      mHal->onPropertyValue(*Create_ec_fcm_ri_ri_line_c2Req(ec_fcm_ri_ri_line_c2),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_ri_ri_line_c2Req(int32_t ec_fcm_ri_ri_line_c2) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_ri_ri_line_c2);
    req->prop = toInt(VehicleProperty::GECKO_FCM_RIRILINEC2);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_ri_ri_line_c3Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_ri_ri_line_c3 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_ri_ri_line_c3");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_ri_ri_line_c3 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.0000038147, -0.0078125));
      mHal->onPropertyValue(*Create_ec_fcm_ri_ri_line_c3Req(ec_fcm_ri_ri_line_c3),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_ri_ri_line_c3Req(int32_t ec_fcm_ri_ri_line_c3) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_ri_ri_line_c3);
    req->prop = toInt(VehicleProperty::GECKO_FCM_RIRILINEC3);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_fcm_spd_downin_cor_sfkWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_spd_downin_cor_sfk = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_spd_downin_cor_sfk");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_spd_downin_cor_sfk = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_spd_downin_cor_sfkReq(ec_fcm_spd_downin_cor_sfk),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_spd_downin_cor_sfkReq(int32_t ec_fcm_spd_downin_cor_sfk) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_spd_downin_cor_sfk);
    req->prop = toInt(VehicleProperty::GECKO_HU_SPDDOWNINCORENABLESW);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_vcu_speed_limit_level_set_fbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_vcu_speed_limit_level_set_fb = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_vcu_speed_limit_level_set_fb");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_vcu_speed_limit_level_set_fb = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_vcu_speed_limit_level_set_fbReq(bc_vcu_speed_limit_level_set_fb),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_vcu_speed_limit_level_set_fbReq(int32_t bc_vcu_speed_limit_level_set_fb) {
    auto req = mValueObjectPool->obtainInt32(bc_vcu_speed_limit_level_set_fb);
    req->prop = toInt(VehicleProperty::GECKO_VCU_SPEEDLIMITLEVELSETFB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_abs_active_staWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_esc_abs_active_sta = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_abs_active_sta");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_esc_abs_active_sta = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_esc_abs_active_staReq(ec_esc_abs_active_sta),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_abs_active_staReq(int32_t ec_esc_abs_active_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_abs_active_sta);
    req->prop = toInt(VehicleProperty::GECKO_ESC_ABSACTIVESTA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}


void GarageModeServerSideHandlerImpl::mc_remind_inrWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t mc_remind_inr = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("mc_remind_inr");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      mc_remind_inr = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_mc_remind_inrReq(mc_remind_inr),true);
  }
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_mc_remind_inrReq(int32_t mc_remind_inr) {
    auto req = mValueObjectPool->obtainInt32(mc_remind_inr);
    req->prop = toInt(VehicleProperty::GECKO_SERVICE_REMIND_TIME_SET);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::mc_remind_start_timeWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  uint32_t mc_remind_start_time = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("mc_remind_start_time");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      mc_remind_start_time = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_mc_remind_start_timeReq(mc_remind_start_time),true);
  }
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_mc_remind_start_timeReq(uint32_t mc_remind_start_time) {
    auto req = mValueObjectPool->obtainInt32(mc_remind_start_time);
    req->prop = toInt(VehicleProperty::GECKO_SERVICE_REMIND_START_TIME);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}


void GarageModeServerSideHandlerImpl::mc_remind_distanceWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  uint32_t mc_remind_distance = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("mc_remind_distance");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      mc_remind_distance = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_mc_remind_distanceReq(mc_remind_distance),true);
  }
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_mc_remind_distanceReq(uint32_t mc_remind_distance) {
    auto req = mValueObjectPool->obtainInt32(mc_remind_distance);
    req->prop = toInt(VehicleProperty::GECKO_SERVICE_REMIND_DISTANCE_SET);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::mc_remind_start_odoWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  float mc_remind_start_odo = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("mc_remind_start_odo");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      mc_remind_start_odo = getActualFloatValue(mPropertyManager->getCProValue(mp),0.1,0);
      mHal->onPropertyValue(*Create_mc_remind_start_odoReq(mc_remind_start_odo),true);
  }
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_mc_remind_start_odoReq(float mc_remind_start_odo) {
    auto req = mValueObjectPool->obtainFloat(mc_remind_start_odo);
    req->prop = toInt(VehicleProperty::GECKO_SERVICE_REMIND_START_ODO);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_dcc_actl_oprt_modeWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_ipu_dcc_actl_oprt_mode = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_dcc_actl_oprt_mode");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ipu_dcc_actl_oprt_mode = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_ipu_dcc_actl_oprt_modeReq(ec_ipu_dcc_actl_oprt_mode),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_dcc_actl_oprt_modeReq(int32_t ec_ipu_dcc_actl_oprt_mode) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_dcc_actl_oprt_mode);
    req->prop = toInt(VehicleProperty::GECKO_IPU_DCCACTL_OPTMODE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}


void GarageModeServerSideHandlerImpl::ec_ipu_over_temperature_failWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_ipu_over_temperature_fail = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_over_temperature_fail");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ipu_over_temperature_fail = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_ipu_over_temperature_failReq(ec_ipu_over_temperature_fail),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_over_temperature_failReq(int32_t ec_ipu_over_temperature_fail) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_over_temperature_fail);
    req->prop = toInt(VehicleProperty::GECKO_IPU_OVER_TEMPERATURE_FAIL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_accl_pedal_posWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_accl_pedal_pos = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_accl_pedal_pos");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_accl_pedal_pos = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_vcu_accl_pedal_posReq(ec_vcu_accl_pedal_pos),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_accl_pedal_posReq(int32_t ec_vcu_accl_pedal_pos) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_accl_pedal_pos);
    req->prop = toInt(VehicleProperty::GECKO_VCU_ACCLPEDAL_POS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_brk_pedal_posWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_brk_pedal_pos = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_brk_pedal_pos");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_brk_pedal_pos = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_vcu_brk_pedal_posReq(ec_vcu_brk_pedal_pos),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_brk_pedal_posReq(int32_t ec_vcu_brk_pedal_pos) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_brk_pedal_pos);
    req->prop = toInt(VehicleProperty::GECKO_VCU_BRKPEDAL_POS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_iso_resistanceWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bms_iso_resistance = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_iso_resistance");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_iso_resistance = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_bms_iso_resistanceReq(ec_bms_iso_resistance),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_iso_resistanceReq(int32_t ec_bms_iso_resistance) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_iso_resistance);
    req->prop = toInt(VehicleProperty::GECKO_BMS_ISORESISTANCE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ehb_brk_pedl_valWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_ehb_brk_pedl_val = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ehb_brk_pedl_val");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ehb_brk_pedl_val = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_ehb_brk_pedl_valReq(ec_ehb_brk_pedl_val),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ehb_brk_pedl_valReq(int32_t ec_ehb_brk_pedl_val) {
    auto req = mValueObjectPool->obtainInt32(ec_ehb_brk_pedl_val);
    req->prop = toInt(VehicleProperty::GECKO_EHB_BRKPEDL_VAL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ehb_brk_pedl_val_vldWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_ehb_brk_pedl_val_vld = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ehb_brk_pedl_val_vld");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ehb_brk_pedl_val_vld = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_ehb_brk_pedl_val_vldReq(ec_ehb_brk_pedl_val_vld),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ehb_brk_pedl_val_vldReq(int32_t ec_ehb_brk_pedl_val_vld) {
    auto req = mValueObjectPool->obtainInt32(ec_ehb_brk_pedl_val_vld);
    req->prop = toInt(VehicleProperty::GECKO_EHB_BRKPEDL_VALVLD);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ehb_brk_pedl_val_percWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_ehb_brk_pedl_val_perc = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ehb_brk_pedl_val_perc");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ehb_brk_pedl_val_perc = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_ehb_brk_pedl_val_percReq(ec_ehb_brk_pedl_val_perc),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ehb_brk_pedl_val_percReq(int32_t ec_ehb_brk_pedl_val_perc) {
    auto req = mValueObjectPool->obtainInt32(ec_ehb_brk_pedl_val_perc);
    req->prop = toInt(VehicleProperty::GECKO_EHB_BRKPEDL_VALPERC);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ehb_brk_pedl_val_perc_vldWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_ehb_brk_pedl_val_perc_vld = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ehb_brk_pedl_val_perc_vld");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ehb_brk_pedl_val_perc_vld = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_ehb_brk_pedl_val_perc_vldReq(ec_ehb_brk_pedl_val_perc_vld),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ehb_brk_pedl_val_perc_vldReq(int32_t ec_ehb_brk_pedl_val_perc_vld) {
    auto req = mValueObjectPool->obtainInt32(ec_ehb_brk_pedl_val_perc_vld);
    req->prop = toInt(VehicleProperty::GECKO_EHB_BRKPEDL_VALPERCVLD);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::mc_travel_average_speedWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(6000));
  float mc_travel_average_speed = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("mc_travel_average_speed");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      mc_travel_average_speed = getActualFloatValue(mPropertyManager->getCProValue(mp), 0.1, 0);
      LOG(INFO) << "mc_travel_average_speed:"<< mc_travel_average_speed;
      mHal->onPropertyValue(*Create_mc_travel_average_speedReq(mc_travel_average_speed),true);
  }
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_mc_travel_average_speedReq(float mc_travel_average_speed) {
    auto req = mValueObjectPool->obtainFloat(mc_travel_average_speed);
    req->prop = toInt(VehicleProperty::GECKO_MCU_TRAVEL_AVERAGE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_dcc_sys_fail_staWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ipu_dcc_sys_fail_sta = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_dcc_sys_fail_sta");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ipu_dcc_sys_fail_sta = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ipu_dcc_sys_fail_staReq(ec_ipu_dcc_sys_fail_sta),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_dcc_sys_fail_staReq(int32_t ec_ipu_dcc_sys_fail_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_dcc_sys_fail_sta);
    req->prop = toInt(VehicleProperty::GECKO_IPU_DCC_SYSFAILSTA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_chrg_target_socWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_chrg_target_soc = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_chrg_target_soc");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_chrg_target_soc = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_chrg_target_socReq(ec_bms_chrg_target_soc),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_chrg_target_socReq(int32_t ec_bms_chrg_target_soc) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_chrg_target_soc);
    req->prop = toInt(VehicleProperty::GECKO_BMS_CHRGTARGETSOC);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bcm_brake_pedal_staWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bcm_brake_pedal_sta = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bcm_brake_pedal_sta");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bcm_brake_pedal_sta = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bcm_brake_pedal_staReq(ec_bcm_brake_pedal_sta),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bcm_brake_pedal_staReq(int32_t ec_bcm_brake_pedal_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_bcm_brake_pedal_sta);
    req->prop = toInt(VehicleProperty::GECKO_BCM_BRAKEPEDALSTA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::fcm_adas_drvr_reqWatcher(){
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t fcm_adas_drvr_req = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("fcm_adas_drvr_req");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        fcm_adas_drvr_req = mPropertyManager->getCProValue(mp);
        LOG(INFO)<<"fcm_adas_drvr_req "<<fcm_adas_drvr_req;
        mHal->onPropertyValue(*Create_fcm_adas_drvr_req(fcm_adas_drvr_req),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_fcm_adas_drvr_req(int32_t value)
{
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_FCM_ADASDRVRREQ);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
} 

void GarageModeServerSideHandlerImpl::fcm_elk_stsWatcher(){
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t fcm_elk_sts = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("fcm_elk_sts");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        fcm_elk_sts = mPropertyManager->getCProValue(mp);
        LOG(INFO)<<"fcm_elk_sts "<<fcm_elk_sts;
        mHal->onPropertyValue(*Create_fcm_elk_sts(fcm_elk_sts),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_fcm_elk_sts(int32_t value)
{
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_FCM_ELKSTS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
} 

void GarageModeServerSideHandlerImpl::fcm_slifs_spd_limWatcher(){
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t fcm_slifs_spd_lim = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("fcm_slifs_spd_lim");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        fcm_slifs_spd_lim = mPropertyManager->getCProValue(mp);
        LOG(INFO)<<"fcm_slifs_spd_lim "<<fcm_slifs_spd_lim;
        mHal->onPropertyValue(*Create_fcm_slifs_spd_lim(fcm_slifs_spd_lim),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_fcm_slifs_spd_lim(int32_t value)
{
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_FCM_SLIFSPDLIM);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
} 

void GarageModeServerSideHandlerImpl::fcm_aeb_statusWatcher(){
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t fcm_aeb_status = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("fcm_aeb_status");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        fcm_aeb_status = mPropertyManager->getCProValue(mp);
        LOG(INFO)<<"fcm_aeb_status "<<fcm_aeb_status;
        mHal->onPropertyValue(*Create_fcm_aeb_status(fcm_aeb_status),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_fcm_aeb_status(int32_t value)
{
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_FCM_AEB_STATUS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
} 

void GarageModeServerSideHandlerImpl::fcm_aeb_statsadsusWatcher(){
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t fcm_aeb_statsadsus = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("fcm_aeb_statsadsus");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        fcm_aeb_statsadsus = mPropertyManager->getCProValue(mp);
        LOG(INFO)<<"fcm_aeb_statsadsus "<<fcm_aeb_statsadsus;
        mHal->onPropertyValue(*Create_fcm_aeb_statsadsus(fcm_aeb_statsadsus),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_fcm_aeb_statsadsus(int32_t value)
{
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_FCM_AEB_STATSADSUS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
} 

void GarageModeServerSideHandlerImpl::hu_dowenaswtWatcher(){
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t hu_dowenaswt = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("hu_dowenaswt");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        hu_dowenaswt = mPropertyManager->getCProValue(mp);
        LOG(INFO)<<"hu_dowenaswt "<<hu_dowenaswt;
        mHal->onPropertyValue(*Create_hu_dowenaswt(hu_dowenaswt),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_hu_dowenaswt(int32_t value)
{
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_HU_DOWENASWT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
} 

    
    
void GarageModeServerSideHandlerImpl::sc_fcm_acc_take_over_reqWatcher(){
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t sc_fcm_acc_take_over_req = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("sc_fcm_acc_take_over_req");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        sc_fcm_acc_take_over_req = mPropertyManager->getCProValue(mp);
        LOG(INFO)<<"sc_fcm_acc_take_over_req "<<sc_fcm_acc_take_over_req;
        mHal->onPropertyValue(*Create_sc_fcm_acc_take_over_reqWatcher(sc_fcm_acc_take_over_req),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_sc_fcm_acc_take_over_reqWatcher(int32_t value)
     {
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_FCM_ACCTAKEOVERREQ);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
} 

void GarageModeServerSideHandlerImpl::fcm_tjatakeoverreqWatcher(){
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t fcm_tjatakeoverreq = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("fcm_tjatakeoverreq");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        fcm_tjatakeoverreq = mPropertyManager->getCProValue(mp);
        LOG(INFO)<<"fcm_tjatakeoverreq "<<fcm_tjatakeoverreq;
        mHal->onPropertyValue(*Create_fcm_tjatakeoverreqWatcher(fcm_tjatakeoverreq),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_fcm_tjatakeoverreqWatcher(int32_t value)
     {
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_FCM_TJATAKEOVERREQ);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
} 

void GarageModeServerSideHandlerImpl::bc_fcm_aeb_recreqWatcher(){
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t bc_fcm_aeb_recreq = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_aeb_recreq");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        bc_fcm_aeb_recreq = mPropertyManager->getCProValue(mp);
        LOG(INFO)<<"bc_fcm_aeb_recreq "<<bc_fcm_aeb_recreq;
        mHal->onPropertyValue(*Create_bc_fcm_aeb_recreqWatcher(bc_fcm_aeb_recreq),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_aeb_recreqWatcher(int32_t value)
     {
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_FCM_AEBRECREQ);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
} 

void GarageModeServerSideHandlerImpl::hu_hma_enable_swWatcher(){
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t hu_hma_enable_sw = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("hu_hma_enable_sw");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        hu_hma_enable_sw = mPropertyManager->getCProValue(mp);
        LOG(INFO)<<"hu_hma_enable_sw "<<hu_hma_enable_sw;
        mHal->onPropertyValue(*Create_hu_hma_enable_swWatcher(hu_hma_enable_sw),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_hu_hma_enable_swWatcher(int32_t value)
     {
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_HU_HMA_ENABLESW);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
} 

void GarageModeServerSideHandlerImpl::hu_ica_enable_sw_tWatcher(){
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t hu_ica_enable_sw_t = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("hu_ica_enable_sw_t");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        hu_ica_enable_sw_t = mPropertyManager->getCProValue(mp);
        LOG(INFO)<<"hu_ica_enable_sw_t "<<hu_ica_enable_sw_t;
        mHal->onPropertyValue(*Create_hu_ica_enable_sw_tWatcher(hu_ica_enable_sw_t),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_hu_ica_enable_sw_tWatcher(int32_t value)
     {
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_HU_ICAENASWT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
} 

void GarageModeServerSideHandlerImpl::hu_ica_avd_truck_setWatcher(){
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t hu_ica_avd_truck_set = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("hu_ica_avd_truck_set");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        hu_ica_avd_truck_set = mPropertyManager->getCProValue(mp);
        LOG(INFO)<<"hu_ica_avd_truck_set "<<hu_ica_avd_truck_set;
        mHal->onPropertyValue(*Create_hu_ica_avd_truck_setWatcher(hu_ica_avd_truck_set),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_hu_ica_avd_truck_setWatcher(int32_t value)
     {
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_HU_ICAAVDTRUCKSET);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
} 

void GarageModeServerSideHandlerImpl::hu_ldw_alert_method_swWatcher(){
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t hu_ldw_alert_method_sw = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("hu_ldw_alert_method_sw");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        hu_ldw_alert_method_sw = mPropertyManager->getCProValue(mp);
        LOG(INFO)<<"hu_ldw_alert_method_sw "<<hu_ldw_alert_method_sw;
        mHal->onPropertyValue(*Create_hu_ldw_alert_method_swWatcher(hu_ldw_alert_method_sw),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_hu_ldw_alert_method_swWatcher(int32_t value)
     {
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_HU_LDW_ALERTMETHODSW);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
} 

void GarageModeServerSideHandlerImpl::hu_lka_enable_swWatcher(){
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t hu_lka_enable_sw = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("hu_lka_enable_sw");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        hu_lka_enable_sw = mPropertyManager->getCProValue(mp);
        LOG(INFO)<<"hu_lka_enable_sw "<<hu_lka_enable_sw;
        mHal->onPropertyValue(*Create_hu_lka_enable_swWatcher(hu_lka_enable_sw),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_hu_lka_enable_swWatcher(int32_t value)
     {
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_HU_LKA_ENABLESW);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
} 

void GarageModeServerSideHandlerImpl::hu_elk_enb_swWatcher(){
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t hu_elk_enb_sw = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("hu_elk_enb_sw");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        hu_elk_enb_sw = mPropertyManager->getCProValue(mp);
        LOG(INFO)<<"hu_elk_enb_sw "<<hu_elk_enb_sw;
        mHal->onPropertyValue(*Create_hu_elk_enb_swWatcher(hu_elk_enb_sw),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_hu_elk_enb_swWatcher(int32_t value)
     {
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_HU_ELKENBSW);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
} 
     
void GarageModeServerSideHandlerImpl::hu_fcw_enable_swWatcher(){
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t hu_fcw_enable_sw = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("hu_fcw_enable_sw");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        hu_fcw_enable_sw = mPropertyManager->getCProValue(mp);
        LOG(INFO)<<"hu_fcw_enable_sw "<<hu_fcw_enable_sw;
        mHal->onPropertyValue(*Create_hu_fcw_enable_swWatcher(hu_fcw_enable_sw),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_hu_fcw_enable_swWatcher(int32_t value)
     {
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_HU_FCW_ENABLESW);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
} 

void GarageModeServerSideHandlerImpl::hu_abe_enable_swWatcher(){
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t hu_abe_enable_sw = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("hu_abe_enable_sw");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        hu_abe_enable_sw = mPropertyManager->getCProValue(mp);
        LOG(INFO)<<"hu_abe_enable_sw "<<hu_abe_enable_sw;
        mHal->onPropertyValue(*Create_hu_abe_enable_swWatcher(hu_abe_enable_sw),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_hu_abe_enable_swWatcher(int32_t value)
     {
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_HU_AEB_ENABLESW);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
} 

void GarageModeServerSideHandlerImpl::hu_bsd_enable_swWatcher(){
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t hu_bsd_enable_sw = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("hu_bsd_enable_sw");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        hu_bsd_enable_sw = mPropertyManager->getCProValue(mp);
        LOG(INFO)<<"hu_bsd_enable_sw "<<hu_bsd_enable_sw;
        mHal->onPropertyValue(*Create_hu_bsd_enable_swWatcher(hu_bsd_enable_sw),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_hu_bsd_enable_swWatcher(int32_t value)
     {
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_HU_BSD_ENABLESW);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
} 

void GarageModeServerSideHandlerImpl::hu_rcw_enable_swWatcher(){
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t hu_rcw_enable_sw = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("hu_rcw_enable_sw");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        hu_rcw_enable_sw = mPropertyManager->getCProValue(mp);
        LOG(INFO)<<"hu_rcw_enable_sw "<<hu_rcw_enable_sw;
        mHal->onPropertyValue(*Create_hu_rcw_enable_swWatcher(hu_rcw_enable_sw),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_hu_rcw_enable_swWatcher(int32_t value)
     {
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_HU_RCW_ENABLESW);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
} 

void GarageModeServerSideHandlerImpl::hu_rcta_enable_swWatcher(){
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t hu_rcta_enable_sw = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("hu_rcta_enable_sw");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        hu_rcta_enable_sw = mPropertyManager->getCProValue(mp);
        LOG(INFO)<<"hu_rcta_enable_sw "<<hu_rcta_enable_sw;
        mHal->onPropertyValue(*Create_hu_rcta_enable_swWatcher(hu_rcta_enable_sw),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_hu_rcta_enable_swWatcher(int32_t value)
     {
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_HU_RCTA_ENABLESW);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
} 

void GarageModeServerSideHandlerImpl::hu_slif_enableswWatcher(){
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t hu_slif_enablesw = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("hu_slif_enablesw");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        hu_slif_enablesw = mPropertyManager->getCProValue(mp);
        LOG(INFO)<<"hu_slif_enablesw "<<hu_slif_enablesw;
        mHal->onPropertyValue(*Create_hu_slif_enableswWatcher(hu_slif_enablesw),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_hu_slif_enableswWatcher(int32_t value)
     {
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_HU_SLIF_ENABLESW);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
} 

void GarageModeServerSideHandlerImpl::hu_slwf_enableswWatcher(){
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t hu_slwf_enablesw = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("hu_slwf_enablesw");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        hu_slwf_enablesw = mPropertyManager->getCProValue(mp);
        LOG(INFO)<<"hu_slwf_enablesw "<<hu_slwf_enablesw;
        mHal->onPropertyValue(*Create_hu_slwf_enableswWatcher(hu_slwf_enablesw),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_hu_slwf_enableswWatcher(int32_t value)
{
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_HU_SLWF_ENABLESW);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
} 

void GarageModeServerSideHandlerImpl::hu_navi_country_codeWatcher(){
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t hu_navi_country_code = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("hu_navi_country_code");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        hu_navi_country_code = mPropertyManager->getCProValue(mp);
        LOG(INFO)<<"hu_navi_country_code "<<hu_navi_country_code;
        mHal->onPropertyValue(*Create_hu_navi_country_codeWatcher(hu_navi_country_code),true);
    }
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_hu_navi_country_codeWatcher(int32_t value)
{
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_HU_NAVICOUNTRYCODE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
} 

void GarageModeServerSideHandlerImpl::bc_bcm_avalueble_key_in_carWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t bc_bcm_avalueble_key_in_car = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_avalueble_key_in_car");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        bc_bcm_avalueble_key_in_car = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_bc_bcm_avalueble_key_in_carReq(bc_bcm_avalueble_key_in_car),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_avalueble_key_in_carReq(int32_t bc_bcm_avalueble_key_in_car) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_avalueble_key_in_car);
    req->prop = toInt(VehicleProperty::GECKO_BCM_AVALUEBLEKEYINCAR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_sys_fail_staWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_vcu_sys_fail_sta = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_sys_fail_sta");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_vcu_sys_fail_sta = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_vcu_sys_fail_staReq(ec_vcu_sys_fail_sta),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_sys_fail_staReq(int32_t ec_vcu_sys_fail_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_sys_fail_sta);
    req->prop = toInt(VehicleProperty::GECKO_VCU_SYSFAILSTA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ccu_remt_steer_whl_heat_fbWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ccu_remt_steer_whl_heat_fb = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccu_remt_steer_whl_heat_fb");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ccu_remt_steer_whl_heat_fb = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ccu_remt_steer_whl_heat_fbReq(ec_ccu_remt_steer_whl_heat_fb),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccu_remt_steer_whl_heat_fbReq(int32_t ec_ccu_remt_steer_whl_heat_fb) {
    auto req = mValueObjectPool->obtainInt32(ec_ccu_remt_steer_whl_heat_fb);
    req->prop = toInt(VehicleProperty::GECKO_CCU_REMTSTEERWHLHEATFB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ccu_remt_power_ctrl_fbWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ccu_remt_power_ctrl_fb = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccu_remt_power_ctrl_fb");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ccu_remt_power_ctrl_fb = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ccu_remt_power_ctrl_fbReq(ec_ccu_remt_power_ctrl_fb),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccu_remt_power_ctrl_fbReq(int32_t ec_ccu_remt_power_ctrl_fb) {
    auto req = mValueObjectPool->obtainInt32(ec_ccu_remt_power_ctrl_fb);
    req->prop = toInt(VehicleProperty::GECKO_CCU_REMTPOWERCTRLFB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ccu_remt_mai_dr_seat_heat_fbWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ccu_remt_mai_dr_seat_heat_fb = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccu_remt_mai_dr_seat_heat_fb");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ccu_remt_mai_dr_seat_heat_fb = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ccu_remt_mai_dr_seat_heat_fbReq(ec_ccu_remt_mai_dr_seat_heat_fb),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccu_remt_mai_dr_seat_heat_fbReq(int32_t ec_ccu_remt_mai_dr_seat_heat_fb) {
    auto req = mValueObjectPool->obtainInt32(ec_ccu_remt_mai_dr_seat_heat_fb);
    req->prop = toInt(VehicleProperty::GECKO_CCU_REMTMAIDRSEATHEATFB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}


void GarageModeServerSideHandlerImpl::bc_pp_sensor_fault_sts_rlWatcher()
{
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t bc_pp_sensor_fault_sts_rl = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("bc_pp_sensor_fault_sts_rl");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        bc_pp_sensor_fault_sts_rl = mPropertyManager->getCProValue(mp);
        LOG(INFO)<<"bc_pp_sensor_fault_sts_rl "<<bc_pp_sensor_fault_sts_rl;
        mHal->onPropertyValue(*Create_bc_pp_sensor_fault_sts_rlReq(bc_pp_sensor_fault_sts_rl),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_pp_sensor_fault_sts_rlReq(int32_t value)
     {
        auto req = mValueObjectPool->obtainInt32(value);
        req->prop = toInt(VehicleProperty::GECKO_PP_SENSOR_FAULT_STS_RL);
        req->areaId = 0;
        req->timestamp = elapsedRealtimeNano();
        req->status = VehiclePropertyStatus::AVAILABLE;
        return req;
    }

void GarageModeServerSideHandlerImpl::bc_pp_sensor_fault_sts_rlmWatcher()
{
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t bc_pp_sensor_fault_sts_rlm = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("bc_pp_sensor_fault_sts_rlm");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        bc_pp_sensor_fault_sts_rlm = mPropertyManager->getCProValue(mp);
        LOG(INFO)<<"bc_pp_sensor_fault_sts_rlm "<<bc_pp_sensor_fault_sts_rlm;
        mHal->onPropertyValue(*Create_bc_pp_sensor_fault_sts_rlmReq(bc_pp_sensor_fault_sts_rlm),true);
    }
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_pp_sensor_fault_sts_rlmReq(int32_t value)
    {
        auto req = mValueObjectPool->obtainInt32(value);
        req->prop = toInt(VehicleProperty::GECKO_PP_SENSOR_FAULT_STS_RLM);
        req->areaId = 0;
        req->timestamp = elapsedRealtimeNano();
        req->status = VehiclePropertyStatus::AVAILABLE;
        return req;
    }

void GarageModeServerSideHandlerImpl::bc_pp_sensor_fault_sts_rrmWatcher()
{
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t bc_pp_sensor_fault_sts_rrm = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("bc_pp_sensor_fault_sts_rrm");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        bc_pp_sensor_fault_sts_rrm = mPropertyManager->getCProValue(mp);
        LOG(INFO)<<"bc_pp_sensor_fault_sts_rrm "<<bc_pp_sensor_fault_sts_rrm;
        mHal->onPropertyValue(*Create_bc_pp_sensor_fault_sts_rrmReq(bc_pp_sensor_fault_sts_rrm),true);
    }
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_pp_sensor_fault_sts_rrmReq(int32_t value)
    {
        auto req = mValueObjectPool->obtainInt32(value);
        req->prop = toInt(VehicleProperty::GECKO_PP_SENSOR_FAULT_STS_RRM);
        req->areaId = 0;
        req->timestamp = elapsedRealtimeNano();
        req->status = VehiclePropertyStatus::AVAILABLE;
        return req;
    }

void GarageModeServerSideHandlerImpl::bc_pp_sensor_fault_sts_rrWatcher()
{
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t bc_pp_sensor_fault_sts_rr = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("bc_pp_sensor_fault_sts_rr");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        bc_pp_sensor_fault_sts_rr = mPropertyManager->getCProValue(mp);
        LOG(INFO)<<"bc_pp_sensor_fault_sts_rr "<<bc_pp_sensor_fault_sts_rr;
        mHal->onPropertyValue(*Create_bc_pp_sensor_fault_sts_rrReq(bc_pp_sensor_fault_sts_rr),true);
    }
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_pp_sensor_fault_sts_rrReq(int32_t value)
    {
        auto req = mValueObjectPool->obtainInt32(value);
        req->prop = toInt(VehicleProperty::GECKO_PP_SENSOR_FAULT_STS_RR);
        req->areaId = 0;
        req->timestamp = elapsedRealtimeNano();
        req->status = VehiclePropertyStatus::AVAILABLE;
        return req;
    }

void GarageModeServerSideHandlerImpl::bc_pp_rl_distWatcher()
{
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t bc_pp_rl_dist = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("bc_pp_rl_dist");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        bc_pp_rl_dist = mPropertyManager->getCProValue(mp);
        LOG(INFO)<<"bc_pp_rl_dist "<<bc_pp_rl_dist;
        mHal->onPropertyValue(*Create_bc_pp_rl_distReq(bc_pp_rl_dist),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_pp_rl_distReq(int32_t value)
    {
        auto req = mValueObjectPool->obtainInt32(value);
        req->prop = toInt(VehicleProperty::GECKO_PP_RLDIST);
        req->areaId = 0;
        req->timestamp = elapsedRealtimeNano();
        req->status = VehiclePropertyStatus::AVAILABLE;
        return req;
    }

void GarageModeServerSideHandlerImpl::bc_pp_rlm_distWatcher()
{
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t bc_pp_rlm_dist = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("bc_pp_rlm_dist");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        bc_pp_rlm_dist = mPropertyManager->getCProValue(mp);
        LOG(INFO)<<"bc_pp_rlm_dist "<<bc_pp_rlm_dist;
        mHal->onPropertyValue(*Create_bc_pp_rlm_distReq(bc_pp_rlm_dist),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_pp_rlm_distReq(int32_t value)
    {
        auto req = mValueObjectPool->obtainInt32(value);
        req->prop = toInt(VehicleProperty::GECKO_PP_RLMDIST);
        req->areaId = 0;
        req->timestamp = elapsedRealtimeNano();
        req->status = VehiclePropertyStatus::AVAILABLE;
        return req;
    }

void GarageModeServerSideHandlerImpl::bc_pp_rrm_distWatcher()
{
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t bc_pp_rrm_dist = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("bc_pp_rrm_dist");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        bc_pp_rrm_dist = mPropertyManager->getCProValue(mp);
        LOG(INFO)<<"bc_pp_rrm_dist "<<bc_pp_rrm_dist;
        mHal->onPropertyValue(*Create_bc_pp_rrm_distReq(bc_pp_rrm_dist),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_pp_rrm_distReq(int32_t value)
    {
        auto req = mValueObjectPool->obtainInt32(value);
        req->prop = toInt(VehicleProperty::GECKO_PP_RRMDIST);
        req->areaId = 0;
        req->timestamp = elapsedRealtimeNano();
        req->status = VehiclePropertyStatus::AVAILABLE;
        return req;
    }

void GarageModeServerSideHandlerImpl::bc_pp_rr_distWatcher()
{
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t bc_pp_rr_dist = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("bc_pp_rr_dist");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        bc_pp_rr_dist = mPropertyManager->getCProValue(mp);
        LOG(INFO)<<"bc_pp_rr_dist "<<bc_pp_rr_dist;
        mHal->onPropertyValue(*Create_bc_pp_rr_distReq(bc_pp_rr_dist),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_pp_rr_distReq(int32_t value)
    {
        auto req = mValueObjectPool->obtainInt32(value);
        req->prop = toInt(VehicleProperty::GECKO_PP_RRDIST);
        req->areaId = 0;
        req->timestamp = elapsedRealtimeNano();
        req->status = VehiclePropertyStatus::AVAILABLE;
        return req;
    }

void GarageModeServerSideHandlerImpl::bc_pp_sdwfsr_distWatcher()
{
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t bc_pp_sdwfsr_dist = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("bc_pp_sdwfsr_dist");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        bc_pp_sdwfsr_dist = mPropertyManager->getCProValue(mp);
        LOG(INFO)<<"bc_pp_sdwfsr_dist "<<bc_pp_sdwfsr_dist;
        mHal->onPropertyValue(*Create_bc_pp_sdwfsr_distReq(bc_pp_sdwfsr_dist),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_pp_sdwfsr_distReq(int32_t value)
     {
        auto req = mValueObjectPool->obtainInt32(value);
        req->prop = toInt(VehicleProperty::GECKO_PP_SDWFSRDIST);
        req->areaId = 0;
        req->timestamp = elapsedRealtimeNano();
        req->status = VehiclePropertyStatus::AVAILABLE;
        return req;
    }

void GarageModeServerSideHandlerImpl::bc_pp_sdwrsl_distWatcher()
{
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t bc_pp_sdwrsl_dist = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("bc_pp_sdwrsl_dist");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        bc_pp_sdwrsl_dist = mPropertyManager->getCProValue(mp);
        LOG(INFO)<<"bc_pp_sdwrsl_dist "<<bc_pp_sdwrsl_dist;
        mHal->onPropertyValue(*Create_bc_pp_sdwrsl_distReq(bc_pp_sdwrsl_dist),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_pp_sdwrsl_distReq(int32_t value)
    {
        auto req = mValueObjectPool->obtainInt32(value);
        req->prop = toInt(VehicleProperty::GECKO_PP_SDWRSL_DIST);
        req->areaId = 0;
        req->timestamp = elapsedRealtimeNano();
        req->status = VehiclePropertyStatus::AVAILABLE;
        return req;
    }

void GarageModeServerSideHandlerImpl::bc_pp_sdwrsl_mid_distWatcher()
{
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t bc_pp_sdwrsl_mid_dist = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("bc_pp_sdwrsl_mid_dist");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        bc_pp_sdwrsl_mid_dist = mPropertyManager->getCProValue(mp);
        LOG(INFO)<<"bc_pp_sdwrsl_mid_dist "<<bc_pp_sdwrsl_mid_dist;

        mHal->onPropertyValue(*Create_bc_pp_sdwrsl_mid_distReq(bc_pp_sdwrsl_mid_dist),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_pp_sdwrsl_mid_distReq(int32_t value)
    {
        auto req = mValueObjectPool->obtainInt32(value);
        req->prop = toInt(VehicleProperty::GECKO_PP_SDWRSL_MID_DIST);
        req->areaId = 0;
        req->timestamp = elapsedRealtimeNano();
        req->status = VehiclePropertyStatus::AVAILABLE;
        return req;
    }

void GarageModeServerSideHandlerImpl::bc_pp_sdwrsr_mid_distWatcher()
{
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t bc_pp_sdwrsr_mid_dist = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("bc_pp_sdwrsr_mid_dist");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        bc_pp_sdwrsr_mid_dist = mPropertyManager->getCProValue(mp);
        LOG(INFO)<<"bc_pp_sdwrsr_mid_dist "<<bc_pp_sdwrsr_mid_dist;
        mHal->onPropertyValue(*Create_bc_pp_sdwrsr_mid_distReq(bc_pp_sdwrsr_mid_dist),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_pp_sdwrsr_mid_distReq(int32_t value)
    {
        auto req = mValueObjectPool->obtainInt32(value);
        req->prop = toInt(VehicleProperty::GECKO_PP_SDWRSR_MID_DIST);
        req->areaId = 0;
        req->timestamp = elapsedRealtimeNano();
        req->status = VehiclePropertyStatus::AVAILABLE;
        return req;
    }

static bool isHexadecimalNumber(const std::string& hexStr) {
    for (char c : hexStr) {
        if (!((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'))) {
            return false;
        }
    }
    return true;
}

void GarageModeServerSideHandlerImpl::bc_fm_auto_seek_resWatcher()
{
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    std::string bc_fm_auto_seek_res;
    ConfigDBC* mp = mPropertyManager->findCProperty("bc_fm_auto_seek_res");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        bc_fm_auto_seek_res = mPropertyManager->getCProStrValue(mp);
        LOG(INFO)<<"bc_fm_auto_seek_res "<<bc_fm_auto_seek_res;
        std::vector<int16_t> value{0};
        std::string flag = bc_fm_auto_seek_res.substr(0, 2);
        if(!isHexadecimalNumber(bc_fm_auto_seek_res))
        {
            ALOGE(" bc_fm_auto_seek_resWatcher msg:%s is err", bc_fm_auto_seek_res.c_str());
            return;
        }
        size_t count = std::stoi(flag,  nullptr, 16);
        if (count > 0) {
            value.clear();
            std::string newStr = bc_fm_auto_seek_res.substr(2);
            size_t start = 0;
            size_t length = 4;
            while (start < newStr.size()) {
                std::string channel = newStr.substr(start, length);
                value.push_back(std::stoi(channel, nullptr, 16));
                start += length;
                ALOGI(" bc_fm_auto_seek_resWatcher channel:%d", std::stoi(channel, nullptr, 16));
            }
        }
        mHal->onPropertyValue(*Create_bc_fm_auto_seek_resWatcherReq(value),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fm_auto_seek_resWatcherReq(std::vector<int16_t> value)
{
    auto req = mValueObjectPool->obtain(VehiclePropertyType::INT32_VEC, value.size());
    req->prop = toInt(VehicleProperty::GECKO_FM_AUTO_SEEK_RES);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    for(int i = 0; i < (int)value.size(); i++){
      req->value.int32Values[i] = value[i];
    }
    return req;
}
void GarageModeServerSideHandlerImpl::fm_searchWatcher()
{
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    std::string fm_search;
    ConfigDBC* mp = mPropertyManager->findCProperty("fm_search");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        fm_search = mPropertyManager->getCProStrValue(mp);
        LOG(INFO)<<"fm_search "<<fm_search;
        if(fm_search.length() < 6){
          ALOGE("fm_search length error %s", fm_search.c_str());
          return;
        }
        std::string flag = fm_search.substr(0, 2);
        std::string data("0000");
        if(flag == "01"){
          //seek搜索有台应答
          data.clear();
          data = fm_search.substr(2);
        }
        int32_t value = std::stoi(data, nullptr, 16);
        LOG(INFO)<<"fm_search:"<<fm_search<<" value:"<<value<< " data:"<<data;
        mHal->onPropertyValue(*Create_fm_searchWatcherReq(value),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_fm_searchWatcherReq(int32_t value)
    {
        auto req = mValueObjectPool->obtainInt32(value);
        req->prop = toInt(VehicleProperty::GECKO_CCM_FM_SEARCH);
        req->areaId = 0;
        req->timestamp = elapsedRealtimeNano();
        req->status = VehiclePropertyStatus::AVAILABLE;
        return req;
    }


void GarageModeServerSideHandlerImpl::fm_volumeWatcher()
{
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t fm_volume = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("fm_volume");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        fm_volume = mPropertyManager->getCProValue(mp);
        LOG(INFO)<<"fm_volume "<<fm_volume;
        mHal->onPropertyValue(*Create_fm_volumeWatcherReq(fm_volume),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_fm_volumeWatcherReq(int32_t value)
{
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_CCM_FM_VOLUME);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_err_amountWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_vcu_err_amount = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_err_amount");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_vcu_err_amount = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_vcu_err_amountReq(ec_vcu_err_amount),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_err_amountReq(int32_t ec_vcu_err_amount) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_err_amount);
    req->prop = toInt(VehicleProperty::GECKO_VCU_ERRAMOUNT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_err_bitWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_vcu_err_bit = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_err_bit");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_vcu_err_bit = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_vcu_err_bitReq(ec_vcu_err_bit),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_err_bitReq(int32_t ec_vcu_err_bit) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_err_bit);
    req->prop = toInt(VehicleProperty::GECKO_VCU_ERRBIT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_carriage_light_staWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t bc_bcm_carriage_light_sta = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_carriage_light_sta");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        bc_bcm_carriage_light_sta = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_bc_bcm_carriage_light_staReq(bc_bcm_carriage_light_sta),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_carriage_light_staReq(int32_t bc_bcm_carriage_light_sta) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_carriage_light_sta);
    req->prop = toInt(VehicleProperty::GECKO_BCM_CARRIAGELIGHTSTA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_eps_steer_wheel_angleWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_eps_steer_wheel_angle = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_eps_steer_wheel_angle");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_eps_steer_wheel_angle = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_eps_steer_wheel_angleReq(ec_eps_steer_wheel_angle),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_eps_steer_wheel_angleReq(int32_t ec_eps_steer_wheel_angle) {
    auto req = mValueObjectPool->obtainInt32(ec_eps_steer_wheel_angle);
    req->prop = toInt(VehicleProperty::GECKO_EPS_STEER_WHEEL_ANGLE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_eps_steer_wheel_angle_validWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_eps_steer_wheel_angle_valid = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_eps_steer_wheel_angle_valid");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_eps_steer_wheel_angle_valid = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_eps_steer_wheel_angle_validReq(ec_eps_steer_wheel_angle_valid),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_eps_steer_wheel_angle_validReq(int32_t ec_eps_steer_wheel_angle_valid) {
    auto req = mValueObjectPool->obtainInt32(ec_eps_steer_wheel_angle_valid);
    req->prop = toInt(VehicleProperty::GECKO_EPS_STEER_WHEEL_ANGLE_VALID);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_eps_rot_speedWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_eps_rot_speed = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_eps_rot_speed");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_eps_rot_speed = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_eps_rot_speedReq(ec_eps_rot_speed),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_eps_rot_speedReq(int32_t ec_eps_rot_speed) {
    auto req = mValueObjectPool->obtainInt32(ec_eps_rot_speed);
    req->prop = toInt(VehicleProperty::GECKO_EPS_ROT_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_eps_steer_wheel_angle_failureWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_eps_steer_wheel_angle_failure = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_eps_steer_wheel_angle_failure");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_eps_steer_wheel_angle_failure = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_eps_steer_wheel_angle_failureReq(ec_eps_steer_wheel_angle_failure),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_eps_steer_wheel_angle_failureReq(int32_t ec_eps_steer_wheel_angle_failure) {
    auto req = mValueObjectPool->obtainInt32(ec_eps_steer_wheel_angle_failure);
    req->prop = toInt(VehicleProperty::GECKO_EPS_STEER_WHEEL_ANGLE_FAILURE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_eps_electric_power_staWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_eps_electric_power_sta = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_eps_electric_power_sta");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_eps_electric_power_sta = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_eps_electric_power_staReq(ec_eps_electric_power_sta),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_eps_electric_power_staReq(int32_t ec_eps_electric_power_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_eps_electric_power_sta);
    req->prop = toInt(VehicleProperty::GECKO_EPS_ELECTRIC_POWER_STA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_eps_steer_wheel_angle_calibratedWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_eps_steer_wheel_angle_calibrated = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_eps_steer_wheel_angle_calibrated");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_eps_steer_wheel_angle_calibrated = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_eps_steer_wheel_angle_calibratedReq(ec_eps_steer_wheel_angle_calibrated),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_eps_steer_wheel_angle_calibratedReq(int32_t ec_eps_steer_wheel_angle_calibrated) {
    auto req = mValueObjectPool->obtainInt32(ec_eps_steer_wheel_angle_calibrated);
    req->prop = toInt(VehicleProperty::GECKO_EPS_STEER_WHEEL_ANGLE_CALIBRATED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_eps_mot_tqWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_eps_mot_tq = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_eps_mot_tq");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_eps_mot_tq = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_eps_mot_tqReq(ec_eps_mot_tq),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_eps_mot_tqReq(int32_t ec_eps_mot_tq) {
    auto req = mValueObjectPool->obtainInt32(ec_eps_mot_tq);
    req->prop = toInt(VehicleProperty::GECKO_EPS_MOT_TQ);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

	
void GarageModeServerSideHandlerImpl::ec_fcm_lgt_fct_actv_flgWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_fcm_lgt_fct_actv_flg = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_lgt_fct_actv_flg");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_fcm_lgt_fct_actv_flg = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_fcm_lgt_fct_actv_flgReq(ec_fcm_lgt_fct_actv_flg),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_lgt_fct_actv_flgReq(int32_t ec_fcm_lgt_fct_actv_flg) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_lgt_fct_actv_flg);
    req->prop = toInt(VehicleProperty::GECKO_FCM_LGT_FCTACTV_FLG);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_fcm_eps_set_steer_whl_aglWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_fcm_eps_set_steer_whl_agl = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_eps_set_steer_whl_agl");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_fcm_eps_set_steer_whl_agl = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_fcm_eps_set_steer_whl_aglReq(ec_fcm_eps_set_steer_whl_agl),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_eps_set_steer_whl_aglReq(int32_t ec_fcm_eps_set_steer_whl_agl) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_eps_set_steer_whl_agl);
    req->prop = toInt(VehicleProperty::GECKO_FCM_EPS_SET_STEERWHLAGL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_fcm_steer_tq_req_activeWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_fcm_steer_tq_req_active = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_steer_tq_req_active");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_fcm_steer_tq_req_active = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_fcm_steer_tq_req_activeReq(ec_fcm_steer_tq_req_active),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_steer_tq_req_activeReq(int32_t ec_fcm_steer_tq_req_active) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_steer_tq_req_active);
    req->prop = toInt(VehicleProperty::GECKO_FCM_STEER_TQREQ_ACTIVE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_fcm_eps_ctrl_reqWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_fcm_eps_ctrl_req = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_eps_ctrl_req");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_fcm_eps_ctrl_req = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_fcm_eps_ctrl_reqReq(ec_fcm_eps_ctrl_req),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_eps_ctrl_reqReq(int32_t ec_fcm_eps_ctrl_req) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_eps_ctrl_req);
    req->prop = toInt(VehicleProperty::GECKO_FCM_EPS_CTRL_REQ);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_fcm_drvr_warn_vib_reqWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_fcm_drvr_warn_vib_req = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_drvr_warn_vib_req");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_fcm_drvr_warn_vib_req = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_fcm_drvr_warn_vib_reqReq(ec_fcm_drvr_warn_vib_req),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_drvr_warn_vib_reqReq(int32_t ec_fcm_drvr_warn_vib_req) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_drvr_warn_vib_req);
    req->prop = toInt(VehicleProperty::GECKO_FCM_DRVR_WARNVIB_REQ);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_fcm_daeps_mode_reqWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_fcm_daeps_mode_req = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_daeps_mode_req");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_fcm_daeps_mode_req = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_fcm_daeps_mode_reqReq(ec_fcm_daeps_mode_req),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_daeps_mode_reqReq(int32_t ec_fcm_daeps_mode_req) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_daeps_mode_req);
    req->prop = toInt(VehicleProperty::GECKO_FCM_DAEPS_MODE_REQ);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_fcm_act_drv_asst_stsWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_fcm_act_drv_asst_sts = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_act_drv_asst_sts");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_fcm_act_drv_asst_sts = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_fcm_act_drv_asst_stsReq(ec_fcm_act_drv_asst_sts),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_act_drv_asst_stsReq(int32_t ec_fcm_act_drv_asst_sts) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_act_drv_asst_sts);
    req->prop = toInt(VehicleProperty::GECKO_FCM_ACTDRV_ASSTSTS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_fcm_overtake_ass_sys_stsWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_fcm_overtake_ass_sys_sts = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_overtake_ass_sys_sts");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_fcm_overtake_ass_sys_sts = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_fcm_overtake_ass_sys_stsReq(ec_fcm_overtake_ass_sys_sts),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_overtake_ass_sys_stsReq(int32_t ec_fcm_overtake_ass_sys_sts) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_overtake_ass_sys_sts);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OVERTAKE_ASSSYSSTS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_fcm_turn_lamp_reqWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_fcm_turn_lamp_req = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_turn_lamp_req");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_fcm_turn_lamp_req = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_fcm_turn_lamp_reqReq(ec_fcm_turn_lamp_req),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_turn_lamp_reqReq(int32_t ec_fcm_turn_lamp_req) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_turn_lamp_req);
    req->prop = toInt(VehicleProperty::GECKO_FCM_TURN_LAMP_REQ);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_tjaica_supps_abortnWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_fcm_tjaica_supps_abortn = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_tjaica_supps_abortn");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_fcm_tjaica_supps_abortn = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_fcm_tjaica_supps_abortnReq(ec_fcm_tjaica_supps_abortn),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_tjaica_supps_abortnReq(int32_t ec_fcm_tjaica_supps_abortn) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_tjaica_supps_abortn);
    req->prop = toInt(VehicleProperty::GECKO_FCM_TJAICA_SUPPS_ABORTN);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_fcm_lka_torq_fact_reqWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    float ec_fcm_lka_torq_fact_req = 0.0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_lka_torq_fact_req");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_fcm_lka_torq_fact_req = getActualFloatValue(mPropertyManager->getCProValue(mp), 0.01, 0);
        mHal->onPropertyValue(*Create_ec_fcm_lka_torq_fact_reqReq(ec_fcm_lka_torq_fact_req),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_lka_torq_fact_reqReq(float ec_fcm_lka_torq_fact_req) {
    auto req = mValueObjectPool->obtainFloat(ec_fcm_lka_torq_fact_req);
    req->prop = toInt(VehicleProperty::GECKO_FCM_LKATORQ_FACT_REQ);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_fcm_hma_supps_abortnWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_fcm_hma_supps_abortn = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_hma_supps_abortn");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_fcm_hma_supps_abortn = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_fcm_hma_supps_abortnReq(ec_fcm_hma_supps_abortn),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_hma_supps_abortnReq(int32_t ec_fcm_hma_supps_abortn) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_hma_supps_abortn);
    req->prop = toInt(VehicleProperty::GECKO_FCM_HMA_SUPPS_ABORTN);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_fcm_lkaldw_supps_abortnWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_fcm_lkaldw_supps_abortn = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_lkaldw_supps_abortn");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_fcm_lkaldw_supps_abortn = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_fcm_lkaldw_supps_abortnReq(ec_fcm_lkaldw_supps_abortn),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_lkaldw_supps_abortnReq(int32_t ec_fcm_lkaldw_supps_abortn) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_lkaldw_supps_abortn);
    req->prop = toInt(VehicleProperty::GECKO_FCM_LKALDW_SUPPS_ABORTN);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_fcm_flt_stsWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_fcm_flt_sts = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_flt_sts");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_fcm_flt_sts = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_fcm_flt_stsReq(ec_fcm_flt_sts),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_flt_stsReq(int32_t ec_fcm_flt_sts) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_flt_sts);
    req->prop = toInt(VehicleProperty::GECKO_FCM_FLTSTS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_fcm_elk_supps_abortnWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_fcm_elk_supps_abortn = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_elk_supps_abortn");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_fcm_elk_supps_abortn = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_fcm_elk_supps_abortnReq(ec_fcm_elk_supps_abortn),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_elk_supps_abortnReq(int32_t ec_fcm_elk_supps_abortn) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_elk_supps_abortn);
    req->prop = toInt(VehicleProperty::GECKO_FCM_ELK_SUPPS_ABORTN);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_fcm_acc_whl_tq_req_valWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_fcm_acc_whl_tq_req_val = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_acc_whl_tq_req_val");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_fcm_acc_whl_tq_req_val = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_fcm_acc_whl_tq_req_valReq(ec_fcm_acc_whl_tq_req_val),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_acc_whl_tq_req_valReq(int32_t ec_fcm_acc_whl_tq_req_val) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_acc_whl_tq_req_val);
    req->prop = toInt(VehicleProperty::GECKO_FCM_ACCWHL_TQREQVAL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}


void GarageModeServerSideHandlerImpl::ec_fcm_acc_whl_tq_req_actvWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_fcm_acc_whl_tq_req_actv = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_acc_whl_tq_req_actv");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_fcm_acc_whl_tq_req_actv = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_fcm_acc_whl_tq_req_actvReq(ec_fcm_acc_whl_tq_req_actv),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_acc_whl_tq_req_actvReq(int32_t ec_fcm_acc_whl_tq_req_actv) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_acc_whl_tq_req_actv);
    req->prop = toInt(VehicleProperty::GECKO_FCM_ACCWHL_TQREQACTV);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_fcm_acc_whl_deceWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    float ec_fcm_acc_whl_dece = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_acc_whl_dece");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_fcm_acc_whl_dece = getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.05, -9.5);
        mHal->onPropertyValue(*Create_ec_fcm_acc_whl_deceReq(ec_fcm_acc_whl_dece),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_acc_whl_deceReq(float ec_fcm_acc_whl_dece) {
    auto req = mValueObjectPool->obtainFloat(ec_fcm_acc_whl_dece);
    req->prop = toInt(VehicleProperty::GECKO_FCM_ACCWHL_DECE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_fcm_acc_tar_accrnWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    float ec_fcm_acc_tar_accrn = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_acc_tar_accrn");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_fcm_acc_tar_accrn = getActualFloatValue(mPropertyManager->getCProValue(mp), 0.05, -5);
        mHal->onPropertyValue(*Create_ec_fcm_acc_tar_accrnReq(ec_fcm_acc_tar_accrn),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_acc_tar_accrnReq(float ec_fcm_acc_tar_accrn) {
    auto req = mValueObjectPool->obtainFloat(ec_fcm_acc_tar_accrn);
    req->prop = toInt(VehicleProperty::GECKO_FCM_ACCTAR_ACCRN);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_fcm_acc_supp_abortWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_fcm_acc_supp_abort = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_acc_supp_abort");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_fcm_acc_supp_abort = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_fcm_acc_supp_abortReq(ec_fcm_acc_supp_abort),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_acc_supp_abortReq(int32_t ec_fcm_acc_supp_abort) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_acc_supp_abort);
    req->prop = toInt(VehicleProperty::GECKO_FCM_ACCSUPP_ABORT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_fcm_acc_tar_accrn_req_actvWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_fcm_acc_tar_accrn_req_actv = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_acc_tar_accrn_req_actv");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_fcm_acc_tar_accrn_req_actv = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_fcm_acc_tar_accrn_req_actvReq(ec_fcm_acc_tar_accrn_req_actv),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_acc_tar_accrn_req_actvReq(int32_t ec_fcm_acc_tar_accrn_req_actv) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_acc_tar_accrn_req_actv);
    req->prop = toInt(VehicleProperty::GECKO_FCM_ACCTAR_ACCRN_REQACTV);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_fcm_epb_req_vWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_fcm_epb_req_v = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_epb_req_v");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_fcm_epb_req_v = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_fcm_epb_req_vReq(ec_fcm_epb_req_v),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_epb_req_vReq(int32_t ec_fcm_epb_req_v) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_epb_req_v);
    req->prop = toInt(VehicleProperty::GECKO_FCM_EPB_REQV);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_fcm_epb_reqWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_fcm_epb_req = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_epb_req");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_fcm_epb_req = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_fcm_epb_reqReq(ec_fcm_epb_req),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_epb_reqReq(int32_t ec_fcm_epb_req) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_epb_req);
    req->prop = toInt(VehicleProperty::GECKO_FCM_EPB_REQ);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_fcm_acc_shutdown_modeWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_fcm_acc_shutdown_mode = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_acc_shutdown_mode");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_fcm_acc_shutdown_mode = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_fcm_acc_shutdown_modeReq(ec_fcm_acc_shutdown_mode),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_acc_shutdown_modeReq(int32_t ec_fcm_acc_shutdown_mode) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_acc_shutdown_mode);
    req->prop = toInt(VehicleProperty::GECKO_FCM_ACC_SHUTDOWN_MODE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_ahd_obj_idWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_fcm_ahd_obj_id = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_ahd_obj_id");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_fcm_ahd_obj_id = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_fcm_ahd_obj_idReq(ec_fcm_ahd_obj_id),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_ahd_obj_idReq(int32_t ec_fcm_ahd_obj_id) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_ahd_obj_id);
    req->prop = toInt(VehicleProperty::GECKO_FCM_AHDOBJID);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_fcm_acc_tgt_axWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    float ec_fcm_acc_tgt_ax = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_acc_tgt_ax");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_fcm_acc_tgt_ax = getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.05, -9.5);
        mHal->onPropertyValue(*Create_ec_fcm_acc_tgt_axReq(ec_fcm_acc_tgt_ax),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_acc_tgt_axReq(float ec_fcm_acc_tgt_ax) {
    auto req = mValueObjectPool->obtainFloat(ec_fcm_acc_tgt_ax);
    req->prop = toInt(VehicleProperty::GECKO_FCM_ACC_TGTAX);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_fcm_aeb_tgt_axWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_fcm_aeb_tgt_ax = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_aeb_tgt_ax");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_fcm_aeb_tgt_ax = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_fcm_aeb_tgt_axReq(ec_fcm_aeb_tgt_ax),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_aeb_tgt_axReq(int32_t ec_fcm_aeb_tgt_ax) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_aeb_tgt_ax);
    req->prop = toInt(VehicleProperty::GECKO_FCM_AEB_TGTAX);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_fcm_acc_modeWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_fcm_acc_mode = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_acc_mode");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_fcm_acc_mode = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_fcm_acc_modeReq(ec_fcm_acc_mode),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_acc_modeReq(int32_t ec_fcm_acc_mode) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_acc_mode);
    req->prop = toInt(VehicleProperty::GECKO_FCM_ACC_MODE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_fcm_acc_req_standstillWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_fcm_acc_req_standstill = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_acc_req_standstill");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_fcm_acc_req_standstill = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_fcm_acc_req_standstillReq(ec_fcm_acc_req_standstill),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_acc_req_standstillReq(int32_t ec_fcm_acc_req_standstill) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_acc_req_standstill);
    req->prop = toInt(VehicleProperty::GECKO_FCM_ACC_REQSTANDSTILL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_fcm_aeb_reqWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_fcm_aeb_req = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_aeb_req");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_fcm_aeb_req = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_fcm_aeb_reqReq(ec_fcm_aeb_req),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_aeb_reqReq(int32_t ec_fcm_aeb_req) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_aeb_req);
    req->prop = toInt(VehicleProperty::GECKO_FCM_AEB_REQ);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_fcm_aeb_standstill_stsWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_fcm_aeb_standstill_sts = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_aeb_standstill_sts");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_fcm_aeb_standstill_sts = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_fcm_aeb_standstill_stsReq(ec_fcm_aeb_standstill_sts),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_aeb_standstill_stsReq(int32_t ec_fcm_aeb_standstill_sts) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_aeb_standstill_sts);
    req->prop = toInt(VehicleProperty::GECKO_FCM_AEB_STANDSTILLSTS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_fcm_aeb_standstill_sts_vWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_fcm_aeb_standstill_sts_v = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_aeb_standstill_sts_v");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_fcm_aeb_standstill_sts_v = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_fcm_aeb_standstill_sts_vReq(ec_fcm_aeb_standstill_sts_v),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_aeb_standstill_sts_vReq(int32_t ec_fcm_aeb_standstill_sts_v) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_aeb_standstill_sts_v);
    req->prop = toInt(VehicleProperty::GECKO_FCM_AEB_STANDSTILLSTSV);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_fcm_aba_levelWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_fcm_aba_level = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_aba_level");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_fcm_aba_level = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_fcm_aba_levelReq(ec_fcm_aba_level),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_aba_levelReq(int32_t ec_fcm_aba_level) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_aba_level);
    req->prop = toInt(VehicleProperty::GECKO_FCM_ABA_LEVEL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_fcm_awb_levelWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_fcm_awb_level = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_awb_level");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_fcm_awb_level = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_fcm_awb_levelReq(ec_fcm_awb_level),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_awb_levelReq(int32_t ec_fcm_awb_level) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_awb_level);
    req->prop = toInt(VehicleProperty::GECKO_FCM_AWB_LEVEL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_fcm_aba_reqWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_fcm_aba_req = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_aba_req");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_fcm_aba_req = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_fcm_aba_reqReq(ec_fcm_aba_req),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_aba_reqReq(int32_t ec_fcm_aba_req) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_aba_req);
    req->prop = toInt(VehicleProperty::GECKO_FCM_ABA_REQ);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_fcm_eba_reqWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_fcm_eba_req = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_eba_req");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_fcm_eba_req = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_fcm_eba_reqReq(ec_fcm_eba_req),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_eba_reqReq(int32_t ec_fcm_eba_req) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_eba_req);
    req->prop = toInt(VehicleProperty::GECKO_FCM_EBA_REQ);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_fcm_awb_reqWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_fcm_awb_req = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_awb_req");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_fcm_awb_req = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_fcm_awb_reqReq(ec_fcm_awb_req),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_awb_reqReq(int32_t ec_fcm_awb_req) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_awb_req);
    req->prop = toInt(VehicleProperty::GECKO_FCM_AWB_REQ);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_fcm_abp_reqWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_fcm_abp_req = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_abp_req");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_fcm_abp_req = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_fcm_abp_reqReq(ec_fcm_abp_req),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_abp_reqReq(int32_t ec_fcm_abp_req) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_abp_req);
    req->prop = toInt(VehicleProperty::GECKO_FCM_ABP_REQ);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_fcm_acc_tgt_ax_reqWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_fcm_acc_tgt_ax_req = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_acc_tgt_ax_req");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_fcm_acc_tgt_ax_req = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_fcm_acc_tgt_ax_reqReq(ec_fcm_acc_tgt_ax_req),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_acc_tgt_ax_reqReq(int32_t ec_fcm_acc_tgt_ax_req) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_acc_tgt_ax_req);
    req->prop = toInt(VehicleProperty::GECKO_FCM_ACC_TGTAX_REQ);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_fcm_crv_decel_staWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_fcm_crv_decel_sta = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_crv_decel_sta");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_fcm_crv_decel_sta = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_fcm_crv_decel_staReq(ec_fcm_crv_decel_sta),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_crv_decel_staReq(int32_t ec_fcm_crv_decel_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_crv_decel_sta);
    req->prop = toInt(VehicleProperty::GECKO_FCM_CRV_DECEL_STA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_fcm_acc_req_drive_offWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_fcm_acc_req_drive_off = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_acc_req_drive_off");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_fcm_acc_req_drive_off = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_fcm_acc_req_drive_offReq(ec_fcm_acc_req_drive_off),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_acc_req_drive_offReq(int32_t ec_fcm_acc_req_drive_off) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_acc_req_drive_off);
    req->prop = toInt(VehicleProperty::GECKO_FCM_ACC_REQDRIVEOFF);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::mc_scs_frnt_wipr_swt_stWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t mc_scs_frnt_wipr_swt_st = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("mc_scs_frnt_wipr_swt_st");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        mc_scs_frnt_wipr_swt_st = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_mc_scs_frnt_wipr_swt_stReq(mc_scs_frnt_wipr_swt_st),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_mc_scs_frnt_wipr_swt_stReq(int32_t mc_scs_frnt_wipr_swt_st) {
    auto req = mValueObjectPool->obtainInt32(mc_scs_frnt_wipr_swt_st);
    req->prop = toInt(VehicleProperty::GECKO_SCS_FRNTWIPR_SWTST);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::mc_scs_low_beam_swt_stWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t mc_scs_low_beam_swt_st = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("mc_scs_low_beam_swt_st");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        mc_scs_low_beam_swt_st = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_mc_scs_low_beam_swt_stReq(mc_scs_low_beam_swt_st),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_mc_scs_low_beam_swt_stReq(int32_t mc_scs_low_beam_swt_st) {
    auto req = mValueObjectPool->obtainInt32(mc_scs_low_beam_swt_st);
    req->prop = toInt(VehicleProperty::GECKO_SCS_LOWBEAM_SWTST);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::mc_scs_hi_beam_swt_stWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t mc_scs_hi_beam_swt_st = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("mc_scs_hi_beam_swt_st");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        mc_scs_hi_beam_swt_st = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_mc_scs_hi_beam_swt_stReq(mc_scs_hi_beam_swt_st),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_mc_scs_hi_beam_swt_stReq(int32_t mc_scs_hi_beam_swt_st) {
    auto req = mValueObjectPool->obtainInt32(mc_scs_hi_beam_swt_st);
    req->prop = toInt(VehicleProperty::GECKO_SCS_HIBEAM_SWTST);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::mc_scs_over_veh_beam_swt_stWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t mc_scs_over_veh_beam_swt_st = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("mc_scs_over_veh_beam_swt_st");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        mc_scs_over_veh_beam_swt_st = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_mc_scs_over_veh_beam_swt_stReq(mc_scs_over_veh_beam_swt_st),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_mc_scs_over_veh_beam_swt_stReq(int32_t mc_scs_over_veh_beam_swt_st) {
    auto req = mValueObjectPool->obtainInt32(mc_scs_over_veh_beam_swt_st);
    req->prop = toInt(VehicleProperty::GECKO_SCS_OVERVEHBEAM_SWTST);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::mc_scs_lamp_auto_stWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t mc_scs_lamp_auto_st = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("mc_scs_lamp_auto_st");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        mc_scs_lamp_auto_st = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_mc_scs_lamp_auto_stReq(mc_scs_lamp_auto_st),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_mc_scs_lamp_auto_stReq(int32_t mc_scs_lamp_auto_st) {
    auto req = mValueObjectPool->obtainInt32(mc_scs_lamp_auto_st);
    req->prop = toInt(VehicleProperty::GECKO_SCS_LAMP_AUTO_ST);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::mc_scs_le_turn_lmp_swt_stWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t mc_scs_le_turn_lmp_swt_st = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("mc_scs_le_turn_lmp_swt_st");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        mc_scs_le_turn_lmp_swt_st = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_mc_scs_le_turn_lmp_swt_stReq(mc_scs_le_turn_lmp_swt_st),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_mc_scs_le_turn_lmp_swt_stReq(int32_t mc_scs_le_turn_lmp_swt_st) {
    auto req = mValueObjectPool->obtainInt32(mc_scs_le_turn_lmp_swt_st);
    req->prop = toInt(VehicleProperty::GECKO_SCS_LETURNLMP_SWTST);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::mc_scs_ri_turn_lmp_swt_stWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t mc_scs_ri_turn_lmp_swt_st = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("mc_scs_ri_turn_lmp_swt_st");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        mc_scs_ri_turn_lmp_swt_st = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_mc_scs_ri_turn_lmp_swt_stReq(mc_scs_ri_turn_lmp_swt_st),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_mc_scs_ri_turn_lmp_swt_stReq(int32_t mc_scs_ri_turn_lmp_swt_st) {
    auto req = mValueObjectPool->obtainInt32(mc_scs_ri_turn_lmp_swt_st);
    req->prop = toInt(VehicleProperty::GECKO_SCS_RITURNLMP_SWTST);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_hv_bat_cell_temp_aveWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_hv_bat_cell_temp_ave = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_hv_bat_cell_temp_ave");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_hv_bat_cell_temp_ave = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_hv_bat_cell_temp_aveReq(ec_bms_hv_bat_cell_temp_ave),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_hv_bat_cell_temp_aveReq(int32_t ec_bms_hv_bat_cell_temp_ave) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_hv_bat_cell_temp_ave);
    req->prop = toInt(VehicleProperty::GECKO_BMS_HV_BAT_CELL_TEMP_AVE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_dcs_actl_chrg_currentWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_dcs_actl_chrg_current = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_dcs_actl_chrg_current");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_dcs_actl_chrg_current = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_dcs_actl_chrg_currentReq(ec_bms_dcs_actl_chrg_current),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_dcs_actl_chrg_currentReq(int32_t ec_bms_dcs_actl_chrg_current) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_dcs_actl_chrg_current);
    req->prop = toInt(VehicleProperty::GECKO_BMS_DCS_ACTL_CHRG_CURRENT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_scs_gear_shift_lever_pst_reqWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_scs_gear_shift_lever_pst_req = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_scs_gear_shift_lever_pst_req");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_scs_gear_shift_lever_pst_req = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_scs_gear_shift_lever_pst_reqReq(ec_scs_gear_shift_lever_pst_req),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_scs_gear_shift_lever_pst_reqReq(int32_t ec_scs_gear_shift_lever_pst_req) {
    auto req = mValueObjectPool->obtainInt32(ec_scs_gear_shift_lever_pst_req);
    req->prop = toInt(VehicleProperty::GECKO_SCS_GEAR_SHIFT_LEVER_PST_REQ);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_ac_chrg_atcl_staWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_ac_chrg_atcl_sta = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_ac_chrg_atcl_sta");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_ac_chrg_atcl_sta = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_ac_chrg_atcl_staReq(ec_bms_ac_chrg_atcl_sta),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_ac_chrg_atcl_staReq(int32_t ec_bms_ac_chrg_atcl_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_ac_chrg_atcl_sta);
    req->prop = toInt(VehicleProperty::GECKO_BMS_AC_CHRG_ATCL_STA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_outlet_coolant_actl_tempWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_outlet_coolant_actl_temp = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_outlet_coolant_actl_temp");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_outlet_coolant_actl_temp = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_outlet_coolant_actl_tempReq(ec_bms_outlet_coolant_actl_temp),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_outlet_coolant_actl_tempReq(int32_t ec_bms_outlet_coolant_actl_temp) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_outlet_coolant_actl_temp);
    req->prop = toInt(VehicleProperty::GECKO_BMS_OUTLET_COOLANT_ACTL_TEMP);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_outlet_coolant_actl_temp_validWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_outlet_coolant_actl_temp_valid = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_outlet_coolant_actl_temp_valid");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_outlet_coolant_actl_temp_valid = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_outlet_coolant_actl_temp_validReq(ec_bms_outlet_coolant_actl_temp_valid),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_outlet_coolant_actl_temp_validReq(int32_t ec_bms_outlet_coolant_actl_temp_valid) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_outlet_coolant_actl_temp_valid);
    req->prop = toInt(VehicleProperty::GECKO_BMS_OUTLET_COOLANT_ACTL_TEMP_VALID);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_inlet_coolant_actl_tempWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_inlet_coolant_actl_temp = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_inlet_coolant_actl_temp");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_inlet_coolant_actl_temp = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_inlet_coolant_actl_tempReq(ec_bms_inlet_coolant_actl_temp),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_inlet_coolant_actl_tempReq(int32_t ec_bms_inlet_coolant_actl_temp) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_inlet_coolant_actl_temp);
    req->prop = toInt(VehicleProperty::GECKO_BMS_INLET_COOLANT_ACTL_TEMP);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_inlet_coolant_actl_temp_validWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_inlet_coolant_actl_temp_valid = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_inlet_coolant_actl_temp_valid");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_inlet_coolant_actl_temp_valid = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_inlet_coolant_actl_temp_validReq(ec_bms_inlet_coolant_actl_temp_valid),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_inlet_coolant_actl_temp_validReq(int32_t ec_bms_inlet_coolant_actl_temp_valid) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_inlet_coolant_actl_temp_valid);
    req->prop = toInt(VehicleProperty::GECKO_BMS_INLET_COOLANT_ACTL_TEMP_VALID);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_max_chrg_voltage_acWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_max_chrg_voltage_ac = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_max_chrg_voltage_ac");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_max_chrg_voltage_ac = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_max_chrg_voltage_acReq(ec_bms_max_chrg_voltage_ac),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_max_chrg_voltage_acReq(int32_t ec_bms_max_chrg_voltage_ac) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_max_chrg_voltage_ac);
    req->prop = toInt(VehicleProperty::GECKO_BMS_MAX_CHRG_VOLTAGE_AC);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_max_chrg_current_acWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_max_chrg_current_ac = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_max_chrg_current_ac");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_max_chrg_current_ac = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_max_chrg_current_acReq(ec_bms_max_chrg_current_ac),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_max_chrg_current_acReq(int32_t ec_bms_max_chrg_current_ac) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_max_chrg_current_ac);
    req->prop = toInt(VehicleProperty::GECKO_BMS_MAX_CHRG_CURRENT_AC);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_bat_sohWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_bat_soh = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_bat_soh");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_bat_soh = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_bat_sohReq(ec_bms_bat_soh),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_bat_sohReq(int32_t ec_bms_bat_soh) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_bat_soh);
    req->prop = toInt(VehicleProperty::GECKO_BMS_BAT_SOH);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_temp_max_dc_charge_socketWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_temp_max_dc_charge_socket = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_temp_max_dc_charge_socket");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_temp_max_dc_charge_socket = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_temp_max_dc_charge_socketReq(ec_bms_temp_max_dc_charge_socket),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_temp_max_dc_charge_socketReq(int32_t ec_bms_temp_max_dc_charge_socket) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_temp_max_dc_charge_socket);
    req->prop = toInt(VehicleProperty::GECKO_BMS_TEMP_MAX_DC_CHARGE_SOCKET);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_pcb_temp_maxWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_pcb_temp_max = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_pcb_temp_max");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_pcb_temp_max = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_pcb_temp_maxReq(ec_bms_pcb_temp_max),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_pcb_temp_maxReq(int32_t ec_bms_pcb_temp_max) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_pcb_temp_max);
    req->prop = toInt(VehicleProperty::GECKO_BMS_PCB_TEMP_MAX);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_max_allow_chrg_cur_dcWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_max_allow_chrg_cur_dc = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_max_allow_chrg_cur_dc");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_max_allow_chrg_cur_dc = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_max_allow_chrg_cur_dcReq(ec_bms_max_allow_chrg_cur_dc),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_max_allow_chrg_cur_dcReq(int32_t ec_bms_max_allow_chrg_cur_dc) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_max_allow_chrg_cur_dc);
    req->prop = toInt(VehicleProperty::GECKO_BMS_MAX_ALLOW_CHRG_CUR_DC);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_max_allow_chrg_vol_dcWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_max_allow_chrg_vol_dc = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_max_allow_chrg_vol_dc");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_max_allow_chrg_vol_dc = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_max_allow_chrg_vol_dcReq(ec_bms_max_allow_chrg_vol_dc),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_max_allow_chrg_vol_dcReq(int32_t ec_bms_max_allow_chrg_vol_dc) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_max_allow_chrg_vol_dc);
    req->prop = toInt(VehicleProperty::GECKO_BMS_MAX_ALLOW_CHRG_VOL_DC);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_electronic_lock_ctrlWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_electronic_lock_ctrl = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_electronic_lock_ctrl");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_electronic_lock_ctrl = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_electronic_lock_ctrlReq(ec_bms_electronic_lock_ctrl),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_electronic_lock_ctrlReq(int32_t ec_bms_electronic_lock_ctrl) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_electronic_lock_ctrl);
    req->prop = toInt(VehicleProperty::GECKO_BMS_ELECTRONIC_LOCK_CTRL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_electronic_lock_stateWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_electronic_lock_state = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_electronic_lock_state");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_electronic_lock_state = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_electronic_lock_stateReq(ec_bms_electronic_lock_state),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_electronic_lock_stateReq(int32_t ec_bms_electronic_lock_state) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_electronic_lock_state);
    req->prop = toInt(VehicleProperty::GECKO_BMS_ELECTRONIC_LOCK_STATE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_contactor_state_dc_chargerWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_contactor_state_dc_charger = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_contactor_state_dc_charger");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_contactor_state_dc_charger = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_contactor_state_dc_chargerReq(ec_bms_contactor_state_dc_charger),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_contactor_state_dc_chargerReq(int32_t ec_bms_contactor_state_dc_charger) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_contactor_state_dc_charger);
    req->prop = toInt(VehicleProperty::GECKO_BMS_CONTACTOR_STATE_DC_CHARGER);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_dcs_charge_requestWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_dcs_charge_request = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_dcs_charge_request");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_dcs_charge_request = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_dcs_charge_requestReq(ec_bms_dcs_charge_request),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_dcs_charge_requestReq(int32_t ec_bms_dcs_charge_request) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_dcs_charge_request);
    req->prop = toInt(VehicleProperty::GECKO_BMS_DCS_CHARGE_REQUEST);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_dcs_chrg_a_plusWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_dcs_chrg_a_plus = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_dcs_chrg_a_plus");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_dcs_chrg_a_plus = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_dcs_chrg_a_plusReq(ec_bms_dcs_chrg_a_plus),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_dcs_chrg_a_plusReq(int32_t ec_bms_dcs_chrg_a_plus) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_dcs_chrg_a_plus);
    req->prop = toInt(VehicleProperty::GECKO_BMS_DCS_CHRG_A_PLUS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_run_stateWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_run_state = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_run_state");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_run_state = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_run_stateReq(ec_bms_run_state),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_run_stateReq(int32_t ec_bms_run_state) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_run_state);
    req->prop = toInt(VehicleProperty::GECKO_BMS_RUN_STATE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_contactor_state_negativeWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_contactor_state_negative = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_contactor_state_negative");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_contactor_state_negative = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_contactor_state_negativeReq(ec_bms_contactor_state_negative),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_contactor_state_negativeReq(int32_t ec_bms_contactor_state_negative) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_contactor_state_negative);
    req->prop = toInt(VehicleProperty::GECKO_BMS_CONTACTOR_STATE_NEGATIVE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_contactor_state_positiveWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_contactor_state_positive = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_contactor_state_positive");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_contactor_state_positive = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_contactor_state_positiveReq(ec_bms_contactor_state_positive),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_contactor_state_positiveReq(int32_t ec_bms_contactor_state_positive) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_contactor_state_positive);
    req->prop = toInt(VehicleProperty::GECKO_BMS_CONTACTOR_STATE_POSITIVE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_contactor_state_prechargeWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_contactor_state_precharge = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_contactor_state_precharge");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_contactor_state_precharge = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_contactor_state_prechargeReq(ec_bms_contactor_state_precharge),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_contactor_state_prechargeReq(int32_t ec_bms_contactor_state_precharge) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_contactor_state_precharge);
    req->prop = toInt(VehicleProperty::GECKO_BMS_CONTACTOR_STATE_PRECHARGE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_supply_voltage_statusWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_supply_voltage_status = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_supply_voltage_status");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_supply_voltage_status = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_supply_voltage_statusReq(ec_bms_supply_voltage_status),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_supply_voltage_statusReq(int32_t ec_bms_supply_voltage_status) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_supply_voltage_status);
    req->prop = toInt(VehicleProperty::GECKO_BMS_SUPPLY_VOLTAGE_STATUS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_emeshutdown_reqWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_emeshutdown_req = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_emeshutdown_req");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_emeshutdown_req = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_emeshutdown_reqReq(ec_bms_emeshutdown_req),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_emeshutdown_reqReq(int32_t ec_bms_emeshutdown_req) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_emeshutdown_req);
    req->prop = toInt(VehicleProperty::GECKO_BMS_EMESHUTDOWN_REQ);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_charge_interlock_staWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_charge_interlock_sta = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_charge_interlock_sta");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_charge_interlock_sta = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_charge_interlock_staReq(ec_bms_charge_interlock_sta),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_charge_interlock_staReq(int32_t ec_bms_charge_interlock_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_charge_interlock_sta);
    req->prop = toInt(VehicleProperty::GECKO_BMS_CHARGE_INTERLOCK_STA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_dis_charge_interlock_staWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_dis_charge_interlock_sta = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_dis_charge_interlock_sta");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_dis_charge_interlock_sta = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_dis_charge_interlock_staReq(ec_bms_dis_charge_interlock_sta),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_dis_charge_interlock_staReq(int32_t ec_bms_dis_charge_interlock_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_dis_charge_interlock_sta);
    req->prop = toInt(VehicleProperty::GECKO_BMS_DIS_CHARGE_INTERLOCK_STA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_batt_balance_staWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_batt_balance_sta = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_batt_balance_sta");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_batt_balance_sta = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_batt_balance_staReq(ec_bms_batt_balance_sta),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_batt_balance_staReq(int32_t ec_bms_batt_balance_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_batt_balance_sta);
    req->prop = toInt(VehicleProperty::GECKO_BMS_BATT_BALANCE_STA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_therm_runaway_snsr_fltWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_therm_runaway_snsr_flt = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_therm_runaway_snsr_flt");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_therm_runaway_snsr_flt = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_therm_runaway_snsr_fltReq(ec_bms_therm_runaway_snsr_flt),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_therm_runaway_snsr_fltReq(int32_t ec_bms_therm_runaway_snsr_flt) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_therm_runaway_snsr_flt);
    req->prop = toInt(VehicleProperty::GECKO_BMS_THERM_RUNAWAY_SNSR_FLT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_therm_runaway_vlv_stWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_therm_runaway_vlv_st = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_therm_runaway_vlv_st");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_therm_runaway_vlv_st = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_therm_runaway_vlv_stReq(ec_bms_therm_runaway_vlv_st),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_therm_runaway_vlv_stReq(int32_t ec_bms_therm_runaway_vlv_st) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_therm_runaway_vlv_st);
    req->prop = toInt(VehicleProperty::GECKO_BMS_THERM_RUNAWAY_VLV_ST);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_obc_uac_act_l1Watcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ipu_obc_uac_act_l1 = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_obc_uac_act_l1");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ipu_obc_uac_act_l1 = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ipu_obc_uac_act_l1Req(ec_ipu_obc_uac_act_l1),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_obc_uac_act_l1Req(int32_t ec_ipu_obc_uac_act_l1) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_obc_uac_act_l1);
    req->prop = toInt(VehicleProperty::GECKO_IPU_OBC_UAC_ACT_L1);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_obc_uac_act_l2Watcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ipu_obc_uac_act_l2 = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_obc_uac_act_l2");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ipu_obc_uac_act_l2 = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ipu_obc_uac_act_l2Req(ec_ipu_obc_uac_act_l2),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_obc_uac_act_l2Req(int32_t ec_ipu_obc_uac_act_l2) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_obc_uac_act_l2);
    req->prop = toInt(VehicleProperty::GECKO_IPU_OBC_UAC_ACT_L2);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_obc_uac_act_l3Watcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ipu_obc_uac_act_l3 = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_obc_uac_act_l3");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ipu_obc_uac_act_l3 = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ipu_obc_uac_act_l3Req(ec_ipu_obc_uac_act_l3),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_obc_uac_act_l3Req(int32_t ec_ipu_obc_uac_act_l3) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_obc_uac_act_l3);
    req->prop = toInt(VehicleProperty::GECKO_IPU_OBC_UAC_ACT_L3);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_obc_iac_act_l1Watcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ipu_obc_iac_act_l1 = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_obc_iac_act_l1");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ipu_obc_iac_act_l1 = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ipu_obc_iac_act_l1Req(ec_ipu_obc_iac_act_l1),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_obc_iac_act_l1Req(int32_t ec_ipu_obc_iac_act_l1) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_obc_iac_act_l1);
    req->prop = toInt(VehicleProperty::GECKO_IPU_OBC_IAC_ACT_L1);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_obc_iac_act_l2Watcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ipu_obc_iac_act_l2 = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_obc_iac_act_l2");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ipu_obc_iac_act_l2 = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ipu_obc_iac_act_l2Req(ec_ipu_obc_iac_act_l2),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_obc_iac_act_l2Req(int32_t ec_ipu_obc_iac_act_l2) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_obc_iac_act_l2);
    req->prop = toInt(VehicleProperty::GECKO_IPU_OBC_IAC_ACT_L2);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_obc_iac_act_l3Watcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ipu_obc_iac_act_l3 = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_obc_iac_act_l3");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ipu_obc_iac_act_l3 = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ipu_obc_iac_act_l3Req(ec_ipu_obc_iac_act_l3),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_obc_iac_act_l3Req(int32_t ec_ipu_obc_iac_act_l3) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_obc_iac_act_l3);
    req->prop = toInt(VehicleProperty::GECKO_IPU_OBC_IAC_ACT_L3);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_device_int_tempWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ipu_device_int_temp = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_device_int_temp");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ipu_device_int_temp = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ipu_device_int_tempReq(ec_ipu_device_int_temp),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_device_int_tempReq(int32_t ec_ipu_device_int_temp) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_device_int_temp);
    req->prop = toInt(VehicleProperty::GECKO_IPU_DEVICE_INT_TEMP);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_obc_temp_inletWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ipu_obc_temp_inlet = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_obc_temp_inlet");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ipu_obc_temp_inlet = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ipu_obc_temp_inletReq(ec_ipu_obc_temp_inlet),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_obc_temp_inletReq(int32_t ec_ipu_obc_temp_inlet) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_obc_temp_inlet);
    req->prop = toInt(VehicleProperty::GECKO_IPU_OBC_TEMP_INLET);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_obc_ac_max_pw_allowWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ipu_obc_ac_max_pw_allow = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_obc_ac_max_pw_allow");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ipu_obc_ac_max_pw_allow = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ipu_obc_ac_max_pw_allowReq(ec_ipu_obc_ac_max_pw_allow),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_obc_ac_max_pw_allowReq(int32_t ec_ipu_obc_ac_max_pw_allow) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_obc_ac_max_pw_allow);
    req->prop = toInt(VehicleProperty::GECKO_IPU_OBC_AC_MAX_PW_ALLOW);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_obc_inlet_electronic_lockWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ipu_obc_inlet_electronic_lock = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_obc_inlet_electronic_lock");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ipu_obc_inlet_electronic_lock = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ipu_obc_inlet_electronic_lockReq(ec_ipu_obc_inlet_electronic_lock),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_obc_inlet_electronic_lockReq(int32_t ec_ipu_obc_inlet_electronic_lock) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_obc_inlet_electronic_lock);
    req->prop = toInt(VehicleProperty::GECKO_IPU_OBC_INLET_ELECTRONIC_LOCK);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_obc_s2_stateWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ipu_obc_s2_state = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_obc_s2_state");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ipu_obc_s2_state = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ipu_obc_s2_stateReq(ec_ipu_obc_s2_state),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_obc_s2_stateReq(int32_t ec_ipu_obc_s2_state) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_obc_s2_state);
    req->prop = toInt(VehicleProperty::GECKO_IPU_OBC_S2_STATE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_obc_wake_up_modeWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ipu_obc_wake_up_mode = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_obc_wake_up_mode");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ipu_obc_wake_up_mode = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ipu_obc_wake_up_modeReq(ec_ipu_obc_wake_up_mode),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_obc_wake_up_modeReq(int32_t ec_ipu_obc_wake_up_mode) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_obc_wake_up_mode);
    req->prop = toInt(VehicleProperty::GECKO_IPU_OBC_WAKE_UP_MODE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_obc_voltage_ok_l1Watcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ipu_obc_voltage_ok_l1 = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_obc_voltage_ok_l1");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ipu_obc_voltage_ok_l1 = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ipu_obc_voltage_ok_l1Req(ec_ipu_obc_voltage_ok_l1),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_obc_voltage_ok_l1Req(int32_t ec_ipu_obc_voltage_ok_l1) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_obc_voltage_ok_l1);
    req->prop = toInt(VehicleProperty::GECKO_IPU_OBC_VOLTAGE_OK_L1);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_obc_voltage_ok_l2Watcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ipu_obc_voltage_ok_l2 = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_obc_voltage_ok_l2");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ipu_obc_voltage_ok_l2 = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ipu_obc_voltage_ok_l2Req(ec_ipu_obc_voltage_ok_l2),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_obc_voltage_ok_l2Req(int32_t ec_ipu_obc_voltage_ok_l2) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_obc_voltage_ok_l2);
    req->prop = toInt(VehicleProperty::GECKO_IPU_OBC_VOLTAGE_OK_L2);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_obc_voltage_ok_l3Watcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ipu_obc_voltage_ok_l3 = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_obc_voltage_ok_l3");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ipu_obc_voltage_ok_l3 = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ipu_obc_voltage_ok_l3Req(ec_ipu_obc_voltage_ok_l3),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_obc_voltage_ok_l3Req(int32_t ec_ipu_obc_voltage_ok_l3) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_obc_voltage_ok_l3);
    req->prop = toInt(VehicleProperty::GECKO_IPU_OBC_VOLTAGE_OK_L3);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_dcc_high_volt_actl_curWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ipu_dcc_high_volt_actl_cur = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_dcc_high_volt_actl_cur");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ipu_dcc_high_volt_actl_cur = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ipu_dcc_high_volt_actl_curReq(ec_ipu_dcc_high_volt_actl_cur),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_dcc_high_volt_actl_curReq(int32_t ec_ipu_dcc_high_volt_actl_cur) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_dcc_high_volt_actl_cur);
    req->prop = toInt(VehicleProperty::GECKO_IPU_DCC_HIGH_VOLT_ACTL_CUR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_dcc_high_volt_actl_volWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ipu_dcc_high_volt_actl_vol = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_dcc_high_volt_actl_vol");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ipu_dcc_high_volt_actl_vol = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ipu_dcc_high_volt_actl_volReq(ec_ipu_dcc_high_volt_actl_vol),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_dcc_high_volt_actl_volReq(int32_t ec_ipu_dcc_high_volt_actl_vol) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_dcc_high_volt_actl_vol);
    req->prop = toInt(VehicleProperty::GECKO_IPU_DCC_HIGH_VOLT_ACTL_VOL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_obc_hvdc_actl_curWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ipu_obc_hvdc_actl_cur = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_obc_hvdc_actl_cur");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ipu_obc_hvdc_actl_cur = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ipu_obc_hvdc_actl_curReq(ec_ipu_obc_hvdc_actl_cur),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_obc_hvdc_actl_curReq(int32_t ec_ipu_obc_hvdc_actl_cur) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_obc_hvdc_actl_cur);
    req->prop = toInt(VehicleProperty::GECKO_IPU_OBC_HVDC_ACTL_CUR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_obc_connect_main_staWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ipu_obc_connect_main_sta = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_obc_connect_main_sta");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ipu_obc_connect_main_sta = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ipu_obc_connect_main_staReq(ec_ipu_obc_connect_main_sta),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_obc_connect_main_staReq(int32_t ec_ipu_obc_connect_main_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_obc_connect_main_sta);
    req->prop = toInt(VehicleProperty::GECKO_IPU_OBC_CONNECT_MAIN_STA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_obc_requestWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ipu_obc_request = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_obc_request");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ipu_obc_request = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ipu_obc_requestReq(ec_ipu_obc_request),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_obc_requestReq(int32_t ec_ipu_obc_request) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_obc_request);
    req->prop = toInt(VehicleProperty::GECKO_IPU_OBC_REQUEST);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_obc_sys_fail_staWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ipu_obc_sys_fail_sta = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_obc_sys_fail_sta");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ipu_obc_sys_fail_sta = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ipu_obc_sys_fail_staReq(ec_ipu_obc_sys_fail_sta),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_obc_sys_fail_staReq(int32_t ec_ipu_obc_sys_fail_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_obc_sys_fail_sta);
    req->prop = toInt(VehicleProperty::GECKO_IPU_OBC_SYS_FAIL_STA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_obc_hvdc_actl_volWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ipu_obc_hvdc_actl_vol = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_obc_hvdc_actl_vol");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ipu_obc_hvdc_actl_vol = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ipu_obc_hvdc_actl_volReq(ec_ipu_obc_hvdc_actl_vol),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_obc_hvdc_actl_volReq(int32_t ec_ipu_obc_hvdc_actl_vol) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_obc_hvdc_actl_vol);
    req->prop = toInt(VehicleProperty::GECKO_IPU_OBC_HVDC_ACTL_VOL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_obc_errbitWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ipu_obc_errbit = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_obc_errbit");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ipu_obc_errbit = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ipu_obc_errbitReq(ec_ipu_obc_errbit),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_obc_errbitReq(int32_t ec_ipu_obc_errbit) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_obc_errbit);
    req->prop = toInt(VehicleProperty::GECKO_IPU_OBC_ERRBIT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_dcc_low_vol_actl_volWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ipu_dcc_low_vol_actl_vol = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_dcc_low_vol_actl_vol");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ipu_dcc_low_vol_actl_vol = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ipu_dcc_low_vol_actl_volReq(ec_ipu_dcc_low_vol_actl_vol),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_dcc_low_vol_actl_volReq(int32_t ec_ipu_dcc_low_vol_actl_vol) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_dcc_low_vol_actl_vol);
    req->prop = toInt(VehicleProperty::GECKO_IPU_DCC_LOW_VOL_ACTL_VOL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_dcc_low_vol_actl_curWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ipu_dcc_low_vol_actl_cur = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_dcc_low_vol_actl_cur");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ipu_dcc_low_vol_actl_cur = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ipu_dcc_low_vol_actl_curReq(ec_ipu_dcc_low_vol_actl_cur),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_dcc_low_vol_actl_curReq(int32_t ec_ipu_dcc_low_vol_actl_cur) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_dcc_low_vol_actl_cur);
    req->prop = toInt(VehicleProperty::GECKO_IPU_DCC_LOW_VOL_ACTL_CUR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_dcc_precharge_completeWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ipu_dcc_precharge_complete = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_dcc_precharge_complete");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ipu_dcc_precharge_complete = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ipu_dcc_precharge_completeReq(ec_ipu_dcc_precharge_complete),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_dcc_precharge_completeReq(int32_t ec_ipu_dcc_precharge_complete) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_dcc_precharge_complete);
    req->prop = toInt(VehicleProperty::GECKO_IPU_DCC_PRECHARGE_COMPLETE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_dcc_derating_oprt_staWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ipu_dcc_derating_oprt_sta = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_dcc_derating_oprt_sta");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ipu_dcc_derating_oprt_sta = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ipu_dcc_derating_oprt_staReq(ec_ipu_dcc_derating_oprt_sta),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_dcc_derating_oprt_staReq(int32_t ec_ipu_dcc_derating_oprt_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_dcc_derating_oprt_sta);
    req->prop = toInt(VehicleProperty::GECKO_IPU_DCC_DERATING_OPRT_STA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_hvil_fail_staWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ipu_hvil_fail_sta = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_hvil_fail_sta");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ipu_hvil_fail_sta = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ipu_hvil_fail_staReq(ec_ipu_hvil_fail_sta),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_hvil_fail_staReq(int32_t ec_ipu_hvil_fail_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_hvil_fail_sta);
    req->prop = toInt(VehicleProperty::GECKO_IPU_HVIL_FAIL_STA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_dcc_errbitWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ipu_dcc_errbit = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_dcc_errbit");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ipu_dcc_errbit = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ipu_dcc_errbitReq(ec_ipu_dcc_errbit),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_dcc_errbitReq(int32_t ec_ipu_dcc_errbit) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_dcc_errbit);
    req->prop = toInt(VehicleProperty::GECKO_IPU_DCC_ERRBIT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_obc_c_cor_cp_cnctd_stsWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ipu_obc_c_cor_cp_cnctd_sts = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_obc_c_cor_cp_cnctd_sts");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ipu_obc_c_cor_cp_cnctd_sts = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ipu_obc_c_cor_cp_cnctd_stsReq(ec_ipu_obc_c_cor_cp_cnctd_sts),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_obc_c_cor_cp_cnctd_stsReq(int32_t ec_ipu_obc_c_cor_cp_cnctd_sts) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_obc_c_cor_cp_cnctd_sts);
    req->prop = toInt(VehicleProperty::GECKO_IPU_OBC_C_COR_CP_CNCTD_STS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_obc_cp_dutyWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ipu_obc_cp_duty = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_obc_cp_duty");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ipu_obc_cp_duty = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ipu_obc_cp_dutyReq(ec_ipu_obc_cp_duty),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_obc_cp_dutyReq(int32_t ec_ipu_obc_cp_duty) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_obc_cp_duty);
    req->prop = toInt(VehicleProperty::GECKO_IPU_OBC_CP_DUTY);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_obc_cp_max_voltWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ipu_obc_cp_max_volt = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_obc_cp_max_volt");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ipu_obc_cp_max_volt = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ipu_obc_cp_max_voltReq(ec_ipu_obc_cp_max_volt),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_obc_cp_max_voltReq(int32_t ec_ipu_obc_cp_max_volt) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_obc_cp_max_volt);
    req->prop = toInt(VehicleProperty::GECKO_IPU_OBC_CP_MAX_VOLT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_obc_process_codeWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ipu_obc_process_code = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_obc_process_code");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ipu_obc_process_code = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ipu_obc_process_codeReq(ec_ipu_obc_process_code),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_obc_process_codeReq(int32_t ec_ipu_obc_process_code) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_obc_process_code);
    req->prop = toInt(VehicleProperty::GECKO_IPU_OBC_PROCESS_CODE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_obc_cc_resisdentWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ipu_obc_cc_resisdent = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_obc_cc_resisdent");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ipu_obc_cc_resisdent = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ipu_obc_cc_resisdentReq(ec_ipu_obc_cc_resisdent),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_obc_cc_resisdentReq(int32_t ec_ipu_obc_cc_resisdent) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_obc_cc_resisdent);
    req->prop = toInt(VehicleProperty::GECKO_IPU_OBC_CC_RESISDENT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_eps_torsion_bar_torqueWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_eps_torsion_bar_torque = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_eps_torsion_bar_torque");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_eps_torsion_bar_torque = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_eps_torsion_bar_torqueReq(ec_eps_torsion_bar_torque),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_eps_torsion_bar_torqueReq(int32_t ec_eps_torsion_bar_torque) {
    auto req = mValueObjectPool->obtainInt32(ec_eps_torsion_bar_torque);
    req->prop = toInt(VehicleProperty::GECKO_EPS_TORSION_BAR_TORQUE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_eps_torsion_bar_torque_dirWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_eps_torsion_bar_torque_dir = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_eps_torsion_bar_torque_dir");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_eps_torsion_bar_torque_dir = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_eps_torsion_bar_torque_dirReq(ec_eps_torsion_bar_torque_dir),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_eps_torsion_bar_torque_dirReq(int32_t ec_eps_torsion_bar_torque_dir) {
    auto req = mValueObjectPool->obtainInt32(ec_eps_torsion_bar_torque_dir);
    req->prop = toInt(VehicleProperty::GECKO_EPS_TORSION_BAR_TORQUE_DIR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_eps_torsion_bar_torque_validWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_eps_torsion_bar_torque_valid = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_eps_torsion_bar_torque_valid");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_eps_torsion_bar_torque_valid = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_eps_torsion_bar_torque_validReq(ec_eps_torsion_bar_torque_valid),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_eps_torsion_bar_torque_validReq(int32_t ec_eps_torsion_bar_torque_valid) {
    auto req = mValueObjectPool->obtainInt32(ec_eps_torsion_bar_torque_valid);
    req->prop = toInt(VehicleProperty::GECKO_EPS_TORSION_BAR_TORQUE_VALID);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_eps_elect_power_consumptionWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_eps_elect_power_consumption = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_eps_elect_power_consumption");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_eps_elect_power_consumption = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_eps_elect_power_consumptionReq(ec_eps_elect_power_consumption),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_eps_elect_power_consumptionReq(int32_t ec_eps_elect_power_consumption) {
    auto req = mValueObjectPool->obtainInt32(ec_eps_elect_power_consumption);
    req->prop = toInt(VehicleProperty::GECKO_EPS_ELECT_POWER_CONSUMPTION);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_eps_advanced_mode_statusWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_eps_advanced_mode_status = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_eps_advanced_mode_status");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_eps_advanced_mode_status = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_eps_advanced_mode_statusReq(ec_eps_advanced_mode_status),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_eps_advanced_mode_statusReq(int32_t ec_eps_advanced_mode_status) {
    auto req = mValueObjectPool->obtainInt32(ec_eps_advanced_mode_status);
    req->prop = toInt(VehicleProperty::GECKO_EPS_ADVANCED_MODE_STATUS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_eps_lat_drv_lvl12_srv_avlWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_eps_lat_drv_lvl12_srv_avl = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_eps_lat_drv_lvl12_srv_avl");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_eps_lat_drv_lvl12_srv_avl = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_eps_lat_drv_lvl12_srv_avlReq(ec_eps_lat_drv_lvl12_srv_avl),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_eps_lat_drv_lvl12_srv_avlReq(int32_t ec_eps_lat_drv_lvl12_srv_avl) {
    auto req = mValueObjectPool->obtainInt32(ec_eps_lat_drv_lvl12_srv_avl);
    req->prop = toInt(VehicleProperty::GECKO_EPS_LAT_DRV_LVL12_SRV_AVL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_eps_lat_mc_hptc_wrn_srv_avlWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_eps_lat_mc_hptc_wrn_srv_avl = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_eps_lat_mc_hptc_wrn_srv_avl");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_eps_lat_mc_hptc_wrn_srv_avl = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_eps_lat_mc_hptc_wrn_srv_avlReq(ec_eps_lat_mc_hptc_wrn_srv_avl),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_eps_lat_mc_hptc_wrn_srv_avlReq(int32_t ec_eps_lat_mc_hptc_wrn_srv_avl) {
    auto req = mValueObjectPool->obtainInt32(ec_eps_lat_mc_hptc_wrn_srv_avl);
    req->prop = toInt(VehicleProperty::GECKO_EPS_LAT_MC_HPTC_WRN_SRV_AVL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_eps_pscm_int_rpc_max_trqWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_eps_pscm_int_rpc_max_trq = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_eps_pscm_int_rpc_max_trq");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_eps_pscm_int_rpc_max_trq = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_eps_pscm_int_rpc_max_trqReq(ec_eps_pscm_int_rpc_max_trq),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_eps_pscm_int_rpc_max_trqReq(int32_t ec_eps_pscm_int_rpc_max_trq) {
    auto req = mValueObjectPool->obtainInt32(ec_eps_pscm_int_rpc_max_trq);
    req->prop = toInt(VehicleProperty::GECKO_EPS_PSCM_INT_RPC_MAX_TRQ);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_eps_torsion_bar_torque_qfWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_eps_torsion_bar_torque_qf = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_eps_torsion_bar_torque_qf");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_eps_torsion_bar_torque_qf = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_eps_torsion_bar_torque_qfReq(ec_eps_torsion_bar_torque_qf),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_eps_torsion_bar_torque_qfReq(int32_t ec_eps_torsion_bar_torque_qf) {
    auto req = mValueObjectPool->obtainInt32(ec_eps_torsion_bar_torque_qf);
    req->prop = toInt(VehicleProperty::GECKO_EPS_TORSION_BAR_TORQUE_QF);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_eps_pscm_int_rpc_min_trqWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_eps_pscm_int_rpc_min_trq = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_eps_pscm_int_rpc_min_trq");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_eps_pscm_int_rpc_min_trq = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_eps_pscm_int_rpc_min_trqReq(ec_eps_pscm_int_rpc_min_trq),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_eps_pscm_int_rpc_min_trqReq(int32_t ec_eps_pscm_int_rpc_min_trq) {
    auto req = mValueObjectPool->obtainInt32(ec_eps_pscm_int_rpc_min_trq);
    req->prop = toInt(VehicleProperty::GECKO_EPS_PSCM_INT_RPC_MIN_TRQ);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_eps_lat_mc_steer_tq_activeWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_eps_lat_mc_steer_tq_active = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_eps_lat_mc_steer_tq_active");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_eps_lat_mc_steer_tq_active = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_eps_lat_mc_steer_tq_activeReq(ec_eps_lat_mc_steer_tq_active),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_eps_lat_mc_steer_tq_activeReq(int32_t ec_eps_lat_mc_steer_tq_active) {
    auto req = mValueObjectPool->obtainInt32(ec_eps_lat_mc_steer_tq_active);
    req->prop = toInt(VehicleProperty::GECKO_EPS_LAT_MC_STEER_TQ_ACTIVE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_eps_lat_mc_hptc_wrn_activeWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_eps_lat_mc_hptc_wrn_active = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_eps_lat_mc_hptc_wrn_active");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_eps_lat_mc_hptc_wrn_active = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_eps_lat_mc_hptc_wrn_activeReq(ec_eps_lat_mc_hptc_wrn_active),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_eps_lat_mc_hptc_wrn_activeReq(int32_t ec_eps_lat_mc_hptc_wrn_active) {
    auto req = mValueObjectPool->obtainInt32(ec_eps_lat_mc_hptc_wrn_active);
    req->prop = toInt(VehicleProperty::GECKO_EPS_LAT_MC_HPTC_WRN_ACTIVE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_eps_max_allwd_rot_spdWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_eps_max_allwd_rot_spd = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_eps_max_allwd_rot_spd");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_eps_max_allwd_rot_spd = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_eps_max_allwd_rot_spdReq(ec_eps_max_allwd_rot_spd),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_eps_max_allwd_rot_spdReq(int32_t ec_eps_max_allwd_rot_spd) {
    auto req = mValueObjectPool->obtainInt32(ec_eps_max_allwd_rot_spd);
    req->prop = toInt(VehicleProperty::GECKO_EPS_MAX_ALLWD_ROT_SPD);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_eps_lks_agl_sys_stsWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_eps_lks_agl_sys_sts = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_eps_lks_agl_sys_sts");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_eps_lks_agl_sys_sts = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_eps_lks_agl_sys_stsReq(ec_eps_lks_agl_sys_sts),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_eps_lks_agl_sys_stsReq(int32_t ec_eps_lks_agl_sys_sts) {
    auto req = mValueObjectPool->obtainInt32(ec_eps_lks_agl_sys_sts);
    req->prop = toInt(VehicleProperty::GECKO_EPS_LKS_AGL_SYS_STS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_eps_max_allwd_aglWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_eps_max_allwd_agl = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_eps_max_allwd_agl");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_eps_max_allwd_agl = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_eps_max_allwd_aglReq(ec_eps_max_allwd_agl),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_eps_max_allwd_aglReq(int32_t ec_eps_max_allwd_agl) {
    auto req = mValueObjectPool->obtainInt32(ec_eps_max_allwd_agl);
    req->prop = toInt(VehicleProperty::GECKO_EPS_MAX_ALLWD_AGL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_eps_steer_tqWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_eps_steer_tq = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_eps_steer_tq");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_eps_steer_tq = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_eps_steer_tqReq(ec_eps_steer_tq),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_eps_steer_tqReq(int32_t ec_eps_steer_tq) {
    auto req = mValueObjectPool->obtainInt32(ec_eps_steer_tq);
    req->prop = toInt(VehicleProperty::GECKO_EPS_STEER_TQ);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_eps_lks_agl_ctrl_avl_stsWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_eps_lks_agl_ctrl_avl_sts = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_eps_lks_agl_ctrl_avl_sts");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_eps_lks_agl_ctrl_avl_sts = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_eps_lks_agl_ctrl_avl_stsReq(ec_eps_lks_agl_ctrl_avl_sts),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_eps_lks_agl_ctrl_avl_stsReq(int32_t ec_eps_lks_agl_ctrl_avl_sts) {
    auto req = mValueObjectPool->obtainInt32(ec_eps_lks_agl_ctrl_avl_sts);
    req->prop = toInt(VehicleProperty::GECKO_EPS_LKS_AGL_CTRL_AVL_STS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_req_brake_light_onWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_esc_req_brake_light_on = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_req_brake_light_on");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_esc_req_brake_light_on = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_esc_req_brake_light_onReq(ec_esc_req_brake_light_on),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_req_brake_light_onReq(int32_t ec_esc_req_brake_light_on) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_req_brake_light_on);
    req->prop = toInt(VehicleProperty::GECKO_ESC_REQ_BRAKE_LIGHT_ON);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_ebd_active_staWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_esc_ebd_active_sta = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_ebd_active_sta");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_esc_ebd_active_sta = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_esc_ebd_active_staReq(ec_esc_ebd_active_sta),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_ebd_active_staReq(int32_t ec_esc_ebd_active_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_ebd_active_sta);
    req->prop = toInt(VehicleProperty::GECKO_ESC_EBD_ACTIVE_STA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_ess_activeWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_esc_ess_active = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_ess_active");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_esc_ess_active = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_esc_ess_activeReq(ec_esc_ess_active),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_ess_activeReq(int32_t ec_esc_ess_active) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_ess_active);
    req->prop = toInt(VehicleProperty::GECKO_ESC_ESS_ACTIVE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_cdp_activeWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_esc_cdp_active = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_cdp_active");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_esc_cdp_active = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_esc_cdp_activeReq(ec_esc_cdp_active),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_cdp_activeReq(int32_t ec_esc_cdp_active) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_cdp_active);
    req->prop = toInt(VehicleProperty::GECKO_ESC_CDP_ACTIVE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_brake_temp_over_heatWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_esc_brake_temp_over_heat = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_brake_temp_over_heat");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_esc_brake_temp_over_heat = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_esc_brake_temp_over_heatReq(ec_esc_brake_temp_over_heat),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_brake_temp_over_heatReq(int32_t ec_esc_brake_temp_over_heat) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_brake_temp_over_heat);
    req->prop = toInt(VehicleProperty::GECKO_ESC_BRAKE_TEMP_OVER_HEAT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_dtc_active_stsWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_esc_dtc_active_sts = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_dtc_active_sts");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_esc_dtc_active_sts = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_esc_dtc_active_stsReq(ec_esc_dtc_active_sts),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_dtc_active_stsReq(int32_t ec_esc_dtc_active_sts) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_dtc_active_sts);
    req->prop = toInt(VehicleProperty::GECKO_ESC_DTC_ACTIVE_STS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_vhcl_standstill_staWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_esc_vhcl_standstill_sta = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_vhcl_standstill_sta");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_esc_vhcl_standstill_sta = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_esc_vhcl_standstill_staReq(ec_esc_vhcl_standstill_sta),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_vhcl_standstill_staReq(int32_t ec_esc_vhcl_standstill_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_vhcl_standstill_sta);
    req->prop = toInt(VehicleProperty::GECKO_ESC_VHCL_STANDSTILL_STA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_dtc_request_rbs_stsWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_esc_dtc_request_rbs_sts = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_dtc_request_rbs_sts");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_esc_dtc_request_rbs_sts = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_esc_dtc_request_rbs_stsReq(ec_esc_dtc_request_rbs_sts),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_dtc_request_rbs_stsReq(int32_t ec_esc_dtc_request_rbs_sts) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_dtc_request_rbs_sts);
    req->prop = toInt(VehicleProperty::GECKO_ESC_DTC_REQUEST_RBS_STS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_dtc_failure_stsWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_esc_dtc_failure_sts = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_dtc_failure_sts");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_esc_dtc_failure_sts = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_esc_dtc_failure_stsReq(ec_esc_dtc_failure_sts),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_dtc_failure_stsReq(int32_t ec_esc_dtc_failure_sts) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_dtc_failure_sts);
    req->prop = toInt(VehicleProperty::GECKO_ESC_DTC_FAILURE_STS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_wheel_speed_kph_v_flWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_esc_wheel_speed_kph_v_fl = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_wheel_speed_kph_v_fl");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_esc_wheel_speed_kph_v_fl = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_esc_wheel_speed_kph_v_flReq(ec_esc_wheel_speed_kph_v_fl),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_wheel_speed_kph_v_flReq(int32_t ec_esc_wheel_speed_kph_v_fl) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_wheel_speed_kph_v_fl);
    req->prop = toInt(VehicleProperty::GECKO_ESC_WHEEL_SPEED_KPH_V_FL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_wheel_direction_flWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_esc_wheel_direction_fl = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_wheel_direction_fl");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_esc_wheel_direction_fl = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_esc_wheel_direction_flReq(ec_esc_wheel_direction_fl),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_wheel_direction_flReq(int32_t ec_esc_wheel_direction_fl) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_wheel_direction_fl);
    req->prop = toInt(VehicleProperty::GECKO_ESC_WHEEL_DIRECTION_FL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_wheel_speed_kph_flWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_esc_wheel_speed_kph_fl = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_wheel_speed_kph_fl");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_esc_wheel_speed_kph_fl = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_esc_wheel_speed_kph_flReq(ec_esc_wheel_speed_kph_fl),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_wheel_speed_kph_flReq(int32_t ec_esc_wheel_speed_kph_fl) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_wheel_speed_kph_fl);
    req->prop = toInt(VehicleProperty::GECKO_ESC_WHEEL_SPEED_KPH_FL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_wheel_speed_kph_v_frWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_esc_wheel_speed_kph_v_fr = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_wheel_speed_kph_v_fr");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_esc_wheel_speed_kph_v_fr = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_esc_wheel_speed_kph_v_frReq(ec_esc_wheel_speed_kph_v_fr),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_wheel_speed_kph_v_frReq(int32_t ec_esc_wheel_speed_kph_v_fr) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_wheel_speed_kph_v_fr);
    req->prop = toInt(VehicleProperty::GECKO_ESC_WHEEL_SPEED_KPH_V_FR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_wheel_direction_frWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_esc_wheel_direction_fr = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_wheel_direction_fr");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_esc_wheel_direction_fr = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_esc_wheel_direction_frReq(ec_esc_wheel_direction_fr),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_wheel_direction_frReq(int32_t ec_esc_wheel_direction_fr) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_wheel_direction_fr);
    req->prop = toInt(VehicleProperty::GECKO_ESC_WHEEL_DIRECTION_FR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_wheel_speed_kph_frWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_esc_wheel_speed_kph_fr = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_wheel_speed_kph_fr");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_esc_wheel_speed_kph_fr = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_esc_wheel_speed_kph_frReq(ec_esc_wheel_speed_kph_fr),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_wheel_speed_kph_frReq(int32_t ec_esc_wheel_speed_kph_fr) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_wheel_speed_kph_fr);
    req->prop = toInt(VehicleProperty::GECKO_ESC_WHEEL_SPEED_KPH_FR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_master_cylinder_presrWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_esc_master_cylinder_presr = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_master_cylinder_presr");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_esc_master_cylinder_presr = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_esc_master_cylinder_presrReq(ec_esc_master_cylinder_presr),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_master_cylinder_presrReq(int32_t ec_esc_master_cylinder_presr) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_master_cylinder_presr);
    req->prop = toInt(VehicleProperty::GECKO_ESC_MASTER_CYLINDER_PRESR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_master_cylinder_presr_vWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_esc_master_cylinder_presr_v = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_master_cylinder_presr_v");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_esc_master_cylinder_presr_v = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_esc_master_cylinder_presr_vReq(ec_esc_master_cylinder_presr_v),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_master_cylinder_presr_vReq(int32_t ec_esc_master_cylinder_presr_v) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_master_cylinder_presr_v);
    req->prop = toInt(VehicleProperty::GECKO_ESC_MASTER_CYLINDER_PRESR_V);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_wheel_speed_kph_v_rlWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_esc_wheel_speed_kph_v_rl = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_wheel_speed_kph_v_rl");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_esc_wheel_speed_kph_v_rl = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_esc_wheel_speed_kph_v_rlReq(ec_esc_wheel_speed_kph_v_rl),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_wheel_speed_kph_v_rlReq(int32_t ec_esc_wheel_speed_kph_v_rl) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_wheel_speed_kph_v_rl);
    req->prop = toInt(VehicleProperty::GECKO_ESC_WHEEL_SPEED_KPH_V_RL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_wheel_direction_rlWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_esc_wheel_direction_rl = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_wheel_direction_rl");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_esc_wheel_direction_rl = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_esc_wheel_direction_rlReq(ec_esc_wheel_direction_rl),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_wheel_direction_rlReq(int32_t ec_esc_wheel_direction_rl) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_wheel_direction_rl);
    req->prop = toInt(VehicleProperty::GECKO_ESC_WHEEL_DIRECTION_RL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_wheel_speed_kph_rlWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_esc_wheel_speed_kph_rl = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_wheel_speed_kph_rl");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_esc_wheel_speed_kph_rl = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_esc_wheel_speed_kph_rlReq(ec_esc_wheel_speed_kph_rl),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_wheel_speed_kph_rlReq(int32_t ec_esc_wheel_speed_kph_rl) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_wheel_speed_kph_rl);
    req->prop = toInt(VehicleProperty::GECKO_ESC_WHEEL_SPEED_KPH_RL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_wheel_speed_kph_v_rrWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_esc_wheel_speed_kph_v_rr = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_wheel_speed_kph_v_rr");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_esc_wheel_speed_kph_v_rr = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_esc_wheel_speed_kph_v_rrReq(ec_esc_wheel_speed_kph_v_rr),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_wheel_speed_kph_v_rrReq(int32_t ec_esc_wheel_speed_kph_v_rr) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_wheel_speed_kph_v_rr);
    req->prop = toInt(VehicleProperty::GECKO_ESC_WHEEL_SPEED_KPH_V_RR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_wheel_direction_rrWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_esc_wheel_direction_rr = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_wheel_direction_rr");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_esc_wheel_direction_rr = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_esc_wheel_direction_rrReq(ec_esc_wheel_direction_rr),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_wheel_direction_rrReq(int32_t ec_esc_wheel_direction_rr) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_wheel_direction_rr);
    req->prop = toInt(VehicleProperty::GECKO_ESC_WHEEL_DIRECTION_RR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_wheel_speed_kph_rrWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_esc_wheel_speed_kph_rr = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_wheel_speed_kph_rr");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_esc_wheel_speed_kph_rr = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_esc_wheel_speed_kph_rrReq(ec_esc_wheel_speed_kph_rr),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_wheel_speed_kph_rrReq(int32_t ec_esc_wheel_speed_kph_rr) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_wheel_speed_kph_rr);
    req->prop = toInt(VehicleProperty::GECKO_ESC_WHEEL_SPEED_KPH_RR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_wheel_speed_rc_sts_flWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_esc_wheel_speed_rc_sts_fl = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_wheel_speed_rc_sts_fl");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_esc_wheel_speed_rc_sts_fl = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_esc_wheel_speed_rc_sts_flReq(ec_esc_wheel_speed_rc_sts_fl),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_wheel_speed_rc_sts_flReq(int32_t ec_esc_wheel_speed_rc_sts_fl) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_wheel_speed_rc_sts_fl);
    req->prop = toInt(VehicleProperty::GECKO_ESC_WHEEL_SPEED_RC_STS_FL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_wheel_speed_rc_sts_frWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_esc_wheel_speed_rc_sts_fr = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_wheel_speed_rc_sts_fr");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_esc_wheel_speed_rc_sts_fr = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_esc_wheel_speed_rc_sts_frReq(ec_esc_wheel_speed_rc_sts_fr),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_wheel_speed_rc_sts_frReq(int32_t ec_esc_wheel_speed_rc_sts_fr) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_wheel_speed_rc_sts_fr);
    req->prop = toInt(VehicleProperty::GECKO_ESC_WHEEL_SPEED_RC_STS_FR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_wheel_speed_rc_sts_rlWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_esc_wheel_speed_rc_sts_rl = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_wheel_speed_rc_sts_rl");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_esc_wheel_speed_rc_sts_rl = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_esc_wheel_speed_rc_sts_rlReq(ec_esc_wheel_speed_rc_sts_rl),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_wheel_speed_rc_sts_rlReq(int32_t ec_esc_wheel_speed_rc_sts_rl) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_wheel_speed_rc_sts_rl);
    req->prop = toInt(VehicleProperty::GECKO_ESC_WHEEL_SPEED_RC_STS_RL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_wheel_speed_rc_sts_rrWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_esc_wheel_speed_rc_sts_rr = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_wheel_speed_rc_sts_rr");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_esc_wheel_speed_rc_sts_rr = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_esc_wheel_speed_rc_sts_rrReq(ec_esc_wheel_speed_rc_sts_rr),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_wheel_speed_rc_sts_rrReq(int32_t ec_esc_wheel_speed_rc_sts_rr) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_wheel_speed_rc_sts_rr);
    req->prop = toInt(VehicleProperty::GECKO_ESC_WHEEL_SPEED_RC_STS_RR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_wheel_speed_rc_flWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_esc_wheel_speed_rc_fl = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_wheel_speed_rc_fl");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_esc_wheel_speed_rc_fl = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_esc_wheel_speed_rc_flReq(ec_esc_wheel_speed_rc_fl),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_wheel_speed_rc_flReq(int32_t ec_esc_wheel_speed_rc_fl) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_wheel_speed_rc_fl);
    req->prop = toInt(VehicleProperty::GECKO_ESC_WHEEL_SPEED_RC_FL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_wheel_speed_rc_frWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_esc_wheel_speed_rc_fr = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_wheel_speed_rc_fr");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_esc_wheel_speed_rc_fr = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_esc_wheel_speed_rc_frReq(ec_esc_wheel_speed_rc_fr),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_wheel_speed_rc_frReq(int32_t ec_esc_wheel_speed_rc_fr) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_wheel_speed_rc_fr);
    req->prop = toInt(VehicleProperty::GECKO_ESC_WHEEL_SPEED_RC_FR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_wheel_speed_rc_rlWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_esc_wheel_speed_rc_rl = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_wheel_speed_rc_rl");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_esc_wheel_speed_rc_rl = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_esc_wheel_speed_rc_rlReq(ec_esc_wheel_speed_rc_rl),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_wheel_speed_rc_rlReq(int32_t ec_esc_wheel_speed_rc_rl) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_wheel_speed_rc_rl);
    req->prop = toInt(VehicleProperty::GECKO_ESC_WHEEL_SPEED_RC_RL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_wheel_speed_rc_rrWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_esc_wheel_speed_rc_rr = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_wheel_speed_rc_rr");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_esc_wheel_speed_rc_rr = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_esc_wheel_speed_rc_rrReq(ec_esc_wheel_speed_rc_rr),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_wheel_speed_rc_rrReq(int32_t ec_esc_wheel_speed_rc_rr) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_wheel_speed_rc_rr);
    req->prop = toInt(VehicleProperty::GECKO_ESC_WHEEL_SPEED_RC_RR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_long_acc_sensor_valueWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_esc_long_acc_sensor_value = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_long_acc_sensor_value");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_esc_long_acc_sensor_value = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_esc_long_acc_sensor_valueReq(ec_esc_long_acc_sensor_value),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_long_acc_sensor_valueReq(int32_t ec_esc_long_acc_sensor_value) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_long_acc_sensor_value);
    req->prop = toInt(VehicleProperty::GECKO_ESC_LONG_ACC_SENSOR_VALUE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_long_acc_sensor_value_vldWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_esc_long_acc_sensor_value_vld = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_long_acc_sensor_value_vld");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_esc_long_acc_sensor_value_vld = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_esc_long_acc_sensor_value_vldReq(ec_esc_long_acc_sensor_value_vld),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_long_acc_sensor_value_vldReq(int32_t ec_esc_long_acc_sensor_value_vld) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_long_acc_sensor_value_vld);
    req->prop = toInt(VehicleProperty::GECKO_ESC_LONG_ACC_SENSOR_VALUE_VLD);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_lat_acc_sensor_value_vldWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_esc_lat_acc_sensor_value_vld = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_lat_acc_sensor_value_vld");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_esc_lat_acc_sensor_value_vld = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_esc_lat_acc_sensor_value_vldReq(ec_esc_lat_acc_sensor_value_vld),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_lat_acc_sensor_value_vldReq(int32_t ec_esc_lat_acc_sensor_value_vld) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_lat_acc_sensor_value_vld);
    req->prop = toInt(VehicleProperty::GECKO_ESC_LAT_ACC_SENSOR_VALUE_VLD);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_lat_acc_sensor_valueWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_esc_lat_acc_sensor_value = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_lat_acc_sensor_value");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_esc_lat_acc_sensor_value = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_esc_lat_acc_sensor_valueReq(ec_esc_lat_acc_sensor_value),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_lat_acc_sensor_valueReq(int32_t ec_esc_lat_acc_sensor_value) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_lat_acc_sensor_value);
    req->prop = toInt(VehicleProperty::GECKO_ESC_LAT_ACC_SENSOR_VALUE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_yaw_rate_vldWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_esc_yaw_rate_vld = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_yaw_rate_vld");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_esc_yaw_rate_vld = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_esc_yaw_rate_vldReq(ec_esc_yaw_rate_vld),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_yaw_rate_vldReq(int32_t ec_esc_yaw_rate_vld) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_yaw_rate_vld);
    req->prop = toInt(VehicleProperty::GECKO_ESC_YAW_RATE_VLD);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_yaw_rateWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_esc_yaw_rate = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_yaw_rate");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_esc_yaw_rate = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_esc_yaw_rateReq(ec_esc_yaw_rate),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_yaw_rateReq(int32_t ec_esc_yaw_rate) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_yaw_rate);
    req->prop = toInt(VehicleProperty::GECKO_ESC_YAW_RATE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_epb_right_currentWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_esc_epb_right_current = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_epb_right_current");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_esc_epb_right_current = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_esc_epb_right_currentReq(ec_esc_epb_right_current),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_epb_right_currentReq(int32_t ec_esc_epb_right_current) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_epb_right_current);
    req->prop = toInt(VehicleProperty::GECKO_ESC_EPB_RIGHT_CURRENT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_epb_right_fault_stateWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_esc_epb_right_fault_state = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_epb_right_fault_state");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_esc_epb_right_fault_state = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_esc_epb_right_fault_stateReq(ec_esc_epb_right_fault_state),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_epb_right_fault_stateReq(int32_t ec_esc_epb_right_fault_state) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_epb_right_fault_state);
    req->prop = toInt(VehicleProperty::GECKO_ESC_EPB_RIGHT_FAULT_STATE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_hbb_hbc_availableWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_esc_hbb_hbc_available = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_hbb_hbc_available");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_esc_hbb_hbc_available = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_esc_hbb_hbc_availableReq(ec_esc_hbb_hbc_available),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_hbb_hbc_availableReq(int32_t ec_esc_hbb_hbc_available) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_hbb_hbc_available);
    req->prop = toInt(VehicleProperty::GECKO_ESC_HBB_HBC_AVAILABLE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_epb_actuator_st_rWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_esc_epb_actuator_st_r = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_epb_actuator_st_r");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_esc_epb_actuator_st_r = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_esc_epb_actuator_st_rReq(ec_esc_epb_actuator_st_r),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_epb_actuator_st_rReq(int32_t ec_esc_epb_actuator_st_r) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_epb_actuator_st_r);
    req->prop = toInt(VehicleProperty::GECKO_ESC_EPB_ACTUATOR_ST_R);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_hbb_hbc_activeWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_esc_hbb_hbc_active = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_hbb_hbc_active");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_esc_hbb_hbc_active = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_esc_hbb_hbc_activeReq(ec_esc_hbb_hbc_active),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_hbb_hbc_activeReq(int32_t ec_esc_hbb_hbc_active) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_hbb_hbc_active);
    req->prop = toInt(VehicleProperty::GECKO_ESC_HBB_HBC_ACTIVE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_whl_tq_dec_req_actvWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_esc_whl_tq_dec_req_actv = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_whl_tq_dec_req_actv");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_esc_whl_tq_dec_req_actv = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_esc_whl_tq_dec_req_actvReq(ec_esc_whl_tq_dec_req_actv),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_whl_tq_dec_req_actvReq(int32_t ec_esc_whl_tq_dec_req_actv) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_whl_tq_dec_req_actv);
    req->prop = toInt(VehicleProperty::GECKO_ESC_WHL_TQ_DEC_REQ_ACTV);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_whl_tq_dec_req_valWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_esc_whl_tq_dec_req_val = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_whl_tq_dec_req_val");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_esc_whl_tq_dec_req_val = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_esc_whl_tq_dec_req_valReq(ec_esc_whl_tq_dec_req_val),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_whl_tq_dec_req_valReq(int32_t ec_esc_whl_tq_dec_req_val) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_whl_tq_dec_req_val);
    req->prop = toInt(VehicleProperty::GECKO_ESC_WHL_TQ_DEC_REQ_VAL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_whl_tq_inc_req_actvWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_esc_whl_tq_inc_req_actv = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_whl_tq_inc_req_actv");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_esc_whl_tq_inc_req_actv = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_esc_whl_tq_inc_req_actvReq(ec_esc_whl_tq_inc_req_actv),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_whl_tq_inc_req_actvReq(int32_t ec_esc_whl_tq_inc_req_actv) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_whl_tq_inc_req_actv);
    req->prop = toInt(VehicleProperty::GECKO_ESC_WHL_TQ_INC_REQ_ACTV);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_whl_tq_inc_req_valWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_esc_whl_tq_inc_req_val = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_whl_tq_inc_req_val");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_esc_whl_tq_inc_req_val = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_esc_whl_tq_inc_req_valReq(ec_esc_whl_tq_inc_req_val),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_whl_tq_inc_req_valReq(int32_t ec_esc_whl_tq_inc_req_val) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_whl_tq_inc_req_val);
    req->prop = toInt(VehicleProperty::GECKO_ESC_WHL_TQ_INC_REQ_VAL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ehb_cdp_requestWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ehb_cdp_request = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ehb_cdp_request");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ehb_cdp_request = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ehb_cdp_requestReq(ec_ehb_cdp_request),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ehb_cdp_requestReq(int32_t ec_ehb_cdp_request) {
    auto req = mValueObjectPool->obtainInt32(ec_ehb_cdp_request);
    req->prop = toInt(VehicleProperty::GECKO_EHB_CDP_REQUEST);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ehb_hhc_active_staWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ehb_hhc_active_sta = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ehb_hhc_active_sta");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ehb_hhc_active_sta = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ehb_hhc_active_staReq(ec_ehb_hhc_active_sta),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ehb_hhc_active_staReq(int32_t ec_ehb_hhc_active_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_ehb_hhc_active_sta);
    req->prop = toInt(VehicleProperty::GECKO_EHB_HHC_ACTIVE_STA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ehb_rgn_brk_stWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ehb_rgn_brk_st = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ehb_rgn_brk_st");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ehb_rgn_brk_st = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ehb_rgn_brk_stReq(ec_ehb_rgn_brk_st),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ehb_rgn_brk_stReq(int32_t ec_ehb_rgn_brk_st) {
    auto req = mValueObjectPool->obtainInt32(ec_ehb_rgn_brk_st);
    req->prop = toInt(VehicleProperty::GECKO_EHB_RGN_BRK_ST);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ehb_ext_req_statusWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ehb_ext_req_status = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ehb_ext_req_status");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ehb_ext_req_status = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ehb_ext_req_statusReq(ec_ehb_ext_req_status),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ehb_ext_req_statusReq(int32_t ec_ehb_ext_req_status) {
    auto req = mValueObjectPool->obtainInt32(ec_ehb_ext_req_status);
    req->prop = toInt(VehicleProperty::GECKO_EHB_EXT_REQ_STATUS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ehb_blaWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ehb_bla = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ehb_bla");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ehb_bla = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ehb_blaReq(ec_ehb_bla),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ehb_blaReq(int32_t ec_ehb_bla) {
    auto req = mValueObjectPool->obtainInt32(ec_ehb_bla);
    req->prop = toInt(VehicleProperty::GECKO_EHB_BLA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ehb_hmi_warning_onWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ehb_hmi_warning_on = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ehb_hmi_warning_on");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ehb_hmi_warning_on = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ehb_hmi_warning_onReq(ec_ehb_hmi_warning_on),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ehb_hmi_warning_onReq(int32_t ec_ehb_hmi_warning_on) {
    auto req = mValueObjectPool->obtainInt32(ec_ehb_hmi_warning_on);
    req->prop = toInt(VehicleProperty::GECKO_EHB_HMI_WARNING_ON);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ehb_epb_dynamic_apply_staWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ehb_epb_dynamic_apply_sta = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ehb_epb_dynamic_apply_sta");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ehb_epb_dynamic_apply_sta = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ehb_epb_dynamic_apply_staReq(ec_ehb_epb_dynamic_apply_sta),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ehb_epb_dynamic_apply_staReq(int32_t ec_ehb_epb_dynamic_apply_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_ehb_epb_dynamic_apply_sta);
    req->prop = toInt(VehicleProperty::GECKO_EHB_EPB_DYNAMIC_APPLY_STA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ehb_pedl_trvl_snsr_fail_pdfWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ehb_pedl_trvl_snsr_fail_pdf = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ehb_pedl_trvl_snsr_fail_pdf");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ehb_pedl_trvl_snsr_fail_pdf = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ehb_pedl_trvl_snsr_fail_pdfReq(ec_ehb_pedl_trvl_snsr_fail_pdf),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ehb_pedl_trvl_snsr_fail_pdfReq(int32_t ec_ehb_pedl_trvl_snsr_fail_pdf) {
    auto req = mValueObjectPool->obtainInt32(ec_ehb_pedl_trvl_snsr_fail_pdf);
    req->prop = toInt(VehicleProperty::GECKO_EHB_PEDL_TRVL_SNSR_FAIL_PDF);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ehb_req_brk_li_onWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ehb_req_brk_li_on = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ehb_req_brk_li_on");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ehb_req_brk_li_on = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ehb_req_brk_li_onReq(ec_ehb_req_brk_li_on),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ehb_req_brk_li_onReq(int32_t ec_ehb_req_brk_li_on) {
    auto req = mValueObjectPool->obtainInt32(ec_ehb_req_brk_li_on);
    req->prop = toInt(VehicleProperty::GECKO_EHB_REQ_BRK_LI_ON);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ehb_pedl_trvl_snsr_fail_pdtWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ehb_pedl_trvl_snsr_fail_pdt = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ehb_pedl_trvl_snsr_fail_pdt");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ehb_pedl_trvl_snsr_fail_pdt = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ehb_pedl_trvl_snsr_fail_pdtReq(ec_ehb_pedl_trvl_snsr_fail_pdt),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ehb_pedl_trvl_snsr_fail_pdtReq(int32_t ec_ehb_pedl_trvl_snsr_fail_pdt) {
    auto req = mValueObjectPool->obtainInt32(ec_ehb_pedl_trvl_snsr_fail_pdt);
    req->prop = toInt(VehicleProperty::GECKO_EHB_PEDL_TRVL_SNSR_FAIL_PDT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ehb_p_runout_pressureWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ehb_p_runout_pressure = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ehb_p_runout_pressure");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ehb_p_runout_pressure = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ehb_p_runout_pressureReq(ec_ehb_p_runout_pressure),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ehb_p_runout_pressureReq(int32_t ec_ehb_p_runout_pressure) {
    auto req = mValueObjectPool->obtainInt32(ec_ehb_p_runout_pressure);
    req->prop = toInt(VehicleProperty::GECKO_EHB_P_RUNOUT_PRESSURE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ehb_brake_pedal_appliedWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ehb_brake_pedal_applied = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ehb_brake_pedal_applied");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ehb_brake_pedal_applied = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ehb_brake_pedal_appliedReq(ec_ehb_brake_pedal_applied),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ehb_brake_pedal_appliedReq(int32_t ec_ehb_brake_pedal_applied) {
    auto req = mValueObjectPool->obtainInt32(ec_ehb_brake_pedal_applied);
    req->prop = toInt(VehicleProperty::GECKO_EHB_BRAKE_PEDAL_APPLIED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ehb_brake_pedal_applied_qWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ehb_brake_pedal_applied_q = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ehb_brake_pedal_applied_q");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ehb_brake_pedal_applied_q = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ehb_brake_pedal_applied_qReq(ec_ehb_brake_pedal_applied_q),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ehb_brake_pedal_applied_qReq(int32_t ec_ehb_brake_pedal_applied_q) {
    auto req = mValueObjectPool->obtainInt32(ec_ehb_brake_pedal_applied_q);
    req->prop = toInt(VehicleProperty::GECKO_EHB_BRAKE_PEDAL_APPLIED_Q);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ehb_cdd_temp_offWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ehb_cdd_temp_off = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ehb_cdd_temp_off");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ehb_cdd_temp_off = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ehb_cdd_temp_offReq(ec_ehb_cdd_temp_off),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ehb_cdd_temp_offReq(int32_t ec_ehb_cdd_temp_off) {
    auto req = mValueObjectPool->obtainInt32(ec_ehb_cdd_temp_off);
    req->prop = toInt(VehicleProperty::GECKO_EHB_CDD_TEMP_OFF);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ehb_s_output_rod_hydraulic_targetWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ehb_s_output_rod_hydraulic_target = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ehb_s_output_rod_hydraulic_target");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ehb_s_output_rod_hydraulic_target = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ehb_s_output_rod_hydraulic_targetReq(ec_ehb_s_output_rod_hydraulic_target),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ehb_s_output_rod_hydraulic_targetReq(int32_t ec_ehb_s_output_rod_hydraulic_target) {
    auto req = mValueObjectPool->obtainInt32(ec_ehb_s_output_rod_hydraulic_target);
    req->prop = toInt(VehicleProperty::GECKO_EHB_S_OUTPUT_ROD_HYDRAULIC_TARGET);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ehb_s_output_rod_driver_percWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ehb_s_output_rod_driver_perc = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ehb_s_output_rod_driver_perc");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ehb_s_output_rod_driver_perc = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ehb_s_output_rod_driver_percReq(ec_ehb_s_output_rod_driver_perc),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ehb_s_output_rod_driver_percReq(int32_t ec_ehb_s_output_rod_driver_perc) {
    auto req = mValueObjectPool->obtainInt32(ec_ehb_s_output_rod_driver_perc);
    req->prop = toInt(VehicleProperty::GECKO_EHB_S_OUTPUT_ROD_DRIVER_PERC);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ehb_epb_actuator_st_rWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ehb_epb_actuator_st_r = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ehb_epb_actuator_st_r");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ehb_epb_actuator_st_r = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ehb_epb_actuator_st_rReq(ec_ehb_epb_actuator_st_r),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ehb_epb_actuator_st_rReq(int32_t ec_ehb_epb_actuator_st_r) {
    auto req = mValueObjectPool->obtainInt32(ec_ehb_epb_actuator_st_r);
    req->prop = toInt(VehicleProperty::GECKO_EHB_EPB_ACTUATOR_ST_R);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ehb_aba_active_staWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ehb_aba_active_sta = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ehb_aba_active_sta");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ehb_aba_active_sta = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ehb_aba_active_staReq(ec_ehb_aba_active_sta),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ehb_aba_active_staReq(int32_t ec_ehb_aba_active_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_ehb_aba_active_sta);
    req->prop = toInt(VehicleProperty::GECKO_EHB_ABA_ACTIVE_STA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ehb_aba_available_staWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ehb_aba_available_sta = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ehb_aba_available_sta");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ehb_aba_available_sta = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ehb_aba_available_staReq(ec_ehb_aba_available_sta),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ehb_aba_available_staReq(int32_t ec_ehb_aba_available_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_ehb_aba_available_sta);
    req->prop = toInt(VehicleProperty::GECKO_EHB_ABA_AVAILABLE_STA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ehb_awb_active_staWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ehb_awb_active_sta = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ehb_awb_active_sta");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ehb_awb_active_sta = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ehb_awb_active_staReq(ec_ehb_awb_active_sta),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ehb_awb_active_staReq(int32_t ec_ehb_awb_active_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_ehb_awb_active_sta);
    req->prop = toInt(VehicleProperty::GECKO_EHB_AWB_ACTIVE_STA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ehb_awb_available_staWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ehb_awb_available_sta = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ehb_awb_available_sta");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ehb_awb_available_sta = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ehb_awb_available_staReq(ec_ehb_awb_available_sta),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ehb_awb_available_staReq(int32_t ec_ehb_awb_available_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_ehb_awb_available_sta);
    req->prop = toInt(VehicleProperty::GECKO_EHB_AWB_AVAILABLE_STA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ehb_aeb_active_staWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ehb_aeb_active_sta = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ehb_aeb_active_sta");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ehb_aeb_active_sta = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ehb_aeb_active_staReq(ec_ehb_aeb_active_sta),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ehb_aeb_active_staReq(int32_t ec_ehb_aeb_active_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_ehb_aeb_active_sta);
    req->prop = toInt(VehicleProperty::GECKO_EHB_AEB_ACTIVE_STA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ehb_aeb_available_staWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ehb_aeb_available_sta = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ehb_aeb_available_sta");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ehb_aeb_available_sta = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ehb_aeb_available_staReq(ec_ehb_aeb_available_sta),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ehb_aeb_available_staReq(int32_t ec_ehb_aeb_available_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_ehb_aeb_available_sta);
    req->prop = toInt(VehicleProperty::GECKO_EHB_AEB_AVAILABLE_STA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ehb_abp_active_staWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ehb_abp_active_sta = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ehb_abp_active_sta");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ehb_abp_active_sta = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ehb_abp_active_staReq(ec_ehb_abp_active_sta),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ehb_abp_active_staReq(int32_t ec_ehb_abp_active_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_ehb_abp_active_sta);
    req->prop = toInt(VehicleProperty::GECKO_EHB_ABP_ACTIVE_STA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ehb_abp_available_staWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ehb_abp_available_sta = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ehb_abp_available_sta");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ehb_abp_available_sta = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ehb_abp_available_staReq(ec_ehb_abp_available_sta),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ehb_abp_available_staReq(int32_t ec_ehb_abp_available_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_ehb_abp_available_sta);
    req->prop = toInt(VehicleProperty::GECKO_EHB_ABP_AVAILABLE_STA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_pp_raeb_set_fbWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_pp_raeb_set_fb = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_pp_raeb_set_fb");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_pp_raeb_set_fb = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_pp_raeb_set_fbReq(ec_pp_raeb_set_fb),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_pp_raeb_set_fbReq(int32_t ec_pp_raeb_set_fb) {
    auto req = mValueObjectPool->obtainInt32(ec_pp_raeb_set_fb);
    req->prop = toInt(VehicleProperty::GECKO_PP_RAEB_SET_FB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_pp_raeb_brkg_reqWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_pp_raeb_brkg_req = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_pp_raeb_brkg_req");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_pp_raeb_brkg_req = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_pp_raeb_brkg_reqReq(ec_pp_raeb_brkg_req),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_pp_raeb_brkg_reqReq(int32_t ec_pp_raeb_brkg_req) {
    auto req = mValueObjectPool->obtainInt32(ec_pp_raeb_brkg_req);
    req->prop = toInt(VehicleProperty::GECKO_PP_RAEB_BRKG_REQ);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_pp_raeb_brkg_req_valWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_pp_raeb_brkg_req_val = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_pp_raeb_brkg_req_val");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_pp_raeb_brkg_req_val = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_pp_raeb_brkg_req_valReq(ec_pp_raeb_brkg_req_val),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_pp_raeb_brkg_req_valReq(int32_t ec_pp_raeb_brkg_req_val) {
    auto req = mValueObjectPool->obtainInt32(ec_pp_raeb_brkg_req_val);
    req->prop = toInt(VehicleProperty::GECKO_PP_RAEB_BRKG_REQ_VAL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_pp_raeb_distance_to_collisionWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_pp_raeb_distance_to_collision = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_pp_raeb_distance_to_collision");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_pp_raeb_distance_to_collision = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_pp_raeb_distance_to_collisionReq(ec_pp_raeb_distance_to_collision),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_pp_raeb_distance_to_collisionReq(int32_t ec_pp_raeb_distance_to_collision) {
    auto req = mValueObjectPool->obtainInt32(ec_pp_raeb_distance_to_collision);
    req->prop = toInt(VehicleProperty::GECKO_PP_RAEB_DISTANCE_TO_COLLISION);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_crrr_rctb_decelarationWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_crrr_rctb_decelaration = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_crrr_rctb_decelaration");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_crrr_rctb_decelaration = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_crrr_rctb_decelarationReq(ec_crrr_rctb_decelaration),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_crrr_rctb_decelarationReq(int32_t ec_crrr_rctb_decelaration) {
    auto req = mValueObjectPool->obtainInt32(ec_crrr_rctb_decelaration);
    req->prop = toInt(VehicleProperty::GECKO_CRRR_RCTB_DECELARATION);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_crrr_rctb_reqWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_crrr_rctb_req = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_crrr_rctb_req");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_crrr_rctb_req = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_crrr_rctb_reqReq(ec_crrr_rctb_req),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_crrr_rctb_reqReq(int32_t ec_crrr_rctb_req) {
    auto req = mValueObjectPool->obtainInt32(ec_crrr_rctb_req);
    req->prop = toInt(VehicleProperty::GECKO_CRRR_RCTB_REQ);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_crrr_rctb_brkg_vldWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_crrr_rctb_brkg_vld = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_crrr_rctb_brkg_vld");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_crrr_rctb_brkg_vld = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_crrr_rctb_brkg_vldReq(ec_crrr_rctb_brkg_vld),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_crrr_rctb_brkg_vldReq(int32_t ec_crrr_rctb_brkg_vld) {
    auto req = mValueObjectPool->obtainInt32(ec_crrr_rctb_brkg_vld);
    req->prop = toInt(VehicleProperty::GECKO_CRRR_RCTB_BRKG_VLD);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_crrr_fov_chg_set_fbWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_crrr_fov_chg_set_fb = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_crrr_fov_chg_set_fb");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_crrr_fov_chg_set_fb = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_crrr_fov_chg_set_fbReq(ec_crrr_fov_chg_set_fb),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_crrr_fov_chg_set_fbReq(int32_t ec_crrr_fov_chg_set_fb) {
    auto req = mValueObjectPool->obtainInt32(ec_crrr_fov_chg_set_fb);
    req->prop = toInt(VehicleProperty::GECKO_CRRR_FOV_CHG_SET_FB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_max_con_dis_curntWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_max_con_dis_curnt = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_max_con_dis_curnt");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_max_con_dis_curnt = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_max_con_dis_curntReq(ec_bms_max_con_dis_curnt),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_max_con_dis_curntReq(int32_t ec_bms_max_con_dis_curnt) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_max_con_dis_curnt);
    req->prop = toInt(VehicleProperty::GECKO_BMS_MAX_CON_DIS_CURNT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_pwr_recup_max_con_chrg_curntWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_pwr_recup_max_con_chrg_curnt = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_pwr_recup_max_con_chrg_curnt");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_pwr_recup_max_con_chrg_curnt = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_pwr_recup_max_con_chrg_curntReq(ec_bms_pwr_recup_max_con_chrg_curnt),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_pwr_recup_max_con_chrg_curntReq(int32_t ec_bms_pwr_recup_max_con_chrg_curnt) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_pwr_recup_max_con_chrg_curnt);
    req->prop = toInt(VehicleProperty::GECKO_BMS_PWR_RECUP_MAX_CON_CHRG_CURNT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_max_instan_dis_curntWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_max_instan_dis_curnt = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_max_instan_dis_curnt");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_max_instan_dis_curnt = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_max_instan_dis_curntReq(ec_bms_max_instan_dis_curnt),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_max_instan_dis_curntReq(int32_t ec_bms_max_instan_dis_curnt) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_max_instan_dis_curnt);
    req->prop = toInt(VehicleProperty::GECKO_BMS_MAX_INSTAN_DIS_CURNT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_pwr_recup_max_instan_chrg_curntWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_pwr_recup_max_instan_chrg_curnt = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_pwr_recup_max_instan_chrg_curnt");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_pwr_recup_max_instan_chrg_curnt = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_pwr_recup_max_instan_chrg_curntReq(ec_bms_pwr_recup_max_instan_chrg_curnt),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_pwr_recup_max_instan_chrg_curntReq(int32_t ec_bms_pwr_recup_max_instan_chrg_curnt) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_pwr_recup_max_instan_chrg_curnt);
    req->prop = toInt(VehicleProperty::GECKO_BMS_PWR_RECUP_MAX_INSTAN_CHRG_CURNT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_cell_vol_aveWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_cell_vol_ave = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_cell_vol_ave");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_cell_vol_ave = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_cell_vol_aveReq(ec_bms_cell_vol_ave),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_cell_vol_aveReq(int32_t ec_bms_cell_vol_ave) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_cell_vol_ave);
    req->prop = toInt(VehicleProperty::GECKO_BMS_CELL_VOL_AVE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_contactor_temp_negativeWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_contactor_temp_negative = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_contactor_temp_negative");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_contactor_temp_negative = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_contactor_temp_negativeReq(ec_bms_contactor_temp_negative),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_contactor_temp_negativeReq(int32_t ec_bms_contactor_temp_negative) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_contactor_temp_negative);
    req->prop = toInt(VehicleProperty::GECKO_BMS_CONTACTOR_TEMP_NEGATIVE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_max_cell_temp_limitWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_max_cell_temp_limit = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_max_cell_temp_limit");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_max_cell_temp_limit = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_max_cell_temp_limitReq(ec_bms_max_cell_temp_limit),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_max_cell_temp_limitReq(int32_t ec_bms_max_cell_temp_limit) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_max_cell_temp_limit);
    req->prop = toInt(VehicleProperty::GECKO_BMS_MAX_CELL_TEMP_LIMIT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_max_cell_vol_limitWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_max_cell_vol_limit = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_max_cell_vol_limit");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_max_cell_vol_limit = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_max_cell_vol_limitReq(ec_bms_max_cell_vol_limit),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_max_cell_vol_limitReq(int32_t ec_bms_max_cell_vol_limit) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_max_cell_vol_limit);
    req->prop = toInt(VehicleProperty::GECKO_BMS_MAX_CELL_VOL_LIMIT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_pwr_limd_flgWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_pwr_limd_flg = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_pwr_limd_flg");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_pwr_limd_flg = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_pwr_limd_flgReq(ec_bms_pwr_limd_flg),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_pwr_limd_flgReq(int32_t ec_bms_pwr_limd_flg) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_pwr_limd_flg);
    req->prop = toInt(VehicleProperty::GECKO_BMS_PWR_LIMD_FLG);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_min_cell_temp_limitWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_min_cell_temp_limit = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_min_cell_temp_limit");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_min_cell_temp_limit = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_min_cell_temp_limitReq(ec_bms_min_cell_temp_limit),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_min_cell_temp_limitReq(int32_t ec_bms_min_cell_temp_limit) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_min_cell_temp_limit);
    req->prop = toInt(VehicleProperty::GECKO_BMS_MIN_CELL_TEMP_LIMIT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_min_cell_vol_limitWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_min_cell_vol_limit = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_min_cell_vol_limit");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_min_cell_vol_limit = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_min_cell_vol_limitReq(ec_bms_min_cell_vol_limit),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_min_cell_vol_limitReq(int32_t ec_bms_min_cell_vol_limit) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_min_cell_vol_limit);
    req->prop = toInt(VehicleProperty::GECKO_BMS_MIN_CELL_VOL_LIMIT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_err_tab_indexWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_err_tab_index = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_err_tab_index");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_err_tab_index = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_err_tab_indexReq(ec_bms_err_tab_index),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_err_tab_indexReq(int32_t ec_bms_err_tab_index) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_err_tab_index);
    req->prop = toInt(VehicleProperty::GECKO_BMS_ERR_TAB_INDEX);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_battery_typeWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_battery_type = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_battery_type");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_battery_type = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_battery_typeReq(ec_bms_battery_type),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_battery_typeReq(int32_t ec_bms_battery_type) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_battery_type);
    req->prop = toInt(VehicleProperty::GECKO_BMS_BATTERY_TYPE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_hw_versionWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_hw_version = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_hw_version");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_hw_version = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_hw_versionReq(ec_bms_hw_version),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_hw_versionReq(int32_t ec_bms_hw_version) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_hw_version);
    req->prop = toInt(VehicleProperty::GECKO_BMS_HW_VERSION);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_pack_identityWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_pack_identity = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_pack_identity");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_pack_identity = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_pack_identityReq(ec_bms_pack_identity),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_pack_identityReq(int32_t ec_bms_pack_identity) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_pack_identity);
    req->prop = toInt(VehicleProperty::GECKO_BMS_PACK_IDENTITY);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_nom_cell_capWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_nom_cell_cap = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_nom_cell_cap");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_nom_cell_cap = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_nom_cell_capReq(ec_bms_nom_cell_cap),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_nom_cell_capReq(int32_t ec_bms_nom_cell_cap) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_nom_cell_cap);
    req->prop = toInt(VehicleProperty::GECKO_BMS_NOM_CELL_CAP);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_bat_capacityWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_bat_capacity = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_bat_capacity");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_bat_capacity = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_bat_capacityReq(ec_bms_bat_capacity),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_bat_capacityReq(int32_t ec_bms_bat_capacity) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_bat_capacity);
    req->prop = toInt(VehicleProperty::GECKO_BMS_BAT_CAPACITY);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bem_spn2560_aaReq(int32_t ec_bem_spn2560_aa) {
    auto req = mValueObjectPool->obtainInt32(ec_bem_spn2560_aa);
    req->prop = toInt(VehicleProperty::GECKO_BEM_SPN2560_AA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bem_spn2560_00Req(int32_t ec_bem_spn2560_00) {
    auto req = mValueObjectPool->obtainInt32(ec_bem_spn2560_00);
    req->prop = toInt(VehicleProperty::GECKO_BEM_SPN2560_00);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bem_spn3904_croReq(int32_t ec_bem_spn3904_cro) {
    auto req = mValueObjectPool->obtainInt32(ec_bem_spn3904_cro);
    req->prop = toInt(VehicleProperty::GECKO_BEM_SPN3904_CRO);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bem_spn3903_cml_ctsReq(int32_t ec_bem_spn3903_cml_cts) {
    auto req = mValueObjectPool->obtainInt32(ec_bem_spn3903_cml_cts);
    req->prop = toInt(VehicleProperty::GECKO_BEM_SPN3903_CML_CTS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bem_spn3906_cstReq(int32_t ec_bem_spn3906_cst) {
    auto req = mValueObjectPool->obtainInt32(ec_bem_spn3906_cst);
    req->prop = toInt(VehicleProperty::GECKO_BEM_SPN3906_CST);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bem_spn3905_ccsReq(int32_t ec_bem_spn3905_ccs) {
    auto req = mValueObjectPool->obtainInt32(ec_bem_spn3905_ccs);
    req->prop = toInt(VehicleProperty::GECKO_BEM_SPN3905_CCS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bem_spn3907_csdReq(int32_t ec_bem_spn3907_csd) {
    auto req = mValueObjectPool->obtainInt32(ec_bem_spn3907_csd);
    req->prop = toInt(VehicleProperty::GECKO_BEM_SPN3907_CSD);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_cem_bms_identify_timoutReq(int32_t ec_cem_bms_identify_timout) {
    auto req = mValueObjectPool->obtainInt32(ec_cem_bms_identify_timout);
    req->prop = toInt(VehicleProperty::GECKO_CEM_BMS_IDENTIFY_TIMOUT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_cem_bms_finish_charge_timeoutReq(int32_t ec_cem_bms_finish_charge_timeout) {
    auto req = mValueObjectPool->obtainInt32(ec_cem_bms_finish_charge_timeout);
    req->prop = toInt(VehicleProperty::GECKO_CEM_BMS_FINISH_CHARGE_TIMEOUT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_cem_battery_parameter_timoutReq(int32_t ec_cem_battery_parameter_timout) {
    auto req = mValueObjectPool->obtainInt32(ec_cem_battery_parameter_timout);
    req->prop = toInt(VehicleProperty::GECKO_CEM_BATTERY_PARAMETER_TIMOUT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_cem_bms_abort_charge_timeoutReq(int32_t ec_cem_bms_abort_charge_timeout) {
    auto req = mValueObjectPool->obtainInt32(ec_cem_bms_abort_charge_timeout);
    req->prop = toInt(VehicleProperty::GECKO_CEM_BMS_ABORT_CHARGE_TIMEOUT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_cem_battery_charge_require_timeoutReq(int32_t ec_cem_battery_charge_require_timeout) {
    auto req = mValueObjectPool->obtainInt32(ec_cem_battery_charge_require_timeout);
    req->prop = toInt(VehicleProperty::GECKO_CEM_BATTERY_CHARGE_REQUIRE_TIMEOUT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_cem_battery_state_timeoutReq(int32_t ec_cem_battery_state_timeout) {
    auto req = mValueObjectPool->obtainInt32(ec_cem_battery_state_timeout);
    req->prop = toInt(VehicleProperty::GECKO_CEM_BATTERY_STATE_TIMEOUT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_cem_bms_charge_statistics_timeoutReq(int32_t ec_cem_bms_charge_statistics_timeout) {
    auto req = mValueObjectPool->obtainInt32(ec_cem_bms_charge_statistics_timeout);
    req->prop = toInt(VehicleProperty::GECKO_CEM_BMS_CHARGE_STATISTICS_TIMEOUT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bst_abort_achive_dcsReq(int32_t ec_bst_abort_achive_dcs) {
    auto req = mValueObjectPool->obtainInt32(ec_bst_abort_achive_dcs);
    req->prop = toInt(VehicleProperty::GECKO_BST_ABORT_ACHIVE_DCS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bst_abort_achive_single_voltReq(int32_t ec_bst_abort_achive_single_volt) {
    auto req = mValueObjectPool->obtainInt32(ec_bst_abort_achive_single_volt);
    req->prop = toInt(VehicleProperty::GECKO_BST_ABORT_ACHIVE_SINGLE_VOLT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bst_abort_achive_total_voltReq(int32_t ec_bst_abort_achive_total_volt) {
    auto req = mValueObjectPool->obtainInt32(ec_bst_abort_achive_total_volt);
    req->prop = toInt(VehicleProperty::GECKO_BST_ABORT_ACHIVE_TOTAL_VOLT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bst_abort_achive_socReq(int32_t ec_bst_abort_achive_soc) {
    auto req = mValueObjectPool->obtainInt32(ec_bst_abort_achive_soc);
    req->prop = toInt(VehicleProperty::GECKO_BST_ABORT_ACHIVE_SOC);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bst_abort_fault_connectorReq(int32_t ec_bst_abort_fault_connector) {
    auto req = mValueObjectPool->obtainInt32(ec_bst_abort_fault_connector);
    req->prop = toInt(VehicleProperty::GECKO_BST_ABORT_FAULT_CONNECTOR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bst_abort_fault_bms_tempReq(int32_t ec_bst_abort_fault_bms_temp) {
    auto req = mValueObjectPool->obtainInt32(ec_bst_abort_fault_bms_temp);
    req->prop = toInt(VehicleProperty::GECKO_BST_ABORT_FAULT_BMS_TEMP);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bst_abort_fault_connector_tempReq(int32_t ec_bst_abort_fault_connector_temp) {
    auto req = mValueObjectPool->obtainInt32(ec_bst_abort_fault_connector_temp);
    req->prop = toInt(VehicleProperty::GECKO_BST_ABORT_FAULT_CONNECTOR_TEMP);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bst_abort_fault_insulationReq(int32_t ec_bst_abort_fault_insulation) {
    auto req = mValueObjectPool->obtainInt32(ec_bst_abort_fault_insulation);
    req->prop = toInt(VehicleProperty::GECKO_BST_ABORT_FAULT_INSULATION);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bst_abort_fault_otherReq(int32_t ec_bst_abort_fault_other) {
    auto req = mValueObjectPool->obtainInt32(ec_bst_abort_fault_other);
    req->prop = toInt(VehicleProperty::GECKO_BST_ABORT_FAULT_OTHER);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bst_abort_fault_voltageReq(int32_t ec_bst_abort_fault_voltage) {
    auto req = mValueObjectPool->obtainInt32(ec_bst_abort_fault_voltage);
    req->prop = toInt(VehicleProperty::GECKO_BST_ABORT_FAULT_VOLTAGE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bst_abort_fault_hvReq(int32_t ec_bst_abort_fault_hv) {
    auto req = mValueObjectPool->obtainInt32(ec_bst_abort_fault_hv);
    req->prop = toInt(VehicleProperty::GECKO_BST_ABORT_FAULT_HV);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bst_abort_fault_battery_tempReq(int32_t ec_bst_abort_fault_battery_temp) {
    auto req = mValueObjectPool->obtainInt32(ec_bst_abort_fault_battery_temp);
    req->prop = toInt(VehicleProperty::GECKO_BST_ABORT_FAULT_BATTERY_TEMP);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bst_abort_error_voltageReq(int32_t ec_bst_abort_error_voltage) {
    auto req = mValueObjectPool->obtainInt32(ec_bst_abort_error_voltage);
    req->prop = toInt(VehicleProperty::GECKO_BST_ABORT_ERROR_VOLTAGE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bst_abort_error_currentReq(int32_t ec_bst_abort_error_current) {
    auto req = mValueObjectPool->obtainInt32(ec_bst_abort_error_current);
    req->prop = toInt(VehicleProperty::GECKO_BST_ABORT_ERROR_CURRENT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_cst_abort_by_bmsWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_cst_abort_by_bms = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_cst_abort_by_bms");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_cst_abort_by_bms = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_cst_abort_by_bmsReq(ec_cst_abort_by_bms),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_cst_abort_by_bmsReq(int32_t ec_cst_abort_by_bms) {
    auto req = mValueObjectPool->obtainInt32(ec_cst_abort_by_bms);
    req->prop = toInt(VehicleProperty::GECKO_CST_ABORT_BY_BMS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_cst_abort_by_faultWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_cst_abort_by_fault = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_cst_abort_by_fault");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_cst_abort_by_fault = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_cst_abort_by_faultReq(ec_cst_abort_by_fault),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_cst_abort_by_faultReq(int32_t ec_cst_abort_by_fault) {
    auto req = mValueObjectPool->obtainInt32(ec_cst_abort_by_fault);
    req->prop = toInt(VehicleProperty::GECKO_CST_ABORT_BY_FAULT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_cst_abort_by_userWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_cst_abort_by_user = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_cst_abort_by_user");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_cst_abort_by_user = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_cst_abort_by_userReq(ec_cst_abort_by_user),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_cst_abort_by_userReq(int32_t ec_cst_abort_by_user) {
    auto req = mValueObjectPool->obtainInt32(ec_cst_abort_by_user);
    req->prop = toInt(VehicleProperty::GECKO_CST_ABORT_BY_USER);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_cst_abort_achive_conditionWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_cst_abort_achive_condition = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_cst_abort_achive_condition");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_cst_abort_achive_condition = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_cst_abort_achive_conditionReq(ec_cst_abort_achive_condition),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_cst_abort_achive_conditionReq(int32_t ec_cst_abort_achive_condition) {
    auto req = mValueObjectPool->obtainInt32(ec_cst_abort_achive_condition);
    req->prop = toInt(VehicleProperty::GECKO_CST_ABORT_ACHIVE_CONDITION);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_cst_abort_fault_energe_transmitWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_cst_abort_fault_energe_transmit = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_cst_abort_fault_energe_transmit");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_cst_abort_fault_energe_transmit = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_cst_abort_fault_energe_transmitReq(ec_cst_abort_fault_energe_transmit),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_cst_abort_fault_energe_transmitReq(int32_t ec_cst_abort_fault_energe_transmit) {
    auto req = mValueObjectPool->obtainInt32(ec_cst_abort_fault_energe_transmit);
    req->prop = toInt(VehicleProperty::GECKO_CST_ABORT_FAULT_ENERGE_TRANSMIT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_cst_abort_fault_charger_inner_tempWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_cst_abort_fault_charger_inner_temp = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_cst_abort_fault_charger_inner_temp");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_cst_abort_fault_charger_inner_temp = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_cst_abort_fault_charger_inner_tempReq(ec_cst_abort_fault_charger_inner_temp),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_cst_abort_fault_charger_inner_tempReq(int32_t ec_cst_abort_fault_charger_inner_temp) {
    auto req = mValueObjectPool->obtainInt32(ec_cst_abort_fault_charger_inner_temp);
    req->prop = toInt(VehicleProperty::GECKO_CST_ABORT_FAULT_CHARGER_INNER_TEMP);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_cst_abort_fault_connetorWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_cst_abort_fault_connetor = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_cst_abort_fault_connetor");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_cst_abort_fault_connetor = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_cst_abort_fault_connetorReq(ec_cst_abort_fault_connetor),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_cst_abort_fault_connetorReq(int32_t ec_cst_abort_fault_connetor) {
    auto req = mValueObjectPool->obtainInt32(ec_cst_abort_fault_connetor);
    req->prop = toInt(VehicleProperty::GECKO_CST_ABORT_FAULT_CONNETOR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_cst_abort_fault_charger_tempWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_cst_abort_fault_charger_temp = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_cst_abort_fault_charger_temp");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_cst_abort_fault_charger_temp = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_cst_abort_fault_charger_tempReq(ec_cst_abort_fault_charger_temp),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_cst_abort_fault_charger_tempReq(int32_t ec_cst_abort_fault_charger_temp) {
    auto req = mValueObjectPool->obtainInt32(ec_cst_abort_fault_charger_temp);
    req->prop = toInt(VehicleProperty::GECKO_CST_ABORT_FAULT_CHARGER_TEMP);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_cst_abort_fault_otherWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_cst_abort_fault_other = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_cst_abort_fault_other");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_cst_abort_fault_other = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_cst_abort_fault_otherReq(ec_cst_abort_fault_other),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_cst_abort_fault_otherReq(int32_t ec_cst_abort_fault_other) {
    auto req = mValueObjectPool->obtainInt32(ec_cst_abort_fault_other);
    req->prop = toInt(VehicleProperty::GECKO_CST_ABORT_FAULT_OTHER);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_cst_abort_fault_charger_stopWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_cst_abort_fault_charger_stop = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_cst_abort_fault_charger_stop");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_cst_abort_fault_charger_stop = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_cst_abort_fault_charger_stopReq(ec_cst_abort_fault_charger_stop),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_cst_abort_fault_charger_stopReq(int32_t ec_cst_abort_fault_charger_stop) {
    auto req = mValueObjectPool->obtainInt32(ec_cst_abort_fault_charger_stop);
    req->prop = toInt(VehicleProperty::GECKO_CST_ABORT_FAULT_CHARGER_STOP);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_cst_abort_error_voltageWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_cst_abort_error_voltage = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_cst_abort_error_voltage");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_cst_abort_error_voltage = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_cst_abort_error_voltageReq(ec_cst_abort_error_voltage),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_cst_abort_error_voltageReq(int32_t ec_cst_abort_error_voltage) {
    auto req = mValueObjectPool->obtainInt32(ec_cst_abort_error_voltage);
    req->prop = toInt(VehicleProperty::GECKO_CST_ABORT_ERROR_VOLTAGE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_cst_abort_error_currentWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_cst_abort_error_current = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_cst_abort_error_current");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_cst_abort_error_current = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_cst_abort_error_currentReq(ec_cst_abort_error_current),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_cst_abort_error_currentReq(int32_t ec_cst_abort_error_current) {
    auto req = mValueObjectPool->obtainInt32(ec_cst_abort_error_current);
    req->prop = toInt(VehicleProperty::GECKO_CST_ABORT_ERROR_CURRENT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bcm_rear_view_mirr_heating_stsWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bcm_rear_view_mirr_heating_sts = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bcm_rear_view_mirr_heating_sts");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bcm_rear_view_mirr_heating_sts = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bcm_rear_view_mirr_heating_stsReq(ec_bcm_rear_view_mirr_heating_sts),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bcm_rear_view_mirr_heating_stsReq(int32_t ec_bcm_rear_view_mirr_heating_sts) {
    auto req = mValueObjectPool->obtainInt32(ec_bcm_rear_view_mirr_heating_sts);
    req->prop = toInt(VehicleProperty::GECKO_BCM_REAR_VIEW_MIRR_HEATING_STS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_tms_ohx_out_tmpWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_tms_ohx_out_tmp = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_tms_ohx_out_tmp");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_tms_ohx_out_tmp = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_tms_ohx_out_tmpReq(ec_tms_ohx_out_tmp),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_tms_ohx_out_tmpReq(int32_t ec_tms_ohx_out_tmp) {
    auto req = mValueObjectPool->obtainInt32(ec_tms_ohx_out_tmp);
    req->prop = toInt(VehicleProperty::GECKO_TMS_OHX_OUT_TMP);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_tms_evap_tmpWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_tms_evap_tmp = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_tms_evap_tmp");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_tms_evap_tmp = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_tms_evap_tmpReq(ec_tms_evap_tmp),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_tms_evap_tmpReq(int32_t ec_tms_evap_tmp) {
    auto req = mValueObjectPool->obtainInt32(ec_tms_evap_tmp);
    req->prop = toInt(VehicleProperty::GECKO_TMS_EVAP_TMP);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_tms_evap_out_tmpWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_tms_evap_out_tmp = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_tms_evap_out_tmp");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_tms_evap_out_tmp = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_tms_evap_out_tmpReq(ec_tms_evap_out_tmp),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_tms_evap_out_tmpReq(int32_t ec_tms_evap_out_tmp) {
    auto req = mValueObjectPool->obtainInt32(ec_tms_evap_out_tmp);
    req->prop = toInt(VehicleProperty::GECKO_TMS_EVAP_OUT_TMP);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_tms_chiller_out_tmpWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_tms_chiller_out_tmp = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_tms_chiller_out_tmp");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_tms_chiller_out_tmp = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_tms_chiller_out_tmpReq(ec_tms_chiller_out_tmp),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_tms_chiller_out_tmpReq(int32_t ec_tms_chiller_out_tmp) {
    auto req = mValueObjectPool->obtainInt32(ec_tms_chiller_out_tmp);
    req->prop = toInt(VehicleProperty::GECKO_TMS_CHILLER_OUT_TMP);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bcm_high_beam_li_fault_fbWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bcm_high_beam_li_fault_fb = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bcm_high_beam_li_fault_fb");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bcm_high_beam_li_fault_fb = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bcm_high_beam_li_fault_fbReq(ec_bcm_high_beam_li_fault_fb),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bcm_high_beam_li_fault_fbReq(int32_t ec_bcm_high_beam_li_fault_fb) {
    auto req = mValueObjectPool->obtainInt32(ec_bcm_high_beam_li_fault_fb);
    req->prop = toInt(VehicleProperty::GECKO_BCM_HIGH_BEAM_LI_FAULT_FB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bcm_low_beam_li_fault_fbWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bcm_low_beam_li_fault_fb = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bcm_low_beam_li_fault_fb");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bcm_low_beam_li_fault_fb = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bcm_low_beam_li_fault_fbReq(ec_bcm_low_beam_li_fault_fb),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bcm_low_beam_li_fault_fbReq(int32_t ec_bcm_low_beam_li_fault_fb) {
    auto req = mValueObjectPool->obtainInt32(ec_bcm_low_beam_li_fault_fb);
    req->prop = toInt(VehicleProperty::GECKO_BCM_LOW_BEAM_LI_FAULT_FB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bcm_vhcl_seekWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bcm_vhcl_seek = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bcm_vhcl_seek");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bcm_vhcl_seek = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bcm_vhcl_seekReq(ec_bcm_vhcl_seek),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bcm_vhcl_seekReq(int32_t ec_bcm_vhcl_seek) {
    auto req = mValueObjectPool->obtainInt32(ec_bcm_vhcl_seek);
    req->prop = toInt(VehicleProperty::GECKO_BCM_VHCL_SEEK);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bcm_illmnd_stsWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bcm_illmnd_sts = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bcm_illmnd_sts");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bcm_illmnd_sts = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bcm_illmnd_stsReq(ec_bcm_illmnd_sts),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bcm_illmnd_stsReq(int32_t ec_bcm_illmnd_sts) {
    auto req = mValueObjectPool->obtainInt32(ec_bcm_illmnd_sts);
    req->prop = toInt(VehicleProperty::GECKO_BCM_ILLMND_STS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bcm_key_frbdnWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bcm_key_frbdn = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bcm_key_frbdn");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bcm_key_frbdn = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bcm_key_frbdnReq(ec_bcm_key_frbdn),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bcm_key_frbdnReq(int32_t ec_bcm_key_frbdn) {
    auto req = mValueObjectPool->obtainInt32(ec_bcm_key_frbdn);
    req->prop = toInt(VehicleProperty::GECKO_BCM_KEY_FRBDN);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bcm_frbdn_key_nrWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bcm_frbdn_key_nr = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bcm_frbdn_key_nr");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bcm_frbdn_key_nr = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bcm_frbdn_key_nrReq(ec_bcm_frbdn_key_nr),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bcm_frbdn_key_nrReq(int32_t ec_bcm_frbdn_key_nr) {
    auto req = mValueObjectPool->obtainInt32(ec_bcm_frbdn_key_nr);
    req->prop = toInt(VehicleProperty::GECKO_BCM_FRBDN_KEY_NR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bcm_start_reqWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bcm_start_req = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bcm_start_req");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bcm_start_req = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bcm_start_reqReq(ec_bcm_start_req),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bcm_start_reqReq(int32_t ec_bcm_start_req) {
    auto req = mValueObjectPool->obtainInt32(ec_bcm_start_req);
    req->prop = toInt(VehicleProperty::GECKO_BCM_START_REQ);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bcm_drv_pe_authent_acsdWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bcm_drv_pe_authent_acsd = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bcm_drv_pe_authent_acsd");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bcm_drv_pe_authent_acsd = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bcm_drv_pe_authent_acsdReq(ec_bcm_drv_pe_authent_acsd),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bcm_drv_pe_authent_acsdReq(int32_t ec_bcm_drv_pe_authent_acsd) {
    auto req = mValueObjectPool->obtainInt32(ec_bcm_drv_pe_authent_acsd);
    req->prop = toInt(VehicleProperty::GECKO_BCM_DRV_PE_AUTHENT_ACSD);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bcm_frpe_authent_acsdWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bcm_frpe_authent_acsd = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bcm_frpe_authent_acsd");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bcm_frpe_authent_acsd = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bcm_frpe_authent_acsdReq(ec_bcm_frpe_authent_acsd),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bcm_frpe_authent_acsdReq(int32_t ec_bcm_frpe_authent_acsd) {
    auto req = mValueObjectPool->obtainInt32(ec_bcm_frpe_authent_acsd);
    req->prop = toInt(VehicleProperty::GECKO_BCM_FRPE_AUTHENT_ACSD);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bcm_ps_reqWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bcm_ps_req = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bcm_ps_req");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bcm_ps_req = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bcm_ps_reqReq(ec_bcm_ps_req),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bcm_ps_reqReq(int32_t ec_bcm_ps_req) {
    auto req = mValueObjectPool->obtainInt32(ec_bcm_ps_req);
    req->prop = toInt(VehicleProperty::GECKO_BCM_PS_REQ);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bcm_frnt_le_door_hndl_swtWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bcm_frnt_le_door_hndl_swt = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bcm_frnt_le_door_hndl_swt");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bcm_frnt_le_door_hndl_swt = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bcm_frnt_le_door_hndl_swtReq(ec_bcm_frnt_le_door_hndl_swt),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bcm_frnt_le_door_hndl_swtReq(int32_t ec_bcm_frnt_le_door_hndl_swt) {
    auto req = mValueObjectPool->obtainInt32(ec_bcm_frnt_le_door_hndl_swt);
    req->prop = toInt(VehicleProperty::GECKO_BCM_FRNT_LE_DOOR_HNDL_SWT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bcm_frnt_ri_door_hndl_swtWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bcm_frnt_ri_door_hndl_swt = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bcm_frnt_ri_door_hndl_swt");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bcm_frnt_ri_door_hndl_swt = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bcm_frnt_ri_door_hndl_swtReq(ec_bcm_frnt_ri_door_hndl_swt),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bcm_frnt_ri_door_hndl_swtReq(int32_t ec_bcm_frnt_ri_door_hndl_swt) {
    auto req = mValueObjectPool->obtainInt32(ec_bcm_frnt_ri_door_hndl_swt);
    req->prop = toInt(VehicleProperty::GECKO_BCM_FRNT_RI_DOOR_HNDL_SWT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bcm_save_power_staWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bcm_save_power_sta = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bcm_save_power_sta");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bcm_save_power_sta = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bcm_save_power_staReq(ec_bcm_save_power_sta),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bcm_save_power_staReq(int32_t ec_bcm_save_power_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_bcm_save_power_sta);
    req->prop = toInt(VehicleProperty::GECKO_BCM_SAVE_POWER_STA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bcm_front_wiper_motor_stsWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bcm_front_wiper_motor_sts = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bcm_front_wiper_motor_sts");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bcm_front_wiper_motor_sts = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bcm_front_wiper_motor_stsReq(ec_bcm_front_wiper_motor_sts),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bcm_front_wiper_motor_stsReq(int32_t ec_bcm_front_wiper_motor_sts) {
    auto req = mValueObjectPool->obtainInt32(ec_bcm_front_wiper_motor_sts);
    req->prop = toInt(VehicleProperty::GECKO_BCM_FRONT_WIPER_MOTOR_STS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bcm_fl_window_stsWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bcm_fl_window_sts = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bcm_fl_window_sts");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bcm_fl_window_sts = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bcm_fl_window_stsReq(ec_bcm_fl_window_sts),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bcm_fl_window_stsReq(int32_t ec_bcm_fl_window_sts) {
    auto req = mValueObjectPool->obtainInt32(ec_bcm_fl_window_sts);
    req->prop = toInt(VehicleProperty::GECKO_BCM_FL_WINDOW_STS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bcm_fr_window_stsWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bcm_fr_window_sts = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bcm_fr_window_sts");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bcm_fr_window_sts = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bcm_fr_window_stsReq(ec_bcm_fr_window_sts),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bcm_fr_window_stsReq(int32_t ec_bcm_fr_window_sts) {
    auto req = mValueObjectPool->obtainInt32(ec_bcm_fr_window_sts);
    req->prop = toInt(VehicleProperty::GECKO_BCM_FR_WINDOW_STS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bcm_fl_windowmotor_stsWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bcm_fl_windowmotor_sts = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bcm_fl_windowmotor_sts");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bcm_fl_windowmotor_sts = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bcm_fl_windowmotor_stsReq(ec_bcm_fl_windowmotor_sts),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bcm_fl_windowmotor_stsReq(int32_t ec_bcm_fl_windowmotor_sts) {
    auto req = mValueObjectPool->obtainInt32(ec_bcm_fl_windowmotor_sts);
    req->prop = toInt(VehicleProperty::GECKO_BCM_FL_WINDOWMOTOR_STS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bcm_fr_windowmotor_stsWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bcm_fr_windowmotor_sts = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bcm_fr_windowmotor_sts");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bcm_fr_windowmotor_sts = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bcm_fr_windowmotor_stsReq(ec_bcm_fr_windowmotor_sts),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bcm_fr_windowmotor_stsReq(int32_t ec_bcm_fr_windowmotor_sts) {
    auto req = mValueObjectPool->obtainInt32(ec_bcm_fr_windowmotor_sts);
    req->prop = toInt(VehicleProperty::GECKO_BCM_FR_WINDOWMOTOR_STS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bcm_wiper_ctrl_frontWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bcm_wiper_ctrl_front = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bcm_wiper_ctrl_front");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bcm_wiper_ctrl_front = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bcm_wiper_ctrl_frontReq(ec_bcm_wiper_ctrl_front),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bcm_wiper_ctrl_frontReq(int32_t ec_bcm_wiper_ctrl_front) {
    auto req = mValueObjectPool->obtainInt32(ec_bcm_wiper_ctrl_front);
    req->prop = toInt(VehicleProperty::GECKO_BCM_WIPER_CTRL_FRONT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bcm_drv_seat_occupant_sensor_stsWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bcm_drv_seat_occupant_sensor_sts = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bcm_drv_seat_occupant_sensor_sts");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bcm_drv_seat_occupant_sensor_sts = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bcm_drv_seat_occupant_sensor_stsReq(ec_bcm_drv_seat_occupant_sensor_sts),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bcm_drv_seat_occupant_sensor_stsReq(int32_t ec_bcm_drv_seat_occupant_sensor_sts) {
    auto req = mValueObjectPool->obtainInt32(ec_bcm_drv_seat_occupant_sensor_sts);
    req->prop = toInt(VehicleProperty::GECKO_BCM_DRV_SEAT_OCCUPANT_SENSOR_STS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bcm_heavy_rain_indWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bcm_heavy_rain_ind = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bcm_heavy_rain_ind");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bcm_heavy_rain_ind = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bcm_heavy_rain_indReq(ec_bcm_heavy_rain_ind),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bcm_heavy_rain_indReq(int32_t ec_bcm_heavy_rain_ind) {
    auto req = mValueObjectPool->obtainInt32(ec_bcm_heavy_rain_ind);
    req->prop = toInt(VehicleProperty::GECKO_BCM_HEAVY_RAIN_IND);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_tpms_pressure_value_rrWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_tpms_pressure_value_rr = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_tpms_pressure_value_rr");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_tpms_pressure_value_rr = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_tpms_pressure_value_rrReq(ec_tpms_pressure_value_rr),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_tpms_pressure_value_rrReq(int32_t ec_tpms_pressure_value_rr) {
    auto req = mValueObjectPool->obtainInt32(ec_tpms_pressure_value_rr);
    req->prop = toInt(VehicleProperty::GECKO_TPMS_PRESSURE_VALUE_RR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_tpms_pressure_value_rlWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_tpms_pressure_value_rl = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_tpms_pressure_value_rl");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_tpms_pressure_value_rl = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_tpms_pressure_value_rlReq(ec_tpms_pressure_value_rl),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_tpms_pressure_value_rlReq(int32_t ec_tpms_pressure_value_rl) {
    auto req = mValueObjectPool->obtainInt32(ec_tpms_pressure_value_rl);
    req->prop = toInt(VehicleProperty::GECKO_TPMS_PRESSURE_VALUE_RL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_tpms_pressure_sta_rlWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_tpms_pressure_sta_rl = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_tpms_pressure_sta_rl");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_tpms_pressure_sta_rl = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_tpms_pressure_sta_rlReq(ec_tpms_pressure_sta_rl),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_tpms_pressure_sta_rlReq(int32_t ec_tpms_pressure_sta_rl) {
    auto req = mValueObjectPool->obtainInt32(ec_tpms_pressure_sta_rl);
    req->prop = toInt(VehicleProperty::GECKO_TPMS_PRESSURE_STA_RL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_tpms_pressure_sta_rrWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_tpms_pressure_sta_rr = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_tpms_pressure_sta_rr");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_tpms_pressure_sta_rr = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_tpms_pressure_sta_rrReq(ec_tpms_pressure_sta_rr),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_tpms_pressure_sta_rrReq(int32_t ec_tpms_pressure_sta_rr) {
    auto req = mValueObjectPool->obtainInt32(ec_tpms_pressure_sta_rr);
    req->prop = toInt(VehicleProperty::GECKO_TPMS_PRESSURE_STA_RR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_tpms_pressure_value_frWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_tpms_pressure_value_fr = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_tpms_pressure_value_fr");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_tpms_pressure_value_fr = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_tpms_pressure_value_frReq(ec_tpms_pressure_value_fr),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_tpms_pressure_value_frReq(int32_t ec_tpms_pressure_value_fr) {
    auto req = mValueObjectPool->obtainInt32(ec_tpms_pressure_value_fr);
    req->prop = toInt(VehicleProperty::GECKO_TPMS_PRESSURE_VALUE_FR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_tpms_pressure_value_flWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_tpms_pressure_value_fl = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_tpms_pressure_value_fl");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_tpms_pressure_value_fl = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_tpms_pressure_value_flReq(ec_tpms_pressure_value_fl),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_tpms_pressure_value_flReq(int32_t ec_tpms_pressure_value_fl) {
    auto req = mValueObjectPool->obtainInt32(ec_tpms_pressure_value_fl);
    req->prop = toInt(VehicleProperty::GECKO_TPMS_PRESSURE_VALUE_FL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_tpms_pressure_sta_flWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_tpms_pressure_sta_fl = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_tpms_pressure_sta_fl");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_tpms_pressure_sta_fl = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_tpms_pressure_sta_flReq(ec_tpms_pressure_sta_fl),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_tpms_pressure_sta_flReq(int32_t ec_tpms_pressure_sta_fl) {
    auto req = mValueObjectPool->obtainInt32(ec_tpms_pressure_sta_fl);
    req->prop = toInt(VehicleProperty::GECKO_TPMS_PRESSURE_STA_FL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_tpms_pressure_sta_frWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_tpms_pressure_sta_fr = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_tpms_pressure_sta_fr");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_tpms_pressure_sta_fr = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_tpms_pressure_sta_frReq(ec_tpms_pressure_sta_fr),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_tpms_pressure_sta_frReq(int32_t ec_tpms_pressure_sta_fr) {
    auto req = mValueObjectPool->obtainInt32(ec_tpms_pressure_sta_fr);
    req->prop = toInt(VehicleProperty::GECKO_TPMS_PRESSURE_STA_FR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bcm_dome_light_staWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bcm_dome_light_sta = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bcm_dome_light_sta");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bcm_dome_light_sta = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bcm_dome_light_staReq(ec_bcm_dome_light_sta),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bcm_dome_light_staReq(int32_t ec_bcm_dome_light_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_bcm_dome_light_sta);
    req->prop = toInt(VehicleProperty::GECKO_BCM_DOME_LIGHT_STA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bcm_back_lamp_staWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bcm_back_lamp_sta = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bcm_back_lamp_sta");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bcm_back_lamp_sta = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bcm_back_lamp_staReq(ec_bcm_back_lamp_sta),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bcm_back_lamp_staReq(int32_t ec_bcm_back_lamp_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_bcm_back_lamp_sta);
    req->prop = toInt(VehicleProperty::GECKO_BCM_BACK_LAMP_STA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bcm_bass_horn_reqWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bcm_bass_horn_req = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bcm_bass_horn_req");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bcm_bass_horn_req = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bcm_bass_horn_reqReq(ec_bcm_bass_horn_req),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bcm_bass_horn_reqReq(int32_t ec_bcm_bass_horn_req) {
    auto req = mValueObjectPool->obtainInt32(ec_bcm_bass_horn_req);
    req->prop = toInt(VehicleProperty::GECKO_BCM_BASS_HORN_REQ);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bcm_ajar_sta_v_hoodWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bcm_ajar_sta_v_hood = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bcm_ajar_sta_v_hood");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bcm_ajar_sta_v_hood = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bcm_ajar_sta_v_hoodReq(ec_bcm_ajar_sta_v_hood),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bcm_ajar_sta_v_hoodReq(int32_t ec_bcm_ajar_sta_v_hood) {
    auto req = mValueObjectPool->obtainInt32(ec_bcm_ajar_sta_v_hood);
    req->prop = toInt(VehicleProperty::GECKO_BCM_AJAR_STA_V_HOOD);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bcm_frnt_fog_li_sw_sigWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bcm_frnt_fog_li_sw_sig = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bcm_frnt_fog_li_sw_sig");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bcm_frnt_fog_li_sw_sig = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bcm_frnt_fog_li_sw_sigReq(ec_bcm_frnt_fog_li_sw_sig),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bcm_frnt_fog_li_sw_sigReq(int32_t ec_bcm_frnt_fog_li_sw_sig) {
    auto req = mValueObjectPool->obtainInt32(ec_bcm_frnt_fog_li_sw_sig);
    req->prop = toInt(VehicleProperty::GECKO_BCM_FRNT_FOG_LI_SW_SIG);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bcm_rear_fog_li_sw_sigWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bcm_rear_fog_li_sw_sig = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bcm_rear_fog_li_sw_sig");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bcm_rear_fog_li_sw_sig = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bcm_rear_fog_li_sw_sigReq(ec_bcm_rear_fog_li_sw_sig),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bcm_rear_fog_li_sw_sigReq(int32_t ec_bcm_rear_fog_li_sw_sig) {
    auto req = mValueObjectPool->obtainInt32(ec_bcm_rear_fog_li_sw_sig);
    req->prop = toInt(VehicleProperty::GECKO_BCM_REAR_FOG_LI_SW_SIG);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bcm_day_run_light_staWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bcm_day_run_light_sta = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bcm_day_run_light_sta");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bcm_day_run_light_sta = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bcm_day_run_light_staReq(ec_bcm_day_run_light_sta),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bcm_day_run_light_staReq(int32_t ec_bcm_day_run_light_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_bcm_day_run_light_sta);
    req->prop = toInt(VehicleProperty::GECKO_BCM_DAY_RUN_LIGHT_STA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bcm_reverse_lamp_staWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bcm_reverse_lamp_sta = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bcm_reverse_lamp_sta");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bcm_reverse_lamp_sta = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bcm_reverse_lamp_staReq(ec_bcm_reverse_lamp_sta),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bcm_reverse_lamp_staReq(int32_t ec_bcm_reverse_lamp_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_bcm_reverse_lamp_sta);
    req->prop = toInt(VehicleProperty::GECKO_BCM_REVERSE_LAMP_STA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bcm_brake_lamp_staWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bcm_brake_lamp_sta = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bcm_brake_lamp_sta");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bcm_brake_lamp_sta = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bcm_brake_lamp_staReq(ec_bcm_brake_lamp_sta),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bcm_brake_lamp_staReq(int32_t ec_bcm_brake_lamp_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_bcm_brake_lamp_sta);
    req->prop = toInt(VehicleProperty::GECKO_BCM_BRAKE_LAMP_STA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bcm_turn_li_stsWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bcm_turn_li_sts = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bcm_turn_li_sts");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bcm_turn_li_sts = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bcm_turn_li_stsReq(ec_bcm_turn_li_sts),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bcm_turn_li_stsReq(int32_t ec_bcm_turn_li_sts) {
    auto req = mValueObjectPool->obtainInt32(ec_bcm_turn_li_sts);
    req->prop = toInt(VehicleProperty::GECKO_BCM_TURN_LI_STS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_act_whl_tqReq(int32_t ec_vcu_act_whl_tq) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_act_whl_tq);
    req->prop = toInt(VehicleProperty::GECKO_VCU_ACT_WHL_TQ);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_act_whl_tq_vldReq(int32_t ec_vcu_act_whl_tq_vld) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_act_whl_tq_vld);
    req->prop = toInt(VehicleProperty::GECKO_VCU_ACT_WHL_TQ_VLD);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_drv_req_whl_tqReq(int32_t ec_vcu_drv_req_whl_tq) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_drv_req_whl_tq);
    req->prop = toInt(VehicleProperty::GECKO_VCU_DRV_REQ_WHL_TQ);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_drv_whl_tq_allwd_maxReq(int32_t ec_vcu_drv_whl_tq_allwd_max) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_drv_whl_tq_allwd_max);
    req->prop = toInt(VehicleProperty::GECKO_VCU_DRV_WHL_TQ_ALLWD_MAX);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_pwr_recup_max_avlb_whl_tq_stsReq(int32_t ec_vcu_pwr_recup_max_avlb_whl_tq_sts) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_pwr_recup_max_avlb_whl_tq_sts);
    req->prop = toInt(VehicleProperty::GECKO_VCU_PWR_RECUP_MAX_AVLB_WHL_TQ_STS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_pwr_recup_actl_whl_tq_stsReq(int32_t ec_vcu_pwr_recup_actl_whl_tq_sts) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_pwr_recup_actl_whl_tq_sts);
    req->prop = toInt(VehicleProperty::GECKO_VCU_PWR_RECUP_ACTL_WHL_TQ_STS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_brk_pwr_recup_max_avlb_whl_tqReq(int32_t ec_vcu_brk_pwr_recup_max_avlb_whl_tq) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_brk_pwr_recup_max_avlb_whl_tq);
    req->prop = toInt(VehicleProperty::GECKO_VCU_BRK_PWR_RECUP_MAX_AVLB_WHL_TQ);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_pwr_recup_act_whl_tqReq(int32_t ec_vcu_pwr_recup_act_whl_tq) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_pwr_recup_act_whl_tq);
    req->prop = toInt(VehicleProperty::GECKO_VCU_PWR_RECUP_ACT_WHL_TQ);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_brk_pwr_recup_act_whl_tqReq(int32_t ec_vcu_brk_pwr_recup_act_whl_tq) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_brk_pwr_recup_act_whl_tq);
    req->prop = toInt(VehicleProperty::GECKO_VCU_BRK_PWR_RECUP_ACT_WHL_TQ);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_brk_pwr_recup_actl_whl_tq_stsReq(int32_t ec_vcu_brk_pwr_recup_actl_whl_tq_sts) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_brk_pwr_recup_actl_whl_tq_sts);
    req->prop = toInt(VehicleProperty::GECKO_VCU_BRK_PWR_RECUP_ACTL_WHL_TQ_STS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_acc_req_drive_offReq(int32_t ec_vcu_acc_req_drive_off) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_acc_req_drive_off);
    req->prop = toInt(VehicleProperty::GECKO_VCU_ACC_REQ_DRIVE_OFF);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_actl_motor_rotate_spdWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_vcu_actl_motor_rotate_spd = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_actl_motor_rotate_spd");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_vcu_actl_motor_rotate_spd = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_vcu_actl_motor_rotate_spdReq(ec_vcu_actl_motor_rotate_spd),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_actl_motor_rotate_spdReq(int32_t ec_vcu_actl_motor_rotate_spd) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_actl_motor_rotate_spd);
    req->prop = toInt(VehicleProperty::GECKO_VCU_ACTL_MOTOR_ROTATE_SPD);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_actl_motor_rotate_spd_vWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_vcu_actl_motor_rotate_spd_v = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_actl_motor_rotate_spd_v");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_vcu_actl_motor_rotate_spd_v = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_vcu_actl_motor_rotate_spd_vReq(ec_vcu_actl_motor_rotate_spd_v),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_actl_motor_rotate_spd_vReq(int32_t ec_vcu_actl_motor_rotate_spd_v) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_actl_motor_rotate_spd_v);
    req->prop = toInt(VehicleProperty::GECKO_VCU_ACTL_MOTOR_ROTATE_SPD_V);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_remt_ac_ctrl_stWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_vcu_remt_ac_ctrl_st = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_remt_ac_ctrl_st");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_vcu_remt_ac_ctrl_st = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_vcu_remt_ac_ctrl_stReq(ec_vcu_remt_ac_ctrl_st),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_remt_ac_ctrl_stReq(int32_t ec_vcu_remt_ac_ctrl_st) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_remt_ac_ctrl_st);
    req->prop = toInt(VehicleProperty::GECKO_VCU_REMT_AC_CTRL_ST);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_remt_ac_defrostl_reqWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_vcu_remt_ac_defrostl_req = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_remt_ac_defrostl_req");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_vcu_remt_ac_defrostl_req = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_vcu_remt_ac_defrostl_reqReq(ec_vcu_remt_ac_defrostl_req),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_remt_ac_defrostl_reqReq(int32_t ec_vcu_remt_ac_defrostl_req) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_remt_ac_defrostl_req);
    req->prop = toInt(VehicleProperty::GECKO_VCU_REMT_AC_DEFROSTL_REQ);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_remt_ac_ctrl_reqWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_vcu_remt_ac_ctrl_req = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_remt_ac_ctrl_req");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_vcu_remt_ac_ctrl_req = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_vcu_remt_ac_ctrl_reqReq(ec_vcu_remt_ac_ctrl_req),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_remt_ac_ctrl_reqReq(int32_t ec_vcu_remt_ac_ctrl_req) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_remt_ac_ctrl_req);
    req->prop = toInt(VehicleProperty::GECKO_VCU_REMT_AC_CTRL_REQ);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_charging_conditions_fbWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_vcu_charging_conditions_fb = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_charging_conditions_fb");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_vcu_charging_conditions_fb = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_vcu_charging_conditions_fbReq(ec_vcu_charging_conditions_fb),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_charging_conditions_fbReq(int32_t ec_vcu_charging_conditions_fb) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_charging_conditions_fb);
    req->prop = toInt(VehicleProperty::GECKO_VCU_CHARGING_CONDITIONS_FB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_accl_pedal_pos_snsr_staWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_vcu_accl_pedal_pos_snsr_sta = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_accl_pedal_pos_snsr_sta");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_vcu_accl_pedal_pos_snsr_sta = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_vcu_accl_pedal_pos_snsr_staReq(ec_vcu_accl_pedal_pos_snsr_sta),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_accl_pedal_pos_snsr_staReq(int32_t ec_vcu_accl_pedal_pos_snsr_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_accl_pedal_pos_snsr_sta);
    req->prop = toInt(VehicleProperty::GECKO_VCU_ACCL_PEDAL_POS_SNSR_STA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_req_epbWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_vcu_req_epb = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_req_epb");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_vcu_req_epb = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_vcu_req_epbReq(ec_vcu_req_epb),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_req_epbReq(int32_t ec_vcu_req_epb) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_req_epb);
    req->prop = toInt(VehicleProperty::GECKO_VCU_REQ_EPB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_acc_trq_ctrl_avlWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_vcu_acc_trq_ctrl_avl = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_acc_trq_ctrl_avl");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_vcu_acc_trq_ctrl_avl = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_vcu_acc_trq_ctrl_avlReq(ec_vcu_acc_trq_ctrl_avl),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_acc_trq_ctrl_avlReq(int32_t ec_vcu_acc_trq_ctrl_avl) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_acc_trq_ctrl_avl);
    req->prop = toInt(VehicleProperty::GECKO_VCU_ACC_TRQ_CTRL_AVL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_acc_standstill_reqWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_vcu_acc_standstill_req = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_acc_standstill_req");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_vcu_acc_standstill_req = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_vcu_acc_standstill_reqReq(ec_vcu_acc_standstill_req),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_acc_standstill_reqReq(int32_t ec_vcu_acc_standstill_req) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_acc_standstill_req);
    req->prop = toInt(VehicleProperty::GECKO_VCU_ACC_STANDSTILL_REQ);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_acc_tgt_axWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_vcu_acc_tgt_ax = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_acc_tgt_ax");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_vcu_acc_tgt_ax = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_vcu_acc_tgt_axReq(ec_vcu_acc_tgt_ax),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_acc_tgt_axReq(int32_t ec_vcu_acc_tgt_ax) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_acc_tgt_ax);
    req->prop = toInt(VehicleProperty::GECKO_VCU_ACC_TGT_AX);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_acc_tgt_ax_reqWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_vcu_acc_tgt_ax_req = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_acc_tgt_ax_req");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_vcu_acc_tgt_ax_req = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_vcu_acc_tgt_ax_reqReq(ec_vcu_acc_tgt_ax_req),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_acc_tgt_ax_reqReq(int32_t ec_vcu_acc_tgt_ax_req) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_acc_tgt_ax_req);
    req->prop = toInt(VehicleProperty::GECKO_VCU_ACC_TGT_AX_REQ);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_drv_req_torq_override_fcmWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_vcu_drv_req_torq_override_fcm = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_drv_req_torq_override_fcm");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_vcu_drv_req_torq_override_fcm = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_vcu_drv_req_torq_override_fcmReq(ec_vcu_drv_req_torq_override_fcm),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_drv_req_torq_override_fcmReq(int32_t ec_vcu_drv_req_torq_override_fcm) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_drv_req_torq_override_fcm);
    req->prop = toInt(VehicleProperty::GECKO_VCU_DRV_REQ_TORQ_OVERRIDE_FCM);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_cruise_ctr_tgt_spdWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_vcu_cruise_ctr_tgt_spd = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_cruise_ctr_tgt_spd");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_vcu_cruise_ctr_tgt_spd = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_vcu_cruise_ctr_tgt_spdReq(ec_vcu_cruise_ctr_tgt_spd),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_cruise_ctr_tgt_spdReq(int32_t ec_vcu_cruise_ctr_tgt_spd) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_cruise_ctr_tgt_spd);
    req->prop = toInt(VehicleProperty::GECKO_VCU_CRUISE_CTR_TGT_SPD);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_cruise_ctrl_staWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_vcu_cruise_ctrl_sta = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_cruise_ctrl_sta");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_vcu_cruise_ctrl_sta = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_vcu_cruise_ctrl_staReq(ec_vcu_cruise_ctrl_sta),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_cruise_ctrl_staReq(int32_t ec_vcu_cruise_ctrl_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_cruise_ctrl_sta);
    req->prop = toInt(VehicleProperty::GECKO_VCU_CRUISE_CTRL_STA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_eps_lks_abort_fbWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_eps_lks_abort_fb = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_eps_lks_abort_fb");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_eps_lks_abort_fb = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_eps_lks_abort_fbReq(ec_eps_lks_abort_fb),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_eps_lks_abort_fbReq(int32_t ec_eps_lks_abort_fb) {
    auto req = mValueObjectPool->obtainInt32(ec_eps_lks_abort_fb);
    req->prop = toInt(VehicleProperty::GECKO_EPS_LKS_ABORT_FB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_sw_versionWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_sw_version = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_sw_version");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_sw_version = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_sw_versionReq(ec_bms_sw_version),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_sw_versionReq(int32_t ec_bms_sw_version) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_sw_version);
    req->prop = toInt(VehicleProperty::GECKO_BMS_SW_VERSION);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_scs_right_11_swtWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_scs_right_11_swt = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_scs_right_11_swt");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_scs_right_11_swt = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_scs_right_11_swtReq(ec_scs_right_11_swt),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_scs_right_11_swtReq(int32_t ec_scs_right_11_swt) {
    auto req = mValueObjectPool->obtainInt32(ec_scs_right_11_swt);
    req->prop = toInt(VehicleProperty::GECKO_SCS_RIGHT_11SWT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_scs_right_12_swtWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_scs_right_12_swt = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_scs_right_12_swt");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_scs_right_12_swt = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_scs_right_12_swtReq(ec_scs_right_12_swt),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_scs_right_12_swtReq(int32_t ec_scs_right_12_swt) {
    auto req = mValueObjectPool->obtainInt32(ec_scs_right_12_swt);
    req->prop = toInt(VehicleProperty::GECKO_SCS_RIGHT_12SWT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_scs_right_13_swtWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_scs_right_13_swt = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_scs_right_13_swt");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_scs_right_13_swt = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_scs_right_13_swtReq(ec_scs_right_13_swt),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_scs_right_13_swtReq(int32_t ec_scs_right_13_swt) {
    auto req = mValueObjectPool->obtainInt32(ec_scs_right_13_swt);
    req->prop = toInt(VehicleProperty::GECKO_SCS_RIGHT_13SWT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ehb_epb_actuator_st_lWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ehb_epb_actuator_st_l = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ehb_epb_actuator_st_l");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ehb_epb_actuator_st_l = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ehb_epb_actuator_st_lReq(ec_ehb_epb_actuator_st_l),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ehb_epb_actuator_st_lReq(int32_t ec_ehb_epb_actuator_st_l) {
    auto req = mValueObjectPool->obtainInt32(ec_ehb_epb_actuator_st_l);
    req->prop = toInt(VehicleProperty::GECKO_EHB_EPB_ACTUATOR_ST_L);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_scs_gear_shift_lever_pst_req_vdWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_scs_gear_shift_lever_pst_req_vd = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_scs_gear_shift_lever_pst_req_vd");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_scs_gear_shift_lever_pst_req_vd = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_scs_gear_shift_lever_pst_req_vdReq(ec_scs_gear_shift_lever_pst_req_vd),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_scs_gear_shift_lever_pst_req_vdReq(int32_t ec_scs_gear_shift_lever_pst_req_vd) {
    auto req = mValueObjectPool->obtainInt32(ec_scs_gear_shift_lever_pst_req_vd);
    req->prop = toInt(VehicleProperty::GECKO_SCS_GEAR_SHIFT_LEVER_PST_REQ_VD);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_dcs_actl_chrg_powerWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_dcs_actl_chrg_power = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_dcs_actl_chrg_power");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_dcs_actl_chrg_power = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_dcs_actl_chrg_powerReq(ec_bms_dcs_actl_chrg_power),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_dcs_actl_chrg_powerReq(int32_t ec_bms_dcs_actl_chrg_power) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_dcs_actl_chrg_power);
    req->prop = toInt(VehicleProperty::GECKO_BMS_DCS_ACTL_CHRG_POWER);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ccu_keep_awake_staWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ccu_keep_awake_sta = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccu_keep_awake_sta");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ccu_keep_awake_sta = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ccu_keep_awake_staReq(ec_ccu_keep_awake_sta),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccu_keep_awake_staReq(int32_t ec_ccu_keep_awake_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_ccu_keep_awake_sta);
    req->prop = toInt(VehicleProperty::GECKO_CCU_KEEPAWAKESTA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_bra_tor_reqWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_vcu_bra_tor_req = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_bra_tor_req");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_vcu_bra_tor_req = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_vcu_bra_tor_reqReq(ec_vcu_bra_tor_req),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_bra_tor_reqReq(int32_t ec_vcu_bra_tor_req) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_bra_tor_req);
    req->prop = toInt(VehicleProperty::GECKO_VCU_BRA_TOR_REQ);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_pp_sensor_fault_sts_flmWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_pp_sensor_fault_sts_flm = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_pp_sensor_fault_sts_flm");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_pp_sensor_fault_sts_flm = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_pp_sensor_fault_sts_flmReq(ec_pp_sensor_fault_sts_flm),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_pp_sensor_fault_sts_flmReq(int32_t ec_pp_sensor_fault_sts_flm) {
    auto req = mValueObjectPool->obtainInt32(ec_pp_sensor_fault_sts_flm);
    req->prop = toInt(VehicleProperty::GECKO_PP_SENSORFAULTSTSFLM);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_pp_sensor_fault_sts_flWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_pp_sensor_fault_sts_fl = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_pp_sensor_fault_sts_fl");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_pp_sensor_fault_sts_fl = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_pp_sensor_fault_sts_flReq(ec_pp_sensor_fault_sts_fl),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_pp_sensor_fault_sts_flReq(int32_t ec_pp_sensor_fault_sts_fl) {
    auto req = mValueObjectPool->obtainInt32(ec_pp_sensor_fault_sts_fl);
    req->prop = toInt(VehicleProperty::GECKO_PP_SENSORFAULTSTSFL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bcm_authent_key_nrWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bcm_authent_key_nr = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bcm_authent_key_nr");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bcm_authent_key_nr = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bcm_authent_key_nrReq(ec_bcm_authent_key_nr),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bcm_authent_key_nrReq(int32_t ec_bcm_authent_key_nr) {
    auto req = mValueObjectPool->obtainInt32(ec_bcm_authent_key_nr);
    req->prop = toInt(VehicleProperty::GECKO_BCM_AUTHENT_KEY_NR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bcm_key_staWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bcm_key_sta = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bcm_key_sta");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bcm_key_sta = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bcm_key_staReq(ec_bcm_key_sta),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bcm_key_staReq(int32_t ec_bcm_key_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_bcm_key_sta);
    req->prop = toInt(VehicleProperty::GECKO_BCM_KEY_STA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bcm_wiper_stop_pos_staWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bcm_wiper_stop_pos_sta = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bcm_wiper_stop_pos_sta");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bcm_wiper_stop_pos_sta = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bcm_wiper_stop_pos_staReq(ec_bcm_wiper_stop_pos_sta),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bcm_wiper_stop_pos_staReq(int32_t ec_bcm_wiper_stop_pos_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_bcm_wiper_stop_pos_sta);
    req->prop = toInt(VehicleProperty::GECKO_BCM_WIPER_STOP_POS_STA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_drv_req_whl_tq_vldReq(int32_t ec_vcu_drv_req_whl_tq_vld) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_drv_req_whl_tq_vld);
    req->prop = toInt(VehicleProperty::GECKO_VCU_DRV_REQ_WHL_TQ_VLD);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_insulation_wrningWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_insulation_wrning = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_insulation_wrning");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_insulation_wrning = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_insulation_wrningReq(ec_bms_insulation_wrning),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_insulation_wrningReq(int32_t ec_bms_insulation_wrning) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_insulation_wrning);
    req->prop = toInt(VehicleProperty::GECKO_BMS_INSULATION_WRNING);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_pp_raeb_work_stsWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_pp_raeb_work_sts = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_pp_raeb_work_sts");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_pp_raeb_work_sts = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_pp_raeb_work_stsReq(ec_pp_raeb_work_sts),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_pp_raeb_work_stsReq(int32_t ec_pp_raeb_work_sts) {
    auto req = mValueObjectPool->obtainInt32(ec_pp_raeb_work_sts);
    req->prop = toInt(VehicleProperty::GECKO_PP_RAEB_WORK_STS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_fcm_tau_gap_setWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_fcm_tau_gap_set = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_tau_gap_set");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_fcm_tau_gap_set = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_fcm_tau_gap_setReq(ec_fcm_tau_gap_set),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_tau_gap_setReq(int32_t ec_fcm_tau_gap_set) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_tau_gap_set);
    req->prop = toInt(VehicleProperty::GECKO_FCM_TAUGAPSET);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::gecko_e2p_rom_resultWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t gecko_e2p_rom_result = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("gecko_e2p_rom_result");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        gecko_e2p_rom_result = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_gecko_e2p_rom_resultReq(gecko_e2p_rom_result),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_gecko_e2p_rom_resultReq(int32_t gecko_e2p_rom_result) {
    auto req = mValueObjectPool->obtainInt32(gecko_e2p_rom_result);
    req->prop = toInt(VehicleProperty::GECKO_ENGINEER_MODE_TEST);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::gecko_key_code_resultWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t gecko_key_code_result = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("gecko_key_code_result");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        gecko_key_code_result = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_gecko_key_code_resultReq(gecko_key_code_result),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_gecko_key_code_resultReq(int32_t gecko_key_code_result) {
    auto req = mValueObjectPool->obtainInt32(gecko_key_code_result);
    req->prop = toInt(VehicleProperty::GECKO_ENGINEER_MODE_TEST);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_fcm_hma_highbeam_reqWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_fcm_hma_highbeam_req = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_hma_highbeam_req");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_fcm_hma_highbeam_req = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_fcm_hma_highbeam_reqReq(ec_fcm_hma_highbeam_req),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_hma_highbeam_reqReq(int32_t ec_fcm_hma_highbeam_req) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_hma_highbeam_req);
    req->prop = toInt(VehicleProperty::GECKO_FCM_HMA_HIGHBEAMREQ);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bcm_hazard_lamp_stsWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bcm_hazard_lamp_sts = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bcm_hazard_lamp_sts");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bcm_hazard_lamp_sts = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bcm_hazard_lamp_stsReq(ec_bcm_hazard_lamp_sts),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bcm_hazard_lamp_stsReq(int32_t ec_bcm_hazard_lamp_sts) {
    auto req = mValueObjectPool->obtainInt32(ec_bcm_hazard_lamp_sts);
    req->prop = toInt(VehicleProperty::GECKO_BCM_HAZARD_LAMPSTS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_rke_reqWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t bc_bcm_rke_req = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_rke_req");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        bc_bcm_rke_req = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_bc_bcm_rke_reqReq(bc_bcm_rke_req),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_rke_reqReq(int32_t bc_bcm_rke_req) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_rke_req);
    req->prop = toInt(VehicleProperty::GECKO_BCM_RKEREQ);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_fcm_hma_stsWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t bc_fcm_hma_sts = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_hma_sts");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        bc_fcm_hma_sts = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_bc_fcm_hma_stsReq(bc_fcm_hma_sts),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_hma_stsReq(int32_t bc_fcm_hma_sts) {
    auto req = mValueObjectPool->obtainInt32(bc_fcm_hma_sts);
    req->prop = toInt(VehicleProperty::GECKO_FCM_HMA_STS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_le_turn_li_fault_fbWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t bc_bcm_le_turn_li_fault_fb = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_le_turn_li_fault_fb");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        bc_bcm_le_turn_li_fault_fb = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_bc_bcm_le_turn_li_fault_fbReq(bc_bcm_le_turn_li_fault_fb),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_le_turn_li_fault_fbReq(int32_t bc_bcm_le_turn_li_fault_fb) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_le_turn_li_fault_fb);
    req->prop = toInt(VehicleProperty::GECKO_BCM_LETURNLIFAULTFB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_ri_turn_li_fault_fbWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t bc_bcm_ri_turn_li_fault_fb = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_ri_turn_li_fault_fb");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        bc_bcm_ri_turn_li_fault_fb = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_bc_bcm_ri_turn_li_fault_fbReq(bc_bcm_ri_turn_li_fault_fb),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_ri_turn_li_fault_fbReq(int32_t bc_bcm_ri_turn_li_fault_fb) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_ri_turn_li_fault_fb);
    req->prop = toInt(VehicleProperty::GECKO_BCM_RITURNLIFAULTFB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_ac_ac_sta_fbWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t bc_ac_ac_sta_fb = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("bc_ac_ac_sta_fb");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        bc_ac_ac_sta_fb = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_bc_ac_ac_sta_fbReq(bc_ac_ac_sta_fb),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ac_ac_sta_fbReq(int32_t bc_ac_ac_sta_fb) {
    auto req = mValueObjectPool->obtainInt32(bc_ac_ac_sta_fb);
    req->prop = toInt(VehicleProperty::GECKO_HVAC_AC_STA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::interval_time(){
  uint32_t count = 0;
  while(true){
    //int64_t currentTime = elapsedRealtime();

    if(powerOnSts > 0){
      //短期记忆时间
        #if 0
        travelTimes = (currentTime - travelBeginTimes)/1000/60;
        if(travelTimes >= lastTravelTimes && travelBeginTimes > 0){
            lastTravelTimes = travelTimes;
            if(travelTimes != updateTravelTimes){
                mHal->onPropertyValue(*Create_power_on_timeReq(travelTimes), true);
                updateTravelTimes = travelTimes;
            }
            
            if(count%9 == 0){
                LOG(INFO) << "travelTimes:"<< travelTimes<<" travelBeginTimes:"<<travelBeginTimes<<" updateTravelTimes:"<< updateTravelTimes;
            }
        }

        ConfigDBC* mp = mPropertyManager->findCProperty("sc_ccm_vehicle_spd_dsp");
        int32_t speed = getActualFloatValue(mPropertyManager->getCProValue(mp),0.05625,0);
        HandlePowerOnspd(speed);
        #endif
    }
    std::this_thread::sleep_for(std::chrono::milliseconds(100));
    count++;
    if(count > 100000)count = 0;
  }
  std::this_thread::sleep_for(std::chrono::milliseconds(100));
}

}  // namespace android::hardware::automotive::vehicle::V2_0::impl
