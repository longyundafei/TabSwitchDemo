/*
 * Copyright (C) 2020 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "GarageModeServerSideHandler.h"
#include <chrono>
#include <condition_variable>
#include <fstream>
#include <thread>
#include <errno.h>
#include <chrono>
#include <stdlib.h>
#include <sys/inotify.h>
#include <android-base/logging.h>
#include <utils/SystemClock.h>
#include "vhal_v2_0/VehicleUtils.h"
#include <log/log.h>
#include "PropertyUtils.h"
#include "CanMap.h"
#include <android-base/properties.h>
#include <android/hardware/automotive/vehicle/2.0/types.h>

namespace android::hardware::automotive::vehicle::V2_0::impl {

using std::chrono::duration_cast;
using std::chrono::steady_clock;
using std::literals::chrono_literals::operator""s;

class GarageModeServerSideHandlerImpl : public GarageModeServerSideHandler {
  public:
    GarageModeServerSideHandlerImpl(
       VehiclePropValuePool* vehicleObjectPool, PropertyManager* pm, EmulatedVehicleHalIface* hal)
       : mValueObjectPool(vehicleObjectPool),
         mPropertyManager(pm),
         mHal(hal)
         {
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::can071_Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::can30A_Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::can30B_Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::can30C_Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ev_vcu_mcu_power_statusWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ccm_soc_power_statusWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_pt_stWatcher, this));  
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_batterycurrentWatcher, this));  
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_packvoltageWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_packvoltage_vWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_remainingchargetimeWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_batterysocWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_mcu_motortorqueWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_mcu_motorspdWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_mcu_buscurrentWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_mcu_busvoltWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_mcu_motortempWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_mcu_igbttempWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_mcu_igbt_overheat_warningWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_mcu_motor_overheat_warningWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_packtotalcellnumWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_packtotaltempnumWatcher, this));  
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_mintempmonomercellWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_maxtempmonomercellWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_maxtempcellWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_mintempcellWatcher, this));  
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_minvoltmonomercellWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_maxvoltmonomercellWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_maxvoltcellWatcher, this));  
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_minvoltcellWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_packudvoltWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_packovervoltWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_overtempWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_deltatempWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_lowinsresWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_celludvoltWatcher, this));  
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_cellovervoltWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_packlowsocWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_packfastchgsocWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_packhighsocWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_packoverchargeWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_ucellinconWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_h_vilfaultWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_batsysnotmtcWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_actual_gearWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_park_stateWatcher, this));  
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_creep_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_chrg_cnctr_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_average_energy_consumptionWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_instant_energy_consumptionWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_chraging_mode_spWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ccm_driver_buckle_statusWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_total_odometerWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_drive_modeWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_brak_sys_warnWatcher, this));
       mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_drive_pwr_limWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_mcu_errWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_hv_batt_errWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_operat_licenceWatcher, this));
       mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_actual_rema_range_vdWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_cltc_rema_range_vdWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_vehicle_spdWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_vehicle_spd_dspWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_actual_rema_rangeWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_cltc_rema_rangeWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_b2_v_v_frame_noWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_b2_v_v_cell_volt_n1Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_b2_v_v_cell_volt_n2Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_b2_v_v_cell_volt_n3Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_b2_v_t_frame_noWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_b2_v_t_cell_temp_n1Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_b2_v_t_cell_temp_n2Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_b2_v_t_cell_temp_n3Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_b2_v_t_cell_temp_n4Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_b2_v_t_cell_temp_n5Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_b2_v_t_cell_temp_n6Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_ac_blower_levelWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_ac_fresh_reci_stateWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_ac_front_defrost_stateWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_ac_heat_stateWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_ac_havc_stateWatcher, this));  
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_ac_ai_rdistribution_modeWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_ac_a_cstateWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_ac_left_set_temperatureWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_ccu_remote_car_searchWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_ccu_remote_lockWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_position_light_statusWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_high_beam_statusWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_low_beam_statusWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_turn_indcr_riWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_turn_indcr_leWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_hazard_light_statusWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_rl_door_ajar_statusWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_rr_door_ajar_statusWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_fr_door_ajar_statusWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_fl_door_ajar_statusWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_rear_fog_light_statusWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_tr_cls_stWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_power_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_brakelight_stWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_park_un_lock_ackWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_pdc1_modeWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_pdc1_buzzer_alarm_patternWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_pdc1_distance_rrmWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_pdc1_distance_rrWatcher, this));
       mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_avas_stateWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_tpms_receiverstateWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_tpms_transducer_locationWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_tpms_tyrestate_frWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_tpms_tyrestate_flWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_tpms_tyrestate_rlWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_tpms_tyrestate_rrWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_tpms_tyretemperatureWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_tpms_tyrepressure_flWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_tpms_tyrepressure_frWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_tpms_tyrepressure_rrWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_tpms_tyrepressure_rlWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::cc_abs_abs_fail_statusWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::cc_eps_run_stateWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_lamplet_statusWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_main_seat_pressure_statusWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_brake_level_alarm_statusWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_main_seat_safety_belt_statusWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_engine_statusWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_low_vol_battery_volWatcher, this));
		mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_key_previous_songWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_key_next_songWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_key_volume_upWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_key_volume_dowmWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_key_mode_muteWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_key_telephoneWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_key_voiceWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_key_homeWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_key_customWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_key_distanceWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_key_speedupWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_key_speeddownWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_key_pagedownWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_key_pageupWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_key_okayWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::sc_ec_ccm_batt_maintain_ctr_cmdWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::sc_ec_ccm_batt_maintain_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::sc_ec_ccm_versionWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::sc_ec_ccm_target_chrg_currWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::sc_ccm_remt_ctrl_flagWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::sc_ec_ccm_operat_licenceWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::interval_time, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ccm_appointment_mode, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ccm_chraging_begin_time_hour, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ccm_chraging_begin_time_minute, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ccm_chraging_end_time_hour, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ccm_chraging_end_time_minute, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ccm_chraging_sunday_loop, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ccm_chraging_monday_loop, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ccm_chraging_tuesday_loop, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ccm_chraging_wednesday_loop, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ccm_chraging_thursday_loop, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ccm_chraging_friday_loop, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ccm_chraging_saturday_loop, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ccm_chraging_target_soc, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_key_long_volume_upWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_key_long_volume_dowmWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_key_long_telephoneWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_key_long_customWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_key_long_previous_songWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_key_long_next_songWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_light_levelWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mcu_voiume_navigationWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mcu_voiume_voicWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mcu_voiume_multimediaWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mcu_voiume_phoneWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mcu_voiume_alarmWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mcu_voiume_keyWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mcu_info_vinWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mcu_info_sn1Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mcu_info_sn2Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mcu_info_sn3Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mcu_info_versionWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_travel_rangeWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_travel_timeWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_average_energy_consumptionWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::rangeModeSet, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::gecko_headlighthSet, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_remind_inrWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_remind_start_timeWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_remind_distanceWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_remind_start_odoWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_ac_hybrid_eco_mode_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_wipr_intl_time_set_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_flwr_me_hm_ctrl_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_illmnd_unlock_sts_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_illmnd_lock_sts_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_lock_horn_on_st_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_esc_disableWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ehb_avh_appld_stWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ehb_epb_system_stateWatcher, this));
	mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ehb_brk_dis_wip_acWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_elec_steer_mode_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_veh_act_recuperate_pwrWatcher, this));
	mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vehicle_driving_pwrWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_srs_passenger_airbag_sta_rsvrWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_front_fog_light_statusWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_key_lo_batt_lvl_warnWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_warn_no_key_foundWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_auto_lamp_statusWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_indication_shiftto_neutralWatcher, this));
	mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_12_v_bat_low_vol_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_sibs_kl30_voltageWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_srs_airbag_warning_lamp_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_srs_drv_seatbelt_buckle_validWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ipu_obc_inlet_connect_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_dcs_inlet_connect_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_pwr_train_connect_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ehb_brake_liquid_level_warnWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_ebd_failedWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_vhcl_p_gear_errorWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_motor_high_temp_wrningWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_mcu_high_temp_wrningWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bcm_central_lock_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_pcu_fail_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_warn_key_out_reminderWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_light_intensityWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_indication_key_closerWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_srs_pass_seatbelt_bucklestatusWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_srs_pass_seatbelt_buckle_validWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_srs_pass_seat_occupant_sensor_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_srs_mid_seat_belt_bucklestatusWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_srs_mid_seat_belt_buckle_validWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_srs_mid_seat_occupant_sensor_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ipu_obc_actl_oprt_modeWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_dcs_act_oprt_modeWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_reserve_powerWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_motor_actual_powerWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_motor_actual_power_typeWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_hdc_statusWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_es_cor_tcs_failedWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_tcs_active_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_esp_active_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ehb_avh_lamp_reqWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ehb_epb_display_msg_idWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ehb_avh_disp_msgWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ehb_epb_warn_lamp_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_obc_oprt_cmd_to_icuWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_ac_envir_temp_vWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_ac_envir_tempWatcher, this));

        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::config_query_sim_cardWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::config_query_4g_strengthWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::config_query_wifi_strengthWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::config_query_wifi_statusWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::config_query_gps_lonWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::config_query_gps_latWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::vcu_chraging_mode_sp_reqWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_pp_fl_distWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_pp_fml_distWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_pp_fmr_distWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_pp_fr_distWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_pp_sdwfsl_distWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_pp_sdwfsl_mid_distWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_pp_sdwfsr_mid_distWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_pp_sensor_fault_sts_frmWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_pp_sensor_fault_sts_frWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_pp_sdwrsr_distWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_pp_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_pp_sw_fdbkWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fcm_elk_set_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fcm_aeb_set_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fcm_hma_set_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fcm_tsr_spd_lim_warnWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fcm_tsr_spd_lim_warn_auWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fcm_tsr_spd_lim_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fcm_slwf_set_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fcm_fcm_intializationWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fcm_elk_left_modeWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fcm_elk_right_modeWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fcm_slif_set_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fcm_trfc_signWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fcm_tsr_lgt_dstWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fcm_tsr_lat_dstWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fcm_tsr_set_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fcm_tsr_spd_limWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fcm_slif_oper_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fcm_audio_warn_hands_offWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fcm_fault_text_infoWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fcm_lka_audio_warningWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fcm_act_drv_asst_sts_hmiWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fcm_tar_obj_accWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fcm_adas_not_avl_reasWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fcm_acc_startWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fcm_ica_truck_set_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fcm_ica_set_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fcm_adas_quit_reasWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fcm_acc_mode_hmiWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fcm_pcw_pre_warnWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fcm_pcw_latent_warnWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fcm_text_info_lka1Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fcm_ldw_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fcm_ldw_set_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fcm_lka_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fcm_le_line_color_fctWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fcm_lka_set_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fcm_ri_line_color_fctWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fcm_ldw_alert_method_set_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fcm_v_set_disWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fcm_aeb_obj_idWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fcm_raeb_work_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fcm_ldw_audio_warnWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fcm_laterallimitWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ipu_obc_inlelt_actl_powerWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_srs_crash_output_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_insulation_wrning_distgshWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_thermalrunaway_wrnWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_dcs_actl_chrg_voltageWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_icu_vehicle_speed_displayed_vWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_icu_icu_trip_a_odometerWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_icu_icu_trip_b_odometerWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::cc_eps_basic_elec_steer_failedWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::cc_eps_mode_set_inhibit_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::cc_eps_sws_hod_hands_off_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_vcu_info_dispWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_vcu_vhcl_speed_fast_warnWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_vcu_drive_mode_key_stagnationWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_vcu_cc_key_stagnationWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_vcu_shift_key_stagnationWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_vcu_lock_veh_warmWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_vcu_sibs_kl30_voltageWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_vcu_sibs_rtcwu_chg_numWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_vcu_sibs_chg_num_allowWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_vcu_sibs_rtcwu_chg_fail_numWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_vcu_sibs_rtc_chrg_stWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_vcu_sibs_wup_volt_allowWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_vcu_sibs_bms_bat_soc_allowWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_vcu_sibs_fb_rtc_wup_flgWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_vcu_ac_chrg_max_currWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_vcu_ac_chrg_modeWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_ccu_open_ventilation_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_ac_ac_unlock_vent_set_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_ac_remote_defrost_ctl_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_ac_temp_set_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_ac_remt_ctrl_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_ccu_remote_power_lock_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_vcu_speed_limit_level_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_vcu_operat_licence_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_vcu_version_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_vcu_vesion_set_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_vcu_wgh_confdenceWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_vcu_wgh_estWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_vcu_wgh_distbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_vcu_cruise_ctrl_sta_for_bacWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_vcu_cruise_ctr_tgt_spd_for_bacWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_ac_indoor_tempWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_light_sw_sigWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_ajar_sta_hoodWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_tmps_abnm_prsr_warnWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_tpms_reset_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_fr_windowmotor_flagsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_fl_windowmotor_flagsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_wash_liquid_level_warnWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_front_wash_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_pas_wdw_initWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_drv_pass_win_sw_sigWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_body_warn_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_key_in_car_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_ps_authent_resWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_trunk_lock_sw_ctrl_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_trunk_lock_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_overspd_cntrl_lock_set_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_park_auto_unlock_set_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_chg_wiper_mt_md_sw_set_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_drv_lf_ant_diag_statusWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_lf_init_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_door_lock_operation_recordWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_int_lf_ant_diag_statusWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_pass_lf_ant_diag_statusWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_illmnd_entry_sts_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_steer_whl_tempWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_steer_whl_heat_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_rear_mirror_heat_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_mai_drvr_seat_tempWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_mai_drvr_seat_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_logo_active_flagWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_rf_init_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_rear_fog_li_fault_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_front_fog_li_fault_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_pos_li_fault_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_back_li_fault_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_brake_li_fault_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_reverse_li_fault_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_day_run_li_fault_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ehb_epb_flt_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ehb_epb_switch_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ehb_failure_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_vhcl_actl_gear_pos_vWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bcm_sys_pwr_mode_vWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bcm_sys_pwr_modeWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bcm_sys_power_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bcm_door_lock_sta_flWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_pwr_recup_intensityWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ccu_diag_tester_onlineWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bcm_back_ladjval_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_rmi_active_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_slope_percent_vWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_slope_percentWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_inv_antithft_auth_rsltWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_ac_auto_blower_mode_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fcm_fcw_set_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_ac_extd_defrost_actv_reqWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_scs_left_swt_vdWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_scs_left_1_swtWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_scs_left_2_swtWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_scs_left_3_swtWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_scs_left_4_swtWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_scs_left_5_swtWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_scs_left_6_swtWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_scs_left_7_swtWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_scs_left_8_swtWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_avas_state_rolling_counterWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_current_over_wrningWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_battery_sub_sys_numWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_battery_sub_sys_codWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_battery_dtc_numWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_battery_dtc_listWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_battery_dtc_indexWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_inv_1_rolling_counterWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_inv_4_err_bitsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_inv_4_rolling_counterWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_scs_right_swt_vdWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_scs_right_14_swtWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_scs_right_15_swtWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_scs_right_16_swtWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_crrr_bsd_warn_rightWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_crrr_bsd_warn_leftWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_crrr_bsd_set_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_crrr_rcta_warn_rightWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_crrr_rcta_warn_leftWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_crrr_rcta_set_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_crrr_rcw_warningWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_crrr_rcw_set_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_crrr_rear_corner_failureWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_crrr_rear_corner_blindnessWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_crrr_dow_set_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_crrr_dow_warn_frWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_crrr_dow_warn_flWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_crrr_dow_warn_rrWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_crrr_dow_warn_rlWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_crrr_dow_warn_rightWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_crrr_dow_warn_leftWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_typ1Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_lat_dst1Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_lgt_dst1Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_lgt_rel_spd1Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_posn_agl1Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_lgt_rel_spd7Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_dir1Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_lgt_rel_spd8Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_sta1Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_typ2Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_lat_dst2Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_lgt_dst2Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_posn_agl2Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_lgt_rel_spd2Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_lgt_rel_spd9Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_dir2Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_sta2Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_typ3Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_lat_dst3Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_lgt_dst3Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_posn_agl3Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_lgt_rel_spd3Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_dir3Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_sta3Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_typ4Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_lat_dst4Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_lgt_dst4Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_posn_agl4Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_lgt_rel_spd4Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_sta4Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_dir4Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_dir7Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_typ5Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_lat_dst5Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_lgt_dst5Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_posn_agl5Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_lgt_rel_spd5Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_dir5Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_sta5Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_sta9Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_typ6Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_lat_dst6Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_lgt_dst6Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_posn_agl6Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_lgt_rel_spd6Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_dir9Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_sta6Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_dir6Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_typ7Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_lat_dst7Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_lgt_dst7Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_posn_agl7Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_sta7Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_lat_dst8Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_lgt_dst8Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_typ8Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_typ9Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_sta8Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_posn_agl8Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_lat_dst9Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_lgt_dst9Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_posn_agl9Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_dir8Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_typ10Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_lat_dst10Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_lgt_dst10Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_posn_agl10Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_sta10Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_lat_dst11Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_lgt_dst11Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_typ11Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_posn_agl11Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_sta11Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_lat_dst12Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_lgt_dst12Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_typ12Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_dir11Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_posn_agl12Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_typ13Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_lat_dst13Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_lgt_dst13Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_sta13Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_posn_agl13Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_lat_dst14Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_lgt_dst14Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_typ14Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_sta14Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_posn_agl14Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_lat_dst15Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_lgt_dst15Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_typ15Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_dir14Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_posn_agl15Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_typ16Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_lat_dst16Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_lgt_dst16Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_lat_dst17Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_lgt_dst17Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_sta16Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_dir16Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_typ17Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_typ18Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_sta17Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_lat_dst18Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_lgt_dst18Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_posn_agl18Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_dir17Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_dir18Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_sta18Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_lgt_rel_spd10Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_posn_agl16Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_lgt_rel_spd11Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_posn_agl17Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_lgt_rel_spd12Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_lgt_rel_spd13Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_dir10Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_lgt_rel_spd14Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_sta12Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_lgt_rel_spd15Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_dir12Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_lgt_rel_spd16Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_dir13Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_sta15Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_lgt_rel_spd17Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_lgt_rel_spd18Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_dir15Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_nr_of_lineWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_le_line_typWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_le_line_rdWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_le_line_dstWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_le_line_c1Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_le_line_c2Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_ri_line_typWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_le_line_c3Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_ri_line_rdWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_ri_line_dstWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_ri_line_c1Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_ri_line_c3Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_ri_line_c2Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_le_le_line_typWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_le_le_line_c1Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_le_le_line_c3Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_le_le_line_rdWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_le_le_line_dstWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_ri_ri_line_c1Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_ri_ri_line_c3Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_ri_ri_line_rdWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_ri_ri_line_dstWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_ri_ri_line_typWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_le_le_line_c2Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_ri_ri_line_c2Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_spd_downin_cor_sfkWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_vcu_speed_limit_level_set_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_abs_active_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ipu_dcc_actl_oprt_modeWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ipu_over_temperature_failWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_accl_pedal_posWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_brk_pedal_posWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_iso_resistanceWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ehb_brk_pedl_valWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ehb_brk_pedl_val_vldWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ehb_brk_pedl_val_percWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ehb_brk_pedl_val_perc_vldWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_travel_average_speedWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ipu_dcc_sys_fail_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bcm_brake_pedal_staWatcher, this));

        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::fcm_adas_drvr_reqWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::fcm_elk_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::fcm_slifs_spd_limWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::fcm_aeb_statusWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::fcm_aeb_statsadsusWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::hu_dowenaswtWatcher, this));

        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::sc_fcm_acc_take_over_reqWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::fcm_tjatakeoverreqWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fcm_aeb_recreqWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::hu_hma_enable_swWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::hu_ica_enable_sw_tWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::hu_ica_avd_truck_setWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::hu_ldw_alert_method_swWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::hu_lka_enable_swWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::hu_elk_enb_swWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::hu_fcw_enable_swWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::hu_abe_enable_swWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::hu_bsd_enable_swWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::hu_rcw_enable_swWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::hu_rcta_enable_swWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::hu_slif_enableswWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::hu_slwf_enableswWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::hu_navi_country_codeWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_avalueble_key_in_carWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_sys_fail_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ccu_remt_steer_whl_heat_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ccu_remt_power_ctrl_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ccu_remt_mai_dr_seat_heat_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_pp_sensor_fault_sts_rlWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_pp_sensor_fault_sts_rlmWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_pp_sensor_fault_sts_rrmWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_pp_sensor_fault_sts_rrWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_pp_rl_distWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_pp_rlm_distWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_pp_rrm_distWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_pp_rr_distWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_pp_sdwfsr_distWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_pp_sdwrsl_distWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_pp_sdwrsl_mid_distWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_pp_sdwrsr_mid_distWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fm_auto_seek_resWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::fm_searchWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::fm_volumeWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_err_amountWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_err_bitWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_carriage_light_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_eps_steer_wheel_angleWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_eps_steer_wheel_angle_validWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_eps_rot_speedWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_eps_steer_wheel_angle_failureWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_eps_electric_power_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_eps_steer_wheel_angle_calibratedWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_eps_mot_tqWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_lgt_fct_actv_flgWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_eps_set_steer_whl_aglWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_steer_tq_req_activeWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_eps_ctrl_reqWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_drvr_warn_vib_reqWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_daeps_mode_reqWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_act_drv_asst_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_overtake_ass_sys_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_turn_lamp_reqWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_tjaica_supps_abortnWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_lka_torq_fact_reqWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_hma_supps_abortnWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_lkaldw_supps_abortnWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_flt_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_elk_supps_abortnWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_acc_whl_tq_req_valWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_acc_whl_tq_req_actvWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_acc_whl_deceWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_acc_tar_accrnWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_acc_supp_abortWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_acc_tar_accrn_req_actvWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_epb_req_vWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_epb_reqWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_acc_shutdown_modeWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_ahd_obj_idWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_acc_tgt_axWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_aeb_tgt_axWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_acc_modeWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_acc_req_standstillWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_aeb_reqWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_aeb_standstill_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_aeb_standstill_sts_vWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_aba_levelWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_awb_levelWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_aba_reqWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_eba_reqWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_awb_reqWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_abp_reqWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_acc_tgt_ax_reqWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_crv_decel_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_acc_req_drive_offWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_scs_frnt_wipr_swt_stWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_scs_low_beam_swt_stWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_scs_hi_beam_swt_stWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_scs_over_veh_beam_swt_stWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_scs_lamp_auto_stWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_scs_le_turn_lmp_swt_stWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_scs_ri_turn_lmp_swt_stWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_hv_bat_cell_temp_aveWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_dcs_actl_chrg_currentWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_scs_gear_shift_lever_pst_reqWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_ac_chrg_atcl_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_outlet_coolant_actl_tempWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_outlet_coolant_actl_temp_validWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_inlet_coolant_actl_tempWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_inlet_coolant_actl_temp_validWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_max_chrg_voltage_acWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_max_chrg_current_acWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_bat_sohWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_temp_max_dc_charge_socketWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_pcb_temp_maxWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_max_allow_chrg_cur_dcWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_max_allow_chrg_vol_dcWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_electronic_lock_ctrlWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_electronic_lock_stateWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_contactor_state_dc_chargerWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_dcs_charge_requestWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_dcs_chrg_a_plusWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_run_stateWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_contactor_state_negativeWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_contactor_state_positiveWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_contactor_state_prechargeWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_supply_voltage_statusWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_emeshutdown_reqWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_charge_interlock_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_dis_charge_interlock_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_batt_balance_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_therm_runaway_snsr_fltWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_therm_runaway_vlv_stWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ipu_obc_uac_act_l1Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ipu_obc_uac_act_l2Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ipu_obc_uac_act_l3Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ipu_obc_iac_act_l1Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ipu_obc_iac_act_l2Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ipu_obc_iac_act_l3Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ipu_device_int_tempWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ipu_obc_temp_inletWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ipu_obc_ac_max_pw_allowWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ipu_obc_inlet_electronic_lockWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ipu_obc_s2_stateWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ipu_obc_wake_up_modeWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ipu_obc_voltage_ok_l1Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ipu_obc_voltage_ok_l2Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ipu_obc_voltage_ok_l3Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ipu_dcc_high_volt_actl_curWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ipu_dcc_high_volt_actl_volWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ipu_obc_hvdc_actl_curWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ipu_obc_connect_main_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ipu_obc_requestWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ipu_obc_sys_fail_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ipu_obc_hvdc_actl_volWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ipu_obc_errbitWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ipu_dcc_low_vol_actl_volWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ipu_dcc_low_vol_actl_curWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ipu_dcc_precharge_completeWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ipu_dcc_derating_oprt_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ipu_hvil_fail_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ipu_dcc_errbitWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ipu_obc_c_cor_cp_cnctd_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ipu_obc_cp_dutyWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ipu_obc_cp_max_voltWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ipu_obc_process_codeWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ipu_obc_cc_resisdentWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_eps_torsion_bar_torqueWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_eps_torsion_bar_torque_dirWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_eps_torsion_bar_torque_validWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_eps_elect_power_consumptionWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_eps_advanced_mode_statusWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_eps_lat_drv_lvl12_srv_avlWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_eps_lat_mc_hptc_wrn_srv_avlWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_eps_pscm_int_rpc_max_trqWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_eps_torsion_bar_torque_qfWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_eps_pscm_int_rpc_min_trqWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_eps_lat_mc_steer_tq_activeWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_eps_lat_mc_hptc_wrn_activeWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_eps_max_allwd_rot_spdWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_eps_lks_agl_sys_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_eps_max_allwd_aglWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_eps_steer_tqWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_eps_lks_abort_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_eps_lks_agl_ctrl_avl_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_req_brake_light_onWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_ebd_active_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_ess_activeWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_cdp_activeWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_brake_temp_over_heatWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_dtc_active_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_vhcl_standstill_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_dtc_request_rbs_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_dtc_failure_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_wheel_speed_kph_v_flWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_wheel_direction_flWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_wheel_speed_kph_flWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_wheel_speed_kph_v_frWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_wheel_direction_frWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_wheel_speed_kph_frWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_master_cylinder_presrWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_master_cylinder_presr_vWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_wheel_speed_kph_v_rlWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_wheel_direction_rlWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_wheel_speed_kph_rlWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_wheel_speed_kph_v_rrWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_wheel_direction_rrWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_wheel_speed_kph_rrWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_wheel_speed_rc_sts_flWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_wheel_speed_rc_sts_frWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_wheel_speed_rc_sts_rlWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_wheel_speed_rc_sts_rrWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_wheel_speed_rc_flWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_wheel_speed_rc_frWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_wheel_speed_rc_rlWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_wheel_speed_rc_rrWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_long_acc_sensor_valueWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_long_acc_sensor_value_vldWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_lat_acc_sensor_value_vldWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_lat_acc_sensor_valueWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_yaw_rateWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_yaw_rate_vldWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_epb_right_currentWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_epb_right_fault_stateWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_hbb_hbc_availableWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_epb_actuator_st_rWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_hbb_hbc_activeWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_whl_tq_dec_req_actvWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_whl_tq_dec_req_valWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_whl_tq_inc_req_actvWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_esc_whl_tq_inc_req_valWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ehb_cdp_requestWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ehb_epb_actuator_st_rWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ehb_epb_actuator_st_lWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ehb_hhc_active_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ehb_rgn_brk_stWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ehb_ext_req_statusWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ehb_blaWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ehb_hmi_warning_onWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ehb_epb_dynamic_apply_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ehb_pedl_trvl_snsr_fail_pdfWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ehb_req_brk_li_onWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ehb_pedl_trvl_snsr_fail_pdtWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ehb_p_runout_pressureWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ehb_brake_pedal_appliedWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ehb_brake_pedal_applied_qWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ehb_cdd_temp_offWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ehb_s_output_rod_hydraulic_targetWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ehb_s_output_rod_driver_percWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ehb_aba_active_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ehb_aba_available_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ehb_awb_active_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ehb_awb_available_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ehb_aeb_active_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ehb_aeb_available_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ehb_abp_active_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ehb_abp_available_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_pp_raeb_set_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_pp_raeb_work_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_pp_raeb_brkg_reqWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_pp_raeb_brkg_req_valWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_pp_raeb_distance_to_collisionWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_crrr_rctb_decelarationWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_crrr_rctb_reqWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_crrr_rctb_brkg_vldWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_crrr_fov_chg_set_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_max_con_dis_curntWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_pwr_recup_max_con_chrg_curntWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_max_instan_dis_curntWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_pwr_recup_max_instan_chrg_curntWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_cell_vol_aveWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_contactor_temp_negativeWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_max_cell_temp_limitWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_max_cell_vol_limitWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_pwr_limd_flgWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_min_cell_temp_limitWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_min_cell_vol_limitWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_err_tab_indexWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_battery_typeWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_hw_versionWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_pack_identityWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_sw_versionWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_nom_cell_capWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_bat_capacityWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_cst_abort_by_bmsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_cst_abort_by_faultWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_cst_abort_by_userWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_cst_abort_achive_conditionWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_cst_abort_fault_energe_transmitWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_cst_abort_fault_charger_inner_tempWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_cst_abort_fault_connetorWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_cst_abort_fault_charger_tempWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_cst_abort_fault_otherWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_cst_abort_fault_charger_stopWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_cst_abort_error_voltageWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_cst_abort_error_currentWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bcm_rear_view_mirr_heating_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_tms_ohx_out_tmpWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_tms_evap_tmpWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_tms_evap_out_tmpWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_tms_chiller_out_tmpWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bcm_high_beam_li_fault_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bcm_low_beam_li_fault_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bcm_vhcl_seekWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bcm_illmnd_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bcm_key_frbdnWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bcm_frbdn_key_nrWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bcm_start_reqWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bcm_drv_pe_authent_acsdWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bcm_frpe_authent_acsdWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bcm_ps_reqWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bcm_frnt_le_door_hndl_swtWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bcm_frnt_ri_door_hndl_swtWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bcm_save_power_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bcm_front_wiper_motor_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bcm_fl_window_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bcm_fr_window_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bcm_fl_windowmotor_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bcm_fr_windowmotor_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bcm_wiper_ctrl_frontWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bcm_drv_seat_occupant_sensor_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bcm_heavy_rain_indWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_tpms_pressure_value_rrWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_tpms_pressure_value_rlWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_tpms_pressure_sta_rlWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_tpms_pressure_sta_rrWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_tpms_pressure_value_frWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_tpms_pressure_value_flWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_tpms_pressure_sta_flWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_tpms_pressure_sta_frWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bcm_dome_light_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bcm_back_lamp_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bcm_bass_horn_reqWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bcm_ajar_sta_v_hoodWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bcm_frnt_fog_li_sw_sigWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bcm_rear_fog_li_sw_sigWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bcm_day_run_light_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bcm_reverse_lamp_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bcm_brake_lamp_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bcm_turn_li_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_actl_motor_rotate_spdWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_actl_motor_rotate_spd_vWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_remt_ac_ctrl_stWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_remt_ac_defrostl_reqWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_remt_ac_ctrl_reqWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_charging_conditions_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_accl_pedal_pos_snsr_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_req_epbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_acc_trq_ctrl_avlWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_acc_standstill_reqWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_acc_tgt_axWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_acc_tgt_ax_reqWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_drv_req_torq_override_fcmWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_cruise_ctr_tgt_spdWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_cruise_ctrl_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_scs_right_11_swtWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_scs_right_12_swtWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_scs_right_13_swtWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_scs_gear_shift_lever_pst_req_vdWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_dcs_actl_chrg_powerWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_ccu_keep_awake_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_vcu_bra_tor_reqWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_pp_sensor_fault_sts_flmWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_pp_sensor_fault_sts_flWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bcm_authent_key_nrWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bcm_key_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bcm_wiper_stop_pos_staWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bms_insulation_wrningWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_tau_gap_setWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::gecko_e2p_rom_resultWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::gecko_key_code_resultWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_fcm_hma_highbeam_reqWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::ec_bcm_hazard_lamp_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_rke_reqWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_fcm_hma_stsWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_le_turn_li_fault_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_bcm_ri_turn_li_fault_fbWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::bc_ac_ac_sta_fbWatcher, this));
	 //
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_travel_short_rangeWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_travel_short_average_speedWatcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_travel_short_average_pwr_consum_Watcher, this));
        mThreads.emplace_back(std::bind(&GarageModeServerSideHandlerImpl::mc_travel_short_timeWatcher, this));
}

    ~GarageModeServerSideHandlerImpl() {
        mShuttingDownFlag.store(true);
        mHeartbeatCV.notify_all();
        for (auto& thread : mThreads) {
            if (thread.joinable()) {
                thread.join();
            }
        }
    }

    void HandleHeartbeat() override;
  public:
    double TotalMileageEEPROM = 0.0;  // EEPROMkm

    // 
    double totalMileageCur = 0;
    int32_t beginTotalMileage = 0;
    float begintravelMileage = 0;
    std::deque<float> spdQueue;
    const unsigned long spdSaveCounter = 10;
    std::condition_variable spdcv;
    std::mutex spdmtx;
    bool fed = false;
    bool spdCanDisp = false;
    int64_t powerOnTimestamp = 0;   //
    int64_t travelBeginTimes = 0;   //
    int64_t travelTimes = 0;   //()
    int64_t lastTravelTimes = 0;   //()
    float averageEnergyConsumption = 0.0;
    int64_t  lastMilliTime = 0;
    int64_t updateTravelTimes = -1;
    float powerOnMileage = 0;       //
    int32_t powerOnSts = 0;         //
    int32_t lastPowerOnSts = 0;     //
    int64_t power_on_milege_time = 0;     //
    int64_t power_on_average_speed_time = 0;     //
    int64_t power_on_average_energy_consumption_time = 0;     //
    float consumption = 0.0;
    float updateaverageEnergy = 0;
    int32_t updateAverageSpd = -1024;
    float updatePowerOnMileage = -1024;


    int32_t monitorTime = 1;        // 1
    float invalidValueFloat = -1024.0;
    int32_t invalidValueInt = -1024;

	  bool energyConsumptionFlag = false;   //
	  float totalEnergyConsumption = 0;     //  
    bool isEnergyConsumption = false;
    int32_t energyCount = 0;


    int32_t chraging_sunday_loop = 0;       //
    int32_t chraging_monday_loop = 0;
    int32_t chraging_tuesday_loop = 0;
    int32_t chraging_wednesday_loop = 0;
    int32_t chraging_thursday_loop = 0;
    int32_t chraging_friday_loop = 0;
    int32_t chraging_saturday_loop = 0;
    //
    std::mutex  bcTpmsTyrepressureFlMtx;
    std::condition_variable  bcTpmsTyrepressureFlCv;

    std::mutex  bcTpmsTyrepressureFrMtx;
    std::condition_variable  bcTpmsTyrepressureFrCv;

    std::mutex  bcTpmsTyrepressureRlMtx;
    std::condition_variable  bcTpmsTyrepressureRlCv;

    std::mutex  bcTpmsTyrepressureRrMtx; 
    std::condition_variable  bcTpmsTyrepressureRrCv;

    std::mutex eVcuChrgStsMtx;                  
    std::condition_variable ecVcuChrgStsCv;

		std::mutex 	bcTpmsTyretemperatureMtx;
		std::condition_variable bcTpmsTyretemperatureCv;
    std::mutex ecMomerMaxTempCellMtx;
    std::condition_variable ecMomerMaxTempCellCv;
    std::mutex ecMomerMinTempCellMtx;
    std::condition_variable ecMomerMinTempCellCv;
  private:
    int SpeedCalculate(float& speedvalue,float newvalue);
    void spdwatchDog();

    void can071_Watcher();
    void can30A_Watcher();
    void can30B_Watcher();
    void can30C_Watcher();

    void loopSendDynamicOrCTLC();
    // 1
    //void monitorChargState();
    // 1
    void monitorTpmsTyretemperatureState();
    // 1
    void monitorMomerMaxTempCell();
    // 1
    void monitorMomerMinTempCell();
    // 1
    void monitorTpmsTyrepressureFlState();
    // 1
    void monitorTpmsTyrepressureFrState();
    // 1
    void monitorTpmsTyrepressureRlState();
    // 1
    void monitorTpmsTyrepressureRrState();

    // MCU
    void ev_vcu_mcu_power_statusWatcher();
    // soc
    void ccm_soc_power_statusWatcher();
    int32_t wait_standby_Entry_condition();
    int32_t wait_active_Entry_condition();
    int32_t wait_SHUTDOWN_CANCELLED_condition();
    int32_t wait_SHUTDOWN_PREPARE_condition();
    int32_t wait_ON_condition();
    int32_t wait_FINISH_condition();
    int32_t wait_str_DEEP_SLEEP_Entry_condition();

    void HeartbeatTimeoutWatcher();
    void SpeedWatcher();
    void ec_vcu_d_cdischrg_permWatcher();
    void ec_vcu_pt_stWatcher();
    void ec_vcu_hvpowerWatcher();
    void ec_vcu_dcd_cworkenableWatcher();
    void ec_vcu_charallowWatcher();
    void ec_vcu_igonWatcher();
    void ec_vcu_sleepindicationsignalWatcher();
    void ec_vcu_livecounter_0x100Watcher();
    void ec_vcu_checksum_0x100Watcher();
    void ec_bms_heatrelaystatusWatcher();
    void ec_bms_cc2statusWatcher();
    void ec_bms_livecounter_0x120Watcher();
    void ec_bms_checksum_0x120Watcher();
    void ec_bms_batinsulatresistanceWatcher();
    void ec_bms_batterycurrentWatcher();
    void ec_bms_packvoltageWatcher();
    void ec_bms_packvoltage_vWatcher();
    void ec_bms_livecounter_0x125Watcher();
    void ec_bms_checksum_0x125Watcher();
    void ec_bms_remainingchargetimeWatcher();
    void ec_bms_batterysocWatcher();
    void ec_bms_livecounter_0x135Watcher();
    void ec_bms_checksum_0x135Watcher();
    void ec_mcu_motortorqueWatcher();
    void ec_mcu_motorspdWatcher();
    void ec_mcu_llivecounter_0x200Watcher();
    void ec_mcu_checksum_0x200Watcher();
    void ec_mcu_buscurrentWatcher();
    void ec_mcu_busvoltWatcher();
    void ec_mcu_llivecounter_0x201Watcher();
    void ec_mcu_checksum_0x201Watcher();
    void ec_mcu_err_codeWatcher();
    void ec_mcu_motortempWatcher();
    void ec_mcu_igbttempWatcher();
    void ec_mcu_motoropermodeWatcher();
    void ec_mcu_llivecounter_0x202Watcher();
    void ec_mcu_checksum_0x202Watcher();
    void ec_mcu_motor_fault_total_numWatcher();
    void ec_mcu_motor_stateWatcher();
    void ec_mcu_igbt_overheat_warningWatcher();
    void ec_mcu_motor_overheat_warningWatcher();
    void ec_mcu_llivecounter_0x203Watcher();
    void ec_mcu_checksum_0x203Watcher();
    void ec_ipu_smart_dc_stWatcher();
    void ec_ipu_livecounter_0x450Watcher();
    void ec_ipu_checksum_0x450Watcher();
    void ec_ipu_c_cresistancevalueWatcher();
    void ec_ipu_livecounter_0x470Watcher();
    void ec_ipu_checksum_0x470Watcher();
    void ec_ipu_ob_cinputvoltageWatcher();
    void ec_ipu_c_pdutycycleWatcher();
    void ec_ipu_ob_cinputcurrentWatcher();
    void ec_ipu_dcd_crealtimeopcurrWatcher();
    void ec_ipu_dcd_coperatingmodeWatcher();
    void ec_ipu_dcd_crealtimeopvoltWatcher();
    void ec_ipu_dcd_cbodytempWatcher();
    void ec_ipu_livecounter_0x490Watcher();
    void ec_ipu_checksum_0x490Watcher();
    void ec_ipu_dcdc_over_tempWatcher();
    void ec_bms_battery_pack_average_tempWatcher();
    void ec_bms_packtotalcellnumWatcher();
    void ec_bms_packtotaltempnumWatcher();
    void ec_bms_maxvoltcellpacknumWatcher();
    void ec_bms_minvoltcellpacknumWatcher();
    void ec_bms_livecounter_0x510Watcher();
    void ec_bms_checksum_0x510Watcher();
    void ec_bms_mintempmonomercellWatcher();
    void ec_bms_maxtempmonomercellWatcher();
    void ec_bms_maxtempcellWatcher();
    void ec_bms_mintempcellWatcher();
    void ec_bms_maxtempcellpacknumWatcher();
    void ec_bms_mintempcellpacknumWatcher();
    void ec_bms_deg_d_ccharsockettemp2Watcher();
    void ec_bms_deg_d_ccharsockettemp1Watcher();
    void ec_bms_livecounter0x511Watcher();
    void ec_bms_checksum_0x511Watcher();
    void ec_bms_minvoltmonomercellWatcher();
    void ec_bms_maxvoltmonomercellWatcher();
    void ec_bms_maxvoltcellWatcher();
    void ec_bms_minvoltcellWatcher();
    void ec_bms_livecounter_0x512Watcher();
    void ec_bms_checksum_0x512Watcher();
    void ec_bms_packratecapWatcher();
    void ec_bms_pack_rate_voltWatcher();
    void ec_bms_packrateenergyWatcher();
    void ec_bms_batt_typeWatcher();
    void ec_bms_battcooltypeWatcher();
    void ec_bms_livecounter_0x520Watcher();
    void ec_bms_checksum_0x520Watcher();
    void ec_bms_packudvoltWatcher();
    void ec_bms_packovervoltWatcher();
    void ec_bms_overtempWatcher();
    void ec_bms_deltatempWatcher();
    void ec_bms_lowinsresWatcher();
    void ec_bms_celludvoltWatcher();
    void ec_bms_cellovervoltWatcher();
    void ec_bms_packlowsocWatcher();
    void ec_bms_packfastchgsocWatcher();
    void ec_bms_packhighsocWatcher();
    void ec_bms_packoverchargeWatcher();
    void ec_bms_ucellinconWatcher();
    void ec_bms_thermalrunawayalarmWatcher();
    void ec_bms_h_vilfaultWatcher();
    void ec_bms_batsysnotmtcWatcher();
    void ec_bms_fault_codeWatcher();
    void ec_bms_batt_fault_total_numWatcher();
    void ec_bms_livecounter_0x522Watcher();
    void ec_bms_checksum_0x522Watcher();
    void ec_vcu_shif_faultWatcher();
    void ec_vcu_shift_positionWatcher();
    void ec_vcu_actual_gearWatcher();
    void ec_vcu_bp_statusWatcher();
    void ec_vcu_park_faultWatcher();
    void ec_vcu_park_stateWatcher();
    void ec_vcu_switch_gear_warnWatcher();
    void ec_vcu_delay_mon_modeWatcher();
    void ec_vcu_ap_statusWatcher();
    void ec_vcu_brk_lamp_ctr_cmdWatcher();
    void ec_vcu_lock_veh_warnWatcher();
    void ec_vcu_creep_stsWatcher();
    void ec_vcu_single_ped_stsWatcher();
    void ec_vcu_ap_faultWatcher();
    void ec_vcu_bp_faultWatcher();
    void ec_vcu_brk_pdl_posWatcher();
    void ec_vcu_livecounter_0x350Watcher();
    void ec_vcu_checksum_0x350Watcher();
    void ec_vcu_chrg_stsWatcher();
    void ec_vcu_chrg_cnctr_stsWatcher();
    void ec_vcu_pt_rdyWatcher();
    void ec_vcu_smart_dc_reqWatcher();
    void ec_vcu_chrg_soc_tar_spWatcher();
    void ec_vcu_dis_chrg_stsWatcher();
    void ec_vcu_dc_chrg_rly_stsWatcher();
    void ec_vcu_average_energy_consum_vdWatcher();
    void ec_vcu_dc_chrg_rly_auxil_cntac_stsWatcher();
    void ec_vcu_braking_remindWatcher();
    void ec_vcu_average_energy_consumptionWatcher();
    void ec_vcu_instant_energy_consumptionWatcher();
    void ec_vcu_instant_energy_consum_vdWatcher();
    void ec_vcu_chraging_mode_spWatcher();
    void ec_vcu_livecounter_0x351Watcher();
    void ec_vcu_checksum_0x351Watcher();
    void ec_ccm_veh_tar_socWatcher();
    void ec_ccm_batt_maintain_ctr_cmdWatcher();
    void ec_ota_modelWatcher();
    void ec_ccm_rechrgn_lv_reqWatcher();
    void ec_ccm_driver_buckle_statusWatcher();
    void ec_ccm_drive_mode_reqWatcher();
    void ec_ccm_operat_licenceWatcher();
    void ec_ccm_versionWatcher();
    void ec_ccm_speed_limit_levelWatcher();
    void ec_ccm_charging_conditionsWatcher();
    void ec_total_odometerWatcher();
    void ec_ccm_target_chrg_currWatcher();
    void ec_ccm_batt_maintain_stsWatcher();
    void ec_ccm_livecounter_0x353Watcher();
    void ec_ccm_checksum_0x353Watcher();
    void ec_ccm_remt_ctrl_flagWatcher();
    void ec_ccm_charging_requestWatcher();
    void ec_ccm_chraging_modeWatcher();
    void ec_ccm_energy_recov_level_cmdWatcher();
    void ec_ccm_creep_ctr_cmdWatcher();
    void ec_ccm_single_ped_ctr_cmdWatcher();
    void ec_ccm_rema_range_dispWatcher();
    void ec_ccm_rema_range_disp_vdWatcher();
    void ec_ccm_livecounter_0x354Watcher();
    void ec_ccm_checksum_0x354Watcher();
    void ec_vcu_drive_modeWatcher();
    void ec_vcu_low_soc_warnWatcher();
    void ec_vcu_can_timeout_faultWatcher();
    void ec_vcu_eas_ins_staWatcher();
    void ec_vcu_faultlevelWatcher();
    void ec_vcu_dc_discharging_fail_warnWatcher();
    void ec_vcu_dc_charging_fail_warnWatcher();
    void ec_vcu_ac_charging_fail_warnWatcher();
    void ec_vcu_12_v_charging_fail_warnWatcher();
    void ec_vcu_brak_sys_warnWatcher();
    void ec_vcu_veh_unable_dri_warnWatcher();
    void ec_vcu_brk_liquid_level_lowWatcher();
    void ec_vcu_vacum_pump_faultWatcher();
    void ec_vcu_mot_water_pump_statusWatcher();
    void ec_vcu_fault_codeWatcher();
    void ec_vcu_fault_treat_levelWatcher();
    void ec_vcu_drive_pwr_limWatcher();
    void ec_vcu_mcu_errWatcher();
    void ec_vcu_hv_batt_errWatcher();
    void ec_vcu_operat_licenceWatcher();
    void ec_vcu_versionWatcher();
    void ec_vcu_speed_limit_levelWatcher();
    void ec_vcu_charging_conditionsWatcher();
    void ec_vcu_livecounter_0x352Watcher();
    void ec_vcu_checksum_0x352Watcher();
    void ec_vcu_comp_neg_rel_staWatcher();
    void ec_vcu_comp_pos_rel_staWatcher();
    void ec_vcu_ipu_errWatcher();
    void ec_vcu_cooling_fail_warnWatcher();
    void ec_vcu_lv_elec_sys_errWatcher();
    void ec_vcu_ac_hv_sys_errWatcher();
    void ec_vcu_ptc2_rel_staWatcher();
    void ec_vcu_ptc1_rel_staWatcher();
    void ec_vcu_highpower_voltageWatcher();
    void ec_vcu_fan_relay_pin_stsWatcher();
    void ec_vcu_water_pump_relay_pin_stsWatcher();
    void ec_vcu_awake_obc_pin_stsWatcher();
    void ec_vcu_awake_bms_pin_stsWatcher();
    void ec_vcu_awake_mcu_pin_stsWatcher();
    void ec_vcu_main_relay_pin_stsWatcher();
    void ec_vcu_dc_chrg_awake_pin_stsWatcher();
    void ec_vcu_ac_chrg_awake_pin_stsWatcher();
    void ec_vcu_water_pump_pwmWatcher();
    void ec_vcu_power_supply_voltagWatcher();
    void ec_vcu_livecounter_0x215Watcher();
    void ec_vcu_checksum_0x215Watcher();
    void ec_vcu_pump_stateWatcher();
    void ec_vcu_mid_door_ajar_statusWatcher();
    void ec_vcu_actual_rema_range_vdWatcher();
    void ec_vcu_cltc_rema_range_vdWatcher();
    void ec_vcu_pt_cenableWatcher();
    void ec_vcu_accmenableWatcher();
    void ec_vcu_vehicle_spdWatcher();
    void ec_vcu_vehicle_spd_dspWatcher();
    //void HandlePowerOnspd(float speed);
    void ec_vcu_actual_rema_rangeWatcher();
    void ec_vcu_cltc_rema_rangeWatcher();
    void bcm_mcu_display_rangeWatcher();    
    void ec_vcu_livecounter_0x250Watcher();
    void ec_vcu_checksum_0x250Watcher();
    void ec_vcu_sofeware_numWatcher();
    void ec_vcu_hardware_numWatcher();
    void ec_vcu_yearWatcher();
    void ec_vcu_monthWatcher();
    void ec_vcu_dayWatcher();
    void ec_ccm_a_ckeyWatcher();
    void ec_ccm_ac_havc_stateWatcher();
    void ec_ccm_vehicle_spd_dspWatcher();
    void ec_ccm_livecounter_0x310Watcher();
    void ec_ccm_checksum_0x310Watcher();
    void ec_b2_v_v_frame_noWatcher();
    void ec_b2_v_v_cell_volt_n1Watcher();
    void ec_b2_v_v_cell_volt_n2Watcher();
    void ec_b2_v_v_cell_volt_n3Watcher();
    void ec_b2_v_t_frame_noWatcher();
    void ec_b2_v_t_cell_temp_n1Watcher();
    void ec_b2_v_t_cell_temp_n2Watcher();
    void ec_b2_v_t_cell_temp_n3Watcher();
    void ec_b2_v_t_cell_temp_n4Watcher();
    void ec_b2_v_t_cell_temp_n5Watcher();
    void ec_b2_v_t_cell_temp_n6Watcher();
    void ec_b2_v_t_cell_temp_n7Watcher();
    void ec_b2_v_gbsn_frame_noWatcher();
    void ec_b2_v_gbsn_sys_code_lengthWatcher();
    void ec_b2_v_gbsn_sys_code_1_7_13_19Watcher();
    void ec_b2_v_gbsn_sys_code_2_8_14_20Watcher();
    void ec_b2_v_gbsn_sys_code_3_9_15_21Watcher();
    void ec_b2_v_gbsn_sys_code_4_10_16_22Watcher();
    void ec_b2_v_gbsn_sys_code_5_11_17_23Watcher();
    void ec_b2_v_gbsn_sys_code_6_12_18_24Watcher();
    void ec_vcu_work_reqWatcher();
    void ec_vcu_livecounter_0x661Watcher();
    void ec_vcu_checksum_0x661Watcher();
    void ec_str_work_reqWatcher();
    void ec_ccm_nm_bitWatcher();
    void ec_ccm_livecounter_0x66_cWatcher();
    void ec_ccm_checksum_0x66_cWatcher();
    void ec_tbox_time_statusWatcher();
    void ec_tbox_yearWatcher();
    void ec_tbox_monthWatcher();
    void ec_tbox_dayWatcher();
    void ec_tbox_hourWatcher();
    void ec_tbox_minuteWatcher();
    void ec_tbox_secondWatcher();
    void ec_ccm_soc_sofeware_numWatcher();
    void ec_ccm_soc_hardware_numWatcher();
    void ec_ccm_mcu_sofeware_numWatcher();
    void ec_ccm_mcu_hardware_numWatcher();
    void ec_bms_batterysoc_virtualWatcher();
    void ec_bms_single_chrg_energyWatcher();
    void ec_bms_livecounter_0x513Watcher();
    void ec_bms_checksum_0x513Watcher();
    void ec_bms_batt_info4_dc_charg_req_currWatcher();
    void ec_bms_batt_info4_dc_charg_req_volWatcher();
    void ec_bms_batt_info4_mach_put_currWatcher();
    void ec_bms_batt_info4_mach_put_voltWatcher();
    void ec_tbox_cpu_temperature_lowWatcher();
    void ec_tbox_cpu_temperature_highWatcher();
    void ec_pcb_temperature_lowWatcher();
    void ec_pcb_temperature_highWatcher();
    void ec_main_power_supply_voltahe_lowWatcher();
    void ec_main_power_supply_voltahe_highWatcher();
    void ec_sim_card_not_presentWatcher();
    void ec_wifi_device_lostWatcher();
    void ec_ccm_detects_eas_node_lossWatcher();
    void ec_ccm_detects_bms_node_lossWatcher();
    void ec_ccm_detects_ipu_node_lossWatcher();
    void ec_ccm_detects_vcu_node_lossWatcher();
    void ec_private_can3_bus_offWatcher();
    void ec_private_can2_bus_offWatcher();
    void ec_private_can1_bus_offWatcher();
    void ec_detect_backup_battery_lostWatcher();
    void ec_ccm_detects_acu_node_lossWatcher();
    void ec_ccm_detects_bcm_node_lossWatcher();
    void ec_ccm_detects_ac_node_lossWatcher();
    void bc_eas_motspdWatcher();
    void bc_eas_eashvil_staWatcher();
    void bc_eas_crtstsWatcher();
    void bc_eas_ip_mtempWatcher();
    void bc_eas_ctrlrstsWatcher();
    void bc_eas_crtpwrWatcher();
    void bc_eas_ctrlrcrtWatcher();
    void bc_eas_ctrlrvoltWatcher();
    void bc_ac_blower_levelWatcher();
    void bc_ac_fan_reqWatcher();
    void bc_ac_fresh_reci_stateWatcher();
    void bc_ac_front_defrost_stateWatcher();
    void bc_ac_heat_stateWatcher();
    void bc_ac_havc_stateWatcher();
    void bc_ac_ai_rdistribution_modeWatcher();
    void bc_ac_a_cstateWatcher();
    void bc_ac_left_set_temperatureWatcher();
    void bc_ac_fan_pwmWatcher();
    void bc_ac_fan_feed_back_voltageWatcher();
    void bc_ac_pt_ctempWatcher();
    void bc_ac_fault_statusWatcher();
    void bc_ac_ptc_over_heatWatcher();
    void bc_ac_eas_speed_reqWatcher();
    void bc_ac_ptcp_power_reqWatcher();
    void bc_ac_press_swtich_stateWatcher();
    void bc_ac_livecounter_0x233Watcher();
    void bc_ac_checksum_0x233Watcher();
    void bc_ccm_fresh_reci_keyWatcher();
    void bc_ccm_front_defrost_keyWatcher();
    void bc_ccm_a_ckeyWatcher();
    void bc_ccm_blower_levelWatcher();
    void bc_ccm_ac_havc_stateWatcher();
    void bc_ccm_air_distribution_mode_reqWatcher();
    void bc_ccm_heat_keyWatcher();
    void bc_ccm_left_set_tempWatcher();
    void bc_ccm_avassetWatcher();
    void bc_ccm_livecounter_0x310Watcher();
    void bc_ccm_checksum_0x310Watcher();
    void bc_ccm_rear_fog_lamp_setWatcher();
    void bc_ccm_left_mirror_setWatcher();
    void bc_ccm_park_un_lock_reqWatcher();
    void bc_ccm_auto_lock_reqWatcher();
    void bc_ccm_auto_unlock_reqWatcher();
    void bc_ccm_remt_contr_lamp_ctr_cmdWatcher();
    void bc_ccu_remote_car_searchWatcher();
    void bc_ccu_remote_lockWatcher();
    void bc_ccm_right_mirror_setWatcher();
    void bc_ccm_livecounter_0x311Watcher();
    void bc_ccm_checksum_0x311Watcher();
    void bc_bcm_position_light_statusWatcher();
    void bc_bcm_high_beam_statusWatcher();
    void bc_bcm_low_beam_statusWatcher();
    void bc_bcm_turn_indcr_riWatcher();
    void bc_bcm_turn_indcr_leWatcher();
    void bc_bcm_hazard_light_statusWatcher();
    void bc_bcm_position_light_warningWatcher();
    void bc_bcm_rl_door_ajar_statusWatcher();
    void bc_bcm_rr_door_ajar_statusWatcher();
    void bc_bcm_fr_door_ajar_statusWatcher();
    void bc_bcm_fl_door_ajar_statusWatcher();
    void bc_bcm_rear_fog_light_statusWatcher();
    void bc_bcm_tr_cls_stWatcher();
    void bc_bcm_power_stsWatcher();
    void bc_bcm_ccm_open_door_warn_feedWatcher();
    void bc_bcm_dtc_fault_statusWatcher();
    void bc_bcm_veh_alrm_sys_stWatcher();
    void bc_bcm_drivelock_stWatcher();
    void bc_bcm_reversinglight_stWatcher();
    void bc_bcm_brakelight_stWatcher();
    void bc_bcm_interiorlight_stWatcher();
    void bc_bcm_right_mirror_set_ackWatcher();
    void bc_bcm_left_mirror_set_ackWatcher();
    void bc_bcm_park_un_lock_ackWatcher();
    void bc_bcm_auto_lock_ackWatcher();
    void bc_bcm_auto_unlock_ackWatcher();
    void bc_bcm_livecounter_0x330Watcher();
    void bc_bcm_checksum_0x330Watcher();
    void bc_bcm_high_beam_rly_errWatcher();
    void bc_bcm_turn_indcr_ri_errWatcher();
    void bc_bcm_turn_indcr_le_errWatcher();
    void bc_bcm_daytime_running_light_errWatcher();
    void bc_bcm_brakelight_errWatcher();
    void bc_bcm_reversinglight_errWatcher();
    void bc_bcm_rear_fog_light_errWatcher();
    void bc_bcm_loss_com_with_acuWatcher();
    int32_t getElectricErr();
    void bc_bcm_loss_com_with_ccmWatcher();
    void bc_bcm_loss_com_with_vcuWatcher();
    void bc_bcm_lv_batt_over_voltWatcher();
    void bc_bcm_lv_batt_under_voltWatcher();
    void bc_bcm_horn_rly_errWatcher();
    void bc_bcm_low_beam_rly_errWatcher();
    void bc_bcm_livecounter_0x331Watcher();
    void bc_bcm_checksum_0x331Watcher();
    void bc_pdc1_button_pressWatcher();
    void bc_pdc1_modeWatcher();
    void bc_pdc1_buzzer_alarm_patternWatcher();
    void bc_pdc1_distance_rmWatcher();
    void bc_pdc1_distance_rrmWatcher();
    void bc_pdc1_distance_rlWatcher();
    void bc_pdc1_distance_rrWatcher();
    void bc_pdc_livecounter_0x165Watcher();
    void bc_pdc_checksum_0x165Watcher();
    void bc_bcm_work_reqWatcher();
    void bc_bcm_livecounter_0x669Watcher();
    void bc_bcm_checksum_0x669Watcher();
    void bc_str_work_reqWatcher();
    void bc_ccm_nm_bitWatcher();
    void bc_ccm_livecounter_0x66_bWatcher();
    void bc_ccm_checksum_0x66_bWatcher();
    void bc_avas_stateWatcher();
    void bc_avas_livecounter_0x411Watcher();
    void bc_avas_checksum_0x411Watcher();
    void bc_bcm_ccm_reset_stWatcher();
    void bc_ota_modelWatcher();
    void bc_ccm_bcm_open_door_warn_setWatcher();
    void bc_ccm_livecounter_0x353Watcher();
    void bc_ccm_checksum_0x353Watcher();
    void bc_ccm_tpms_learning_validWatcher();
    void bc_ccm_remt_ctrl_flagWatcher();
    void bc_ccm_livecounter_0x354Watcher();
    void bc_ccm_checksum_0x354Watcher();
    void bc_tpms_receiverstateWatcher();
    void bc_tpms_transducer_locationWatcher();
    void bc_tpms_tyrestate_frWatcher();
    void bc_tpms_tyrestate_flWatcher();
    void bc_tpms_tyrestate_rlWatcher();
    void bc_tpms_tyrestate_rrWatcher();
    void bc_tpms_tyretemperatureWatcher();
    void bc_tpms_tyrepressure_flWatcher();
    void bc_tpms_tyrepressure_frWatcher();
    void bc_tpms_tyrepressure_rrWatcher();
    void bc_tpms_tyrepressure_rlWatcher();
    void cc_acu_gsensor_faultWatcher();
    void cc_acu_system_stsWatcher();
    void cc_acu_airb_warn_lamp_stWatcher();
    void cc_acu_crash_outp_stsWatcher();
    void cc_acu_livecounter_0x133Watcher();
    void cc_acu_checksum_0x133Watcher();
    void cc_abs_abs_fail_statusWatcher();
    void cc_abs_llivecounter_0x171Watcher();
    void cc_abs_checksum_0x171Watcher();
    void cc_eps_run_stateWatcher();
    void cc_eps_livecounter_0x300Watcher();
    void cc_eps_checksum_0x300Watcher();
    void cc_eps_motor_curr_fltWatcher();
    void cc_eps_motor_volt_fltWatcher();
    void cc_eps_torq_snr_s_sig_out_rng_fltWatcher();
    void cc_eps_torq_snr_p_sig_out_rng_fltWatcher();
    void cc_eps_torq_snr_t1_t2_sig_sync_fltWatcher();
    void cc_eps_torq_snr_t1_sig_out_rng_fltWatcher();
    void cc_eps_torq_snr_t2_sig_out_rng_fltWatcher();
    void cc_eps_torq_snr5_v_fltWatcher();
    void cc_eps_can_bus_fltWatcher();
    void cc_eps_over_volt_fltWatcher();
    void cc_eps_under_volt_fltWatcher();
    void cc_eps_uncalibrated_angle_fltWatcher();
    void cc_eps_over_heat_fltWatcher();
    void cc_eps_relay_fltWatcher();
    void cc_eps_motor_curr_fellow_fltWatcher();
    void cc_eps_motor_drv_fltWatcher();
    void cc_eps_vcu_time_out_fltWatcher();
    void cc_eps_livecounter_0x301Watcher();
    void cc_eps_checksum_0x301Watcher();
    void cc_abs_wheel_speed_fr_no_signal_errWatcher();
    void cc_abs_wheel_speed_fr_interm_errWatcher();
    void cc_abs_wheel_speed_fr_open_short_errWatcher();
    void cc_abs_wheel_speed_fl_no_signal_errWatcher();
    void cc_abs_wheel_speed_fl_interm_errWatcher();
    void cc_abs_wheel_speed_fl_open_short_errWatcher();
    void cc_abs_power_undervoltWatcher();
    void cc_abs_power_overvoltWatcher();
    void cc_abs_valve_relay_errWatcher();
    void cc_abs_wheel_speed_freq_errWatcher();
    void cc_abs_wheel_speed_rr_no_signal_errWatcher();
    void cc_abs_wheel_speed_rr_interm_errWatcher();
    void cc_abs_wheel_speed_rr_open_short_errWatcher();
    void cc_abs_wheel_speed_rl_no_signal_errWatcher();
    void cc_abs_wheel_speed_rl_interm_errWatcher();
    void cc_abs_wheel_speed_rl_open_short_errWatcher();
    void cc_abs_outlet_valve_rr_errWatcher();
    void cc_abs_inlet_valve_rr_errWatcher();
    void cc_abs_outlet_valve_rl_errWatcher();
    void cc_abs_inlet_valve_rl_errWatcher();
    void cc_abs_outlet_valve_fr_errWatcher();
    void cc_abs_inlet_valve_fr_errWatcher();
    void cc_abs_outlet_valve_fl_errWatcher();
    void cc_abs_inlet_valve_fl_errWatcher();
    void cc_abs_current_max_fault_levelWatcher();
    void cc_abs_can_bus_off_errWatcher();
    void cc_abs_can_hardware_errWatcher();
    void cc_abs_ecu_hardware_errWatcher();
    void cc_abs_motor_relay_errWatcher();
    void cc_abs_motor_errWatcher();
    void cc_abs_valve_errWatcher();
    void cc_abs_livecounter_0x420Watcher();
    void cc_abs_checksum_0x420Watcher();
    void mc_lamplet_statusWatcher();
    void mc_main_seat_pressure_statusWatcher();
    void mc_brake_level_alarm_statusWatcher();
    void mc_main_seat_safety_belt_statusWatcher();
    void mc_engine_statusWatcher();
    void mc_low_vol_battery_volWatcher();
	void mc_key_previous_songWatcher();
    void mc_key_next_songWatcher();
    void mc_key_volume_upWatcher();
    void mc_key_volume_dowmWatcher();
    void mc_key_mode_muteWatcher();
    void mc_key_telephoneWatcher();
    void mc_key_voiceWatcher();
    void mc_key_homeWatcher();
    void mc_key_customWatcher();
    void mc_key_distanceWatcher();
    void mc_key_speedupWatcher();
    void mc_key_speeddownWatcher();
    void mc_key_pagedownWatcher();
    void mc_key_pageupWatcher();
    void mc_key_okayWatcher();
    void mc_key_long_volume_upWatcher();
    void mc_key_long_volume_dowmWatcher();
    void mc_key_long_telephoneWatcher();
    void mc_key_long_customWatcher();
    void mc_key_long_previous_songWatcher();
    void mc_key_long_next_songWatcher();
    void mc_light_levelWatcher();
    void sc_ec_ccm_batt_maintain_ctr_cmdWatcher();
    void sc_ec_ccm_batt_maintain_stsWatcher();
    void sc_ec_ccm_versionWatcher();
    void sc_ec_ccm_soc_sofeware_numWatcher();
    void sc_ec_ccm_soc_hardware_numWatcher();
    void sc_ec_ccm_mcu_software_numWatcher();
    void sc_ec_ccm_mcu_hardware_numWatcher();
    void sc_ec_ccm_target_chrg_currWatcher();
    void sc_ccm_remote_lockWatcher();
    void sc_ccm_remote_car_searchWatcher();
    void sc_ccm_remt_ctrl_flagWatcher();
    void sc_ec_ccm_operat_licenceWatcher();
    void ec_bms_realtimealowdischapowerWatcher();
    void ec_ipu_ipuhvil_staWatcher();
    void ec_ipu_mainrelayposistatusWatcher();
    void ec_ipu_workstatusWatcher();
    void ec_vcu_tqreqWatcher();
    void ec_bms_softwareversionWatcher();
    void ec_ipu_hardware_numWatcher();
    void ec_ipu_sofeware_numWatcher();
    void interval_time();
    float getActualFloatValue(int32_t raw_value, float factor, int offset);
    float getActualFloatValue_offset_is_float(int32_t raw_value, float factor, float offset);
    void ccm_appointment_mode();
    void ccm_chraging_begin_time_hour();
    void ccm_chraging_begin_time_minute();
    void ccm_chraging_end_time_hour();
    void ccm_chraging_end_time_minute();
    void ccm_chraging_sunday_loop();
    void ccm_chraging_monday_loop();
    void ccm_chraging_tuesday_loop();
    void ccm_chraging_wednesday_loop();
    void ccm_chraging_thursday_loop();
    void ccm_chraging_friday_loop();
    void ccm_chraging_saturday_loop();
    void ccm_chraging_target_soc();
    void ec_ipu_obc_output_voltageWatcher();
    void ec_ipu_obc_output_currentWatcher();
    void ec_bms_mainrelaynega_statusWatcher();
    void ec_bms_batterysohWatcher();
    void ec_bms_soeWatcher();
    void ec_bms_hv_batt_stWatcher();		
    void ec_bms_initstatusWatcher();
    void bcm_rear_fog_light_errWatcher();	       
    void bcm_reversinglight_errWatcher();	       
    void bcm_brakelight_errWatcher();	           
    void bcm_daytime_running_light_errWatcher();	
    void bcm_position_light_errWatcher();	       
    void bcm_turn_indcr_le_errWatcher();	        
    void bcm_turn_indcr_ri_errWatcher();	        
    void bcm_high_beam_rly_errWatcher();	        
    void bcm_low_beam_rly_errWatcher();
    void mcu_voiume_navigationWatcher();
    void mcu_voiume_voicWatcher();
    void mcu_voiume_multimediaWatcher();
    void mcu_voiume_phoneWatcher();
    void mcu_voiume_alarmWatcher();
    void mcu_voiume_keyWatcher();  	                		
    void mcu_info_vin1Watcher();
    void mcu_info_vin2Watcher();
    void mcu_info_vin3Watcher();
    void mcu_info_vinWatcher();
    void mcu_info_sn1Watcher();
    void mcu_info_sn2Watcher();
    void mcu_info_sn3Watcher();
    void mcu_info_versionWatcher();
    void mc_travel_rangeWatcher();
    void mc_travel_timeWatcher();
    void mc_average_energy_consumptionWatcher();
    void rangeModeSet();
    void gecko_headlighthSet();
    void mc_remind_inrWatcher();
    void mc_remind_start_timeWatcher();
    void mc_remind_distanceWatcher();
    void mc_remind_start_odoWatcher();
    void bc_ac_hybrid_eco_mode_staWatcher();
    void bc_bcm_wipr_intl_time_set_fbWatcher();
    void bc_bcm_flwr_me_hm_ctrl_fbWatcher();
    void bc_bcm_illmnd_unlock_sts_fbWatcher();
    void bc_bcm_illmnd_lock_sts_fbWatcher();
    void bc_bcm_lock_horn_on_st_fbWatcher();
    void ec_esc_esc_disableWatcher();
    void ec_ehb_avh_appld_stWatcher();
    void ec_ehb_epb_system_stateWatcher();
    void ec_ehb_brk_dis_wip_acWatcher();
    void ec_elec_steer_mode_staWatcher();
    void bc_veh_act_recuperate_pwrWatcher();
    void ec_vehicle_driving_pwrWatcher();
    void ec_srs_passenger_airbag_sta_rsvrWatcher();
    void bc_bcm_front_fog_light_statusWatcher();
    void bc_bcm_key_lo_batt_lvl_warnWatcher();
    void bc_bcm_warn_no_key_foundWatcher();
    void bc_bcm_auto_lamp_statusWatcher();
    void bc_bcm_indication_shiftto_neutralWatcher();
    void ec_vcu_12_v_bat_low_vol_staWatcher();
    void ec_vcu_sibs_kl30_voltageWatcher();
    void ec_srs_airbag_warning_lamp_stsWatcher();
    void ec_srs_drv_seatbelt_buckle_validWatcher();
    void ec_ipu_obc_inlet_connect_staWatcher();
    void ec_bms_dcs_inlet_connect_staWatcher();
    void ec_bms_pwr_train_connect_staWatcher();
    void ec_ehb_brake_liquid_level_warnWatcher();
    void ec_esc_ebd_failedWatcher();
    void ec_vcu_vhcl_p_gear_errorWatcher();
    void ec_vcu_motor_high_temp_wrningWatcher();
    void ec_vcu_mcu_high_temp_wrningWatcher();
    void ec_bcm_central_lock_stsWatcher();
    void ec_vcu_pcu_fail_staWatcher();
    void bc_bcm_warn_key_out_reminderWatcher();
    void bc_bcm_light_intensityWatcher();
    void bc_bcm_indication_key_closerWatcher();
    void ec_srs_pass_seatbelt_bucklestatusWatcher();
    void ec_srs_pass_seatbelt_buckle_validWatcher();
    void ec_srs_pass_seat_occupant_sensor_stsWatcher();
    void ec_srs_mid_seat_belt_bucklestatusWatcher();
    void ec_srs_mid_seat_belt_buckle_validWatcher();
    void ec_srs_mid_seat_occupant_sensor_stsWatcher();
    void ec_ipu_obc_actl_oprt_modeWatcher();
    void ec_bms_dcs_act_oprt_modeWatcher();
    void ec_vcu_reserve_powerWatcher();
    void ec_vcu_motor_actual_powerWatcher();
    void ec_vcu_motor_actual_power_typeWatcher();
    void ec_vcu_hdc_statusWatcher();
    void ec_esc_es_cor_tcs_failedWatcher();
    void ec_esc_tcs_active_staWatcher();
    void ec_esc_esp_active_staWatcher();
    void ec_ehb_avh_lamp_reqWatcher();
    void ec_ehb_epb_display_msg_idWatcher();
    void ec_ehb_avh_disp_msgWatcher();
    void ec_ehb_epb_warn_lamp_staWatcher();
    void ec_vcu_obc_oprt_cmd_to_icuWatcher();
    void bc_ac_envir_temp_vWatcher();
    void bc_ac_envir_tempWatcher();
    void config_query_sim_cardWatcher();
    void config_query_4g_strengthWatcher();
    void config_query_wifi_strengthWatcher();
    void config_query_wifi_statusWatcher();
    void config_query_gps_lonWatcher();
    void config_query_gps_latWatcher();
    void vcu_chraging_mode_sp_reqWatcher();
     void bc_pp_fl_distWatcher();
     void bc_pp_fml_distWatcher();
     void bc_pp_fmr_distWatcher();
     void bc_pp_fr_distWatcher();
     void bc_pp_sdwfsl_distWatcher();
     void bc_pp_sdwfsl_mid_distWatcher();
     void bc_pp_sdwfsr_mid_distWatcher();
     void bc_pp_sensor_fault_sts_frmWatcher();
     void bc_pp_sensor_fault_sts_frWatcher();
     void bc_pp_sdwrsr_distWatcher();
     void bc_pp_staWatcher();
     void bc_pp_sw_fdbkWatcher();
     void bc_fcm_elk_set_fbWatcher();
     void bc_fcm_aeb_set_fbWatcher();
     void bc_fcm_hma_set_fbWatcher();
     void bc_fcm_tsr_spd_lim_warnWatcher();
     void bc_fcm_tsr_spd_lim_warn_auWatcher();
     void bc_fcm_tsr_spd_lim_stsWatcher();
     void bc_fcm_slwf_set_fbWatcher();
     void bc_fcm_fcm_intializationWatcher();
     void bc_fcm_elk_left_modeWatcher();
     void bc_fcm_elk_right_modeWatcher();
     void bc_fcm_slif_set_fbWatcher();
     void bc_fcm_trfc_signWatcher();
     void bc_fcm_tsr_lgt_dstWatcher();
     void bc_fcm_tsr_lat_dstWatcher();
     void bc_fcm_tsr_set_fbWatcher();
     void bc_fcm_tsr_spd_limWatcher();
     void bc_fcm_slif_oper_stsWatcher();
     void bc_fcm_audio_warn_hands_offWatcher();
     void bc_fcm_fault_text_infoWatcher();
     void bc_fcm_lka_audio_warningWatcher();
     void bc_fcm_act_drv_asst_sts_hmiWatcher();
     void bc_fcm_tar_obj_accWatcher();
     void bc_fcm_adas_not_avl_reasWatcher();
     void bc_fcm_acc_startWatcher();
     void bc_fcm_ica_truck_set_fbWatcher();
     void bc_fcm_ica_set_fbWatcher();
     void bc_fcm_adas_quit_reasWatcher();
     void bc_fcm_acc_mode_hmiWatcher();
     void bc_fcm_pcw_pre_warnWatcher();
     void bc_fcm_pcw_latent_warnWatcher();
     void bc_fcm_text_info_lka1Watcher();
     void bc_fcm_ldw_stsWatcher();
     void bc_fcm_ldw_set_fbWatcher();
     void bc_fcm_lka_stsWatcher();
     void bc_fcm_le_line_color_fctWatcher();
     void bc_fcm_lka_set_fbWatcher();
     void bc_fcm_ri_line_color_fctWatcher();
     void bc_fcm_ldw_alert_method_set_fbWatcher();
     void bc_fcm_v_set_disWatcher();
     void bc_fcm_aeb_obj_idWatcher();
     void bc_fcm_raeb_work_stsWatcher();
     void bc_fcm_ldw_audio_warnWatcher();
     void bc_fcm_laterallimitWatcher();
     void ec_ipu_obc_inlelt_actl_powerWatcher();
     void ec_srs_crash_output_stsWatcher();
     void ec_bms_insulation_wrning_distgshWatcher();
     void ec_bms_thermalrunaway_wrnWatcher();
     void ec_bms_dcs_actl_chrg_voltageWatcher();
     void ec_icu_vehicle_speed_displayed_vWatcher();
     void ec_icu_icu_trip_a_odometerWatcher();
     void ec_icu_icu_trip_b_odometerWatcher();
     void cc_eps_basic_elec_steer_failedWatcher();
     void cc_eps_mode_set_inhibit_fbWatcher();
     void cc_eps_sws_hod_hands_off_stsWatcher();
     void bc_vcu_info_dispWatcher();
     void bc_vcu_vhcl_speed_fast_warnWatcher();
     void bc_vcu_drive_mode_key_stagnationWatcher();
     void bc_vcu_cc_key_stagnationWatcher();
     void bc_vcu_shift_key_stagnationWatcher();
     void bc_vcu_lock_veh_warmWatcher();
     void bc_vcu_sibs_kl30_voltageWatcher();
     void bc_vcu_sibs_rtcwu_chg_numWatcher();
     void bc_vcu_sibs_chg_num_allowWatcher();
     void bc_vcu_sibs_rtcwu_chg_fail_numWatcher();
     void bc_vcu_sibs_rtc_chrg_stWatcher();
     void bc_vcu_sibs_wup_volt_allowWatcher();
     void bc_vcu_sibs_bms_bat_soc_allowWatcher();
     void bc_vcu_sibs_fb_rtc_wup_flgWatcher();
     void bc_vcu_ac_chrg_max_currWatcher();
     void bc_vcu_ac_chrg_modeWatcher();
     void bc_ccu_open_ventilation_fbWatcher();
     void bc_ac_ac_unlock_vent_set_fbWatcher();
     void bc_ac_remote_defrost_ctl_fbWatcher();
     void bc_ac_temp_set_fbWatcher();
     void bc_ac_remt_ctrl_fbWatcher();
     void bc_ccu_remote_power_lock_fbWatcher();
     void bc_vcu_speed_limit_level_fbWatcher();
     void bc_vcu_operat_licence_fbWatcher();
     void bc_vcu_version_fbWatcher();
     void bc_vcu_vesion_set_fbWatcher();
     void bc_vcu_wgh_confdenceWatcher();
     void bc_vcu_wgh_estWatcher();
     void bc_vcu_wgh_distbWatcher();
     void bc_vcu_cruise_ctrl_sta_for_bacWatcher();
     void bc_vcu_cruise_ctr_tgt_spd_for_bacWatcher();
     void bc_ac_indoor_tempWatcher();
     void bc_bcm_light_sw_sigWatcher();
     void bc_bcm_ajar_sta_hoodWatcher();
     void bc_tmps_abnm_prsr_warnWatcher();
     void bc_bcm_tpms_reset_stsWatcher();
     void bc_bcm_fr_windowmotor_flagsWatcher();
     void bc_bcm_fl_windowmotor_flagsWatcher();
     void bc_bcm_wash_liquid_level_warnWatcher();
     void bc_bcm_front_wash_stsWatcher();
     void bc_bcm_pas_wdw_initWatcher();
     void bc_bcm_drv_pass_win_sw_sigWatcher();
     void bc_bcm_body_warn_stsWatcher();
     void bc_bcm_key_in_car_staWatcher();
     void bc_bcm_ps_authent_resWatcher();
     void bc_bcm_trunk_lock_sw_ctrl_fbWatcher();
     void bc_bcm_trunk_lock_staWatcher();
     void bc_bcm_overspd_cntrl_lock_set_fbWatcher();
     void bc_bcm_park_auto_unlock_set_fbWatcher();
     void bc_bcm_chg_wiper_mt_md_sw_set_fbWatcher();
     void bc_drv_lf_ant_diag_statusWatcher();
     void bc_bcm_lf_init_staWatcher();
     void bc_bcm_door_lock_operation_recordWatcher();
     void bc_int_lf_ant_diag_statusWatcher();
     void bc_pass_lf_ant_diag_statusWatcher();
     void bc_bcm_illmnd_entry_sts_fbWatcher();
     void bc_bcm_steer_whl_tempWatcher();
     void bc_bcm_steer_whl_heat_stsWatcher();
     void bc_bcm_rear_mirror_heat_stsWatcher();
     void bc_bcm_mai_drvr_seat_tempWatcher();
     void bc_bcm_mai_drvr_seat_stsWatcher();
     void bc_bcm_logo_active_flagWatcher();
     void bc_bcm_rf_init_staWatcher();
     void bc_bcm_rear_fog_li_fault_fbWatcher();
     void bc_bcm_front_fog_li_fault_fbWatcher();
     void bc_bcm_pos_li_fault_fbWatcher();
     void bc_bcm_back_li_fault_fbWatcher();
     void bc_bcm_brake_li_fault_fbWatcher();
     void bc_bcm_reverse_li_fault_fbWatcher();
     void bc_bcm_day_run_li_fault_fbWatcher();
     void ec_ehb_epb_flt_stsWatcher();
     void ec_ehb_epb_switch_stsWatcher();
     void ec_ehb_failure_stsWatcher();
     void ec_vcu_vhcl_actl_gear_pos_vWatcher();
     void ec_bcm_sys_pwr_mode_vWatcher();
     void ec_bcm_sys_pwr_modeWatcher();
     void ec_bcm_sys_power_stsWatcher();
     void ec_bcm_door_lock_sta_flWatcher();
     void ec_vcu_pwr_recup_intensityWatcher();
     void ec_ccu_diag_tester_onlineWatcher();
     void ec_bcm_back_ladjval_fbWatcher();
     void ec_esc_rmi_active_staWatcher();
     void ec_esc_slope_percent_vWatcher();
     void ec_esc_slope_percentWatcher();
     void ec_inv_antithft_auth_rsltWatcher();
     void bc_ac_auto_blower_mode_staWatcher();
     void bc_fcm_fcw_set_fbWatcher();
     void bc_ac_extd_defrost_actv_reqWatcher();
     void ec_scs_left_swt_vdWatcher();
     void ec_scs_left_1_swtWatcher();
     void ec_scs_left_2_swtWatcher();
     void ec_scs_left_3_swtWatcher();
     void ec_scs_left_4_swtWatcher();
     void ec_scs_left_5_swtWatcher();
     void ec_scs_left_6_swtWatcher();
     void ec_scs_left_7_swtWatcher();
     void ec_scs_left_8_swtWatcher();
     void ec_avas_state_rolling_counterWatcher();
     void ec_bms_current_over_wrningWatcher();
     void ec_bms_battery_sub_sys_numWatcher();
     void ec_bms_battery_sub_sys_codWatcher();
     void ec_bms_battery_dtc_numWatcher();
     void ec_bms_battery_dtc_listWatcher();
     void ec_bms_battery_dtc_indexWatcher();
     void ec_inv_1_rolling_counterWatcher();
     void ec_inv_4_err_bitsWatcher();
     void ec_inv_4_rolling_counterWatcher();
     void ec_scs_right_swt_vdWatcher();
     void ec_scs_right_14_swtWatcher();
     void ec_scs_right_15_swtWatcher();
     void ec_scs_right_16_swtWatcher();
     void ec_crrr_bsd_warn_rightWatcher();
     void ec_crrr_bsd_warn_leftWatcher();
     void ec_crrr_bsd_set_fbWatcher();
     void ec_crrr_rcta_warn_rightWatcher();
     void ec_crrr_rcta_warn_leftWatcher();
     void ec_crrr_rcta_set_fbWatcher();
     void ec_crrr_rcw_warningWatcher();
     void ec_crrr_rcw_set_fbWatcher();
     void ec_crrr_rear_corner_failureWatcher();
     void ec_crrr_rear_corner_blindnessWatcher();
     void ec_crrr_dow_set_fbWatcher();
     void ec_crrr_dow_warn_frWatcher();
     void ec_crrr_dow_warn_flWatcher();
     void ec_crrr_dow_warn_rrWatcher();
     void ec_crrr_dow_warn_rlWatcher();
     void ec_crrr_dow_warn_rightWatcher();
     void ec_crrr_dow_warn_leftWatcher();
     void ec_fcm_obj_typ1Watcher();
     void ec_fcm_obj_lat_dst1Watcher();
     void ec_fcm_obj_lgt_dst1Watcher();
     void ec_fcm_lgt_rel_spd1Watcher();
     void ec_fcm_obj_posn_agl1Watcher();
     void ec_fcm_lgt_rel_spd7Watcher();
     void ec_fcm_obj_movmt_dir1Watcher();
     void ec_fcm_lgt_rel_spd8Watcher();
     void ec_fcm_obj_movmt_sta1Watcher();
     void ec_fcm_obj_typ2Watcher();
     void ec_fcm_obj_lat_dst2Watcher();
     void ec_fcm_obj_lgt_dst2Watcher();
     void ec_fcm_obj_posn_agl2Watcher();
     void ec_fcm_lgt_rel_spd2Watcher();
     void ec_fcm_lgt_rel_spd9Watcher();
     void ec_fcm_obj_movmt_dir2Watcher();
     void ec_fcm_obj_movmt_sta2Watcher();
     void ec_fcm_obj_typ3Watcher();
     void ec_fcm_obj_lat_dst3Watcher();
     void ec_fcm_obj_lgt_dst3Watcher();
     void ec_fcm_obj_posn_agl3Watcher();
     void ec_fcm_lgt_rel_spd3Watcher();
     void ec_fcm_obj_movmt_dir3Watcher();
     void ec_fcm_obj_movmt_sta3Watcher();
     void ec_fcm_obj_typ4Watcher();
     void ec_fcm_obj_lat_dst4Watcher();
     void ec_fcm_obj_lgt_dst4Watcher();
     void ec_fcm_obj_posn_agl4Watcher();
     void ec_fcm_lgt_rel_spd4Watcher();
     void ec_fcm_obj_movmt_sta4Watcher();
     void ec_fcm_obj_movmt_dir4Watcher();
     void ec_fcm_obj_movmt_dir7Watcher();
     void ec_fcm_obj_typ5Watcher();
     void ec_fcm_obj_lat_dst5Watcher();
     void ec_fcm_obj_lgt_dst5Watcher();
     void ec_fcm_obj_posn_agl5Watcher();
     void ec_fcm_lgt_rel_spd5Watcher();
     void ec_fcm_obj_movmt_dir5Watcher();
     void ec_fcm_obj_movmt_sta5Watcher();
     void ec_fcm_obj_movmt_sta9Watcher();
     void ec_fcm_obj_typ6Watcher();
     void ec_fcm_obj_lat_dst6Watcher();
     void ec_fcm_obj_lgt_dst6Watcher();
     void ec_fcm_obj_posn_agl6Watcher();
     void ec_fcm_lgt_rel_spd6Watcher();
     void ec_fcm_obj_movmt_dir9Watcher();
     void ec_fcm_obj_movmt_sta6Watcher();
     void ec_fcm_obj_movmt_dir6Watcher();
     void ec_fcm_obj_typ7Watcher();
     void ec_fcm_obj_lat_dst7Watcher();
     void ec_fcm_obj_lgt_dst7Watcher();
     void ec_fcm_obj_posn_agl7Watcher();
     void ec_fcm_obj_movmt_sta7Watcher();
     void ec_fcm_obj_lat_dst8Watcher();
     void ec_fcm_obj_lgt_dst8Watcher();
     void ec_fcm_obj_typ8Watcher();
     void ec_fcm_obj_typ9Watcher();
     void ec_fcm_obj_movmt_sta8Watcher();
     void ec_fcm_obj_posn_agl8Watcher();
     void ec_fcm_obj_lat_dst9Watcher();
     void ec_fcm_obj_lgt_dst9Watcher();
     void ec_fcm_obj_posn_agl9Watcher();
     void ec_fcm_obj_movmt_dir8Watcher();
     void ec_fcm_obj_typ10Watcher();
     void ec_fcm_obj_lat_dst10Watcher();
     void ec_fcm_obj_lgt_dst10Watcher();
     void ec_fcm_obj_posn_agl10Watcher();
     void ec_fcm_obj_movmt_sta10Watcher();
     void ec_fcm_obj_lat_dst11Watcher();
     void ec_fcm_obj_lgt_dst11Watcher();
     void ec_fcm_obj_typ11Watcher();
     void ec_fcm_obj_posn_agl11Watcher();
     void ec_fcm_obj_movmt_sta11Watcher();
     void ec_fcm_obj_lat_dst12Watcher();
     void ec_fcm_obj_lgt_dst12Watcher();
     void ec_fcm_obj_typ12Watcher();
     void ec_fcm_obj_movmt_dir11Watcher();
     void ec_fcm_obj_posn_agl12Watcher();
     void ec_fcm_obj_typ13Watcher();
     void ec_fcm_obj_lat_dst13Watcher();
     void ec_fcm_obj_lgt_dst13Watcher();
     void ec_fcm_obj_movmt_sta13Watcher();
     void ec_fcm_obj_posn_agl13Watcher();
     void ec_fcm_obj_lat_dst14Watcher();
     void ec_fcm_obj_lgt_dst14Watcher();
     void ec_fcm_obj_typ14Watcher();
     void ec_fcm_obj_movmt_sta14Watcher();
     void ec_fcm_obj_posn_agl14Watcher();
     void ec_fcm_obj_lat_dst15Watcher();
     void ec_fcm_obj_lgt_dst15Watcher();
     void ec_fcm_obj_typ15Watcher();
     void ec_fcm_obj_movmt_dir14Watcher();
     void ec_fcm_obj_posn_agl15Watcher();
     void ec_fcm_obj_typ16Watcher();
     void ec_fcm_obj_lat_dst16Watcher();
     void ec_fcm_obj_lgt_dst16Watcher();
     void ec_fcm_obj_lat_dst17Watcher();
     void ec_fcm_obj_lgt_dst17Watcher();
     void ec_fcm_obj_movmt_sta16Watcher();
     void ec_fcm_obj_movmt_dir16Watcher();
     void ec_fcm_obj_typ17Watcher();
     void ec_fcm_obj_typ18Watcher();
     void ec_fcm_obj_movmt_sta17Watcher();
     void ec_fcm_obj_lat_dst18Watcher();
     void ec_fcm_obj_lgt_dst18Watcher();
     void ec_fcm_obj_posn_agl18Watcher();
     void ec_fcm_obj_movmt_dir17Watcher();
     void ec_fcm_obj_movmt_dir18Watcher();
     void ec_fcm_obj_movmt_sta18Watcher();
     void ec_fcm_lgt_rel_spd10Watcher();
     void ec_fcm_obj_posn_agl16Watcher();
     void ec_fcm_lgt_rel_spd11Watcher();
     void ec_fcm_obj_posn_agl17Watcher();
     void ec_fcm_lgt_rel_spd12Watcher();
     void ec_fcm_lgt_rel_spd13Watcher();
     void ec_fcm_obj_movmt_dir10Watcher();
     void ec_fcm_lgt_rel_spd14Watcher();
     void ec_fcm_obj_movmt_sta12Watcher();
     void ec_fcm_lgt_rel_spd15Watcher();
     void ec_fcm_obj_movmt_dir12Watcher();
     void ec_fcm_lgt_rel_spd16Watcher();
     void ec_fcm_obj_movmt_dir13Watcher();
     void ec_fcm_obj_movmt_sta15Watcher();
     void ec_fcm_lgt_rel_spd17Watcher();
     void ec_fcm_lgt_rel_spd18Watcher();
     void ec_fcm_obj_movmt_dir15Watcher();
     void ec_fcm_nr_of_lineWatcher();
     void ec_fcm_le_line_typWatcher();
     void ec_fcm_le_line_rdWatcher();
     void ec_fcm_le_line_dstWatcher();
     void ec_fcm_le_line_c1Watcher();
     void ec_fcm_le_line_c2Watcher();
     void ec_fcm_ri_line_typWatcher();
     void ec_fcm_le_line_c3Watcher();
     void ec_fcm_ri_line_rdWatcher();
     void ec_fcm_ri_line_dstWatcher();
     void ec_fcm_ri_line_c1Watcher();
     void ec_fcm_ri_line_c3Watcher();
     void ec_fcm_ri_line_c2Watcher();
     void ec_fcm_le_le_line_typWatcher();
     void ec_fcm_le_le_line_c1Watcher();
     void ec_fcm_le_le_line_c3Watcher();
     void ec_fcm_le_le_line_rdWatcher();
     void ec_fcm_le_le_line_dstWatcher();
     void ec_fcm_ri_ri_line_c1Watcher();
     void ec_fcm_ri_ri_line_c3Watcher();
     void ec_fcm_ri_ri_line_rdWatcher();
     void ec_fcm_ri_ri_line_dstWatcher();
     void ec_fcm_ri_ri_line_typWatcher();
     void ec_fcm_le_le_line_c2Watcher();
     void ec_fcm_ri_ri_line_c2Watcher();
     void ec_fcm_spd_downin_cor_sfkWatcher();
     void bc_vcu_speed_limit_level_set_fbWatcher();
     void ec_esc_abs_active_staWatcher();
     void ec_ipu_dcc_actl_oprt_modeWatcher();
     void ec_ipu_over_temperature_failWatcher();
     void ec_vcu_accl_pedal_posWatcher();
     void ec_vcu_brk_pedal_posWatcher();
     void ec_bms_iso_resistanceWatcher();
     void ec_ehb_brk_pedl_valWatcher();
     void ec_ehb_brk_pedl_val_vldWatcher();
     void ec_ehb_brk_pedl_val_percWatcher();
     void ec_ehb_brk_pedl_val_perc_vldWatcher();
     void mc_travel_average_speedWatcher();
     void ec_ipu_dcc_sys_fail_staWatcher();
     void ec_bms_chrg_target_socWatcher();
     void ec_bcm_brake_pedal_staWatcher();

     void fcm_adas_drvr_reqWatcher();
     void fcm_elk_stsWatcher();
     void fcm_slifs_spd_limWatcher();
     void fcm_aeb_statusWatcher();
     void fcm_aeb_statsadsusWatcher();
     void hu_dowenaswtWatcher();

     void sc_fcm_acc_take_over_reqWatcher();
     void fcm_tjatakeoverreqWatcher();
     void bc_fcm_aeb_recreqWatcher();
     void hu_hma_enable_swWatcher();
     void hu_ica_enable_sw_tWatcher();
     void hu_ica_avd_truck_setWatcher();
     void hu_ldw_alert_method_swWatcher();
     void hu_lka_enable_swWatcher();
     void hu_elk_enb_swWatcher();
     void hu_fcw_enable_swWatcher();
     void hu_abe_enable_swWatcher();
     void hu_bsd_enable_swWatcher();
     void hu_rcw_enable_swWatcher();
     void hu_rcta_enable_swWatcher();
     void hu_slif_enableswWatcher();
     void hu_slwf_enableswWatcher();
     void hu_navi_country_codeWatcher();
     void bc_bcm_avalueble_key_in_carWatcher();
     void ec_vcu_sys_fail_staWatcher();
     void ec_ccu_remt_steer_whl_heat_fbWatcher();
     void ec_ccu_remt_power_ctrl_fbWatcher();
     void ec_ccu_remt_mai_dr_seat_heat_fbWatcher();

     void bc_pp_sensor_fault_sts_rlWatcher();
     void bc_pp_sensor_fault_sts_rlmWatcher();
     void bc_pp_sensor_fault_sts_rrmWatcher();
     void bc_pp_sensor_fault_sts_rrWatcher();
     void bc_pp_rl_distWatcher();
     void bc_pp_rlm_distWatcher();
     void bc_pp_rrm_distWatcher();
     void bc_pp_rr_distWatcher();
     void bc_pp_sdwfsr_distWatcher();
     void bc_pp_sdwrsl_distWatcher();
     void bc_pp_sdwrsl_mid_distWatcher();
     void bc_pp_sdwrsr_mid_distWatcher();
     void bc_fm_auto_seek_resWatcher();
     void fm_searchWatcher();
     void fm_volumeWatcher();
     void ec_vcu_err_amountWatcher();
     void ec_vcu_err_bitWatcher();
     void bc_bcm_carriage_light_staWatcher();
     void ec_eps_steer_wheel_angleWatcher();
     void ec_eps_steer_wheel_angle_validWatcher();
     void ec_eps_rot_speedWatcher();
     void ec_eps_steer_wheel_angle_failureWatcher();
     void ec_eps_electric_power_staWatcher();
     void ec_eps_steer_wheel_angle_calibratedWatcher();
     void ec_eps_mot_tqWatcher();
     void ec_fcm_lgt_fct_actv_flgWatcher();
     void ec_fcm_eps_set_steer_whl_aglWatcher();
     void ec_fcm_steer_tq_req_activeWatcher();
     void ec_fcm_eps_ctrl_reqWatcher();
     void ec_fcm_drvr_warn_vib_reqWatcher();
     void ec_fcm_daeps_mode_reqWatcher();
     void ec_fcm_act_drv_asst_stsWatcher();
     void ec_fcm_overtake_ass_sys_stsWatcher();
     void ec_fcm_turn_lamp_reqWatcher();
     void ec_fcm_tjaica_supps_abortnWatcher();
     void ec_fcm_lka_torq_fact_reqWatcher();
     void ec_fcm_hma_supps_abortnWatcher();
     void ec_fcm_lkaldw_supps_abortnWatcher();
     void ec_fcm_flt_stsWatcher();
     void ec_fcm_elk_supps_abortnWatcher();
     void ec_fcm_acc_whl_tq_req_valWatcher();
     void ec_fcm_acc_whl_tq_req_actvWatcher();
     void ec_fcm_acc_whl_deceWatcher();
     void ec_fcm_acc_tar_accrnWatcher();
     void ec_fcm_acc_supp_abortWatcher();
     void ec_fcm_acc_tar_accrn_req_actvWatcher();
     void ec_fcm_epb_req_vWatcher();
     void ec_fcm_epb_reqWatcher();
     void ec_fcm_acc_shutdown_modeWatcher();
     void ec_fcm_ahd_obj_idWatcher();
     void ec_fcm_acc_tgt_axWatcher();
     void ec_fcm_aeb_tgt_axWatcher();
     void ec_fcm_acc_modeWatcher();
     void ec_fcm_acc_req_standstillWatcher();
     void ec_fcm_aeb_reqWatcher();
     void ec_fcm_aeb_standstill_stsWatcher();
     void ec_fcm_aeb_standstill_sts_vWatcher();
     void ec_fcm_aba_levelWatcher();
     void ec_fcm_awb_levelWatcher();
     void ec_fcm_aba_reqWatcher();
     void ec_fcm_eba_reqWatcher();
     void ec_fcm_awb_reqWatcher();
     void ec_fcm_abp_reqWatcher();
     void ec_fcm_acc_tgt_ax_reqWatcher();
     void ec_fcm_crv_decel_staWatcher();
     void ec_fcm_acc_req_drive_offWatcher();
     void mc_scs_frnt_wipr_swt_stWatcher();
     void mc_scs_low_beam_swt_stWatcher();
     void mc_scs_hi_beam_swt_stWatcher();
     void mc_scs_over_veh_beam_swt_stWatcher();
     void mc_scs_lamp_auto_stWatcher();
     void mc_scs_le_turn_lmp_swt_stWatcher();
     void mc_scs_ri_turn_lmp_swt_stWatcher();
    void ec_bms_hv_bat_cell_temp_aveWatcher();
    void ec_bms_dcs_actl_chrg_currentWatcher();
    void ec_scs_gear_shift_lever_pst_reqWatcher();
    void ec_bms_ac_chrg_atcl_staWatcher();
    void ec_bms_outlet_coolant_actl_tempWatcher();
    void ec_bms_outlet_coolant_actl_temp_validWatcher();
    void ec_bms_inlet_coolant_actl_tempWatcher();
    void ec_bms_inlet_coolant_actl_temp_validWatcher();
    void ec_bms_max_chrg_voltage_acWatcher();
    void ec_bms_max_chrg_current_acWatcher();
    void ec_bms_bat_sohWatcher();
    void ec_bms_temp_max_dc_charge_socketWatcher();
    void ec_bms_pcb_temp_maxWatcher();
    void ec_bms_max_allow_chrg_cur_dcWatcher();
    void ec_bms_max_allow_chrg_vol_dcWatcher();
    void ec_bms_electronic_lock_ctrlWatcher();
    void ec_bms_electronic_lock_stateWatcher();
    void ec_bms_contactor_state_dc_chargerWatcher();
    void ec_bms_dcs_charge_requestWatcher();
    void ec_bms_dcs_chrg_a_plusWatcher();
    void ec_bms_run_stateWatcher();
    void ec_bms_contactor_state_negativeWatcher();
    void ec_bms_contactor_state_positiveWatcher();
    void ec_bms_contactor_state_prechargeWatcher();
    void ec_bms_supply_voltage_statusWatcher();
    void ec_bms_emeshutdown_reqWatcher();
    void ec_bms_charge_interlock_staWatcher();
    void ec_bms_dis_charge_interlock_staWatcher();
    void ec_bms_batt_balance_staWatcher();
    void ec_bms_therm_runaway_snsr_fltWatcher();
    void ec_bms_therm_runaway_vlv_stWatcher();
    void ec_ipu_obc_uac_act_l1Watcher();
    void ec_ipu_obc_uac_act_l2Watcher();
    void ec_ipu_obc_uac_act_l3Watcher();
    void ec_ipu_obc_iac_act_l1Watcher();
    void ec_ipu_obc_iac_act_l2Watcher();
    void ec_ipu_obc_iac_act_l3Watcher();
    void ec_ipu_device_int_tempWatcher();
    void ec_ipu_obc_temp_inletWatcher();
    void ec_ipu_obc_ac_max_pw_allowWatcher();
    void ec_ipu_obc_inlet_electronic_lockWatcher();
    void ec_ipu_obc_s2_stateWatcher();
    void ec_ipu_obc_wake_up_modeWatcher();
    void ec_ipu_obc_voltage_ok_l1Watcher();
    void ec_ipu_obc_voltage_ok_l2Watcher();
    void ec_ipu_obc_voltage_ok_l3Watcher();
    void ec_ipu_dcc_high_volt_actl_curWatcher();
    void ec_ipu_dcc_high_volt_actl_volWatcher();
    void ec_ipu_obc_hvdc_actl_curWatcher();
    void ec_ipu_obc_connect_main_staWatcher();
    void ec_ipu_obc_requestWatcher();
    void ec_ipu_obc_sys_fail_staWatcher();
    void ec_ipu_obc_hvdc_actl_volWatcher();
    void ec_ipu_obc_errbitWatcher();
    void ec_ipu_dcc_low_vol_actl_volWatcher();
    void ec_ipu_dcc_low_vol_actl_curWatcher();
    void ec_ipu_dcc_precharge_completeWatcher();
    void ec_ipu_dcc_derating_oprt_staWatcher();
    void ec_ipu_hvil_fail_staWatcher();
    void ec_ipu_dcc_errbitWatcher();
    void ec_ipu_obc_c_cor_cp_cnctd_stsWatcher();
    void ec_ipu_obc_cp_dutyWatcher();
    void ec_ipu_obc_cp_max_voltWatcher();
    void ec_ipu_obc_process_codeWatcher();
    void ec_ipu_obc_cc_resisdentWatcher();
    void ec_eps_torsion_bar_torqueWatcher();
    void ec_eps_torsion_bar_torque_dirWatcher();
    void ec_eps_torsion_bar_torque_validWatcher();
    void ec_eps_elect_power_consumptionWatcher();
    void ec_eps_advanced_mode_statusWatcher();
    void ec_eps_lat_drv_lvl12_srv_avlWatcher();
    void ec_eps_lat_mc_hptc_wrn_srv_avlWatcher();
    void ec_eps_pscm_int_rpc_max_trqWatcher();
    void ec_eps_torsion_bar_torque_qfWatcher();
    void ec_eps_pscm_int_rpc_min_trqWatcher();
    void ec_eps_lat_mc_steer_tq_activeWatcher();
    void ec_eps_lat_mc_hptc_wrn_activeWatcher();
    void ec_eps_max_allwd_rot_spdWatcher();
    void ec_eps_lks_agl_sys_stsWatcher();
    void ec_eps_max_allwd_aglWatcher();
    void ec_eps_steer_tqWatcher();
    void ec_eps_lks_abort_fbWatcher();
    void ec_eps_lks_agl_ctrl_avl_stsWatcher();
    void ec_esc_req_brake_light_onWatcher();
    void ec_esc_ebd_active_staWatcher();
    void ec_esc_ess_activeWatcher();
    void ec_esc_cdp_activeWatcher();
    void ec_esc_brake_temp_over_heatWatcher();
    void ec_esc_dtc_active_stsWatcher();
    void ec_esc_vhcl_standstill_staWatcher();
    void ec_esc_dtc_request_rbs_stsWatcher();
    void ec_esc_dtc_failure_stsWatcher();
    void ec_esc_wheel_speed_kph_v_flWatcher();
    void ec_esc_wheel_direction_flWatcher();
    void ec_esc_wheel_speed_kph_flWatcher();
    void ec_esc_wheel_speed_kph_v_frWatcher();
    void ec_esc_wheel_direction_frWatcher();
    void ec_esc_wheel_speed_kph_frWatcher();
    void ec_esc_master_cylinder_presrWatcher();
    void ec_esc_master_cylinder_presr_vWatcher();
    void ec_esc_wheel_speed_kph_v_rlWatcher();
    void ec_esc_wheel_direction_rlWatcher();
    void ec_esc_wheel_speed_kph_rlWatcher();
    void ec_esc_wheel_speed_kph_v_rrWatcher();
    void ec_esc_wheel_direction_rrWatcher();
    void ec_esc_wheel_speed_kph_rrWatcher();
    void ec_esc_wheel_speed_rc_sts_flWatcher();
    void ec_esc_wheel_speed_rc_sts_frWatcher();
    void ec_esc_wheel_speed_rc_sts_rlWatcher();
    void ec_esc_wheel_speed_rc_sts_rrWatcher();
    void ec_esc_wheel_speed_rc_flWatcher();
    void ec_esc_wheel_speed_rc_frWatcher();
    void ec_esc_wheel_speed_rc_rlWatcher();
    void ec_esc_wheel_speed_rc_rrWatcher();
    void ec_esc_long_acc_sensor_valueWatcher();
    void ec_esc_long_acc_sensor_value_vldWatcher();
    void ec_esc_lat_acc_sensor_value_vldWatcher();
    void ec_esc_lat_acc_sensor_valueWatcher();
    void ec_esc_yaw_rateWatcher();
    void ec_esc_yaw_rate_vldWatcher();
    void ec_esc_epb_right_currentWatcher();
    void ec_esc_epb_right_fault_stateWatcher();
    void ec_esc_hbb_hbc_availableWatcher();
    void ec_esc_epb_actuator_st_rWatcher();
    void ec_esc_hbb_hbc_activeWatcher();
    void ec_esc_whl_tq_dec_req_actvWatcher();
    void ec_esc_whl_tq_dec_req_valWatcher();
    void ec_esc_whl_tq_inc_req_actvWatcher();
    void ec_esc_whl_tq_inc_req_valWatcher();
    void ec_ehb_cdp_requestWatcher();
    void ec_ehb_epb_actuator_st_rWatcher();
    void ec_ehb_epb_actuator_st_lWatcher();
    void ec_ehb_hhc_active_staWatcher();
    void ec_ehb_rgn_brk_stWatcher();
    void ec_ehb_ext_req_statusWatcher();
    void ec_ehb_blaWatcher();
    void ec_ehb_hmi_warning_onWatcher();
    void ec_ehb_epb_dynamic_apply_staWatcher();
    void ec_ehb_pedl_trvl_snsr_fail_pdfWatcher();
    void ec_ehb_req_brk_li_onWatcher();
    void ec_ehb_pedl_trvl_snsr_fail_pdtWatcher();
    void ec_ehb_p_runout_pressureWatcher();
    void ec_ehb_brake_pedal_appliedWatcher();
    void ec_ehb_brake_pedal_applied_qWatcher();
    void ec_ehb_cdd_temp_offWatcher();
    void ec_ehb_s_output_rod_hydraulic_targetWatcher();
    void ec_ehb_s_output_rod_driver_percWatcher();
    void ec_ehb_aba_active_staWatcher();
    void ec_ehb_aba_available_staWatcher();
    void ec_ehb_awb_active_staWatcher();
    void ec_ehb_awb_available_staWatcher();
    void ec_ehb_aeb_active_staWatcher();
    void ec_ehb_aeb_available_staWatcher();
    void ec_ehb_abp_active_staWatcher();
    void ec_ehb_abp_available_staWatcher();
    void ec_pp_raeb_set_fbWatcher();
    void ec_pp_raeb_work_stsWatcher();
    void ec_pp_raeb_brkg_reqWatcher();
    void ec_pp_raeb_brkg_req_valWatcher();
    void ec_pp_raeb_distance_to_collisionWatcher();
    void ec_crrr_rctb_decelarationWatcher();
    void ec_crrr_rctb_reqWatcher();
    void ec_crrr_rctb_brkg_vldWatcher();
    void ec_crrr_fov_chg_set_fbWatcher();
    void ec_bms_max_con_dis_curntWatcher();
    void ec_bms_pwr_recup_max_con_chrg_curntWatcher();
    void ec_bms_max_instan_dis_curntWatcher();
    void ec_bms_pwr_recup_max_instan_chrg_curntWatcher();
    void ec_bms_cell_vol_aveWatcher();
    void ec_bms_contactor_temp_negativeWatcher();
    void ec_bms_max_cell_temp_limitWatcher();
    void ec_bms_max_cell_vol_limitWatcher();
    void ec_bms_pwr_limd_flgWatcher();
    void ec_bms_min_cell_temp_limitWatcher();
    void ec_bms_min_cell_vol_limitWatcher();
    void ec_bms_err_tab_indexWatcher();
    void ec_bms_battery_typeWatcher();
    void ec_bms_hw_versionWatcher();
    void ec_bms_pack_identityWatcher();
    void ec_bms_sw_versionWatcher();
    void ec_bms_nom_cell_capWatcher();
    void ec_bms_bat_capacityWatcher();
    void ec_cst_abort_by_bmsWatcher();
    void ec_cst_abort_by_faultWatcher();
    void ec_cst_abort_by_userWatcher();
    void ec_cst_abort_achive_conditionWatcher();
    void ec_cst_abort_fault_energe_transmitWatcher();
    void ec_cst_abort_fault_charger_inner_tempWatcher();
    void ec_cst_abort_fault_connetorWatcher();
    void ec_cst_abort_fault_charger_tempWatcher();
    void ec_cst_abort_fault_otherWatcher();
    void ec_cst_abort_fault_charger_stopWatcher();
    void ec_cst_abort_error_voltageWatcher();
    void ec_cst_abort_error_currentWatcher();
    void ec_bcm_rear_view_mirr_heating_stsWatcher();
    void ec_tms_ohx_out_tmpWatcher();
    void ec_tms_evap_tmpWatcher();
    void ec_tms_evap_out_tmpWatcher();
    void ec_tms_chiller_out_tmpWatcher();
    void ec_bcm_high_beam_li_fault_fbWatcher();
    void ec_bcm_low_beam_li_fault_fbWatcher();
    void ec_bcm_vhcl_seekWatcher();
    void ec_bcm_illmnd_stsWatcher();
    void ec_bcm_key_frbdnWatcher();
    void ec_bcm_frbdn_key_nrWatcher();
    void ec_bcm_start_reqWatcher();
    void ec_bcm_drv_pe_authent_acsdWatcher();
    void ec_bcm_frpe_authent_acsdWatcher();
    void ec_bcm_ps_reqWatcher();
    void ec_bcm_frnt_le_door_hndl_swtWatcher();
    void ec_bcm_frnt_ri_door_hndl_swtWatcher();
    void ec_bcm_save_power_staWatcher();
    void ec_bcm_front_wiper_motor_stsWatcher();
    void ec_bcm_fl_window_stsWatcher();
    void ec_bcm_fr_window_stsWatcher();
    void ec_bcm_fl_windowmotor_stsWatcher();
    void ec_bcm_fr_windowmotor_stsWatcher();
    void ec_bcm_wiper_ctrl_frontWatcher();
    void ec_bcm_drv_seat_occupant_sensor_stsWatcher();
    void ec_bcm_heavy_rain_indWatcher();
    void ec_tpms_pressure_value_rrWatcher();
    void ec_tpms_pressure_value_rlWatcher();
    void ec_tpms_pressure_sta_rlWatcher();
    void ec_tpms_pressure_sta_rrWatcher();
    void ec_tpms_pressure_value_frWatcher();
    void ec_tpms_pressure_value_flWatcher();
    void ec_tpms_pressure_sta_flWatcher();
    void ec_tpms_pressure_sta_frWatcher();
    void ec_bcm_dome_light_staWatcher();
    void ec_bcm_back_lamp_staWatcher();
    void ec_bcm_bass_horn_reqWatcher();
    void ec_bcm_ajar_sta_v_hoodWatcher();
    void ec_bcm_frnt_fog_li_sw_sigWatcher();
    void ec_bcm_rear_fog_li_sw_sigWatcher();
    void ec_bcm_day_run_light_staWatcher();
    void ec_bcm_reverse_lamp_staWatcher();
    void ec_bcm_brake_lamp_staWatcher();
    void ec_bcm_turn_li_stsWatcher();
    void ec_vcu_actl_motor_rotate_spdWatcher();
    void ec_vcu_actl_motor_rotate_spd_vWatcher();
    void ec_vcu_remt_ac_ctrl_stWatcher();
    void ec_vcu_remt_ac_defrostl_reqWatcher();
    void ec_vcu_remt_ac_ctrl_reqWatcher();
    void ec_vcu_charging_conditions_fbWatcher();
    void ec_vcu_accl_pedal_pos_snsr_staWatcher();
    void ec_vcu_req_epbWatcher();
    void ec_vcu_acc_trq_ctrl_avlWatcher();
    void ec_vcu_acc_standstill_reqWatcher();
    void ec_vcu_acc_tgt_axWatcher();
    void ec_vcu_acc_tgt_ax_reqWatcher();
    void ec_vcu_drv_req_torq_override_fcmWatcher();
    void ec_vcu_cruise_ctr_tgt_spdWatcher();
    void ec_vcu_cruise_ctrl_staWatcher();
     void ec_scs_right_11_swtWatcher();
     void ec_scs_right_12_swtWatcher();
     void ec_scs_right_13_swtWatcher();
    void ec_scs_gear_shift_lever_pst_req_vdWatcher();
    void ec_bms_dcs_actl_chrg_powerWatcher();
    void ec_ccu_keep_awake_staWatcher();
    void ec_vcu_bra_tor_reqWatcher();
    void ec_pp_sensor_fault_sts_flmWatcher();
    void ec_pp_sensor_fault_sts_flWatcher();
    void ec_bcm_authent_key_nrWatcher();
    void ec_bcm_key_staWatcher();
    void ec_bcm_wiper_stop_pos_staWatcher();
    void ec_bms_insulation_wrningWatcher();
    void ec_fcm_tau_gap_setWatcher();
    void gecko_e2p_rom_resultWatcher();
    void gecko_key_code_resultWatcher();
    void ec_fcm_hma_highbeam_reqWatcher();
    void ec_bcm_hazard_lamp_stsWatcher();
    void bc_bcm_rke_reqWatcher();
    void bc_fcm_hma_stsWatcher();
    void bc_bcm_le_turn_li_fault_fbWatcher();
    void bc_bcm_ri_turn_li_fault_fbWatcher();
    void bc_ac_ac_sta_fbWatcher();
     int GetFcwAebValue();
    void mc_travel_short_rangeWatcher();
    void mc_travel_short_average_speedWatcher();
    void mc_travel_short_average_pwr_consum_Watcher();
    void mc_travel_short_timeWatcher();
  private:

    recyclable_ptr<VehiclePropValue> CreatespeedReq(float speed);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_d_cdischrg_permReq(float ec_vcu_d_cdischrg_perm);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_pt_stReq(int32_t ec_vcu_pt_st);
    recyclable_ptr<VehiclePropValue> Create_mcu_power_stReq(int32_t mcu_power_st);
    recyclable_ptr<VehiclePropValue> Create_soc_power_stReq(int32_t soc_power_st,int32_t para_value);
    recyclable_ptr<VehiclePropValue> To_notification_tbox_soc_power_status(int32_t soc_power_st);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_hvpowerReq(int32_t ec_vcu_hvpower);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_dcd_cworkenableReq(int32_t ec_vcu_dcd_cworkenable);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_charallowReq(float ec_vcu_charallow);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_igonReq(int32_t ec_vcu_igon);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_sleepindicationsignalReq(float ec_vcu_sleepindicationsignal);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_livecounter_0x100Req(float ec_vcu_livecounter_0x100);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_checksum_0x100Req(float ec_vcu_checksum_0x100);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_heatrelaystatusReq(int32_t ec_bms_heatrelaystatus);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_cc2statusReq(float ec_bms_cc2status);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_livecounter_0x120Req(float ec_bms_livecounter_0x120);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_checksum_0x120Req(float ec_bms_checksum_0x120);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_batinsulatresistanceReq(int ec_bms_batinsulatresistance);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_batterycurrentReq(float ec_bms_batterycurrent);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_packvoltageReq(int32_t ec_bms_packvoltage);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_packvoltage_vReq(int32_t ec_bms_packvoltage_v);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_livecounter_0x125Req(float ec_bms_livecounter_0x125);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_checksum_0x125Req(float ec_bms_checksum_0x125);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_remainingchargetimeReq(int32_t ec_bms_remainingchargetime);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_batterysocReq(float ec_bms_batterysoc);
    recyclable_ptr<VehiclePropValue> Create_ec_batterylowsignalReq(int32_t batterylowsignal);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_livecounter_0x135Req(float ec_bms_livecounter_0x135);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_checksum_0x135Req(float ec_bms_checksum_0x135);
    recyclable_ptr<VehiclePropValue> Create_ec_mcu_motortorqueReq(int ec_mcu_motortorque);
    recyclable_ptr<VehiclePropValue> Create_ec_mcu_motorspdReq(float ec_mcu_motorspd);
    recyclable_ptr<VehiclePropValue> Create_ec_mcu_llivecounter_0x200Req(float ec_mcu_llivecounter_0x200);
    recyclable_ptr<VehiclePropValue> Create_ec_mcu_checksum_0x200Req(float ec_mcu_checksum_0x200);
    recyclable_ptr<VehiclePropValue> Create_ec_mcu_buscurrentReq(int ec_mcu_buscurrent);
    recyclable_ptr<VehiclePropValue> Create_ec_mcu_busvoltReq(int ec_mcu_busvolt);
    recyclable_ptr<VehiclePropValue> Create_ec_mcu_llivecounter_0x201Req(float ec_mcu_llivecounter_0x201);
    recyclable_ptr<VehiclePropValue> Create_ec_mcu_checksum_0x201Req(float ec_mcu_checksum_0x201);
    recyclable_ptr<VehiclePropValue> Create_ec_mcu_err_codeReq(int32_t ec_mcu_err_code);
    recyclable_ptr<VehiclePropValue> Create_ec_mcu_motortempReq(int32_t ec_mcu_motortemp);
    recyclable_ptr<VehiclePropValue> Create_ec_mcu_igbttempReq(int32_t ec_mcu_igbttemp);
    recyclable_ptr<VehiclePropValue> Create_ec_mcu_motoropermodeReq(int32_t ec_mcu_motoropermode);
    recyclable_ptr<VehiclePropValue> Create_ec_mcu_llivecounter_0x202Req(float ec_mcu_llivecounter_0x202);
    recyclable_ptr<VehiclePropValue> Create_ec_mcu_checksum_0x202Req(float ec_mcu_checksum_0x202);
    recyclable_ptr<VehiclePropValue> Create_ec_mcu_motor_fault_total_numReq(int32_t ec_mcu_motor_fault_total_num);
    recyclable_ptr<VehiclePropValue> Create_ec_mcu_motor_stateReq(int32_t ec_mcu_motor_state);
    recyclable_ptr<VehiclePropValue> Create_ec_mcu_igbt_overheat_warningReq(int32_t ec_mcu_igbt_overheat_warning);
    recyclable_ptr<VehiclePropValue> Create_ec_mcu_motor_overheat_warningReq(int32_t ec_mcu_motor_overheat_warning);
    recyclable_ptr<VehiclePropValue> Create_ec_mcu_llivecounter_0x203Req(float ec_mcu_llivecounter_0x203);
    recyclable_ptr<VehiclePropValue> Create_ec_mcu_checksum_0x203Req(float ec_mcu_checksum_0x203);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_smart_dc_stReq(int32_t ec_ipu_smart_dc_st);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_livecounter_0x450Req(float ec_ipu_livecounter_0x450);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_checksum_0x450Req(float ec_ipu_checksum_0x450);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_c_cresistancevalueReq(float ec_ipu_c_cresistancevalue);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_livecounter_0x470Req(float ec_ipu_livecounter_0x470);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_checksum_0x470Req(float ec_ipu_checksum_0x470);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_ob_cinputvoltageReq(int32_t ec_ipu_ob_cinputvoltage);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_c_pdutycycleReq(int ec_ipu_c_pdutycycle);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_ob_cinputcurrentReq(int32_t ec_ipu_ob_cinputcurrent);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_dcd_crealtimeopcurrReq(int32_t ec_ipu_dcd_crealtimeopcurr);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_dcd_coperatingmodeReq(int32_t ec_ipu_dcd_coperatingmode);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_dcd_crealtimeopvoltReq(int32_t ec_ipu_dcd_crealtimeopvolt);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_dcd_cbodytempReq(int32_t ec_ipu_dcd_cbodytemp);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_livecounter_0x490Req(float ec_ipu_livecounter_0x490);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_checksum_0x490Req(float ec_ipu_checksum_0x490);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_dcdc_over_tempReq(int32_t ec_ipu_dcdc_over_temp);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_battery_pack_average_tempReq(float ec_bms_battery_pack_average_temp);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_packtotalcellnumReq(int32_t ec_bms_packtotalcellnum);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_packtotaltempnumReq(int32_t ec_bms_packtotaltempnum);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_maxvoltcellpacknumReq(int ec_bms_maxvoltcellpacknum);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_minvoltcellpacknumReq(int ec_bms_minvoltcellpacknum);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_livecounter_0x510Req(float ec_bms_livecounter_0x510);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_checksum_0x510Req(float ec_bms_checksum_0x510);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_mintempmonomercellReq(int ec_bms_mintempmonomercell);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_maxtempmonomercellReq(int ec_bms_maxtempmonomercell);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_maxtempcellReq(float ec_bms_maxtempcell);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_mintempcellReq(float ec_bms_mintempcell);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_maxtempcellpacknumReq(int ec_bms_maxtempcellpacknum);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_mintempcellpacknumReq(int ec_bms_mintempcellpacknum);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_deg_d_ccharsockettemp2Req(int ec_bms_deg_d_ccharsockettemp2);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_deg_d_ccharsockettemp1Req(int ec_bms_deg_d_ccharsockettemp1);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_livecounter0x511Req(float ec_bms_livecounter0x511);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_checksum_0x511Req(float ec_bms_checksum_0x511);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_minvoltmonomercellReq(int ec_bms_minvoltmonomercell);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_maxvoltmonomercellReq(int ec_bms_maxvoltmonomercell);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_maxvoltcellReq(float ec_bms_maxvoltcell);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_minvoltcellReq(float ec_bms_minvoltcell);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_livecounter_0x512Req(float ec_bms_livecounter_0x512);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_checksum_0x512Req(float ec_bms_checksum_0x512);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_packratecapReq(float ec_bms_packratecap);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_pack_rate_voltReq(float ec_bms_pack_rate_volt);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_packrateenergyReq(float ec_bms_packrateenergy);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_batt_typeReq(float ec_bms_batt_type);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_battcooltypeReq(float ec_bms_battcooltype);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_livecounter_0x520Req(float ec_bms_livecounter_0x520);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_checksum_0x520Req(float ec_bms_checksum_0x520);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_packudvoltReq(int32_t ec_bms_packudvolt);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_packovervoltReq(int32_t ec_bms_packovervolt);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_overtempReq(int32_t ec_bms_overtemp);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_deltatempReq(int32_t ec_bms_deltatemp);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_lowinsresReq(int32_t ec_bms_lowinsres);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_celludvoltReq(int32_t ec_bms_celludvolt);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_cellovervoltReq(int32_t ec_bms_cellovervolt);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_packlowsocReq(int32_t ec_bms_packlowsoc);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_packfastchgsocReq(int32_t ec_bms_packfastchgsoc);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_packhighsocReq(int32_t ec_bms_packhighsoc);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_packoverchargeReq(int32_t ec_bms_packovercharge);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_ucellinconReq(int32_t ec_bms_ucellincon);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_thermalrunawayalarmReq(int32_t ec_bms_thermalrunawayalarm);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_h_vilfaultReq(int32_t ec_bms_h_vilfault);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_batsysnotmtcReq(int32_t ec_bms_batsysnotmtc);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_fault_codeReq(int32_t ec_bms_fault_code);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_batt_fault_total_numReq(int32_t ec_bms_batt_fault_total_num);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_livecounter_0x522Req(float ec_bms_livecounter_0x522);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_checksum_0x522Req(float ec_bms_checksum_0x522);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_shif_faultReq(float ec_vcu_shif_fault);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_shift_positionReq(int32_t ec_vcu_shift_position);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_actual_gearReq(int32_t ec_vcu_actual_gear);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_bp_statusReq(int ec_vcu_bp_status);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_park_faultReq(float ec_vcu_park_fault);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_park_stateReq(int32_t ec_vcu_park_state);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_switch_gear_warnReq(int32_t ec_vcu_switch_gear_warn);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_delay_mon_modeReq(float ec_vcu_delay_mon_mode);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_ap_statusReq(int ec_vcu_ap_status);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_brk_lamp_ctr_cmdReq(float ec_vcu_brk_lamp_ctr_cmd);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_lock_veh_warnReq(int32_t ec_vcu_lock_veh_warn);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_creep_stsReq(int32_t ec_vcu_creep_sts);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_single_ped_stsReq(int32_t ec_vcu_single_ped_sts);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_ap_faultReq(float ec_vcu_ap_fault);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_bp_faultReq(float ec_vcu_bp_fault);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_brk_pdl_posReq(float ec_vcu_brk_pdl_pos);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_livecounter_0x350Req(float ec_vcu_livecounter_0x350);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_checksum_0x350Req(float ec_vcu_checksum_0x350);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_chrg_stsReq(int32_t ec_vcu_chrg_sts);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_chrg_cnctr_stsReq(int32_t ec_vcu_chrg_cnctr_sts);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_pt_rdyReq(int32_t ec_vcu_pt_rdy);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_smart_dc_reqReq(int32_t ec_vcu_smart_dc_req);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_chrg_soc_tar_spReq(int32_t ec_vcu_chrg_soc_tar_sp);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_dis_chrg_stsReq(int32_t ec_vcu_dis_chrg_sts);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_dc_chrg_rly_stsReq(int32_t ec_vcu_dc_chrg_rly_sts);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_average_energy_consum_vdReq(int32_t ec_vcu_average_energy_consum_vd);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_dc_chrg_rly_auxil_cntac_stsReq(float ec_vcu_dc_chrg_rly_auxil_cntac_sts);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_braking_remindReq(int32_t ec_vcu_braking_remind);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_average_energy_consumptionReq(float ec_vcu_average_energy_consumption);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_instant_energy_consumptionReq(float ec_vcu_instant_energy_consumption);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_instant_energy_consum_vdReq(int32_t ec_vcu_instant_energy_consum_vd);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_chraging_mode_spReq(int32_t ec_vcu_chraging_mode_sp);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_livecounter_0x351Req(float ec_vcu_livecounter_0x351);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_checksum_0x351Req(float ec_vcu_checksum_0x351);
    recyclable_ptr<VehiclePropValue> Create_ec_ccm_veh_tar_socReq(float ec_ccm_veh_tar_soc);
    recyclable_ptr<VehiclePropValue> Create_ec_ccm_batt_maintain_ctr_cmdReq(float ec_ccm_batt_maintain_ctr_cmd);
    recyclable_ptr<VehiclePropValue> Create_ec_ota_modelReq(float ec_ota_model);
    recyclable_ptr<VehiclePropValue> Create_ec_ccm_rechrgn_lv_reqReq(float ec_ccm_rechrgn_lv_req);
    recyclable_ptr<VehiclePropValue> Create_ec_ccm_driver_buckle_statusReq(int32_t ec_ccm_driver_buckle_status, int32_t areaId);
    recyclable_ptr<VehiclePropValue> Create_ec_ccm_drive_mode_reqReq(float ec_ccm_drive_mode_req);
    recyclable_ptr<VehiclePropValue> Create_ec_ccm_operat_licenceReq(float ec_ccm_operat_licence);
    recyclable_ptr<VehiclePropValue> Create_ec_ccm_versionReq(float ec_ccm_version);
    recyclable_ptr<VehiclePropValue> Create_ec_ccm_speed_limit_levelReq(float ec_ccm_speed_limit_level);
    recyclable_ptr<VehiclePropValue> Create_ec_ccm_charging_conditionsReq(float ec_ccm_charging_conditions);
    recyclable_ptr<VehiclePropValue> Create_ec_total_odometerReq(float ec_total_odometer);
    recyclable_ptr<VehiclePropValue> Create_power_on_milegeReq(float power_on_milege);
    recyclable_ptr<VehiclePropValue> Create_power_on_average_speedReq(int32_t power_on_average_speed);
    recyclable_ptr<VehiclePropValue> Create_power_on_average_energy_consumptionReq(float ec_total_odometer);
    recyclable_ptr<VehiclePropValue> Create_power_on_timeReq(int32_t power_on_time);
    recyclable_ptr<VehiclePropValue> Create_ec_ccm_target_chrg_currReq(float ec_ccm_target_chrg_curr);
    recyclable_ptr<VehiclePropValue> Create_ec_ccm_batt_maintain_stsReq(float ec_ccm_batt_maintain_sts);
    recyclable_ptr<VehiclePropValue> Create_ec_ccm_livecounter_0x353Req(float ec_ccm_livecounter_0x353);
    recyclable_ptr<VehiclePropValue> Create_ec_ccm_checksum_0x353Req(float ec_ccm_checksum_0x353);
    recyclable_ptr<VehiclePropValue> Create_ec_ccm_remt_ctrl_flagReq(float ec_ccm_remt_ctrl_flag);
    recyclable_ptr<VehiclePropValue> Create_ec_ccm_charging_requestReq(float ec_ccm_charging_request);
    recyclable_ptr<VehiclePropValue> Create_ec_ccm_chraging_modeReq(float ec_ccm_chraging_mode);
    recyclable_ptr<VehiclePropValue> Create_ec_ccm_energy_recov_level_cmdReq(float ec_ccm_energy_recov_level_cmd);
    recyclable_ptr<VehiclePropValue> Create_ec_ccm_creep_ctr_cmdReq(float ec_ccm_creep_ctr_cmd);
    recyclable_ptr<VehiclePropValue> Create_ec_ccm_single_ped_ctr_cmdReq(float ec_ccm_single_ped_ctr_cmd);
    recyclable_ptr<VehiclePropValue> Create_ec_ccm_rema_range_dispReq(float ec_ccm_rema_range_disp);
    recyclable_ptr<VehiclePropValue> Create_ec_ccm_rema_range_disp_vdReq(float ec_ccm_rema_range_disp_vd);
    recyclable_ptr<VehiclePropValue> Create_ec_ccm_livecounter_0x354Req(float ec_ccm_livecounter_0x354);
    recyclable_ptr<VehiclePropValue> Create_ec_ccm_checksum_0x354Req(float ec_ccm_checksum_0x354);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_drive_modeReq(int32_t ec_vcu_drive_mode);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_low_soc_warnReq(int32_t ec_vcu_low_soc_warn);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_can_timeout_faultReq(float ec_vcu_can_timeout_fault);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_eas_ins_staReq(int32_t ec_vcu_eas_ins_sta);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_faultlevelReq(int32_t ec_vcu_faultlevel);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_dc_discharging_fail_warnReq(int32_t ec_vcu_dc_discharging_fail_warn);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_dc_charging_fail_warnReq(int32_t ec_vcu_dc_charging_fail_warn);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_ac_charging_fail_warnReq(int32_t ec_vcu_ac_charging_fail_warn);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_12_v_charging_fail_warnReq(int32_t ec_vcu_12_v_charging_fail_warn);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_brak_sys_warnReq(int32_t ec_vcu_brak_sys_warn);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_veh_unable_dri_warnReq(int32_t ec_vcu_veh_unable_dri_warn);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_brk_liquid_level_lowReq(float ec_vcu_brk_liquid_level_low);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_vacum_pump_faultReq(int32_t ec_vcu_vacum_pump_fault);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_mot_water_pump_statusReq(int32_t ec_vcu_mot_water_pump_status);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_fault_codeReq(int32_t ec_vcu_fault_code);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_fault_treat_levelReq(float ec_vcu_fault_treat_level);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_drive_pwr_limReq(int32_t ec_vcu_drive_pwr_lim);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_mcu_errReq(int32_t ec_vcu_mcu_err);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_hv_batt_errReq(int32_t ec_vcu_hv_batt_err);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_operat_licenceReq(int32_t ec_vcu_operat_licence);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_versionReq(int32_t ec_vcu_version);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_speed_limit_levelReq(int32_t ec_vcu_speed_limit_level);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_charging_conditionsReq(int32_t ec_vcu_charging_conditions);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_livecounter_0x352Req(float ec_vcu_livecounter_0x352);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_checksum_0x352Req(float ec_vcu_checksum_0x352);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_comp_neg_rel_staReq(float ec_vcu_comp_neg_rel_sta);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_comp_pos_rel_staReq(float ec_vcu_comp_pos_rel_sta);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_ipu_errReq(int32_t ec_vcu_ipu_err);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_cooling_fail_warnReq(int32_t ec_vcu_cooling_fail_warn);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_lv_elec_sys_errReq(int32_t ec_vcu_lv_elec_sys_err);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_ac_hv_sys_errReq(int32_t ec_vcu_ac_hv_sys_err);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_ptc2_rel_staReq(int32_t ec_vcu_ptc2_rel_sta);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_ptc1_rel_staReq(int32_t ec_vcu_ptc1_rel_sta);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_highpower_voltageReq(float ec_vcu_highpower_voltage);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_fan_relay_pin_stsReq(int32_t ec_vcu_fan_relay_pin_sts);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_water_pump_relay_pin_stsReq(float ec_vcu_water_pump_relay_pin_sts);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_awake_obc_pin_stsReq(float ec_vcu_awake_obc_pin_sts);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_awake_bms_pin_stsReq(float ec_vcu_awake_bms_pin_sts);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_awake_mcu_pin_stsReq(float ec_vcu_awake_mcu_pin_sts);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_main_relay_pin_stsReq(float ec_vcu_main_relay_pin_sts);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_dc_chrg_awake_pin_stsReq(float ec_vcu_dc_chrg_awake_pin_sts);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_ac_chrg_awake_pin_stsReq(float ec_vcu_ac_chrg_awake_pin_sts);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_water_pump_pwmReq(int32_t ec_vcu_water_pump_pwm);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_power_supply_voltagReq(int32_t ec_vcu_power_supply_voltag);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_livecounter_0x215Req(float ec_vcu_livecounter_0x215);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_checksum_0x215Req(float ec_vcu_checksum_0x215);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_pump_stateReq(float ec_vcu_pump_state);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_mid_door_ajar_statusReq(int32_t ec_vcu_mid_door_ajar_status);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_actual_rema_range_vdReq(int32_t ec_vcu_actual_rema_range_vd);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_cltc_rema_range_vdReq(int32_t ec_vcu_cltc_rema_range_vd);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_pt_cenableReq(float ec_vcu_pt_cenable);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_accmenableReq(float ec_vcu_accmenable);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_vehicle_spdReq(float ec_vcu_vehicle_spd);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_actual_rema_rangeReq(float ec_vcu_actual_rema_range);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_cltc_rema_rangeReq(float ec_vcu_cltc_rema_range);
    recyclable_ptr<VehiclePropValue> Create_bcm_mcu_display_rangeReq(int32_t bcm_mcu_display_range);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_livecounter_0x250Req(float ec_vcu_livecounter_0x250);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_checksum_0x250Req(float ec_vcu_checksum_0x250);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_sofeware_numReq(int32_t ec_vcu_sofeware_num);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_hardware_numReq(int32_t ec_vcu_hardware_num);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_yearReq(float ec_vcu_year);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_monthReq(float ec_vcu_month);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_dayReq(float ec_vcu_day);
    recyclable_ptr<VehiclePropValue> Create_ec_ccm_a_ckeyReq(float ec_ccm_a_ckey);
    recyclable_ptr<VehiclePropValue> Create_ec_ccm_ac_havc_stateReq(float ec_ccm_ac_havc_state);
    recyclable_ptr<VehiclePropValue> Create_ec_ccm_vehicle_spd_dspReq(float ec_ccm_vehicle_spd_dsp);
    recyclable_ptr<VehiclePropValue> Create_ec_ccm_livecounter_0x310Req(float ec_ccm_livecounter_0x310);
    recyclable_ptr<VehiclePropValue> Create_ec_ccm_checksum_0x310Req(float ec_ccm_checksum_0x310);
    recyclable_ptr<VehiclePropValue> Create_ec_b2_v_v_frame_noReq(int32_t ec_b2_v_v_frame_no);
    recyclable_ptr<VehiclePropValue> Create_ec_b2_v_v_cell_volt_n1Req(int32_t ec_b2_v_v_cell_volt_n1);
    recyclable_ptr<VehiclePropValue> Create_ec_b2_v_v_cell_volt_n2Req(int32_t ec_b2_v_v_cell_volt_n2);
    recyclable_ptr<VehiclePropValue> Create_ec_b2_v_v_cell_volt_n3Req(int32_t ec_b2_v_v_cell_volt_n3);
    recyclable_ptr<VehiclePropValue> Create_ec_b2_v_t_frame_noReq(int32_t ec_b2_v_t_frame_no);
    recyclable_ptr<VehiclePropValue> Create_ec_b2_v_t_cell_temp_n1Req(int32_t ec_b2_v_t_cell_temp_n1);
    recyclable_ptr<VehiclePropValue> Create_ec_b2_v_t_cell_temp_n2Req(int32_t ec_b2_v_t_cell_temp_n2);
    recyclable_ptr<VehiclePropValue> Create_ec_b2_v_t_cell_temp_n3Req(int32_t ec_b2_v_t_cell_temp_n3);
    recyclable_ptr<VehiclePropValue> Create_ec_b2_v_t_cell_temp_n4Req(int32_t ec_b2_v_t_cell_temp_n4);
    recyclable_ptr<VehiclePropValue> Create_ec_b2_v_t_cell_temp_n5Req(int32_t ec_b2_v_t_cell_temp_n5);
    recyclable_ptr<VehiclePropValue> Create_ec_b2_v_t_cell_temp_n6Req(int32_t ec_b2_v_t_cell_temp_n6);
    recyclable_ptr<VehiclePropValue> Create_ec_b2_v_t_cell_temp_n7Req(int32_t ec_b2_v_t_cell_temp_n7);
    recyclable_ptr<VehiclePropValue> Create_ec_b2_v_gbsn_frame_noReq(float ec_b2_v_gbsn_frame_no);
    recyclable_ptr<VehiclePropValue> Create_ec_b2_v_gbsn_sys_code_lengthReq(float ec_b2_v_gbsn_sys_code_length);
    recyclable_ptr<VehiclePropValue> Create_ec_b2_v_gbsn_sys_code_1_7_13_19Req(float ec_b2_v_gbsn_sys_code_1_7_13_19);
    recyclable_ptr<VehiclePropValue> Create_ec_b2_v_gbsn_sys_code_2_8_14_20Req(float ec_b2_v_gbsn_sys_code_2_8_14_20);
    recyclable_ptr<VehiclePropValue> Create_ec_b2_v_gbsn_sys_code_3_9_15_21Req(float ec_b2_v_gbsn_sys_code_3_9_15_21);
    recyclable_ptr<VehiclePropValue> Create_ec_b2_v_gbsn_sys_code_4_10_16_22Req(float ec_b2_v_gbsn_sys_code_4_10_16_22);
    recyclable_ptr<VehiclePropValue> Create_ec_b2_v_gbsn_sys_code_5_11_17_23Req(float ec_b2_v_gbsn_sys_code_5_11_17_23);
    recyclable_ptr<VehiclePropValue> Create_ec_b2_v_gbsn_sys_code_6_12_18_24Req(float ec_b2_v_gbsn_sys_code_6_12_18_24);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_work_reqReq(float ec_vcu_work_req);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_livecounter_0x661Req(float ec_vcu_livecounter_0x661);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_checksum_0x661Req(float ec_vcu_checksum_0x661);
    recyclable_ptr<VehiclePropValue> Create_ec_str_work_reqReq(float ec_str_work_req);
    recyclable_ptr<VehiclePropValue> Create_ec_ccm_nm_bitReq(float ec_ccm_nm_bit);
    recyclable_ptr<VehiclePropValue> Create_ec_ccm_livecounter_0x66_cReq(float ec_ccm_livecounter_0x66_c);
    recyclable_ptr<VehiclePropValue> Create_ec_ccm_checksum_0x66_cReq(float ec_ccm_checksum_0x66_c);
    recyclable_ptr<VehiclePropValue> Create_ec_tbox_time_statusReq(float ec_tbox_time_status);
    recyclable_ptr<VehiclePropValue> Create_ec_tbox_yearReq(float ec_tbox_year);
    recyclable_ptr<VehiclePropValue> Create_ec_tbox_monthReq(float ec_tbox_month);
    recyclable_ptr<VehiclePropValue> Create_ec_tbox_dayReq(float ec_tbox_day);
    recyclable_ptr<VehiclePropValue> Create_ec_tbox_hourReq(float ec_tbox_hour);
    recyclable_ptr<VehiclePropValue> Create_ec_tbox_minuteReq(float ec_tbox_minute);
    recyclable_ptr<VehiclePropValue> Create_ec_tbox_secondReq(float ec_tbox_second);
    recyclable_ptr<VehiclePropValue> Create_ec_ccm_soc_sofeware_numReq(float ec_ccm_soc_sofeware_num);
    recyclable_ptr<VehiclePropValue> Create_ec_ccm_soc_hardware_numReq(float ec_ccm_soc_hardware_num);
    recyclable_ptr<VehiclePropValue> Create_ec_ccm_mcu_sofeware_numReq(float ec_ccm_mcu_sofeware_num);
    recyclable_ptr<VehiclePropValue> Create_ec_ccm_mcu_hardware_numReq(float ec_ccm_mcu_hardware_num);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_batterysoc_virtualReq(float ec_bms_batterysoc_virtual);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_single_chrg_energyReq(int32_t ec_bms_single_chrg_energy);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_livecounter_0x513Req(float ec_bms_livecounter_0x513);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_checksum_0x513Req(float ec_bms_checksum_0x513);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_batt_info4_dc_charg_req_currReq(float ec_bms_batt_info4_dc_charg_req_curr);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_batt_info4_dc_charg_req_volReq(float ec_bms_batt_info4_dc_charg_req_vol);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_batt_info4_mach_put_currReq(float ec_bms_batt_info4_mach_put_curr);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_batt_info4_mach_put_voltReq(float ec_bms_batt_info4_mach_put_volt);
    recyclable_ptr<VehiclePropValue> Create_ec_tbox_cpu_temperature_lowReq(float ec_tbox_cpu_temperature_low);
    recyclable_ptr<VehiclePropValue> Create_ec_tbox_cpu_temperature_highReq(float ec_tbox_cpu_temperature_high);
    recyclable_ptr<VehiclePropValue> Create_ec_pcb_temperature_lowReq(float ec_pcb_temperature_low);
    recyclable_ptr<VehiclePropValue> Create_ec_pcb_temperature_highReq(float ec_pcb_temperature_high);
    recyclable_ptr<VehiclePropValue> Create_ec_main_power_supply_voltahe_lowReq(float ec_main_power_supply_voltahe_low);
    recyclable_ptr<VehiclePropValue> Create_ec_main_power_supply_voltahe_highReq(float ec_main_power_supply_voltahe_high);
    recyclable_ptr<VehiclePropValue> Create_ec_sim_card_not_presentReq(float ec_sim_card_not_present);
    recyclable_ptr<VehiclePropValue> Create_ec_wifi_device_lostReq(float ec_wifi_device_lost);
    recyclable_ptr<VehiclePropValue> Create_ec_ccm_detects_eas_node_lossReq(float ec_ccm_detects_eas_node_loss);
    recyclable_ptr<VehiclePropValue> Create_ec_ccm_detects_bms_node_lossReq(float ec_ccm_detects_bms_node_loss);
    recyclable_ptr<VehiclePropValue> Create_ec_ccm_detects_ipu_node_lossReq(float ec_ccm_detects_ipu_node_loss);
    recyclable_ptr<VehiclePropValue> Create_ec_ccm_detects_vcu_node_lossReq(float ec_ccm_detects_vcu_node_loss);
    recyclable_ptr<VehiclePropValue> Create_ec_private_can3_bus_offReq(float ec_private_can3_bus_off);
    recyclable_ptr<VehiclePropValue> Create_ec_private_can2_bus_offReq(float ec_private_can2_bus_off);
    recyclable_ptr<VehiclePropValue> Create_ec_private_can1_bus_offReq(float ec_private_can1_bus_off);
    recyclable_ptr<VehiclePropValue> Create_ec_detect_backup_battery_lostReq(float ec_detect_backup_battery_lost);
    recyclable_ptr<VehiclePropValue> Create_ec_ccm_detects_acu_node_lossReq(float ec_ccm_detects_acu_node_loss);
    recyclable_ptr<VehiclePropValue> Create_ec_ccm_detects_bcm_node_lossReq(float ec_ccm_detects_bcm_node_loss);
    recyclable_ptr<VehiclePropValue> Create_ec_ccm_detects_ac_node_lossReq(float ec_ccm_detects_ac_node_loss);
    recyclable_ptr<VehiclePropValue> Create_bc_eas_motspdReq(float bc_eas_motspd);
    recyclable_ptr<VehiclePropValue> Create_bc_eas_eashvil_staReq(float bc_eas_eashvil_sta);
    recyclable_ptr<VehiclePropValue> Create_bc_eas_crtstsReq(float bc_eas_crtsts);
    recyclable_ptr<VehiclePropValue> Create_bc_eas_ip_mtempReq(float bc_eas_ip_mtemp);
    recyclable_ptr<VehiclePropValue> Create_bc_eas_ctrlrstsReq(float bc_eas_ctrlrsts);
    recyclable_ptr<VehiclePropValue> Create_bc_eas_crtpwrReq(int32_t bc_eas_crtpwr);
    recyclable_ptr<VehiclePropValue> Create_bc_eas_ctrlrcrtReq(float bc_eas_ctrlrcrt);
    recyclable_ptr<VehiclePropValue> Create_bc_eas_ctrlrvoltReq(float bc_eas_ctrlrvolt);
    recyclable_ptr<VehiclePropValue> Create_bc_ac_blower_levelReq(int32_t bc_ac_blower_level);
    recyclable_ptr<VehiclePropValue> Create_bc_ac_fan_reqReq(float bc_ac_fan_req);
    recyclable_ptr<VehiclePropValue> Create_bc_ac_fresh_reci_stateReq(int32_t bc_ac_fresh_reci_state);
    recyclable_ptr<VehiclePropValue> Create_bc_ac_front_defrost_stateReq(int32_t bc_ac_front_defrost_state, int32_t areaId);
    recyclable_ptr<VehiclePropValue> Create_bc_ac_heat_stateReq(int32_t bc_ac_heat_state);
    recyclable_ptr<VehiclePropValue> Create_bc_ac_havc_stateReq(int32_t bc_ac_havc_state);
    recyclable_ptr<VehiclePropValue> Create_bc_ac_ai_rdistribution_modeReq(int32_t bc_ac_ai_rdistribution_mode);
    recyclable_ptr<VehiclePropValue> Create_bc_ac_a_cstateReq(int32_t bc_ac_a_cstate);
    recyclable_ptr<VehiclePropValue> Create_bc_ac_left_set_temperatureReq(float bc_ac_left_set_temperature, int32_t areaId);
    recyclable_ptr<VehiclePropValue> Create_bc_ac_fan_pwmReq(float bc_ac_fan_pwm);
    recyclable_ptr<VehiclePropValue> Create_bc_ac_fan_feed_back_voltageReq(float bc_ac_fan_feed_back_voltage);
    recyclable_ptr<VehiclePropValue> Create_bc_ac_pt_ctempReq(float bc_ac_pt_ctemp);
    recyclable_ptr<VehiclePropValue> Create_bc_ac_fault_statusReq(int32_t bc_ac_fault_status);
    recyclable_ptr<VehiclePropValue> Create_bc_ac_ptc_over_heatReq(float bc_ac_ptc_over_heat);
    recyclable_ptr<VehiclePropValue> Create_bc_ac_eas_speed_reqReq(float bc_ac_eas_speed_req);
    recyclable_ptr<VehiclePropValue> Create_bc_ac_ptcp_power_reqReq(float bc_ac_ptcp_power_req);
    recyclable_ptr<VehiclePropValue> Create_bc_ac_press_swtich_stateReq(float bc_ac_press_swtich_state);
    recyclable_ptr<VehiclePropValue> Create_bc_ac_livecounter_0x233Req(float bc_ac_livecounter_0x233);
    recyclable_ptr<VehiclePropValue> Create_bc_ac_checksum_0x233Req(float bc_ac_checksum_0x233);
    recyclable_ptr<VehiclePropValue> Create_bc_ccm_fresh_reci_keyReq(float bc_ccm_fresh_reci_key);
    recyclable_ptr<VehiclePropValue> Create_bc_ccm_front_defrost_keyReq(float bc_ccm_front_defrost_key);
    recyclable_ptr<VehiclePropValue> Create_bc_ccm_a_ckeyReq(float bc_ccm_a_ckey);
    recyclable_ptr<VehiclePropValue> Create_bc_ccm_blower_levelReq(float bc_ccm_blower_level);
    recyclable_ptr<VehiclePropValue> Create_bc_ccm_ac_havc_stateReq(float bc_ccm_ac_havc_state);
    recyclable_ptr<VehiclePropValue> Create_bc_ccm_air_distribution_mode_reqReq(float bc_ccm_air_distribution_mode_req);
    recyclable_ptr<VehiclePropValue> Create_bc_ccm_heat_keyReq(float bc_ccm_heat_key);
    recyclable_ptr<VehiclePropValue> Create_bc_ccm_left_set_tempReq(float bc_ccm_left_set_temp);
    recyclable_ptr<VehiclePropValue> Create_bc_ccm_avassetReq(float bc_ccm_avasset);
    recyclable_ptr<VehiclePropValue> Create_bc_ccm_livecounter_0x310Req(float bc_ccm_livecounter_0x310);
    recyclable_ptr<VehiclePropValue> Create_bc_ccm_checksum_0x310Req(float bc_ccm_checksum_0x310);
    recyclable_ptr<VehiclePropValue> Create_bc_ccm_rear_fog_lamp_setReq(float bc_ccm_rear_fog_lamp_set);
    recyclable_ptr<VehiclePropValue> Create_bc_ccm_left_mirror_setReq(float bc_ccm_left_mirror_set);
    recyclable_ptr<VehiclePropValue> Create_bc_ccm_park_un_lock_reqReq(float bc_ccm_park_un_lock_req);
    recyclable_ptr<VehiclePropValue> Create_bc_ccm_auto_lock_reqReq(float bc_ccm_auto_lock_req);
    recyclable_ptr<VehiclePropValue> Create_bc_ccm_auto_unlock_reqReq(float bc_ccm_auto_unlock_req);
    recyclable_ptr<VehiclePropValue> Create_bc_ccm_remt_contr_lamp_ctr_cmdReq(float bc_ccm_remt_contr_lamp_ctr_cmd);
    recyclable_ptr<VehiclePropValue> Create_bc_ccu_remote_car_searchReq(int32_t bc_ccm_remote_car_search);
    recyclable_ptr<VehiclePropValue> Create_bc_ccu_remote_lockReq(int32_t bc_ccu_remote_lock);
    recyclable_ptr<VehiclePropValue> Create_bc_ccm_right_mirror_setReq(float bc_ccm_right_mirror_set);
    recyclable_ptr<VehiclePropValue> Create_bc_ccm_livecounter_0x311Req(float bc_ccm_livecounter_0x311);
    recyclable_ptr<VehiclePropValue> Create_bc_ccm_checksum_0x311Req(float bc_ccm_checksum_0x311);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_position_light_statusReq(int32_t bc_bcm_position_light_status);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_high_beam_statusReq(int32_t bc_bcm_high_beam_status);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_low_beam_statusReq(int32_t bc_bcm_low_beam_status);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_turn_indcr_riReq(int32_t bc_bcm_turn_indcr_ri);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_turn_indcr_leReq(int32_t bc_bcm_turn_indcr_le);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_hazard_light_statusReq(int32_t bc_bcm_hazard_light_status);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_position_light_warningReq(int32_t bc_bcm_position_light_warning);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_rl_door_ajar_statusReq(int32_t bc_bcm_rl_door_ajar_status);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_rr_door_ajar_statusReq(int32_t bc_bcm_rr_door_ajar_status);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_fr_door_ajar_statusReq(int32_t bc_bcm_fr_door_ajar_status);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_fl_door_ajar_statusReq(int32_t bc_bcm_fl_door_ajar_status);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_rear_fog_light_statusReq(int32_t bc_bcm_rear_fog_light_status);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_tr_cls_stReq(int32_t bc_bcm_tr_cls_st);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_power_stsReq(int32_t bc_bcm_power_sts);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_ccm_open_door_warn_feedReq(int32_t bc_bcm_ccm_open_door_warn_feed);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_dtc_fault_statusReq(int32_t bc_bcm_dtc_fault_status);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_veh_alrm_sys_stReq(int32_t bc_bcm_veh_alrm_sys_st);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_drivelock_stReq(int32_t bc_bcm_drivelock_st);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_reversinglight_stReq(float bc_bcm_reversinglight_st);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_brakelight_stReq(int32_t bc_bcm_brakelight_st);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_interiorlight_stReq(int32_t bc_bcm_interiorlight_st);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_right_mirror_set_ackReq(int32_t bc_bcm_right_mirror_set_ack);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_left_mirror_set_ackReq(int32_t bc_bcm_left_mirror_set_ack);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_park_un_lock_ackReq(int32_t bc_bcm_park_un_lock_ack);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_auto_lock_ackReq(int32_t bc_bcm_auto_lock_ack);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_auto_unlock_ackReq(int32_t bc_bcm_auto_unlock_ack);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_livecounter_0x330Req(float bc_bcm_livecounter_0x330);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_checksum_0x330Req(float bc_bcm_checksum_0x330);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_high_beam_rly_errReq(float bc_bcm_high_beam_rly_err);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_turn_indcr_ri_errReq(float bc_bcm_turn_indcr_ri_err);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_turn_indcr_le_errReq(float bc_bcm_turn_indcr_le_err);
    //recyclable_ptr<VehiclePropValue> Create_bc_bcm_position_light_errReq(float bc_bcm_position_light_err);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_daytime_running_light_errReq(float bc_bcm_daytime_running_light_err);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_brakelight_errReq(float bc_bcm_brakelight_err);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_reversinglight_errReq(float bc_bcm_reversinglight_err);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_rear_fog_light_errReq(float bc_bcm_rear_fog_light_err);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_loss_com_with_acuReq(float bc_bcm_loss_com_with_acu);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_loss_com_with_ccmReq(float bc_bcm_loss_com_with_ccm);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_loss_com_with_vcuReq(float bc_bcm_loss_com_with_vcu);
    recyclable_ptr<VehiclePropValue> Create_electric_errReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_lv_batt_over_voltReq(float bc_bcm_lv_batt_over_volt);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_lv_batt_under_voltReq(float bc_bcm_lv_batt_under_volt);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_horn_rly_errReq(float bc_bcm_horn_rly_err);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_low_beam_rly_errReq(float bc_bcm_low_beam_rly_err);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_livecounter_0x331Req(float bc_bcm_livecounter_0x331);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_checksum_0x331Req(float bc_bcm_checksum_0x331);
    recyclable_ptr<VehiclePropValue> Create_bc_pdc1_button_pressReq(int32_t bc_pdc1_button_press);
    recyclable_ptr<VehiclePropValue> Create_bc_pdc1_modeReq(int32_t bc_pdc1_mode);
    recyclable_ptr<VehiclePropValue> Create_bc_pdc1_buzzer_alarm_patternReq(int32_t bc_pdc1_buzzer_alarm_pattern);
    recyclable_ptr<VehiclePropValue> Create_bc_pdc1_distance_rmReq(int32_t bc_pdc1_distance_rm);
    recyclable_ptr<VehiclePropValue> Create_bc_pdc1_distance_rrmReq(int32_t bc_pdc1_distance_rrm);
    recyclable_ptr<VehiclePropValue> Create_bc_pdc1_distance_rlReq(int32_t bc_pdc1_distance_rl);
    recyclable_ptr<VehiclePropValue> Create_bc_pdc1_distance_rrReq(int32_t bc_pdc1_distance_rr);
    recyclable_ptr<VehiclePropValue> Create_bc_pdc_livecounter_0x165Req(float bc_pdc_livecounter_0x165);
    recyclable_ptr<VehiclePropValue> Create_bc_pdc_checksum_0x165Req(float bc_pdc_checksum_0x165);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_work_reqReq(float bc_bcm_work_req);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_livecounter_0x669Req(float bc_bcm_livecounter_0x669);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_checksum_0x669Req(float bc_bcm_checksum_0x669);
    recyclable_ptr<VehiclePropValue> Create_bc_str_work_reqReq(float bc_str_work_req);
    recyclable_ptr<VehiclePropValue> Create_bc_ccm_nm_bitReq(float bc_ccm_nm_bit);
    recyclable_ptr<VehiclePropValue> Create_bc_ccm_livecounter_0x66_bReq(float bc_ccm_livecounter_0x66_b);
    recyclable_ptr<VehiclePropValue> Create_bc_ccm_checksum_0x66_bReq(float bc_ccm_checksum_0x66_b);
    recyclable_ptr<VehiclePropValue> Create_bc_avas_stateReq(int32_t bc_avas_state);
    recyclable_ptr<VehiclePropValue> Create_bc_avas_livecounter_0x411Req(float bc_avas_livecounter_0x411);
    recyclable_ptr<VehiclePropValue> Create_bc_avas_checksum_0x411Req(float bc_avas_checksum_0x411);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_ccm_reset_stReq(float bc_bcm_ccm_reset_st);
    recyclable_ptr<VehiclePropValue> Create_bc_ota_modelReq(float bc_ota_model);
    recyclable_ptr<VehiclePropValue> Create_bc_ccm_bcm_open_door_warn_setReq(float bc_ccm_bcm_open_door_warn_set);
    recyclable_ptr<VehiclePropValue> Create_bc_ccm_livecounter_0x353Req(float bc_ccm_livecounter_0x353);
    recyclable_ptr<VehiclePropValue> Create_bc_ccm_checksum_0x353Req(float bc_ccm_checksum_0x353);
    recyclable_ptr<VehiclePropValue> Create_bc_ccm_tpms_learning_validReq(float bc_ccm_tpms_learning_valid);
    recyclable_ptr<VehiclePropValue> Create_bc_ccm_remt_ctrl_flagReq(float bc_ccm_remt_ctrl_flag);
    recyclable_ptr<VehiclePropValue> Create_bc_ccm_livecounter_0x354Req(float bc_ccm_livecounter_0x354);
    recyclable_ptr<VehiclePropValue> Create_bc_ccm_checksum_0x354Req(float bc_ccm_checksum_0x354);
    recyclable_ptr<VehiclePropValue> Create_bc_tpms_receiverstateReq(int32_t bc_tpms_receiverstate);
    recyclable_ptr<VehiclePropValue> Create_bc_tpms_transducer_locationReq(int32_t bc_tpms_transducer_location);
    recyclable_ptr<VehiclePropValue> Create_bc_tpms_tyrestate_frReq(int32_t bc_tpms_tyrestate_fr);
    recyclable_ptr<VehiclePropValue> Create_bc_tpms_tyrestate_flReq(int32_t bc_tpms_tyrestate_fl);
    recyclable_ptr<VehiclePropValue> Create_bc_tpms_tyrestate_rlReq(int32_t bc_tpms_tyrestate_rl);
    recyclable_ptr<VehiclePropValue> Create_bc_tpms_tyrestate_rrReq(int32_t bc_tpms_tyrestate_rr);
    recyclable_ptr<VehiclePropValue> Create_bc_tpms_tyretemperatureReq(float bc_tpms_tyretemperature,int current_tyre);
    recyclable_ptr<VehiclePropValue> Create_bc_tpms_tyrepressure_flReq(float bc_tpms_tyrepressure_fl);
    recyclable_ptr<VehiclePropValue> Create_bc_tpms_tyrepressure_frReq(float bc_tpms_tyrepressure_fr);
    recyclable_ptr<VehiclePropValue> Create_bc_tpms_tyrepressure_rrReq(float bc_tpms_tyrepressure_rr);
    recyclable_ptr<VehiclePropValue> Create_bc_tpms_tyrepressure_rlReq(float bc_tpms_tyrepressure_rl);
    recyclable_ptr<VehiclePropValue> Create_cc_acu_gsensor_faultReq(int32_t cc_acu_gsensor_fault);
    recyclable_ptr<VehiclePropValue> Create_cc_acu_system_stsReq(float cc_acu_system_sts);
    recyclable_ptr<VehiclePropValue> Create_cc_acu_airb_warn_lamp_stReq(int32_t cc_acu_airb_warn_lamp_st);
    recyclable_ptr<VehiclePropValue> Create_cc_acu_crash_outp_stsReq(float cc_acu_crash_outp_sts);
    recyclable_ptr<VehiclePropValue> Create_cc_acu_livecounter_0x133Req(float cc_acu_livecounter_0x133);
    recyclable_ptr<VehiclePropValue> Create_cc_acu_checksum_0x133Req(float cc_acu_checksum_0x133);
    recyclable_ptr<VehiclePropValue> Create_cc_abs_abs_fail_statusReq(int32_t cc_abs_abs_fail_status);
    recyclable_ptr<VehiclePropValue> Create_cc_abs_llivecounter_0x171Req(float cc_abs_llivecounter_0x171);
    recyclable_ptr<VehiclePropValue> Create_cc_abs_checksum_0x171Req(float cc_abs_checksum_0x171);
    recyclable_ptr<VehiclePropValue> Create_cc_eps_run_stateReq(int32_t cc_eps_run_state);
    recyclable_ptr<VehiclePropValue> Create_cc_eps_livecounter_0x300Req(float cc_eps_livecounter_0x300);
    recyclable_ptr<VehiclePropValue> Create_cc_eps_checksum_0x300Req(float cc_eps_checksum_0x300);
    recyclable_ptr<VehiclePropValue> Create_cc_eps_motor_curr_fltReq(float cc_eps_motor_curr_flt);
    recyclable_ptr<VehiclePropValue> Create_cc_eps_motor_volt_fltReq(float cc_eps_motor_volt_flt);
    recyclable_ptr<VehiclePropValue> Create_cc_eps_torq_snr_s_sig_out_rng_fltReq(float cc_eps_torq_snr_s_sig_out_rng_flt);
    recyclable_ptr<VehiclePropValue> Create_cc_eps_torq_snr_p_sig_out_rng_fltReq(float cc_eps_torq_snr_p_sig_out_rng_flt);
    recyclable_ptr<VehiclePropValue> Create_cc_eps_torq_snr_t1_t2_sig_sync_fltReq(float cc_eps_torq_snr_t1_t2_sig_sync_flt);
    recyclable_ptr<VehiclePropValue> Create_cc_eps_torq_snr_t1_sig_out_rng_fltReq(float cc_eps_torq_snr_t1_sig_out_rng_flt);
    recyclable_ptr<VehiclePropValue> Create_cc_eps_torq_snr_t2_sig_out_rng_fltReq(float cc_eps_torq_snr_t2_sig_out_rng_flt);
    recyclable_ptr<VehiclePropValue> Create_cc_eps_torq_snr5_v_fltReq(float cc_eps_torq_snr5_v_flt);
    recyclable_ptr<VehiclePropValue> Create_cc_eps_can_bus_fltReq(float cc_eps_can_bus_flt);
    recyclable_ptr<VehiclePropValue> Create_cc_eps_over_volt_fltReq(float cc_eps_over_volt_flt);
    recyclable_ptr<VehiclePropValue> Create_cc_eps_under_volt_fltReq(float cc_eps_under_volt_flt);
    recyclable_ptr<VehiclePropValue> Create_cc_eps_uncalibrated_angle_fltReq(float cc_eps_uncalibrated_angle_flt);
    recyclable_ptr<VehiclePropValue> Create_cc_eps_over_heat_fltReq(float cc_eps_over_heat_flt);
    recyclable_ptr<VehiclePropValue> Create_cc_eps_relay_fltReq(float cc_eps_relay_flt);
    recyclable_ptr<VehiclePropValue> Create_cc_eps_motor_curr_fellow_fltReq(float cc_eps_motor_curr_fellow_flt);
    recyclable_ptr<VehiclePropValue> Create_cc_eps_motor_drv_fltReq(float cc_eps_motor_drv_flt);
    recyclable_ptr<VehiclePropValue> Create_cc_eps_vcu_time_out_fltReq(float cc_eps_vcu_time_out_flt);
    recyclable_ptr<VehiclePropValue> Create_cc_eps_livecounter_0x301Req(float cc_eps_livecounter_0x301);
    recyclable_ptr<VehiclePropValue> Create_cc_eps_checksum_0x301Req(float cc_eps_checksum_0x301);
    recyclable_ptr<VehiclePropValue> Create_cc_abs_wheel_speed_fr_no_signal_errReq(float cc_abs_wheel_speed_fr_no_signal_err);
    recyclable_ptr<VehiclePropValue> Create_cc_abs_wheel_speed_fr_interm_errReq(float cc_abs_wheel_speed_fr_interm_err);
    recyclable_ptr<VehiclePropValue> Create_cc_abs_wheel_speed_fr_open_short_errReq(float cc_abs_wheel_speed_fr_open_short_err);
    recyclable_ptr<VehiclePropValue> Create_cc_abs_wheel_speed_fl_no_signal_errReq(float cc_abs_wheel_speed_fl_no_signal_err);
    recyclable_ptr<VehiclePropValue> Create_cc_abs_wheel_speed_fl_interm_errReq(float cc_abs_wheel_speed_fl_interm_err);
    recyclable_ptr<VehiclePropValue> Create_cc_abs_wheel_speed_fl_open_short_errReq(float cc_abs_wheel_speed_fl_open_short_err);
    recyclable_ptr<VehiclePropValue> Create_cc_abs_power_undervoltReq(float cc_abs_power_undervolt);
    recyclable_ptr<VehiclePropValue> Create_cc_abs_power_overvoltReq(float cc_abs_power_overvolt);
    recyclable_ptr<VehiclePropValue> Create_cc_abs_valve_relay_errReq(float cc_abs_valve_relay_err);
    recyclable_ptr<VehiclePropValue> Create_cc_abs_wheel_speed_freq_errReq(float cc_abs_wheel_speed_freq_err);
    recyclable_ptr<VehiclePropValue> Create_cc_abs_wheel_speed_rr_no_signal_errReq(float cc_abs_wheel_speed_rr_no_signal_err);
    recyclable_ptr<VehiclePropValue> Create_cc_abs_wheel_speed_rr_interm_errReq(float cc_abs_wheel_speed_rr_interm_err);
    recyclable_ptr<VehiclePropValue> Create_cc_abs_wheel_speed_rr_open_short_errReq(float cc_abs_wheel_speed_rr_open_short_err);
    recyclable_ptr<VehiclePropValue> Create_cc_abs_wheel_speed_rl_no_signal_errReq(float cc_abs_wheel_speed_rl_no_signal_err);
    recyclable_ptr<VehiclePropValue> Create_cc_abs_wheel_speed_rl_interm_errReq(float cc_abs_wheel_speed_rl_interm_err);
    recyclable_ptr<VehiclePropValue> Create_cc_abs_wheel_speed_rl_open_short_errReq(float cc_abs_wheel_speed_rl_open_short_err);
    recyclable_ptr<VehiclePropValue> Create_cc_abs_outlet_valve_rr_errReq(float cc_abs_outlet_valve_rr_err);
    recyclable_ptr<VehiclePropValue> Create_cc_abs_inlet_valve_rr_errReq(float cc_abs_inlet_valve_rr_err);
    recyclable_ptr<VehiclePropValue> Create_cc_abs_outlet_valve_rl_errReq(float cc_abs_outlet_valve_rl_err);
    recyclable_ptr<VehiclePropValue> Create_cc_abs_inlet_valve_rl_errReq(float cc_abs_inlet_valve_rl_err);
    recyclable_ptr<VehiclePropValue> Create_cc_abs_outlet_valve_fr_errReq(float cc_abs_outlet_valve_fr_err);
    recyclable_ptr<VehiclePropValue> Create_cc_abs_inlet_valve_fr_errReq(float cc_abs_inlet_valve_fr_err);
    recyclable_ptr<VehiclePropValue> Create_cc_abs_outlet_valve_fl_errReq(float cc_abs_outlet_valve_fl_err);
    recyclable_ptr<VehiclePropValue> Create_cc_abs_inlet_valve_fl_errReq(float cc_abs_inlet_valve_fl_err);
    recyclable_ptr<VehiclePropValue> Create_cc_abs_current_max_fault_levelReq(float cc_abs_current_max_fault_level);
    recyclable_ptr<VehiclePropValue> Create_cc_abs_can_bus_off_errReq(float cc_abs_can_bus_off_err);
    recyclable_ptr<VehiclePropValue> Create_cc_abs_can_hardware_errReq(float cc_abs_can_hardware_err);
    recyclable_ptr<VehiclePropValue> Create_cc_abs_ecu_hardware_errReq(float cc_abs_ecu_hardware_err);
    recyclable_ptr<VehiclePropValue> Create_cc_abs_motor_relay_errReq(float cc_abs_motor_relay_err);
    recyclable_ptr<VehiclePropValue> Create_cc_abs_motor_errReq(float cc_abs_motor_err);
    recyclable_ptr<VehiclePropValue> Create_cc_abs_valve_errReq(float cc_abs_valve_err);
    recyclable_ptr<VehiclePropValue> Create_cc_abs_livecounter_0x420Req(float cc_abs_livecounter_0x420);
    recyclable_ptr<VehiclePropValue> Create_cc_abs_checksum_0x420Req(float cc_abs_checksum_0x420);
    recyclable_ptr<VehiclePropValue> Create_mc_lamplet_statusReq(int32_t mc_lamplet_status);
    recyclable_ptr<VehiclePropValue> Create_mc_main_seat_pressure_statusReq(int32_t mc_main_seat_pressure_status);
    recyclable_ptr<VehiclePropValue> Create_mc_brake_level_alarm_statusReq(int32_t mc_brake_level_alarm_status);
    recyclable_ptr<VehiclePropValue> Create_mc_main_seat_safety_belt_statusReq(int32_t mc_main_seat_safety_belt_status);
    recyclable_ptr<VehiclePropValue> Create_mc_engine_statusReq(int32_t mc_engine_status);
    recyclable_ptr<VehiclePropValue> Create_mc_low_vol_battery_volReq(float mc_low_vol_battery_vol);
	  recyclable_ptr<VehiclePropValue> Create_mcu_steering_002_keyWatcher(int32_t mcu_steering_002_action, KeyCodeType mcu_steering_002_keycode);
    recyclable_ptr<VehiclePropValue> Create_mcu_steering_002_customWatcher(int32_t mcu_steering_002_action, CustomInputType mcu_steering_002_keycode);
    recyclable_ptr<VehiclePropValue> Create_sc_ec_ccm_batt_maintain_ctr_cmdReq(int32_t sc_ec_ccm_batt_maintain_ctr_cmd);
    recyclable_ptr<VehiclePropValue> Create_sc_ec_ccm_batt_maintain_stsReq(int32_t sc_ec_ccm_batt_maintain_sts);
    recyclable_ptr<VehiclePropValue> Create_sc_ec_ccm_versionReq(int32_t sc_ec_ccm_version);
    recyclable_ptr<VehiclePropValue> Create_sc_ec_ccm_soc_sofeware_numReq(int32_t sc_ec_ccm_soc_sofeware_num);
    recyclable_ptr<VehiclePropValue> Create_sc_ec_ccm_soc_hardware_numReq(int32_t sc_ec_ccm_soc_hardware_num);
    recyclable_ptr<VehiclePropValue> Create_sc_ec_ccm_mcu_software_numReq(int32_t sc_ec_ccm_mcu_software_num);
    recyclable_ptr<VehiclePropValue> Create_sc_ec_ccm_mcu_hardware_numReq(int32_t sc_ec_ccm_mcu_hardware_num);
    recyclable_ptr<VehiclePropValue> Create_sc_ec_ccm_target_chrg_currReq(int32_t sc_ec_ccm_target_chrg_curr);
    recyclable_ptr<VehiclePropValue> Create_sc_ccm_remote_lockReq(int32_t sc_ccm_remote_lock);
    recyclable_ptr<VehiclePropValue> Create_sc_ccm_remote_car_searchReq(int32_t sc_ccm_remote_car_search);
    recyclable_ptr<VehiclePropValue> Create_sc_ccm_remt_ctrl_flagReq(int32_t sc_ccm_remt_ctrl_flag);
    recyclable_ptr<VehiclePropValue> Create_sc_ec_ccm_operat_licenceReq(int32_t sc_ec_ccm_operat_licence);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_realtimealowdischapowerReq(int32_t ec_bms_realtimealowdischapower);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_ipuhvil_staReq(int32_t ec_ipu_ipuhvil_sta);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_mainrelayposistatusReq(int ec_ipu_mainrelayposistatus);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_workstatusReq(int ec_ipu_workstatus);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_tqreqReq(int ec_vcu_tqreq);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_softwareversionReq(int ec_bms_softwareversion);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_hardware_numReq(int ec_ipu_hardware_num);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_sofeware_numReq(int ec_ipu_sofeware_num);
    recyclable_ptr<VehiclePropValue> Create_appointment_modeReq(int32_t appointment_mode_type);
    recyclable_ptr<VehiclePropValue> Create_chraging_begin_time_hourReq(int32_t chraging_begin_time_hour);
    recyclable_ptr<VehiclePropValue> Create_chraging_begin_time_minuteReq(int32_t chraging_begin_time_minute);
    recyclable_ptr<VehiclePropValue> Create_chraging_end_time_hourReq(int32_t chraging_end_time_hour);
    recyclable_ptr<VehiclePropValue> Create_chraging_end_time_minuteReq(int32_t chraging_end_time_minute);
    recyclable_ptr<VehiclePropValue> Create_chraging_loopReq();
    recyclable_ptr<VehiclePropValue> Create_chraging_target_socReq(int32_t chraging_target_soc);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_obc_output_voltageReq(int32_t ipu_obc_output_voltage);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_obc_output_currentReq(int32_t ec_ipu_obc_output_current);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_mainrelaynega_statusReq(int32_t ec_bms_mainrelaynega_status);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_batterysohReq(int32_t ec_bms_batterysoh);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_soeReq(int32_t ec_bms_soe);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_hv_batt_stReq(int32_t ec_bms_hv_batt_st);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_initstatusReq(int32_t ec_bms_initstatus);
    recyclable_ptr<VehiclePropValue> Create_mc_light_levelReq(int32_t mc_light_level);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_rear_fog_light_errReq(int32_t value);       
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_reversinglight_errReq(int32_t value);       
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_brakelight_errReq(int32_t value);           
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_daytime_running_light_errReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_position_light_errReq(int32_t value);       
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_turn_indcr_le_errReq(int32_t value);            
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_turn_indcr_ri_errReq(int32_t value);            
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_high_beam_rly_errReq(int32_t value);            
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_low_beam_rly_errReq(int32_t value);             
    recyclable_ptr<VehiclePropValue> Create_bc_motion_park_stateReq(int32_t value);                
    recyclable_ptr<VehiclePropValue> Create_bc_park_chrg_cnctr_stsReq(int32_t value); 
    recyclable_ptr<VehiclePropValue> Create_mcu_voiume_navigationReq(int32_t value); 
    recyclable_ptr<VehiclePropValue> Create_mcu_voiume_voicReq(int32_t value); 
    recyclable_ptr<VehiclePropValue> Create_mcu_voiume_multimediaReq(int32_t value); 
    recyclable_ptr<VehiclePropValue> Create_mcu_voiume_phoneReq(int32_t value); 
    recyclable_ptr<VehiclePropValue> Create_mcu_voiume_alarmReq(int32_t value); 
    recyclable_ptr<VehiclePropValue> Create_mcu_voiume_keyReq(int32_t value); 
    recyclable_ptr<VehiclePropValue> Create_mcu_info_vin1Req(std::string value);
    recyclable_ptr<VehiclePropValue> Create_mcu_info_vin2Req(std::string value);
    recyclable_ptr<VehiclePropValue> Create_mcu_info_vin3Req(std::string value);
    recyclable_ptr<VehiclePropValue> Create_mcu_info_vinReq(std::string value);
    recyclable_ptr<VehiclePropValue> Create_mcu_info_sn1Req(std::string value);
    recyclable_ptr<VehiclePropValue> Create_mcu_info_sn2Req(std::string value);
    recyclable_ptr<VehiclePropValue> Create_mcu_info_sn3Req(std::string value);
    recyclable_ptr<VehiclePropValue> Create_mcu_info_versionReq(std::string value);
    recyclable_ptr<VehiclePropValue> Create_mc_travel_rangeReq(float value);
    recyclable_ptr<VehiclePropValue> Create_mc_travel_timeReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_mc_average_energy_consumptionReq(float value);
    recyclable_ptr<VehiclePropValue> Creat_range_modeReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Creat_gecko_headlighthReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_mc_remind_inrReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_mc_remind_start_timeReq(uint32_t value);
    recyclable_ptr<VehiclePropValue> Create_mc_remind_distanceReq(uint32_t value);
    recyclable_ptr<VehiclePropValue> Create_mc_remind_start_odoReq(float value);
    recyclable_ptr<VehiclePropValue> Create_bc_ac_hybrid_eco_mode_staReq(int32_t bc_ac_hybrid_eco_mode_sta);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_wipr_intl_time_set_fbReq(int32_t bc_bcm_wipr_intl_time_set_fb);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_flwr_me_hm_ctrl_fbReq(int32_t bc_bcm_flwr_me_hm_ctrl_fb);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_illmnd_unlock_sts_fbReq(int32_t bc_bcm_illmnd_unlock_sts_fb);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_illmnd_lock_sts_fbReq(int32_t bc_bcm_illmnd_lock_sts_fb);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_lock_horn_on_st_fbReq(int32_t bc_bcm_lock_horn_on_st_fb);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_esc_disableReq(int32_t ec_esc_esc_disable);
    recyclable_ptr<VehiclePropValue> Create_ec_ehb_avh_appld_stReq(int32_t ec_ehb_avh_appld_st);
    recyclable_ptr<VehiclePropValue> Create_ec_ehb_epb_system_stateReq(int32_t ec_ehb_epb_system_state);
    recyclable_ptr<VehiclePropValue> Create_ec_ehb_brk_dis_wip_acReq(int32_t ec_ehb_brk_dis_wip_ac);
    recyclable_ptr<VehiclePropValue> Create_ec_elec_steer_mode_staReq(int32_t ec_elec_steer_mode_sta);
    recyclable_ptr<VehiclePropValue> Create_bc_veh_act_recuperate_pwrReq(int32_t bc_veh_act_recuperate_pwr);
    recyclable_ptr<VehiclePropValue> Create_ec_vehicle_driving_pwrReq(int32_t ec_vehicle_driving_pwr);
    recyclable_ptr<VehiclePropValue> Create_ec_srs_passenger_airbag_sta_rsvrReq(int32_t ec_srs_passenger_airbag_sta_rsvr);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_front_fog_light_statusReq(int32_t bc_bcm_front_fog_light_status);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_key_lo_batt_lvl_warnReq(int32_t bc_bcm_key_lo_batt_lvl_warn);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_warn_no_key_foundReq(int32_t bc_bcm_warn_no_key_found);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_auto_lamp_statusReq(int32_t bc_bcm_auto_lamp_status);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_indication_shiftto_neutralReq(int32_t bc_bcm_indication_shiftto_neutral);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_12_v_bat_low_vol_staReq(int32_t ec_vcu_12_v_bat_low_vol_sta);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_sibs_kl30_voltageReq(int32_t ec_vcu_sibs_kl30_voltage);
    recyclable_ptr<VehiclePropValue> Create_ec_srs_airbag_warning_lamp_stsReq(int32_t ec_srs_airbag_warning_lamp_sts);
    recyclable_ptr<VehiclePropValue> Create_ec_srs_drv_seatbelt_buckle_validReq(int32_t ec_srs_drv_seatbelt_buckle_valid);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_obc_inlet_connect_staReq(int32_t ec_ipu_obc_inlet_connect_sta);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_dcs_inlet_connect_staReq(int32_t ec_bms_dcs_inlet_connect_sta);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_pwr_train_connect_staReq(int32_t ec_bms_pwr_train_connect_sta);
    recyclable_ptr<VehiclePropValue> Create_ec_ehb_brake_liquid_level_warnReq(int32_t ec_ehb_brake_liquid_level_warn);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_ebd_failedReq(int32_t ec_esc_ebd_failed);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_vhcl_p_gear_errorReq(int32_t ec_vcu_vhcl_p_gear_error);
    recyclable_ptr<VehiclePropValue> Create_ec_bcm_central_lock_stsReq(int32_t ec_bcm_central_lock_sts);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_pcu_fail_staReq(int32_t ec_vcu_pcu_fail_sta);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_mcu_high_temp_wrningReq(int32_t ec_vcu_mcu_high_temp_wrning);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_motor_high_temp_wrningReq(int32_t ec_vcu_motor_high_temp_wrning);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_warn_key_out_reminderReq(int32_t bc_bcm_warn_key_out_reminder);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_light_intensityReq(int32_t bc_bcm_light_intensity);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_indication_key_closerReq(int32_t bc_bcm_indication_key_closer);
    recyclable_ptr<VehiclePropValue> Create_ec_srs_pass_seatbelt_bucklestatusReq(int32_t ec_srs_pass_seatbelt_bucklestatus);
    recyclable_ptr<VehiclePropValue> Create_ec_srs_pass_seatbelt_buckle_validReq(int32_t ec_srs_pass_seatbelt_buckle_valid);
    recyclable_ptr<VehiclePropValue> Create_ec_srs_pass_seat_occupant_sensor_stsReq(int32_t ec_srs_pass_seat_occupant_sensor_sts);
    recyclable_ptr<VehiclePropValue> Create_ec_srs_mid_seat_belt_bucklestatusReq(int32_t ec_srs_mid_seat_belt_bucklestatus);
    recyclable_ptr<VehiclePropValue> Create_ec_srs_mid_seat_belt_buckle_validReq(int32_t ec_srs_mid_seat_belt_buckle_valid);
    recyclable_ptr<VehiclePropValue> Create_ec_srs_mid_seat_occupant_sensor_stsReq(int32_t ec_srs_mid_seat_occupant_sensor_sts);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_obc_actl_oprt_modeReq(int32_t ec_ipu_obc_actl_oprt_mode);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_dcs_act_oprt_modeReq(int32_t ec_bms_dcs_act_oprt_mode);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_reserve_powerReq(int32_t ec_vcu_reserve_power);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_motor_actual_powerReq(int32_t ec_vcu_motor_actual_power);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_motor_actual_power_typeReq(int32_t ec_vcu_motor_actual_power_type);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_hdc_statusReq(int32_t ec_vcu_hdc_status);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_es_cor_tcs_failedReq(int32_t ec_esc_es_cor_tcs_failed);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_tcs_active_staReq(int32_t ec_esc_tcs_active_sta);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_esp_active_staReq(int32_t ec_esc_esp_active_sta);
    recyclable_ptr<VehiclePropValue> Create_ec_ehb_avh_lamp_reqReq(int32_t ec_ehb_avh_lamp_req);
    recyclable_ptr<VehiclePropValue> Create_ec_ehb_epb_display_msg_idReq(int32_t ec_ehb_epb_display_msg_id);
    recyclable_ptr<VehiclePropValue> Create_ec_ehb_avh_disp_msgReq(int32_t ec_ehb_avh_disp_msg);
    recyclable_ptr<VehiclePropValue> Create_ec_ehb_epb_warn_lamp_staReq(int32_t ec_ehb_epb_warn_lamp_sta);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_obc_oprt_cmd_to_icuReq(int32_t ec_vcu_obc_oprt_cmd_to_icu);
    recyclable_ptr<VehiclePropValue> Create_bc_ac_envir_temp_vReq(int32_t bc_ac_envir_temp_v);
    recyclable_ptr<VehiclePropValue> Create_bc_ac_envir_tempReq(float bc_ac_envir_temp);
    recyclable_ptr<VehiclePropValue> Create_config_queryReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_vcu_chraging_mode_sp_reqReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_pp_fl_distReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_pp_fml_distReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_pp_fmr_distReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_pp_fr_distReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_pp_sdwfsl_distReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_pp_sdwfsl_mid_distReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_pp_sdwfsr_mid_distReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_pp_sensor_fault_sts_frmReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_pp_sensor_fault_sts_frReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_pp_sdwrsr_distReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_pp_staReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_pp_sw_fdbkReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_elk_set_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_aeb_set_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_aeb_and_fcw_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_hma_set_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_tsr_spd_lim_warnReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_tsr_spd_lim_warn_auReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_tsr_spd_lim_stsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_slwf_set_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_fcm_intializationReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_elk_left_modeReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_elk_right_modeReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_slif_set_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_trfc_signReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_tsr_lgt_dstReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_tsr_lat_dstReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_tsr_set_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_tsr_spd_limReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_slif_oper_stsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_audio_warn_hands_offReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_fault_text_infoReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_lka_audio_warningReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_act_drv_asst_sts_hmiReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_tar_obj_accReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_adas_not_avl_reasReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_acc_startReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_ica_truck_set_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_ica_set_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_adas_quit_reasReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_acc_mode_hmiReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_pcw_pre_warnReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_pcw_latent_warnReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_text_info_lka1Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_ldw_stsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_ldw_set_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_lka_stsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_le_line_color_fctReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_lka_set_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_ri_line_color_fctReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_ldw_alert_method_set_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_v_set_disReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_aeb_obj_idReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_raeb_work_stsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_ldw_audio_warnReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_laterallimitReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_obc_inlelt_actl_powerReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_srs_crash_output_stsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_insulation_wrning_distgshReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_thermalrunaway_wrnReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_dcs_actl_chrg_voltageReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_icu_vehicle_speed_displayed_vReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_icu_icu_trip_a_odometerReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_icu_icu_trip_b_odometerReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_cc_eps_basic_elec_steer_failedReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_cc_eps_mode_set_inhibit_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_cc_eps_sws_hod_hands_off_stsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_vcu_info_dispReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_vcu_vhcl_speed_fast_warnReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_vcu_drive_mode_key_stagnationReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_vcu_cc_key_stagnationReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_vcu_shift_key_stagnationReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_vcu_lock_veh_warmReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_vcu_sibs_kl30_voltageReq(float value);
    recyclable_ptr<VehiclePropValue> Create_bc_vcu_sibs_rtcwu_chg_numReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_vcu_sibs_chg_num_allowReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_vcu_sibs_rtcwu_chg_fail_numReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_vcu_sibs_rtc_chrg_stReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_vcu_sibs_wup_volt_allowReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_vcu_sibs_bms_bat_soc_allowReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_vcu_sibs_fb_rtc_wup_flgReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_vcu_ac_chrg_max_currReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_vcu_ac_chrg_modeReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_ccu_open_ventilation_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_ac_ac_unlock_vent_set_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_ac_remote_defrost_ctl_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_ac_temp_set_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_ac_remt_ctrl_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_ccu_remote_power_lock_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_vcu_speed_limit_level_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_vcu_operat_licence_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_vcu_version_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_vcu_vesion_set_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_vcu_wgh_confdenceReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_vcu_wgh_estReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_vcu_wgh_distbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_vcu_cruise_ctrl_sta_for_bacReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_vcu_cruise_ctr_tgt_spd_for_bacReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_ac_indoor_tempReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_light_sw_sigReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_ajar_sta_hoodReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_tmps_abnm_prsr_warnReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_tpms_reset_stsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_fr_windowmotor_flagsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_fl_windowmotor_flagsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_wash_liquid_level_warnReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_front_wash_stsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_pas_wdw_initReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_drv_pass_win_sw_sigReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_body_warn_stsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_key_in_car_staReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_ps_authent_resReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_trunk_lock_sw_ctrl_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_trunk_lock_staReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_overspd_cntrl_lock_set_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_park_auto_unlock_set_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_chg_wiper_mt_md_sw_set_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_drv_lf_ant_diag_statusReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_lf_init_staReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_door_lock_operation_recordReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_int_lf_ant_diag_statusReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_pass_lf_ant_diag_statusReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_illmnd_entry_sts_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_steer_whl_tempReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_steer_whl_heat_stsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_rear_mirror_heat_stsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_mai_drvr_seat_tempReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_mai_drvr_seat_stsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_logo_active_flagReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_rf_init_staReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_rear_fog_li_fault_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_front_fog_li_fault_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_pos_li_fault_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_back_li_fault_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_brake_li_fault_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_reverse_li_fault_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_day_run_li_fault_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ehb_epb_flt_stsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ehb_epb_switch_stsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ehb_failure_stsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_vhcl_actl_gear_pos_vReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bcm_sys_pwr_mode_vReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bcm_sys_pwr_modeReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bcm_sys_power_stsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bcm_door_lock_sta_flReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_pwr_recup_intensityReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ccu_diag_tester_onlineReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bcm_back_ladjval_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_rmi_active_staReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_slope_percent_vReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_slope_percentReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_inv_antithft_auth_rsltReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_ac_auto_blower_mode_staReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_fcw_set_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_ac_extd_defrost_actv_reqReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_scs_left_swt_vdReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_scs_left_1_swtReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_scs_left_2_swtReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_scs_left_3_swtReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_scs_left_4_swtReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_scs_left_5_swtReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_scs_left_6_swtReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_scs_left_7_swtReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_scs_left_8_swtReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_avas_state_rolling_counterReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_current_over_wrningReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_battery_sub_sys_numReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_battery_sub_sys_codReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_battery_dtc_numReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_battery_dtc_listReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_battery_dtc_indexReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_inv_1_rolling_counterReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_inv_4_err_bitsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_inv_4_rolling_counterReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_scs_right_swt_vdReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_scs_right_14_swtReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_scs_right_15_swtReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_scs_right_16_swtReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_crrr_bsd_warn_rightReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_crrr_bsd_warn_leftReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_crrr_bsd_set_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_crrr_rcta_warn_rightReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_crrr_rcta_warn_leftReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_crrr_rcta_set_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_crrr_rcw_warningReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_crrr_rcw_set_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_crrr_rear_corner_failureReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_crrr_rear_corner_blindnessReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_crrr_dow_set_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_crrr_dow_warn_frReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_crrr_dow_warn_flReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_crrr_dow_warn_rrReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_crrr_dow_warn_rlReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_crrr_dow_warn_rightReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_crrr_dow_warn_leftReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_typ1Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_lat_dst1Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_lgt_dst1Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_lgt_rel_spd1Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_posn_agl1Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_lgt_rel_spd7Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_movmt_dir1Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_lgt_rel_spd8Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_movmt_sta1Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_typ2Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_lat_dst2Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_lgt_dst2Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_posn_agl2Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_lgt_rel_spd2Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_lgt_rel_spd9Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_movmt_dir2Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_movmt_sta2Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_typ3Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_lat_dst3Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_lgt_dst3Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_posn_agl3Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_lgt_rel_spd3Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_movmt_dir3Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_movmt_sta3Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_typ4Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_lat_dst4Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_lgt_dst4Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_posn_agl4Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_lgt_rel_spd4Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_movmt_sta4Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_movmt_dir4Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_movmt_dir7Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_typ5Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_lat_dst5Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_lgt_dst5Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_posn_agl5Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_lgt_rel_spd5Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_movmt_dir5Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_movmt_sta5Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_movmt_sta9Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_typ6Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_lat_dst6Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_lgt_dst6Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_posn_agl6Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_lgt_rel_spd6Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_movmt_dir9Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_movmt_sta6Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_movmt_dir6Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_typ7Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_lat_dst7Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_lgt_dst7Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_posn_agl7Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_movmt_sta7Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_lat_dst8Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_lgt_dst8Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_typ8Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_typ9Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_movmt_sta8Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_posn_agl8Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_lat_dst9Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_lgt_dst9Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_posn_agl9Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_movmt_dir8Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_typ10Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_lat_dst10Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_lgt_dst10Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_posn_agl10Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_movmt_sta10Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_lat_dst11Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_lgt_dst11Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_typ11Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_posn_agl11Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_movmt_sta11Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_lat_dst12Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_lgt_dst12Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_typ12Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_movmt_dir11Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_posn_agl12Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_typ13Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_lat_dst13Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_lgt_dst13Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_movmt_sta13Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_posn_agl13Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_lat_dst14Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_lgt_dst14Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_typ14Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_movmt_sta14Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_posn_agl14Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_lat_dst15Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_lgt_dst15Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_typ15Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_movmt_dir14Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_posn_agl15Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_typ16Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_lat_dst16Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_lgt_dst16Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_lat_dst17Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_lgt_dst17Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_movmt_sta16Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_movmt_dir16Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_typ17Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_typ18Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_movmt_sta17Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_lat_dst18Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_lgt_dst18Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_posn_agl18Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_movmt_dir17Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_movmt_dir18Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_movmt_sta18Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_lgt_rel_spd10Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_posn_agl16Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_lgt_rel_spd11Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_posn_agl17Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_lgt_rel_spd12Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_lgt_rel_spd13Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_movmt_dir10Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_lgt_rel_spd14Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_movmt_sta12Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_lgt_rel_spd15Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_movmt_dir12Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_lgt_rel_spd16Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_movmt_dir13Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_movmt_sta15Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_lgt_rel_spd17Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_lgt_rel_spd18Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_obj_movmt_dir15Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_nr_of_lineReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_le_line_typReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_le_line_rdReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_le_line_dstReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_le_line_c1Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_le_line_c2Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_ri_line_typReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_le_line_c3Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_ri_line_rdReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_ri_line_dstReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_ri_line_c1Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_ri_line_c3Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_ri_line_c2Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_le_le_line_typReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_le_le_line_c1Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_le_le_line_c3Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_le_le_line_rdReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_le_le_line_dstReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_ri_ri_line_c1Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_ri_ri_line_c3Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_ri_ri_line_rdReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_ri_ri_line_dstReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_ri_ri_line_typReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_le_le_line_c2Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_ri_ri_line_c2Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_spd_downin_cor_sfkReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_vcu_speed_limit_level_set_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_abs_active_staReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_dcc_actl_oprt_modeReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_over_temperature_failReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_accl_pedal_posReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_brk_pedal_posReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_iso_resistanceReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ehb_brk_pedl_valReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ehb_brk_pedl_val_vldReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ehb_brk_pedl_val_percReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ehb_brk_pedl_val_perc_vldReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_mc_travel_average_speedReq(float value);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_dcc_sys_fail_staReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_chrg_target_socReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bcm_brake_pedal_staReq(int32_t value);

    recyclable_ptr<VehiclePropValue> Create_fcm_adas_drvr_req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_fcm_elk_sts(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_fcm_slifs_spd_lim(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_fcm_aeb_status(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_fcm_aeb_statsadsus(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_hu_dowenaswt(int32_t value);

    recyclable_ptr<VehiclePropValue> Create_sc_fcm_acc_take_over_reqWatcher(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_fcm_tjatakeoverreqWatcher(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_aeb_recreqWatcher(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_hu_hma_enable_swWatcher(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_hu_ica_enable_sw_tWatcher(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_hu_ica_avd_truck_setWatcher(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_hu_ldw_alert_method_swWatcher(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_hu_lka_enable_swWatcher(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_hu_elk_enb_swWatcher(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_hu_fcw_enable_swWatcher(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_hu_abe_enable_swWatcher(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_hu_bsd_enable_swWatcher(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_hu_rcw_enable_swWatcher(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_hu_rcta_enable_swWatcher(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_hu_slif_enableswWatcher(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_hu_slwf_enableswWatcher(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_hu_navi_country_codeWatcher(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_avalueble_key_in_carReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_sys_fail_staReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ccu_remt_steer_whl_heat_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ccu_remt_power_ctrl_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ccu_remt_mai_dr_seat_heat_fbReq(int32_t value);

    recyclable_ptr<VehiclePropValue> Create_bc_pp_sensor_fault_sts_rlReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_pp_sensor_fault_sts_rlmReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_pp_sensor_fault_sts_rrmReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_pp_sensor_fault_sts_rrReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_pp_rl_distReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_pp_rlm_distReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_pp_rrm_distReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_pp_rr_distReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_pp_sdwfsr_distReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_pp_sdwrsl_distReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_pp_sdwrsl_mid_distReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_pp_sdwrsr_mid_distReq(int32_t value);

    recyclable_ptr<VehiclePropValue> Create_bc_fm_auto_seek_resWatcherReq(std::vector<int16_t> value);
    recyclable_ptr<VehiclePropValue> Create_fm_searchWatcherReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_fm_volumeWatcherReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_err_amountReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_err_bitReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_carriage_light_staReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_eps_steer_wheel_angleReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_eps_steer_wheel_angle_validReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_eps_rot_speedReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_eps_steer_wheel_angle_failureReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_eps_electric_power_staReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_eps_steer_wheel_angle_calibratedReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_eps_mot_tqReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_lgt_fct_actv_flgReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_eps_set_steer_whl_aglReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_steer_tq_req_activeReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_eps_ctrl_reqReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_drvr_warn_vib_reqReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_daeps_mode_reqReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_act_drv_asst_stsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_overtake_ass_sys_stsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_turn_lamp_reqReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_tjaica_supps_abortnReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_lka_torq_fact_reqReq(float value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_hma_supps_abortnReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_lkaldw_supps_abortnReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_flt_stsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_elk_supps_abortnReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_acc_whl_tq_req_valReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_acc_whl_tq_req_actvReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_acc_whl_deceReq(float value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_acc_tar_accrnReq(float value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_acc_supp_abortReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_acc_tar_accrn_req_actvReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_epb_req_vReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_epb_reqReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_acc_shutdown_modeReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_ahd_obj_idReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_acc_tgt_axReq(float value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_aeb_tgt_axReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_acc_modeReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_acc_req_standstillReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_aeb_reqReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_aeb_standstill_stsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_aeb_standstill_sts_vReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_aba_levelReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_awb_levelReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_aba_reqReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_eba_reqReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_awb_reqReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_abp_reqReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_acc_tgt_ax_reqReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_crv_decel_staReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_acc_req_drive_offReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_mc_scs_frnt_wipr_swt_stReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_mc_scs_low_beam_swt_stReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_mc_scs_hi_beam_swt_stReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_mc_scs_over_veh_beam_swt_stReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_mc_scs_lamp_auto_stReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_mc_scs_le_turn_lmp_swt_stReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_mc_scs_ri_turn_lmp_swt_stReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_hv_bat_cell_temp_aveReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_dcs_actl_chrg_currentReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_scs_gear_shift_lever_pst_reqReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_ac_chrg_atcl_staReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_outlet_coolant_actl_tempReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_outlet_coolant_actl_temp_validReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_inlet_coolant_actl_tempReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_inlet_coolant_actl_temp_validReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_max_chrg_voltage_acReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_max_chrg_current_acReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_bat_sohReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_temp_max_dc_charge_socketReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_pcb_temp_maxReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_max_allow_chrg_cur_dcReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_max_allow_chrg_vol_dcReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_electronic_lock_ctrlReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_electronic_lock_stateReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_contactor_state_dc_chargerReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_dcs_charge_requestReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_dcs_chrg_a_plusReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_run_stateReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_contactor_state_negativeReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_contactor_state_positiveReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_contactor_state_prechargeReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_supply_voltage_statusReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_emeshutdown_reqReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_charge_interlock_staReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_dis_charge_interlock_staReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_batt_balance_staReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_therm_runaway_snsr_fltReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_therm_runaway_vlv_stReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_obc_uac_act_l1Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_obc_uac_act_l2Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_obc_uac_act_l3Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_obc_iac_act_l1Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_obc_iac_act_l2Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_obc_iac_act_l3Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_device_int_tempReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_obc_temp_inletReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_obc_ac_max_pw_allowReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_obc_inlet_electronic_lockReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_obc_s2_stateReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_obc_wake_up_modeReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_obc_voltage_ok_l1Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_obc_voltage_ok_l2Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_obc_voltage_ok_l3Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_dcc_high_volt_actl_curReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_dcc_high_volt_actl_volReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_obc_hvdc_actl_curReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_obc_connect_main_staReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_obc_requestReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_obc_sys_fail_staReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_obc_hvdc_actl_volReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_obc_errbitReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_dcc_low_vol_actl_volReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_dcc_low_vol_actl_curReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_dcc_precharge_completeReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_dcc_derating_oprt_staReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_hvil_fail_staReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_dcc_errbitReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_obc_c_cor_cp_cnctd_stsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_obc_cp_dutyReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_obc_cp_max_voltReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_obc_process_codeReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ipu_obc_cc_resisdentReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_eps_torsion_bar_torqueReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_eps_torsion_bar_torque_dirReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_eps_torsion_bar_torque_validReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_eps_elect_power_consumptionReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_eps_advanced_mode_statusReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_eps_lat_drv_lvl12_srv_avlReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_eps_lat_mc_hptc_wrn_srv_avlReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_eps_pscm_int_rpc_max_trqReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_eps_torsion_bar_torque_qfReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_eps_pscm_int_rpc_min_trqReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_eps_lat_mc_steer_tq_activeReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_eps_lat_mc_hptc_wrn_activeReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_eps_max_allwd_rot_spdReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_eps_lks_agl_sys_stsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_eps_max_allwd_aglReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_eps_steer_tqReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_eps_lks_abort_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_eps_lks_agl_ctrl_avl_stsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_req_brake_light_onReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_ebd_active_staReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_ess_activeReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_cdp_activeReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_brake_temp_over_heatReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_dtc_active_stsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_vhcl_standstill_staReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_dtc_request_rbs_stsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_dtc_failure_stsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_wheel_speed_kph_v_flReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_wheel_direction_flReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_wheel_speed_kph_flReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_wheel_speed_kph_v_frReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_wheel_direction_frReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_wheel_speed_kph_frReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_master_cylinder_presrReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_master_cylinder_presr_vReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_wheel_speed_kph_v_rlReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_wheel_direction_rlReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_wheel_speed_kph_rlReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_wheel_speed_kph_v_rrReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_wheel_direction_rrReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_wheel_speed_kph_rrReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_wheel_speed_rc_sts_flReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_wheel_speed_rc_sts_frReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_wheel_speed_rc_sts_rlReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_wheel_speed_rc_sts_rrReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_wheel_speed_rc_flReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_wheel_speed_rc_frReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_wheel_speed_rc_rlReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_wheel_speed_rc_rrReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_long_acc_sensor_valueReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_long_acc_sensor_value_vldReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_lat_acc_sensor_value_vldReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_lat_acc_sensor_valueReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_yaw_rateReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_yaw_rate_vldReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_epb_right_currentReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_epb_right_fault_stateReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_hbb_hbc_availableReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_epb_actuator_st_rReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_hbb_hbc_activeReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_whl_tq_dec_req_actvReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_whl_tq_dec_req_valReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_whl_tq_inc_req_actvReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_esc_whl_tq_inc_req_valReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ehb_cdp_requestReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ehb_epb_actuator_st_rReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ehb_epb_actuator_st_lReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ehb_hhc_active_staReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ehb_rgn_brk_stReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ehb_ext_req_statusReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ehb_blaReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ehb_hmi_warning_onReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ehb_epb_dynamic_apply_staReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ehb_pedl_trvl_snsr_fail_pdfReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ehb_req_brk_li_onReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ehb_pedl_trvl_snsr_fail_pdtReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ehb_p_runout_pressureReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ehb_brake_pedal_appliedReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ehb_brake_pedal_applied_qReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ehb_cdd_temp_offReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ehb_s_output_rod_hydraulic_targetReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ehb_s_output_rod_driver_percReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ehb_aba_active_staReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ehb_aba_available_staReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ehb_awb_active_staReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ehb_awb_available_staReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ehb_aeb_active_staReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ehb_aeb_available_staReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ehb_abp_active_staReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ehb_abp_available_staReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_pp_raeb_set_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_pp_raeb_work_stsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_pp_raeb_brkg_reqReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_pp_raeb_brkg_req_valReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_pp_raeb_distance_to_collisionReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_crrr_rctb_decelarationReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_crrr_rctb_reqReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_crrr_rctb_brkg_vldReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_crrr_fov_chg_set_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_max_con_dis_curntReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_pwr_recup_max_con_chrg_curntReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_max_instan_dis_curntReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_pwr_recup_max_instan_chrg_curntReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_cell_vol_aveReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_contactor_temp_negativeReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_max_cell_temp_limitReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_max_cell_vol_limitReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_pwr_limd_flgReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_min_cell_temp_limitReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_min_cell_vol_limitReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_err_tab_indexReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_battery_typeReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_hw_versionReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_pack_identityReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_sw_versionReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_nom_cell_capReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_bat_capacityReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bem_spn2560_aaReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bem_spn2560_00Req(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bem_spn3904_croReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bem_spn3903_cml_ctsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bem_spn3906_cstReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bem_spn3905_ccsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bem_spn3907_csdReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_cem_bms_identify_timoutReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_cem_bms_finish_charge_timeoutReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_cem_battery_parameter_timoutReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_cem_bms_abort_charge_timeoutReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_cem_battery_charge_require_timeoutReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_cem_battery_state_timeoutReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_cem_bms_charge_statistics_timeoutReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bst_abort_achive_dcsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bst_abort_achive_single_voltReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bst_abort_achive_total_voltReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bst_abort_achive_socReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bst_abort_fault_connectorReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bst_abort_fault_bms_tempReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bst_abort_fault_connector_tempReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bst_abort_fault_insulationReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bst_abort_fault_otherReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bst_abort_fault_voltageReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bst_abort_fault_hvReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bst_abort_fault_battery_tempReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bst_abort_error_voltageReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bst_abort_error_currentReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_cst_abort_by_bmsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_cst_abort_by_faultReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_cst_abort_by_userReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_cst_abort_achive_conditionReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_cst_abort_fault_energe_transmitReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_cst_abort_fault_charger_inner_tempReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_cst_abort_fault_connetorReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_cst_abort_fault_charger_tempReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_cst_abort_fault_otherReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_cst_abort_fault_charger_stopReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_cst_abort_error_voltageReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_cst_abort_error_currentReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bcm_rear_view_mirr_heating_stsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_tms_ohx_out_tmpReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_tms_evap_tmpReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_tms_evap_out_tmpReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_tms_chiller_out_tmpReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bcm_high_beam_li_fault_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bcm_low_beam_li_fault_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bcm_vhcl_seekReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bcm_illmnd_stsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bcm_key_frbdnReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bcm_frbdn_key_nrReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bcm_start_reqReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bcm_drv_pe_authent_acsdReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bcm_frpe_authent_acsdReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bcm_ps_reqReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bcm_frnt_le_door_hndl_swtReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bcm_frnt_ri_door_hndl_swtReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bcm_save_power_staReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bcm_front_wiper_motor_stsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bcm_fl_window_stsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bcm_fr_window_stsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bcm_fl_windowmotor_stsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bcm_fr_windowmotor_stsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bcm_wiper_ctrl_frontReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bcm_drv_seat_occupant_sensor_stsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bcm_heavy_rain_indReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_tpms_pressure_value_rrReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_tpms_pressure_value_rlReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_tpms_pressure_sta_rlReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_tpms_pressure_sta_rrReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_tpms_pressure_value_frReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_tpms_pressure_value_flReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_tpms_pressure_sta_flReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_tpms_pressure_sta_frReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bcm_dome_light_staReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bcm_back_lamp_staReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bcm_bass_horn_reqReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bcm_ajar_sta_v_hoodReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bcm_frnt_fog_li_sw_sigReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bcm_rear_fog_li_sw_sigReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bcm_day_run_light_staReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bcm_reverse_lamp_staReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bcm_brake_lamp_staReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bcm_turn_li_stsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_act_whl_tqReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_act_whl_tq_vldReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_drv_req_whl_tqReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_drv_whl_tq_allwd_maxReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_pwr_recup_max_avlb_whl_tq_stsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_pwr_recup_actl_whl_tq_stsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_brk_pwr_recup_max_avlb_whl_tqReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_pwr_recup_act_whl_tqReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_brk_pwr_recup_act_whl_tqReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_brk_pwr_recup_actl_whl_tq_stsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_acc_req_drive_offReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_actl_motor_rotate_spdReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_actl_motor_rotate_spd_vReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_remt_ac_ctrl_stReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_remt_ac_defrostl_reqReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_remt_ac_ctrl_reqReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_charging_conditions_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_accl_pedal_pos_snsr_staReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_req_epbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_acc_trq_ctrl_avlReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_acc_standstill_reqReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_acc_tgt_axReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_acc_tgt_ax_reqReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_drv_req_torq_override_fcmReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_cruise_ctr_tgt_spdReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_cruise_ctrl_staReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_scs_right_11_swtReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_scs_right_12_swtReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_scs_right_13_swtReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_scs_gear_shift_lever_pst_req_vdReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_dcs_actl_chrg_powerReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_ccu_keep_awake_staReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_bra_tor_reqReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_pp_sensor_fault_sts_flmReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_pp_sensor_fault_sts_flReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bcm_authent_key_nrReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bcm_key_staReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bcm_wiper_stop_pos_staReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_vcu_drv_req_whl_tq_vldReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bms_insulation_wrningReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_tau_gap_setReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_gecko_e2p_rom_resultReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_gecko_key_code_resultReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_fcm_hma_highbeam_reqReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_ec_bcm_hazard_lamp_stsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_rke_reqReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_fcm_hma_stsReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_le_turn_li_fault_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_bcm_ri_turn_li_fault_fbReq(int32_t value);
    recyclable_ptr<VehiclePropValue> Create_bc_ac_ac_sta_fbReq(int32_t value);
    VehiclePropValuePool* const mValueObjectPool;
    PropertyManager* const mPropertyManager;
    EmulatedVehicleHalIface* const mHal;

    // TODO(chenhaosjtuacm): use std::filesystem when toolchain >= gcc8 is available
    const std::string mPowerStateMarkerPath;

    std::atomic<bool> mSystemShuttingDownPrepareFlag{false};
    std::atomic<bool> mShuttingDownFlag{false};
    std::atomic<steady_clock::time_point> mLastHeartbeatTime{};
    std::vector<std::thread> mThreads;
    std::condition_variable mHeartbeatCV;
    std::mutex mHeartbeatMutex;
//    const std::string mSpeedFilePath = "./speed.txt";  // 

};

/*
1BATOFF;
2 SLEEP;
3 STANDBY;
4 ACTIVE;
5 STRSOCRAM;
*/
#define SYSFS_PATH "/sys/kernel/need_power_key_lock_debug"  // sysfs 
#define SYSFS_PATH1 "/sys/kernel/power_key_lock_debug"  // sysfs 
int clr_power_key_status(){

    int fd;
    char buf[2];  // 10

    //  sysfs 
    fd = open(SYSFS_PATH, O_WRONLY);
    if (fd < 0) {
        perror("Failed to open sysfs file");
        return -1;
    }

    //  sysfs 
    snprintf(buf, sizeof(buf), "%d", 0);

    if (write(fd, buf, sizeof(buf)) < 0) {
        perror("Failed to write to sysfs file");
        close(fd);
        return -1;
    }

    // 
    close(fd);
    //  sysfs 
    fd = open(SYSFS_PATH1, O_WRONLY);
    if (fd < 0) {
        perror("Failed to open sysfs file");
        return -1;
    }

    //  sysfs 
    snprintf(buf, sizeof(buf), "%d", 0);

    if (write(fd, buf, sizeof(buf)) < 0) {
        perror("Failed to write to sysfs file");
        close(fd);
        return -1;
    }

    // 
    close(fd);

    return 0;
}
int set_power_key_lock(int value)
{
    int fd;
    char buf[2];  // 10

    //  sysfs 
    fd = open(SYSFS_PATH, O_WRONLY);
    if (fd < 0) {
        perror("Failed to open sysfs file");
        return -1;
    }

    //  sysfs 
    snprintf(buf, sizeof(buf), "%d", value);

    if (write(fd, buf, sizeof(buf)) < 0) {
        perror("Failed to write to sysfs file");
        close(fd);
        return -1;
    }

    // 
    close(fd);
    //  sysfs 
    fd = open(SYSFS_PATH1, O_WRONLY);
    if (fd < 0) {
        perror("Failed to open sysfs file");
        return -1;
    }

    //  sysfs 
    snprintf(buf, sizeof(buf), "%d", 0);

    if (write(fd, buf, sizeof(buf)) < 0) {
        perror("Failed to write to sysfs file");
        close(fd);
        return -1;
    }

    // 
    close(fd);

    return 0;
}
int get_need_power_key_lock(int *value)
{
    int fd;
    char buf[2];  // 10
    //  sysfs 
    fd = open(SYSFS_PATH, O_RDONLY);
    if (fd < 0) {
        perror("Failed to open sysfs file");
        return -1;
    }
    //  sysfs 
    if (read(fd, buf, sizeof(buf)) < 0) {
        perror("Failed to read from sysfs file");
        close(fd);
        return -1;
    }
    // 
    *value = atoi(buf);
    // 
    close(fd);
    return 0;
}
int get_power_key_lock(int *value)
{
    int fd;
    char buf[2];  // 10
    //  sysfs 
    fd = open(SYSFS_PATH1, O_RDONLY);
    if (fd < 0) {
        perror("Failed to open sysfs file");
        return -1;
    }
    //  sysfs 
    if (read(fd, buf, sizeof(buf)) < 0) {
        perror("Failed to read from sysfs file");
        close(fd);
        return -1;
    }
    // 
    *value = atoi(buf);
    // 
    close(fd);
    return 0;
}

void GarageModeServerSideHandlerImpl::HandleHeartbeat() {
    LOG(DEBUG) << __func__ << ": received heartbeat from the client";
    mLastHeartbeatTime.store(steady_clock::now());
}

void GarageModeServerSideHandlerImpl::HeartbeatTimeoutWatcher() {
    constexpr auto kHeartbeatTimeout = duration_cast<steady_clock::duration>(5s);
    constexpr auto kHeartbeatCheckPeriod = 1s;
    while (!mShuttingDownFlag.load()) {
        if (!mSystemShuttingDownPrepareFlag.load()) {
            std::unique_lock<std::mutex> heartbeatLock(mHeartbeatMutex);
            mHeartbeatCV.wait(heartbeatLock, [this]() {
                return mSystemShuttingDownPrepareFlag.load() || mShuttingDownFlag.load();
            });

            // Reset mLastHeartbeatTime everytime after entering shutdown state
            HandleHeartbeat();
        }
        auto timeSinceLastHeartbeat = steady_clock::now() - mLastHeartbeatTime.load();
        if (timeSinceLastHeartbeat > kHeartbeatTimeout) {
            LOG(ERROR) << __func__ << ": heartbeat timeout!";
            // TODO(chenhaosjtuacm): Shutdown AGL
            break;
        }
        std::this_thread::sleep_for(kHeartbeatCheckPeriod);
    }
}
/*
60
*/
void GarageModeServerSideHandlerImpl::can071_Watcher() {
    
  ConfigDBC* mp0 = mPropertyManager->findCProperty("ec_vcu_act_whl_tq_vld");
  ConfigDBC* mp1 = mPropertyManager->findCProperty("ec_vcu_act_whl_tq");
  ConfigDBC* mp2 = mPropertyManager->findCProperty("ec_vcu_drv_req_whl_tq_vld");
  ConfigDBC* mp3 = mPropertyManager->findCProperty("ec_vcu_drv_req_whl_tq");
  ConfigDBC* mp4 = mPropertyManager->findCProperty("ec_vcu_drv_whl_tq_allwd_max");
  ConfigDBC* mp5 = mPropertyManager->findCProperty("ec_vcu_pwr_recup_actl_whl_tq_sts");
  ConfigDBC* mp6 = mPropertyManager->findCProperty("ec_vcu_pwr_recup_max_avlb_whl_tq_sts");
  ConfigDBC* mp7 = mPropertyManager->findCProperty("ec_vcu_brk_pwr_recup_max_avlb_whl_tq");
  ConfigDBC* mp8 = mPropertyManager->findCProperty("ec_vcu_pwr_recup_act_whl_tq");
  ConfigDBC* mp9 = mPropertyManager->findCProperty("ec_vcu_acc_req_drive_off");
  ConfigDBC* mp10 = mPropertyManager->findCProperty("ec_vcu_brk_pwr_recup_actl_whl_tq_sts");
  ConfigDBC* mp11 = mPropertyManager->findCProperty("ec_vcu_brk_pwr_recup_act_whl_tq");
  int32_t ec_vcu_act_whl_tq_vld = 0;
  int32_t ec_vcu_act_whl_tq = 0;
  int32_t ec_vcu_drv_req_whl_tq_vld = 0;
  int32_t ec_vcu_drv_req_whl_tq = 0;
  int32_t ec_vcu_drv_whl_tq_allwd_max = 0;
  int32_t ec_vcu_pwr_recup_actl_whl_tq_sts = 0;
  int32_t ec_vcu_pwr_recup_max_avlb_whl_tq_sts = 0;
  int32_t ec_vcu_brk_pwr_recup_max_avlb_whl_tq = 0;
  int32_t ec_vcu_pwr_recup_act_whl_tq = 0;
  int32_t ec_vcu_acc_req_drive_off = 0;
  int32_t ec_vcu_brk_pwr_recup_actl_whl_tq_sts = 0;
  int32_t ec_vcu_brk_pwr_recup_act_whl_tq = 0;
  while(!mShuttingDownFlag.load()){
    //
    mPropertyManager->getCan071State();
    if (mPropertyManager->getCProValue(mp0,&ec_vcu_act_whl_tq_vld)){
      mHal->onPropertyValue(*Create_ec_vcu_act_whl_tq_vldReq(ec_vcu_act_whl_tq_vld),true);
    }

    if (mPropertyManager->getCProValue(mp1, &ec_vcu_act_whl_tq)) {
      mHal->onPropertyValue(*Create_ec_vcu_act_whl_tqReq(ec_vcu_act_whl_tq), true);
    }
    
    if (mPropertyManager->getCProValue(mp2, &ec_vcu_drv_req_whl_tq_vld)) {
      mHal->onPropertyValue(*Create_ec_vcu_drv_req_whl_tq_vldReq(ec_vcu_drv_req_whl_tq_vld), true);
    }
    
    if (mPropertyManager->getCProValue(mp3, &ec_vcu_drv_req_whl_tq)) {
      mHal->onPropertyValue(*Create_ec_vcu_drv_req_whl_tqReq(ec_vcu_drv_req_whl_tq), true);
    }
    
    if (mPropertyManager->getCProValue(mp4, &ec_vcu_drv_whl_tq_allwd_max)) {
      mHal->onPropertyValue(*Create_ec_vcu_drv_whl_tq_allwd_maxReq(ec_vcu_drv_whl_tq_allwd_max), true);
    }
    if (mPropertyManager->getCProValue(mp5, &ec_vcu_pwr_recup_actl_whl_tq_sts)) {
      mHal->onPropertyValue(*Create_ec_vcu_pwr_recup_actl_whl_tq_stsReq(ec_vcu_pwr_recup_actl_whl_tq_sts), true);
    }
    
    if (mPropertyManager->getCProValue(mp6, &ec_vcu_pwr_recup_max_avlb_whl_tq_sts)) {
      mHal->onPropertyValue(*Create_ec_vcu_pwr_recup_max_avlb_whl_tq_stsReq(ec_vcu_pwr_recup_max_avlb_whl_tq_sts), true);
    }
    
    if (mPropertyManager->getCProValue(mp7, &ec_vcu_brk_pwr_recup_max_avlb_whl_tq)) {
      mHal->onPropertyValue(*Create_ec_vcu_brk_pwr_recup_max_avlb_whl_tqReq(ec_vcu_brk_pwr_recup_max_avlb_whl_tq), true);
    }
    
    if (mPropertyManager->getCProValue(mp8, &ec_vcu_pwr_recup_act_whl_tq)) {
      mHal->onPropertyValue(*Create_ec_vcu_pwr_recup_act_whl_tqReq(ec_vcu_pwr_recup_act_whl_tq), true);
    }
    
    if (mPropertyManager->getCProValue(mp9, &ec_vcu_acc_req_drive_off)) {
      mHal->onPropertyValue(*Create_ec_vcu_acc_req_drive_offReq(ec_vcu_acc_req_drive_off), true);
    }
    
    if (mPropertyManager->getCProValue(mp10, &ec_vcu_brk_pwr_recup_actl_whl_tq_sts)) {
      mHal->onPropertyValue(*Create_ec_vcu_brk_pwr_recup_actl_whl_tq_stsReq(ec_vcu_brk_pwr_recup_actl_whl_tq_sts), true);
    }
    
    if (mPropertyManager->getCProValue(mp11, &ec_vcu_brk_pwr_recup_act_whl_tq)) {
      mHal->onPropertyValue(*Create_ec_vcu_brk_pwr_recup_act_whl_tqReq(ec_vcu_brk_pwr_recup_act_whl_tq), true);
    }
  }
}

void GarageModeServerSideHandlerImpl::can30A_Watcher() {
    ConfigDBC* mp0 = mPropertyManager->findCProperty("ec_bem_spn2560_aa");
    ConfigDBC* mp1 = mPropertyManager->findCProperty("ec_bem_spn2560_00");
    ConfigDBC* mp2 = mPropertyManager->findCProperty("ec_bem_spn3904_cro");
    ConfigDBC* mp3 = mPropertyManager->findCProperty("ec_bem_spn3903_cml_cts");
    ConfigDBC* mp4 = mPropertyManager->findCProperty("ec_bem_spn3906_cst");
    ConfigDBC* mp5 = mPropertyManager->findCProperty("ec_bem_spn3905_ccs");
    ConfigDBC* mp6 = mPropertyManager->findCProperty("ec_bem_spn3907_csd");
    int32_t ec_bem_spn2560_aa = 0;
    int32_t ec_bem_spn2560_00 = 0;
    int32_t ec_bem_spn3904_cro = 0;
    int32_t ec_bem_spn3903_cml_cts = 0;
    int32_t ec_bem_spn3906_cst = 0;
    int32_t ec_bem_spn3905_ccs = 0;
    int32_t ec_bem_spn3907_csd = 0;
    while(!mShuttingDownFlag.load()){
      //
      mPropertyManager->getCan30AState();
      if (mPropertyManager->getCProValue(mp0, &ec_bem_spn2560_aa)){
        mHal->onPropertyValue(*Create_ec_bem_spn2560_aaReq(ec_bem_spn2560_aa),true);
      }

      if (mPropertyManager->getCProValue(mp1, &ec_bem_spn2560_00)){
        mHal->onPropertyValue(*Create_ec_bem_spn2560_00Req(ec_bem_spn2560_00),true);
      }

      if (mPropertyManager->getCProValue(mp2, &ec_bem_spn3904_cro)){
        mHal->onPropertyValue(*Create_ec_bem_spn3904_croReq(ec_bem_spn3904_cro),true);
      }

      if (mPropertyManager->getCProValue(mp3, &ec_bem_spn3903_cml_cts)){
        mHal->onPropertyValue(*Create_ec_bem_spn3903_cml_ctsReq(ec_bem_spn3903_cml_cts),true);
      }

      if (mPropertyManager->getCProValue(mp4, &ec_bem_spn3906_cst)){
        mHal->onPropertyValue(*Create_ec_bem_spn3906_cstReq(ec_bem_spn3906_cst),true);
      }

      if (mPropertyManager->getCProValue(mp5, &ec_bem_spn3905_ccs)){
        mHal->onPropertyValue(*Create_ec_bem_spn3905_ccsReq(ec_bem_spn3905_ccs),true);
      }

      if (mPropertyManager->getCProValue(mp6, &ec_bem_spn3907_csd)){
        mHal->onPropertyValue(*Create_ec_bem_spn3907_csdReq(ec_bem_spn3907_csd),true);
      }
    }
}

void GarageModeServerSideHandlerImpl::can30B_Watcher() {
  ConfigDBC* mp0 = mPropertyManager->findCProperty("ec_cem_bms_identify_timout");
  ConfigDBC* mp1 = mPropertyManager->findCProperty("ec_cem_bms_finish_charge_timeout");
  ConfigDBC* mp2 = mPropertyManager->findCProperty("ec_cem_battery_parameter_timout");
  ConfigDBC* mp3 = mPropertyManager->findCProperty("ec_cem_bms_abort_charge_timeout");
  ConfigDBC* mp4 = mPropertyManager->findCProperty("ec_cem_battery_charge_require_timeout");
  ConfigDBC* mp5 = mPropertyManager->findCProperty("ec_cem_battery_state_timeout");
  ConfigDBC* mp6 = mPropertyManager->findCProperty("ec_cem_bms_charge_statistics_timeout");

  int32_t ec_cem_bms_identify_timout = 0;
  int32_t ec_cem_bms_finish_charge_timeout = 0;
  int32_t ec_cem_battery_parameter_timout = 0;
  int32_t ec_cem_bms_abort_charge_timeout = 0;
  int32_t ec_cem_battery_charge_require_timeout = 0;
  int32_t ec_cem_battery_state_timeout = 0;
  int32_t ec_cem_bms_charge_statistics_timeout = 0;

  while(!mShuttingDownFlag.load()){
    //
    mPropertyManager->getCan30BState();
    if (mPropertyManager->getCProValue(mp0,&ec_cem_bms_identify_timout)){
      mHal->onPropertyValue(*Create_ec_cem_bms_identify_timoutReq(ec_cem_bms_identify_timout),true);
    }

    if (mPropertyManager->getCProValue(mp1,&ec_cem_bms_finish_charge_timeout)){
      mHal->onPropertyValue(*Create_ec_cem_bms_finish_charge_timeoutReq(ec_cem_bms_finish_charge_timeout),true);
    }

    if (mPropertyManager->getCProValue(mp2,&ec_cem_battery_parameter_timout)){
      mHal->onPropertyValue(*Create_ec_cem_battery_parameter_timoutReq(ec_cem_battery_parameter_timout),true);
    }

    if (mPropertyManager->getCProValue(mp3,&ec_cem_bms_abort_charge_timeout)){
      mHal->onPropertyValue(*Create_ec_cem_bms_abort_charge_timeoutReq(ec_cem_bms_abort_charge_timeout),true);
    }

    if (mPropertyManager->getCProValue(mp4,&ec_cem_battery_charge_require_timeout)){
      mHal->onPropertyValue(*Create_ec_cem_battery_charge_require_timeoutReq(ec_cem_battery_charge_require_timeout),true);
    }

    if (mPropertyManager->getCProValue(mp5,&ec_cem_battery_state_timeout)){
      mHal->onPropertyValue(*Create_ec_cem_battery_state_timeoutReq(ec_cem_battery_state_timeout),true);
    }

    if (mPropertyManager->getCProValue(mp6,&ec_cem_bms_charge_statistics_timeout)){
      mHal->onPropertyValue(*Create_ec_cem_bms_charge_statistics_timeoutReq(ec_cem_bms_charge_statistics_timeout),true);
    }
  }
}

void GarageModeServerSideHandlerImpl::can30C_Watcher() {
  ConfigDBC* mp0 = mPropertyManager->findCProperty("ec_bst_abort_achive_dcs");
  ConfigDBC* mp1 = mPropertyManager->findCProperty("ec_bst_abort_achive_single_volt");
  ConfigDBC* mp2 = mPropertyManager->findCProperty("ec_bst_abort_achive_total_volt");
  ConfigDBC* mp3 = mPropertyManager->findCProperty("ec_bst_abort_achive_soc");
  ConfigDBC* mp4 = mPropertyManager->findCProperty("ec_bst_abort_fault_connector");
  ConfigDBC* mp5 = mPropertyManager->findCProperty("ec_bst_abort_fault_bms_temp");
  ConfigDBC* mp6 = mPropertyManager->findCProperty("ec_bst_abort_fault_connector_temp");
  ConfigDBC* mp7 = mPropertyManager->findCProperty("ec_bst_abort_fault_insulation");
  ConfigDBC* mp8 = mPropertyManager->findCProperty("ec_bst_abort_fault_other");
  ConfigDBC* mp9 = mPropertyManager->findCProperty("ec_bst_abort_fault_voltage");
  ConfigDBC* mp10 = mPropertyManager->findCProperty("ec_bst_abort_fault_hv");
  ConfigDBC* mp11 = mPropertyManager->findCProperty("ec_bst_abort_fault_battery_temp");
  ConfigDBC* mp12 = mPropertyManager->findCProperty("ec_bst_abort_error_voltage");
  ConfigDBC* mp13 = mPropertyManager->findCProperty("ec_bst_abort_error_current");
  int32_t ec_bst_abort_achive_dcs = 0;
  int32_t ec_bst_abort_achive_single_volt = 0;
  int32_t ec_bst_abort_achive_total_volt = 0;
  int32_t ec_bst_abort_achive_soc = 0;
  int32_t ec_bst_abort_fault_connector = 0;
  int32_t ec_bst_abort_fault_bms_temp = 0;
  int32_t ec_bst_abort_fault_connector_temp = 0;
  int32_t ec_bst_abort_fault_insulation = 0;
  int32_t ec_bst_abort_fault_other = 0;
  int32_t ec_bst_abort_fault_voltage = 0;
  int32_t ec_bst_abort_fault_hv = 0;
  int32_t ec_bst_abort_fault_battery_temp = 0;
  int32_t ec_bst_abort_error_voltage = 0;
  int32_t ec_bst_abort_error_current = 0;
  while(!mShuttingDownFlag.load()){
    //
    mPropertyManager->getCan30CState();
    if (mPropertyManager->getCProValue(mp0,&ec_bst_abort_achive_dcs)){
      mHal->onPropertyValue(*Create_ec_bst_abort_achive_dcsReq(ec_bst_abort_achive_dcs),true);
    }

    if (mPropertyManager->getCProValue(mp1,&ec_bst_abort_achive_single_volt)){
      mHal->onPropertyValue(*Create_ec_bst_abort_achive_single_voltReq(ec_bst_abort_achive_single_volt),true);
    }

    if (mPropertyManager->getCProValue(mp2,&ec_bst_abort_achive_total_volt)){
      mHal->onPropertyValue(*Create_ec_bst_abort_achive_total_voltReq(ec_bst_abort_achive_total_volt),true);
    }

    if (mPropertyManager->getCProValue(mp3,&ec_bst_abort_achive_soc)){
      mHal->onPropertyValue(*Create_ec_bst_abort_achive_socReq(ec_bst_abort_achive_soc),true);
    }

    if (mPropertyManager->getCProValue(mp4,&ec_bst_abort_fault_connector)){
      mHal->onPropertyValue(*Create_ec_bst_abort_fault_connectorReq(ec_bst_abort_fault_connector),true);
    }

    if (mPropertyManager->getCProValue(mp5,&ec_bst_abort_fault_bms_temp)){
      mHal->onPropertyValue(*Create_ec_bst_abort_fault_bms_tempReq(ec_bst_abort_fault_bms_temp),true);
    }

    if (mPropertyManager->getCProValue(mp6,&ec_bst_abort_fault_connector_temp)){
      mHal->onPropertyValue(*Create_ec_bst_abort_fault_connector_tempReq(ec_bst_abort_fault_connector_temp),true);
    }

    if (mPropertyManager->getCProValue(mp7,&ec_bst_abort_fault_insulation)){
      mHal->onPropertyValue(*Create_ec_bst_abort_fault_insulationReq(ec_bst_abort_fault_insulation),true);
    }

    if (mPropertyManager->getCProValue(mp8,&ec_bst_abort_fault_other)){
      mHal->onPropertyValue(*Create_ec_bst_abort_fault_otherReq(ec_bst_abort_fault_other),true);
    }

    if (mPropertyManager->getCProValue(mp9,&ec_bst_abort_fault_voltage)){
      mHal->onPropertyValue(*Create_ec_bst_abort_fault_voltageReq(ec_bst_abort_fault_voltage),true);
    }

    if (mPropertyManager->getCProValue(mp10,&ec_bst_abort_fault_hv)){
      mHal->onPropertyValue(*Create_ec_bst_abort_fault_hvReq(ec_bst_abort_fault_hv),true);
    }

    if (mPropertyManager->getCProValue(mp11,&ec_bst_abort_fault_battery_temp)){
      mHal->onPropertyValue(*Create_ec_bst_abort_fault_battery_tempReq(ec_bst_abort_fault_battery_temp),true);
    }

    if (mPropertyManager->getCProValue(mp12,&ec_bst_abort_error_voltage)){
      mHal->onPropertyValue(*Create_ec_bst_abort_error_voltageReq(ec_bst_abort_error_voltage),true);
    }

    if (mPropertyManager->getCProValue(mp13,&ec_bst_abort_error_current)){
      mHal->onPropertyValue(*Create_ec_bst_abort_error_currentReq(ec_bst_abort_error_current),true);
    }
  }
}


float GarageModeServerSideHandlerImpl::getActualFloatValue(int32_t raw_value, float factor, int offset) {
     if(raw_value == -1024) {
         return raw_value;
     } else {
         return static_cast<float>(raw_value * factor + offset);
     }
}

float GarageModeServerSideHandlerImpl::getActualFloatValue_offset_is_float(int32_t raw_value, float factor, float offset) {
     if(raw_value == -1024) {
         return -1024.0;
     } else {
         return static_cast<float>(raw_value * factor + offset);
     }
}

//onPropertyValueFromCar
void GarageModeServerSideHandlerImpl::SpeedWatcher() {
  float speed = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_vehicle_spd");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      speed = getActualFloatValue(mPropertyManager->getCProValue(mp),0.05625,0);
      mHal->onPropertyValue(*CreatespeedReq(speed),true);
  }
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::CreatespeedReq(float speed) {
    auto req = mValueObjectPool->obtainFloat(speed);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_d_cdischrg_permWatcher() {
  float ec_vcu_d_cdischrg_perm = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_d_cdischrg_perm");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_d_cdischrg_perm = getActualFloatValue(mPropertyManager->getCProValue(mp),0.1,0);
      mHal->onPropertyValue(*Create_ec_vcu_d_cdischrg_permReq(ec_vcu_d_cdischrg_perm),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_d_cdischrg_permReq(float ec_vcu_d_cdischrg_perm) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_d_cdischrg_perm);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_pt_stWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_pt_st = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_pt_st");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_pt_st = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_vcu_pt_stReq(ec_vcu_pt_st),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_pt_stReq(int32_t ec_vcu_pt_st) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_pt_st);
    req->prop = toInt(VehicleProperty::GECKO_VCU_PT_ST);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ev_vcu_mcu_power_statusWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t mcu_power_st = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("gecko_bcm_mcu_power_status");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      mcu_power_st = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_mcu_power_stReq(mcu_power_st),true);
  }
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_mcu_power_stReq(int32_t mcu_power_st){
    auto req = mValueObjectPool->obtainInt32(mcu_power_st);
    req->prop = toInt(VehicleProperty::GECKO_MCU_POWER_STATUS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

#define WAIT_POWER_STATE_RETRY  650
/*
1BATOFF;
2 SLEEP;
3 STANDBY;
4 ACTIVE;
5 STRSOCRAM;
*/
int32_t GarageModeServerSideHandlerImpl::wait_standby_Entry_condition(){
    StatusCode status = StatusCode::OK;
    VehiclePropValue requestProp = VehiclePropValue {};
    requestProp.prop = toInt(VehicleProperty::AP_POWER_STATE_REPORT);
    requestProp.areaId = 0;
    int retry = 0;
    int32_t ret = 0;
    while(1){
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
        if(retry>WAIT_POWER_STATE_RETRY){
		    LOG(INFO) << "wait_standby_Entry_condition timeout";
            break;
	    }
        auto value = mHal->get(requestProp, &status);
        ret = value->value.int32Values[0];
        retry++;
        if(value != nullptr){
            LOG(INFO) << __func__ << " dxy value->value.int32Values[0] " << value->value.int32Values[0];
            if((value->value.int32Values[0]==toInt(VehicleApPowerStateReport::DEEP_SLEEP_EXIT))
               ||(value->value.int32Values[0]==toInt(VehicleApPowerStateReport::ON))
               ||(value->value.int32Values[0]==toInt(VehicleApPowerStateReport::WAIT_FOR_VHAL))
               ||(value->value.int32Values[0]==toInt(VehicleApPowerStateReport::SHUTDOWN_PREPARE))
               ||(value->value.int32Values[0]==toInt(VehicleApPowerStateReport::SHUTDOWN_POSTPONE))
               ||(value->value.int32Values[0]==toInt(VehicleApPowerStateReport::DEEP_SLEEP_ENTRY)))
                break;
        }else{
            LOG(INFO) << "dxy value->value.int32Values[0] is null" ;
        }
    }
    return ret;
}

int32_t GarageModeServerSideHandlerImpl::wait_active_Entry_condition(){
  StatusCode status = StatusCode::OK;
  VehiclePropValue requestProp = VehiclePropValue {};
  requestProp.prop = toInt(VehicleProperty::AP_POWER_STATE_REPORT);
  requestProp.areaId = 0;
  int retry = 0;
  int32_t ret = 0;
  while(1){
      std::this_thread::sleep_for(std::chrono::milliseconds(100));
      if(retry>WAIT_POWER_STATE_RETRY){
      LOG(INFO) << "wait_active_Entry_condition timeout";
          break;
    }
      auto value = mHal->get(requestProp, &status);
      ret = value->value.int32Values[0];
      retry++;
      if(value != nullptr){
          LOG(INFO) << __func__ << " dxy value->value.int32Values[0] " << value->value.int32Values[0];
//            if((value->value.int32Values[0]==toInt(VehicleApPowerStateReport::DEEP_SLEEP_EXIT))||(value->value.int32Values[0]==toInt(VehicleApPowerStateReport::SHUTDOWN_CANCELLED))||(value->value.int32Values[0]==toInt(VehicleApPowerStateReport::WAIT_FOR_VHAL)))
            if((value->value.int32Values[0]==toInt(VehicleApPowerStateReport::DEEP_SLEEP_EXIT))||
                 (value->value.int32Values[0]==toInt(VehicleApPowerStateReport::SHUTDOWN_CANCELLED))||
                 (value->value.int32Values[0]==toInt(VehicleApPowerStateReport::WAIT_FOR_VHAL))||
                 (value->value.int32Values[0]==toInt(VehicleApPowerStateReport::SHUTDOWN_POSTPONE))||
                 (value->value.int32Values[0]==toInt(VehicleApPowerStateReport::ON))||
                 (value->value.int32Values[0]==toInt(VehicleApPowerStateReport::DEEP_SLEEP_ENTRY)))
              break;
      }else{
          LOG(INFO) << "dxy value->value.int32Values[0] is null" ;
      }
  }
  return ret;
}

int32_t GarageModeServerSideHandlerImpl::wait_SHUTDOWN_CANCELLED_condition(){
  StatusCode status = StatusCode::OK;
  VehiclePropValue requestProp = VehiclePropValue {};
  requestProp.prop = toInt(VehicleProperty::AP_POWER_STATE_REPORT);
  requestProp.areaId = 0;
  int retry = 0;
  int32_t ret = 0;
  while(1){
      std::this_thread::sleep_for(std::chrono::milliseconds(100));
      if(retry>WAIT_POWER_STATE_RETRY){
      LOG(INFO) << "wait_active_Entry_condition timeout";
          break;
    }
      auto value = mHal->get(requestProp, &status);
      ret = value->value.int32Values[0];
      retry++;
      if(value != nullptr){
          LOG(INFO) << __func__ << " dxy value->value.int32Values[0] " << value->value.int32Values[0];
            if(value->value.int32Values[0]==toInt(VehicleApPowerStateReport::SHUTDOWN_CANCELLED))
              break;
      }else{
          LOG(INFO) << "dxy value->value.int32Values[0] is null" ;
      }
  }
  return ret;
}
int32_t GarageModeServerSideHandlerImpl::wait_SHUTDOWN_PREPARE_condition(){
  StatusCode status = StatusCode::OK;
  VehiclePropValue requestProp = VehiclePropValue {};
  requestProp.prop = toInt(VehicleProperty::AP_POWER_STATE_REPORT);
  requestProp.areaId = 0;
  int retry = 0;
  int32_t ret = 0;
  while(1){
      std::this_thread::sleep_for(std::chrono::milliseconds(100));
      if(retry>WAIT_POWER_STATE_RETRY){
      LOG(INFO) << __func__ << " timeout";
          break;
    }
      auto value = mHal->get(requestProp, &status);
      ret = value->value.int32Values[0];
      retry++;
      if(value != nullptr){
          LOG(INFO) << __func__ << " dxy value->value.int32Values[0] " << value->value.int32Values[0];
            if(value->value.int32Values[0]==toInt(VehicleApPowerStateReport::SHUTDOWN_PREPARE)||
              (value->value.int32Values[0]==toInt(VehicleApPowerStateReport::SHUTDOWN_POSTPONE)))
              break;
      }else{
          LOG(INFO) << "dxy value->value.int32Values[0] is null" ;
      }
  }
  return ret;
}
int32_t GarageModeServerSideHandlerImpl::wait_ON_condition(){
  StatusCode status = StatusCode::OK;
  VehiclePropValue requestProp = VehiclePropValue {};
  requestProp.prop = toInt(VehicleProperty::AP_POWER_STATE_REPORT);
  requestProp.areaId = 0;
  int retry = 0;
  int32_t ret = 0;
  while(1){
      std::this_thread::sleep_for(std::chrono::milliseconds(100));
      if(retry>WAIT_POWER_STATE_RETRY){
      LOG(INFO) << __func__ << " timeout";
          break;
    }
      auto value = mHal->get(requestProp, &status);
      ret = value->value.int32Values[0];
      retry++;
      if(value != nullptr){
          LOG(INFO) << __func__ << " dxy value->value.int32Values[0] " << value->value.int32Values[0];
            if(value->value.int32Values[0]==toInt(VehicleApPowerStateReport::ON))
              break;
      }else{
          LOG(INFO) << "dxy value->value.int32Values[0] is null" ;
      }
  }
  return ret;
}
int32_t GarageModeServerSideHandlerImpl::wait_FINISH_condition(){
  StatusCode status = StatusCode::OK;
  VehiclePropValue requestProp = VehiclePropValue {};
  requestProp.prop = toInt(VehicleProperty::AP_POWER_STATE_REPORT);
  requestProp.areaId = 0;
  int retry = 0;
  int32_t ret = 0;
  while(1){
      std::this_thread::sleep_for(std::chrono::milliseconds(100));
      if(retry>WAIT_POWER_STATE_RETRY){
      LOG(INFO) << "wait_finish_Entry_condition timeout";
          break;
    }
      auto value = mHal->get(requestProp, &status);
      ret = value->value.int32Values[0];
      retry++;
      if(value != nullptr){
          LOG(INFO) << __func__ << " dxy value->value.int32Values[0] " << value->value.int32Values[0];
            if(value->value.int32Values[0]==toInt(VehicleApPowerStateReport::DEEP_SLEEP_ENTRY))
              break;
      }else{
          LOG(INFO) << "dxy value->value.int32Values[0] is null" ;
      }
  }
  return ret;
}

int32_t GarageModeServerSideHandlerImpl::wait_str_DEEP_SLEEP_Entry_condition(){
    StatusCode status = StatusCode::OK;
    VehiclePropValue requestProp = VehiclePropValue {};
    requestProp.prop = toInt(VehicleProperty::AP_POWER_STATE_REPORT);
    requestProp.areaId = 0;
    int retry = 0;
    int32_t ret = 0;
    while(1){
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
        if(retry>WAIT_POWER_STATE_RETRY){
          LOG(INFO) << "dxy wait_str_DEEP_SLEEP_Entry_condition timeout";
          break;
        }
        auto value = mHal->get(requestProp, &status);
        ret = value->value.int32Values[0];
        retry++;
        if(value != nullptr){
            LOG(INFO) << __func__ << " dxy value->value.int32Values[0] " << value->value.int32Values[0] << " " 
		      << toInt(VehicleApPowerStateReport::DEEP_SLEEP_ENTRY);
	    if(value->value.int32Values[0]==toInt(VehicleApPowerStateReport::SHUTDOWN_POSTPONE)){
		if(mPropertyManager->get_postpone_counter()>10000){
		    retry = 0;
		}
                mPropertyManager->ponstpone_counter_dec(100);
                LOG(INFO) << "dxy wait_str_DEEP_SLEEP_Entry_condition get_postpone_counter:" << mPropertyManager->get_postpone_counter();
		if(mPropertyManager->get_postpone_counter()<=0){
	            //pwr_key
                    clr_power_key_status();
	            return ret;
		}
            }
            if((value->value.int32Values[0]==toInt(VehicleApPowerStateReport::DEEP_SLEEP_ENTRY))||
               (value->value.int32Values[0]==toInt(VehicleApPowerStateReport::ON)))
                break;
        }else{
            LOG(INFO) << "dxy value->value.int32Values[0] is null" ;
        }
    }
    return ret;
}

void GarageModeServerSideHandlerImpl::ccm_soc_power_statusWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(8000));
  int32_t soc_power_st = 0;
  while(!mShuttingDownFlag.load()){
      SLOGW("zhugang# wait for new status");
      std::vector<uint8_t> vecMsg = mPropertyManager->Powerstatusdequeue();
      for (uint8_t byte : vecMsg) {
        SLOGW("zhugang# %d",static_cast<int>(byte));
      }
      soc_power_st = static_cast<int>(vecMsg[0]);
      int32_t to_ready_str {5};
      int32_t ap_power_status = 0;
      SLOGW("dxy-- cmd get gecko_ccm_soc_power_status = %d",soc_power_st);
      {
        android::base::SetProperty("gecko.powerstatus",std::to_string(soc_power_st) );
        if(3 == soc_power_st || 4 == soc_power_st){
          mHal->onPropertyValue(*To_notification_tbox_soc_power_status(soc_power_st),true);
          if(3 == soc_power_st){
            SLOGW("dxy-- cmd standby mode");
            int need_power_key_lock = 0;
            int power_key_lock = 0;
            int retry_counter = 0;
            while(1){
              get_need_power_key_lock(&need_power_key_lock);
              get_power_key_lock(&power_key_lock);
              if(need_power_key_lock==1&&power_key_lock==1){
                retry_counter++;
                if(retry_counter>80){
                  SLOGW("dxy-- standby wait power key lock timeout");
                  break;
                }
                std::this_thread::sleep_for(std::chrono::milliseconds(300));
              }else{
                break;
              }
            }
	          ap_power_status = wait_standby_Entry_condition();
            if((toInt(VehicleApPowerStateReport::DEEP_SLEEP_EXIT) == ap_power_status)||
               (toInt(VehicleApPowerStateReport::ON) == ap_power_status)||
               (toInt(VehicleApPowerStateReport::WAIT_FOR_VHAL) == ap_power_status)){
              SLOGW("dxy-- cmd go to runing standby mode 1 2");
              mHal->onPropertyValue(*Create_soc_power_stReq(1,2),true);     // go to runing garage mode
              wait_SHUTDOWN_PREPARE_condition();
            }
            if((toInt(VehicleApPowerStateReport::DEEP_SLEEP_ENTRY) == ap_power_status)
               ||(toInt(VehicleApPowerStateReport::SHUTDOWN_PREPARE) == ap_power_status)
               ||(toInt(VehicleApPowerStateReport::SHUTDOWN_POSTPONE) == ap_power_status)){
              SLOGW("dxy-- standby mode not change");
            }
          }
          if(4 == soc_power_st){
            SLOGW("dxy-- cmd activity mode");
            mHal->onPropertyValue(*To_notification_tbox_soc_power_status(soc_power_st),true);
            int need_power_key_lock = 0;
            int power_key_lock = 0;
            int retry_counter = 0;
            while(1){
              get_need_power_key_lock(&need_power_key_lock);
              get_power_key_lock(&power_key_lock);
              if(need_power_key_lock==1&&power_key_lock==1){
                retry_counter++;
                if(retry_counter>80){
                  SLOGW("dxy-- active wait power key lock timeout");
                  break;
                }
                std::this_thread::sleep_for(std::chrono::milliseconds(300));
              }else{
                break;
              }
            }
	          ap_power_status = wait_active_Entry_condition();
            if((toInt(VehicleApPowerStateReport::SHUTDOWN_PREPARE) == ap_power_status)||
               (toInt(VehicleApPowerStateReport::SHUTDOWN_POSTPONE) == ap_power_status)||
               (toInt(VehicleApPowerStateReport::DEEP_SLEEP_ENTRY) == ap_power_status)){
              SLOGW("dxy-- cmd activity mode go to runing cancel sleep mode 2 0");
              mHal->onPropertyValue(*Create_soc_power_stReq(2,0),true);     // cancel the sleep mode
              ap_power_status = wait_SHUTDOWN_CANCELLED_condition();
              mHal->onPropertyValue(*Create_soc_power_stReq(0,0),true);
              wait_ON_condition();
            }else if(toInt(VehicleApPowerStateReport::SHUTDOWN_CANCELLED) == ap_power_status){
              SLOGW("dxy-- cmd prevalue is 5 go to run 0 0, on");
              mHal->onPropertyValue(*Create_soc_power_stReq(0,0),true);
              wait_ON_condition();
            }else if(toInt(VehicleApPowerStateReport::DEEP_SLEEP_EXIT) == ap_power_status){
              SLOGW("dxy-- cmd prevalue is 6 go to run 0 0, on");
              mHal->onPropertyValue(*Create_soc_power_stReq(0,0),true);
              wait_ON_condition();
            }else if(toInt(VehicleApPowerStateReport::WAIT_FOR_VHAL) == ap_power_status){
              SLOGW("dxy-- cmd activity mode go to runing activity mode 0 0");
              mHal->onPropertyValue(*Create_soc_power_stReq(0,0),true);
              wait_ON_condition();
            }else if(toInt(VehicleApPowerStateReport::ON) == ap_power_status){
              SLOGW("dxy-- active mode not change");
            }
            ////
          }
        }
        if(to_ready_str == soc_power_st){
          SLOGW("dxy-- cmd get going to str mode");
          int need_power_key_lock = 0;
          get_need_power_key_lock(&need_power_key_lock); 
          if(0==need_power_key_lock){
            set_power_key_lock(1);
            mHal->onPropertyValue(*To_notification_tbox_soc_power_status(soc_power_st),true);
	          ap_power_status = wait_str_DEEP_SLEEP_Entry_condition();
            if(toInt(VehicleApPowerStateReport::DEEP_SLEEP_ENTRY) == ap_power_status){
              SLOGW("dxy-- cmd get prv process mode 3 go to run finish 3 0" );
              std::this_thread::sleep_for(std::chrono::milliseconds(200));
              mHal->onPropertyValue(*Create_soc_power_stReq(toInt(VehicleApPowerStateReq::FINISHED),0),true);
            }else if(toInt(VehicleApPowerStateReport::ON) == ap_power_status){
              SLOGW("dxy-- cmd get prv process mode 7 go to run 1 4" );
              mHal->onPropertyValue(*Create_soc_power_stReq(toInt(VehicleApPowerStateReq::SHUTDOWN_PREPARE),4),true);
              wait_FINISH_condition();
              mHal->onPropertyValue(*Create_soc_power_stReq(toInt(VehicleApPowerStateReq::FINISHED),0),true);
            }
          }else{
            SLOGW("dxy-- str mode doing");
          }
        }
      }
  }
}

// tbox soc 
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::To_notification_tbox_soc_power_status(int32_t soc_power_st){
    auto req = mValueObjectPool->obtainInt32(soc_power_st);
    req->prop = toInt(VehicleProperty::GECKO_SOC_POWER_STATUS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}


recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_soc_power_stReq(int32_t soc_power_st, int32_t para_value){
    auto req = mValueObjectPool->obtain(VehiclePropertyType::INT32_VEC, 2);
    req->prop = toInt(VehicleProperty::AP_POWER_STATE_REQ);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    req->value.int32Values[0] = soc_power_st;
    req->value.int32Values[1] = para_value;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_dcd_cworkenableWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_dcd_cworkenable = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_dcd_cworkenable");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_dcd_cworkenable = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_vcu_dcd_cworkenableReq(ec_vcu_dcd_cworkenable),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_dcd_cworkenableReq(int32_t ec_vcu_dcd_cworkenable) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_dcd_cworkenable);
    req->prop = toInt(VehicleProperty::GECKO_DCD_CWORKENABLE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_charallowWatcher() {
  float ec_vcu_charallow = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_charallow");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_charallow = getActualFloatValue(mPropertyManager->getCProValue(mp),0.1,0);
      mHal->onPropertyValue(*Create_ec_vcu_charallowReq(ec_vcu_charallow),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_charallowReq(float ec_vcu_charallow) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_charallow);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_sleepindicationsignalWatcher() {
  float ec_vcu_sleepindicationsignal = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_sleepindicationsignal");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_sleepindicationsignal = getActualFloatValue(mPropertyManager->getCProValue(mp),0.1,0);
      mHal->onPropertyValue(*Create_ec_vcu_sleepindicationsignalReq(ec_vcu_sleepindicationsignal),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_sleepindicationsignalReq(float ec_vcu_sleepindicationsignal) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_sleepindicationsignal);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_livecounter_0x100Watcher() {
  float ec_vcu_livecounter_0x100 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_livecounter_0x100");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_livecounter_0x100 = getActualFloatValue(mPropertyManager->getCProValue(mp),0.1,0);
      mHal->onPropertyValue(*Create_ec_vcu_livecounter_0x100Req(ec_vcu_livecounter_0x100),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_livecounter_0x100Req(float ec_vcu_livecounter_0x100) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_livecounter_0x100);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_checksum_0x100Watcher() {
  float ec_vcu_checksum_0x100 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_checksum_0x100");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_checksum_0x100 = getActualFloatValue(mPropertyManager->getCProValue(mp),0.1,0);
      mHal->onPropertyValue(*Create_ec_vcu_checksum_0x100Req(ec_vcu_checksum_0x100),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_checksum_0x100Req(float ec_vcu_checksum_0x100) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_checksum_0x100);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_bms_cc2statusWatcher() {
  float ec_bms_cc2status = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_cc2status");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_cc2status = getActualFloatValue(mPropertyManager->getCProValue(mp),0.1,0);
      mHal->onPropertyValue(*Create_ec_bms_cc2statusReq(ec_bms_cc2status),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_cc2statusReq(float ec_bms_cc2status) {
    auto req = mValueObjectPool->obtainFloat(ec_bms_cc2status);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_bms_livecounter_0x120Watcher() {
  float ec_bms_livecounter_0x120 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_livecounter_0x120");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_livecounter_0x120 = getActualFloatValue(mPropertyManager->getCProValue(mp),0.1,0);
      mHal->onPropertyValue(*Create_ec_bms_livecounter_0x120Req(ec_bms_livecounter_0x120),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_livecounter_0x120Req(float ec_bms_livecounter_0x120) {
    auto req = mValueObjectPool->obtainFloat(ec_bms_livecounter_0x120);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_bms_checksum_0x120Watcher() {
  float ec_bms_checksum_0x120 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_checksum_0x120");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_checksum_0x120 = getActualFloatValue(mPropertyManager->getCProValue(mp),0.1,0);
      mHal->onPropertyValue(*Create_ec_bms_checksum_0x120Req(ec_bms_checksum_0x120),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_checksum_0x120Req(float ec_bms_checksum_0x120) {
    auto req = mValueObjectPool->obtainFloat(ec_bms_checksum_0x120);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_bms_batinsulatresistanceWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int ec_bms_batinsulatresistance = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_batinsulatresistance");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_batinsulatresistance = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_bms_batinsulatresistanceReq(ec_bms_batinsulatresistance),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_batinsulatresistanceReq(int ec_bms_batinsulatresistance) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_batinsulatresistance);
    req->prop = toInt(VehicleProperty::GECKO_BMS_BATINSULATRESISTANCE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_bms_batterycurrentWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  float ec_bms_batterycurrent = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_batterycurrent");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_batterycurrent = getActualFloatValue(mPropertyManager->getCProValue(mp),0.1,-1000);
      mHal->onPropertyValue(*Create_ec_bms_batterycurrentReq(ec_bms_batterycurrent),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_batterycurrentReq(float ec_bms_batterycurrent) {
    auto req = mValueObjectPool->obtainFloat(ec_bms_batterycurrent);
    req->prop = toInt(VehicleProperty::GECKO_EV_BATTERY_CURRENT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_packvoltageWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bms_packvoltage = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_packvoltage");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_packvoltage = static_cast<int32_t>(getActualFloatValue(mPropertyManager->getCProValue(mp),0.1,0));
      mHal->onPropertyValue(*Create_ec_bms_packvoltageReq(ec_bms_packvoltage),true);

  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_packvoltageReq(int32_t ec_bms_packvoltage) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_packvoltage);
    req->prop = toInt(VehicleProperty::GECKO_EV_BATTERY_VOLTAGE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_packvoltage_vWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bms_packvoltage_v = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_packvoltage_v");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_packvoltage_v = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_bms_packvoltage_vReq(ec_bms_packvoltage_v),true);

  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_packvoltage_vReq(int32_t ec_bms_packvoltage_v) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_packvoltage_v);
    req->prop = toInt(VehicleProperty::GECKO_EV_BATTERY_VOLTAGE_V);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_livecounter_0x125Watcher() {
  float ec_bms_livecounter_0x125 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_livecounter_0x125");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_livecounter_0x125 = getActualFloatValue(mPropertyManager->getCProValue(mp),0.1,0);
      mHal->onPropertyValue(*Create_ec_bms_livecounter_0x125Req(ec_bms_livecounter_0x125),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_livecounter_0x125Req(float ec_bms_livecounter_0x125) {
    auto req = mValueObjectPool->obtainFloat(ec_bms_livecounter_0x125);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_bms_checksum_0x125Watcher() {
  float ec_bms_checksum_0x125 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_checksum_0x125");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_checksum_0x125 = getActualFloatValue(mPropertyManager->getCProValue(mp),0.1,0);
      mHal->onPropertyValue(*Create_ec_bms_checksum_0x125Req(ec_bms_checksum_0x125),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_checksum_0x125Req(float ec_bms_checksum_0x125) {
    auto req = mValueObjectPool->obtainFloat(ec_bms_checksum_0x125);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_bms_remainingchargetimeWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bms_remainingchargetime = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_remainingchargetime");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_remainingchargetime = static_cast<int32_t> (mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_bms_remainingchargetimeReq(ec_bms_remainingchargetime),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_remainingchargetimeReq(int32_t ec_bms_remainingchargetime) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_remainingchargetime);
    req->prop = toInt(VehicleProperty::GECKO_EV_CHARGE_TIME_REMAINING);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_bms_batterysocWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  float ec_bms_batterysoc = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_batterysoc");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_batterysoc = getActualFloatValue(mPropertyManager->getCProValue(mp),0.1,0);
      mHal->onPropertyValue(*Create_ec_bms_batterysocReq(ec_bms_batterysoc),true);
      // int32_t batterylowsigna = 0;
      // if(ec_bms_batterysoc <= 10.0){
      //   batterylowsigna = 1;
      // } else if(ec_bms_batterysoc <= 20.0 && ec_bms_batterysoc > 10.0){
      //   batterylowsigna = 2;
      // }
      // LOG(INFO) << "ec_bms_batterysoc:"<<ec_bms_batterysoc<<"batterylowsigna:"<<batterylowsigna;
      // mHal->onPropertyValue(*Create_ec_batterylowsignalReq(batterylowsigna),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_batterysocReq(float ec_bms_batterysoc) {
    auto req = mValueObjectPool->obtainFloat(ec_bms_batterysoc);
    req->prop = toInt(VehicleProperty::EV_BATTERY_LEVEL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_batterylowsignalReq(int32_t batterylowsigna){
    auto req = mValueObjectPool->obtainInt32(batterylowsigna);
    req->prop = toInt(VehicleProperty::GECKO_BATTERYLOWSIGNAL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_livecounter_0x135Watcher() {
  float ec_bms_livecounter_0x135 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_livecounter_0x135");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_livecounter_0x135 = getActualFloatValue(mPropertyManager->getCProValue(mp),0.1,0);
      mHal->onPropertyValue(*Create_ec_bms_livecounter_0x135Req(ec_bms_livecounter_0x135),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_livecounter_0x135Req(float ec_bms_livecounter_0x135) {
    auto req = mValueObjectPool->obtainFloat(ec_bms_livecounter_0x135);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_bms_checksum_0x135Watcher() {
  float ec_bms_checksum_0x135 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_checksum_0x135");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_checksum_0x135 = getActualFloatValue(mPropertyManager->getCProValue(mp),0.1,0);
      mHal->onPropertyValue(*Create_ec_bms_checksum_0x135Req(ec_bms_checksum_0x135),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_checksum_0x135Req(float ec_bms_checksum_0x135) {
    auto req = mValueObjectPool->obtainFloat(ec_bms_checksum_0x135);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_mcu_motortorqueWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int ec_mcu_motortorque = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_mcu_motortorque");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_mcu_motortorque = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_mcu_motortorqueReq(ec_mcu_motortorque),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_mcu_motortorqueReq(int ec_mcu_motortorque) {
    auto req = mValueObjectPool->obtainInt32(ec_mcu_motortorque);
    req->prop = toInt(VehicleProperty::GECKO_MCU_MOTORTORQUE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_mcu_motorspdWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  float ec_mcu_motorspd = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_mcu_motorspd");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_mcu_motorspd = getActualFloatValue(mPropertyManager->getCProValue(mp),1,-12000);
      mHal->onPropertyValue(*Create_ec_mcu_motorspdReq(ec_mcu_motorspd),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_mcu_motorspdReq(float ec_mcu_motorspd) {
    auto req = mValueObjectPool->obtainFloat(ec_mcu_motorspd);
    req->prop = toInt(VehicleProperty::ENGINE_RPM);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_mcu_llivecounter_0x200Watcher() {
  float ec_mcu_llivecounter_0x200 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_mcu_llivecounter_0x200");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_mcu_llivecounter_0x200 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_mcu_llivecounter_0x200Req(ec_mcu_llivecounter_0x200),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_mcu_llivecounter_0x200Req(float ec_mcu_llivecounter_0x200) {
    auto req = mValueObjectPool->obtainFloat(ec_mcu_llivecounter_0x200);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_mcu_checksum_0x200Watcher() {
  float ec_mcu_checksum_0x200 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_mcu_checksum_0x200");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_mcu_checksum_0x200 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_mcu_checksum_0x200Req(ec_mcu_checksum_0x200),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_mcu_checksum_0x200Req(float ec_mcu_checksum_0x200) {
    auto req = mValueObjectPool->obtainFloat(ec_mcu_checksum_0x200);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_mcu_buscurrentWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int ec_mcu_buscurrent = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_mcu_buscurrent");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_mcu_buscurrent = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_mcu_buscurrentReq(ec_mcu_buscurrent),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_mcu_buscurrentReq(int ec_mcu_buscurrent) {
    auto req = mValueObjectPool->obtainInt32(ec_mcu_buscurrent);
    req->prop = toInt(VehicleProperty::GECKO_MCU_BUSCURRENT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_mcu_busvoltWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int ec_mcu_busvolt = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_mcu_busvolt");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_mcu_busvolt = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_mcu_busvoltReq(ec_mcu_busvolt),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_mcu_busvoltReq(int ec_mcu_busvolt) {
    auto req = mValueObjectPool->obtainInt32(ec_mcu_busvolt);
    req->prop = toInt(VehicleProperty::GECKO_MCU_BUSVOLT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_mcu_llivecounter_0x201Watcher() {
  float ec_mcu_llivecounter_0x201 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_mcu_llivecounter_0x201");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_mcu_llivecounter_0x201 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_mcu_llivecounter_0x201Req(ec_mcu_llivecounter_0x201),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_mcu_llivecounter_0x201Req(float ec_mcu_llivecounter_0x201) {
    auto req = mValueObjectPool->obtainFloat(ec_mcu_llivecounter_0x201);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_mcu_checksum_0x201Watcher() {
  float ec_mcu_checksum_0x201 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_mcu_checksum_0x201");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_mcu_checksum_0x201 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_mcu_checksum_0x201Req(ec_mcu_checksum_0x201),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_mcu_checksum_0x201Req(float ec_mcu_checksum_0x201) {
    auto req = mValueObjectPool->obtainFloat(ec_mcu_checksum_0x201);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_mcu_motortempWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_mcu_motortemp = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_mcu_motortemp");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_mcu_motortemp = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_mcu_motortempReq(ec_mcu_motortemp),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_mcu_motortempReq(int32_t ec_mcu_motortemp) {
    auto req = mValueObjectPool->obtainInt32(ec_mcu_motortemp);
    req->prop = toInt(VehicleProperty::GECKO_ENGINE_TEMP);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_mcu_igbttempWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_mcu_igbttemp = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_mcu_igbttemp");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_mcu_igbttemp = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_mcu_igbttempReq(ec_mcu_igbttemp),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_mcu_igbttempReq(int32_t ec_mcu_igbttemp) {
    auto req = mValueObjectPool->obtainInt32(ec_mcu_igbttemp);
    req->prop = toInt(VehicleProperty::GECKO_MCU_IGBTTEMP);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_mcu_llivecounter_0x202Watcher() {
  float ec_mcu_llivecounter_0x202 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_mcu_llivecounter_0x202");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_mcu_llivecounter_0x202 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_mcu_llivecounter_0x202Req(ec_mcu_llivecounter_0x202),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_mcu_llivecounter_0x202Req(float ec_mcu_llivecounter_0x202) {
    auto req = mValueObjectPool->obtainFloat(ec_mcu_llivecounter_0x202);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_mcu_checksum_0x202Watcher() {
  float ec_mcu_checksum_0x202 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_mcu_checksum_0x202");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_mcu_checksum_0x202 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_mcu_checksum_0x202Req(ec_mcu_checksum_0x202),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_mcu_checksum_0x202Req(float ec_mcu_checksum_0x202) {
    auto req = mValueObjectPool->obtainFloat(ec_mcu_checksum_0x202);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_mcu_motor_stateWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_mcu_motor_state = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_mcu_motor_state");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_mcu_motor_state = static_cast<int32_t> (mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_mcu_motor_stateReq(ec_mcu_motor_state),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_mcu_motor_stateReq(int32_t ec_mcu_motor_state) {
    auto req = mValueObjectPool->obtainInt32(ec_mcu_motor_state);
    req->prop = toInt(VehicleProperty::GECKO_ENGINE_STATE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_mcu_llivecounter_0x203Watcher() {
  float ec_mcu_llivecounter_0x203 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_mcu_llivecounter_0x203");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_mcu_llivecounter_0x203 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_mcu_llivecounter_0x203Req(ec_mcu_llivecounter_0x203),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_mcu_llivecounter_0x203Req(float ec_mcu_llivecounter_0x203) {
    auto req = mValueObjectPool->obtainFloat(ec_mcu_llivecounter_0x203);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_mcu_checksum_0x203Watcher() {
  float ec_mcu_checksum_0x203 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_mcu_checksum_0x203");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_mcu_checksum_0x203 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_mcu_checksum_0x203Req(ec_mcu_checksum_0x203),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_mcu_checksum_0x203Req(float ec_mcu_checksum_0x203) {
    auto req = mValueObjectPool->obtainFloat(ec_mcu_checksum_0x203);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ipu_smart_dc_stWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_ipu_smart_dc_st = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_smart_dc_st");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ipu_smart_dc_st = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_ipu_smart_dc_stReq(ec_ipu_smart_dc_st),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_smart_dc_stReq(int32_t ec_ipu_smart_dc_st) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_smart_dc_st);
    req->prop = toInt(VehicleProperty::GECKO_IPU_SMART_DC_ST);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ipu_livecounter_0x450Watcher() {
  float ec_ipu_livecounter_0x450 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_livecounter_0x450");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ipu_livecounter_0x450 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ipu_livecounter_0x450Req(ec_ipu_livecounter_0x450),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_livecounter_0x450Req(float ec_ipu_livecounter_0x450) {
    auto req = mValueObjectPool->obtainFloat(ec_ipu_livecounter_0x450);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ipu_checksum_0x450Watcher() {
  float ec_ipu_checksum_0x450 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_checksum_0x450");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ipu_checksum_0x450 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ipu_checksum_0x450Req(ec_ipu_checksum_0x450),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_checksum_0x450Req(float ec_ipu_checksum_0x450) {
    auto req = mValueObjectPool->obtainFloat(ec_ipu_checksum_0x450);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ipu_c_cresistancevalueWatcher() {
  float ec_ipu_c_cresistancevalue = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_c_cresistancevalue");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ipu_c_cresistancevalue = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ipu_c_cresistancevalueReq(ec_ipu_c_cresistancevalue),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_c_cresistancevalueReq(float ec_ipu_c_cresistancevalue) {
    auto req = mValueObjectPool->obtainFloat(ec_ipu_c_cresistancevalue);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ipu_livecounter_0x470Watcher() {
  float ec_ipu_livecounter_0x470 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_livecounter_0x470");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ipu_livecounter_0x470 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ipu_livecounter_0x470Req(ec_ipu_livecounter_0x470),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_livecounter_0x470Req(float ec_ipu_livecounter_0x470) {
    auto req = mValueObjectPool->obtainFloat(ec_ipu_livecounter_0x470);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ipu_checksum_0x470Watcher() {
  float ec_ipu_checksum_0x470 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_checksum_0x470");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ipu_checksum_0x470 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ipu_checksum_0x470Req(ec_ipu_checksum_0x470),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_checksum_0x470Req(float ec_ipu_checksum_0x470) {
    auto req = mValueObjectPool->obtainFloat(ec_ipu_checksum_0x470);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_dcd_crealtimeopcurrWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_ipu_dcd_crealtimeopcurr = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_dcd_crealtimeopcurr");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ipu_dcd_crealtimeopcurr = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_ipu_dcd_crealtimeopcurrReq(ec_ipu_dcd_crealtimeopcurr),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_dcd_crealtimeopcurrReq(int32_t ec_ipu_dcd_crealtimeopcurr) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_dcd_crealtimeopcurr);
    req->prop = toInt(VehicleProperty::GECKO_IPU_DCDCREALTIMEOPCURR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ipu_dcd_coperatingmodeWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_ipu_dcd_coperatingmode = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_dcd_coperatingmode");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ipu_dcd_coperatingmode = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_ipu_dcd_coperatingmodeReq(ec_ipu_dcd_coperatingmode),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_dcd_coperatingmodeReq(int32_t ec_ipu_dcd_coperatingmode) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_dcd_coperatingmode);
    req->prop = toInt(VehicleProperty::GECKO_IPU_DCDCOPERATINGMODE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_dcd_crealtimeopvoltWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_ipu_dcd_crealtimeopvolt = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_dcd_crealtimeopvolt");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ipu_dcd_crealtimeopvolt = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_ipu_dcd_crealtimeopvoltReq(ec_ipu_dcd_crealtimeopvolt),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_dcd_crealtimeopvoltReq(int32_t ec_ipu_dcd_crealtimeopvolt) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_dcd_crealtimeopvolt);
    req->prop = toInt(VehicleProperty::GECKO_IPU_DCDCREALTIMEOPVOLT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_dcd_cbodytempWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_ipu_dcd_cbodytemp = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_dcd_cbodytemp");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ipu_dcd_cbodytemp = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_ipu_dcd_cbodytempReq(ec_ipu_dcd_cbodytemp),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_dcd_cbodytempReq(int32_t ec_ipu_dcd_cbodytemp) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_dcd_cbodytemp);
    req->prop = toInt(VehicleProperty::GECKO_IPU_DCDCBODYTEMP);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ipu_livecounter_0x490Watcher() {
  float ec_ipu_livecounter_0x490 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_livecounter_0x490");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ipu_livecounter_0x490 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ipu_livecounter_0x490Req(ec_ipu_livecounter_0x490),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_livecounter_0x490Req(float ec_ipu_livecounter_0x490) {
    auto req = mValueObjectPool->obtainFloat(ec_ipu_livecounter_0x490);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ipu_checksum_0x490Watcher() {
  float ec_ipu_checksum_0x490 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_checksum_0x490");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ipu_checksum_0x490 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ipu_checksum_0x490Req(ec_ipu_checksum_0x490),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_checksum_0x490Req(float ec_ipu_checksum_0x490) {
    auto req = mValueObjectPool->obtainFloat(ec_ipu_checksum_0x490);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_bms_battery_pack_average_tempWatcher() {
  float ec_bms_battery_pack_average_temp = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_battery_pack_average_temp");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_battery_pack_average_temp = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_bms_battery_pack_average_tempReq(ec_bms_battery_pack_average_temp),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_battery_pack_average_tempReq(float ec_bms_battery_pack_average_temp) {
    auto req = mValueObjectPool->obtainFloat(ec_bms_battery_pack_average_temp);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_bms_packtotalcellnumWatcher() {
  int32_t ec_bms_packtotalcellnum = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_packtotalcellnum");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_packtotalcellnum = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_bms_packtotalcellnumReq(ec_bms_packtotalcellnum),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_packtotalcellnumReq(int32_t ec_bms_packtotalcellnum) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_packtotalcellnum);
    req->prop = toInt(VehicleProperty::GECKO_BMS_PACKTOTALCELLNUM);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_bms_packtotaltempnumWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bms_packtotaltempnum = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_packtotaltempnum");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_packtotaltempnum = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_bms_packtotaltempnumReq(ec_bms_packtotaltempnum),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_packtotaltempnumReq(int32_t ec_bms_packtotaltempnum) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_packtotaltempnum);
    req->prop = toInt(VehicleProperty::GECKO_BMS_PACKTOTALTEMPNUM);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_bms_maxvoltcellpacknumWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int ec_bms_maxvoltcellpacknum = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_maxvoltcellpacknum");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_maxvoltcellpacknum = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_bms_maxvoltcellpacknumReq(ec_bms_maxvoltcellpacknum),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_maxvoltcellpacknumReq(int ec_bms_maxvoltcellpacknum) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_maxvoltcellpacknum);
    req->prop = toInt(VehicleProperty::GECKO_BMS_MAXVOLTCELLPACKNUM);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_bms_minvoltcellpacknumWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int ec_bms_minvoltcellpacknum = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_minvoltcellpacknum");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_minvoltcellpacknum = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_bms_minvoltcellpacknumReq(ec_bms_minvoltcellpacknum),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_minvoltcellpacknumReq(int ec_bms_minvoltcellpacknum) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_minvoltcellpacknum);
    req->prop = toInt(VehicleProperty::GECKO_BMS_MINVOLTCELLPACKNUM);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_bms_livecounter_0x510Watcher() {
  float ec_bms_livecounter_0x510 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_livecounter_0x510");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_livecounter_0x510 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_bms_livecounter_0x510Req(ec_bms_livecounter_0x510),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_livecounter_0x510Req(float ec_bms_livecounter_0x510) {
    auto req = mValueObjectPool->obtainFloat(ec_bms_livecounter_0x510);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_bms_checksum_0x510Watcher() {
  float ec_bms_checksum_0x510 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_checksum_0x510");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_checksum_0x510 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_bms_checksum_0x510Req(ec_bms_checksum_0x510),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_checksum_0x510Req(float ec_bms_checksum_0x510) {
    auto req = mValueObjectPool->obtainFloat(ec_bms_checksum_0x510);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_bms_mintempmonomercellWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int ec_bms_mintempmonomercell = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_mintempmonomercell");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_mintempmonomercell = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_bms_mintempmonomercellReq(ec_bms_mintempmonomercell),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_mintempmonomercellReq(int ec_bms_mintempmonomercell) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_mintempmonomercell);
    req->prop = toInt(VehicleProperty::GECKO_BMS_MINTEMPMONOMERCELL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_bms_maxtempmonomercellWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int ec_bms_maxtempmonomercell = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_maxtempmonomercell");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_maxtempmonomercell = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_bms_maxtempmonomercellReq(ec_bms_maxtempmonomercell),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_maxtempmonomercellReq(int ec_bms_maxtempmonomercell) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_maxtempmonomercell);
    req->prop = toInt(VehicleProperty::GECKO_BMS_MAXTEMPMONOMERCELL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_bms_maxtempcellWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  float ec_bms_maxtempcell = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_maxtempcell");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_maxtempcell = getActualFloatValue(mPropertyManager->getCProValue(mp),1.0,-40);
      mHal->onPropertyValue(*Create_ec_bms_maxtempcellReq(ec_bms_maxtempcell),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_maxtempcellReq(float ec_bms_maxtempcell) {
    auto req = mValueObjectPool->obtainFloat(ec_bms_maxtempcell);
    req->prop = toInt(VehicleProperty::GECKO_MOMER_MAX_TEMPCELL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_bms_mintempcellWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  float ec_bms_mintempcell = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_mintempcell");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_mintempcell = getActualFloatValue(mPropertyManager->getCProValue(mp),1.0,-40);
      mHal->onPropertyValue(*Create_ec_bms_mintempcellReq(ec_bms_mintempcell),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_mintempcellReq(float ec_bms_mintempcell) {
    auto req = mValueObjectPool->obtainFloat(ec_bms_mintempcell);
    req->prop = toInt(VehicleProperty::GECKO_MOMER_MIN_TEMPCELL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_bms_maxtempcellpacknumWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int ec_bms_maxtempcellpacknum = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_maxtempcellpacknum");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_maxtempcellpacknum = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_bms_maxtempcellpacknumReq(ec_bms_maxtempcellpacknum),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_maxtempcellpacknumReq(int ec_bms_maxtempcellpacknum) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_maxtempcellpacknum);
    req->prop = toInt(VehicleProperty::GECKO_BMS_MAXTEMPCELLPACKNUM);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_bms_mintempcellpacknumWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int ec_bms_mintempcellpacknum = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_mintempcellpacknum");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_mintempcellpacknum = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_bms_mintempcellpacknumReq(ec_bms_mintempcellpacknum),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_mintempcellpacknumReq(int ec_bms_mintempcellpacknum) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_mintempcellpacknum);
    req->prop = toInt(VehicleProperty::GECKO_BMS_MINTEMPCELLPACKNUM);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_bms_deg_d_ccharsockettemp2Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int ec_bms_deg_d_ccharsockettemp2 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_deg_d_ccharsockettemp2");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_deg_d_ccharsockettemp2 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_bms_deg_d_ccharsockettemp2Req(ec_bms_deg_d_ccharsockettemp2),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_deg_d_ccharsockettemp2Req(int ec_bms_deg_d_ccharsockettemp2) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_deg_d_ccharsockettemp2);
    req->prop = toInt(VehicleProperty::GECKO_BMS_DEG_DCCHARSOCKETTEMP2);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_bms_deg_d_ccharsockettemp1Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int ec_bms_deg_d_ccharsockettemp1 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_deg_d_ccharsockettemp1");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_deg_d_ccharsockettemp1 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_bms_deg_d_ccharsockettemp1Req(ec_bms_deg_d_ccharsockettemp1),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_deg_d_ccharsockettemp1Req(int ec_bms_deg_d_ccharsockettemp1) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_deg_d_ccharsockettemp1);
    req->prop = toInt(VehicleProperty::GECKO_BMS_DEG_DCCHARSOCKETTEMP1);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_bms_livecounter0x511Watcher() {
  float ec_bms_livecounter0x511 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_livecounter0x511");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_livecounter0x511 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_bms_livecounter0x511Req(ec_bms_livecounter0x511),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_livecounter0x511Req(float ec_bms_livecounter0x511) {
    auto req = mValueObjectPool->obtainFloat(ec_bms_livecounter0x511);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_bms_checksum_0x511Watcher() {
  float ec_bms_checksum_0x511 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_checksum_0x511");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_checksum_0x511 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_bms_checksum_0x511Req(ec_bms_checksum_0x511),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_checksum_0x511Req(float ec_bms_checksum_0x511) {
    auto req = mValueObjectPool->obtainFloat(ec_bms_checksum_0x511);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_bms_minvoltmonomercellWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int ec_bms_minvoltmonomercell = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_minvoltmonomercell");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_minvoltmonomercell = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_bms_minvoltmonomercellReq(ec_bms_minvoltmonomercell),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_minvoltmonomercellReq(int ec_bms_minvoltmonomercell) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_minvoltmonomercell);
    req->prop = toInt(VehicleProperty::GECKO_BMS_MINVOLTMONOMERCELL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_bms_maxvoltmonomercellWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int ec_bms_maxvoltmonomercell = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_maxvoltmonomercell");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_maxvoltmonomercell = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_bms_maxvoltmonomercellReq(ec_bms_maxvoltmonomercell),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_maxvoltmonomercellReq(int ec_bms_maxvoltmonomercell) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_maxvoltmonomercell);
    req->prop = toInt(VehicleProperty::GECKO_BMS_MAXVOLTMONOMERCELL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_bms_maxvoltcellWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  float ec_bms_maxvoltcell = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_maxvoltcell");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_maxvoltcell = getActualFloatValue(mPropertyManager->getCProValue(mp),1.0,0);
      mHal->onPropertyValue(*Create_ec_bms_maxvoltcellReq(ec_bms_maxvoltcell),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_maxvoltcellReq(float ec_bms_maxvoltcell) {
    auto req = mValueObjectPool->obtainFloat(ec_bms_maxvoltcell);
    req->prop = toInt(VehicleProperty::GECKO_MOMER_MAX_VOLTCELL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_bms_minvoltcellWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  float ec_bms_minvoltcell = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_minvoltcell");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_minvoltcell = getActualFloatValue(mPropertyManager->getCProValue(mp),1.0,0);
      mHal->onPropertyValue(*Create_ec_bms_minvoltcellReq(ec_bms_minvoltcell),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_minvoltcellReq(float ec_bms_minvoltcell) {
    auto req = mValueObjectPool->obtainFloat(ec_bms_minvoltcell);
    req->prop = toInt(VehicleProperty::GECKO_MOMER_MIN_VOLTCELL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_bms_livecounter_0x512Watcher() {
  float ec_bms_livecounter_0x512 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_livecounter_0x512");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_livecounter_0x512 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_bms_livecounter_0x512Req(ec_bms_livecounter_0x512),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_livecounter_0x512Req(float ec_bms_livecounter_0x512) {
    auto req = mValueObjectPool->obtainFloat(ec_bms_livecounter_0x512);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_bms_checksum_0x512Watcher() {
  float ec_bms_checksum_0x512 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_checksum_0x512");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_checksum_0x512 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_bms_checksum_0x512Req(ec_bms_checksum_0x512),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_checksum_0x512Req(float ec_bms_checksum_0x512) {
    auto req = mValueObjectPool->obtainFloat(ec_bms_checksum_0x512);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_bms_packratecapWatcher() {
  float ec_bms_packratecap = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_packratecap");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_packratecap = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_bms_packratecapReq(ec_bms_packratecap),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_packratecapReq(float ec_bms_packratecap) {
    auto req = mValueObjectPool->obtainFloat(ec_bms_packratecap);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_bms_pack_rate_voltWatcher() {
  float ec_bms_pack_rate_volt = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_pack_rate_volt");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_pack_rate_volt = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_bms_pack_rate_voltReq(ec_bms_pack_rate_volt),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_pack_rate_voltReq(float ec_bms_pack_rate_volt) {
    auto req = mValueObjectPool->obtainFloat(ec_bms_pack_rate_volt);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_bms_packrateenergyWatcher() {
  float ec_bms_packrateenergy = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_packrateenergy");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_packrateenergy = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_bms_packrateenergyReq(ec_bms_packrateenergy),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_packrateenergyReq(float ec_bms_packrateenergy) {
    auto req = mValueObjectPool->obtainFloat(ec_bms_packrateenergy);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_bms_batt_typeWatcher() {
  float ec_bms_batt_type = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_batt_type");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_batt_type = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_bms_batt_typeReq(ec_bms_batt_type),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_batt_typeReq(float ec_bms_batt_type) {
    auto req = mValueObjectPool->obtainFloat(ec_bms_batt_type);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_bms_battcooltypeWatcher() {
  float ec_bms_battcooltype = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_battcooltype");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_battcooltype = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_bms_battcooltypeReq(ec_bms_battcooltype),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_battcooltypeReq(float ec_bms_battcooltype) {
    auto req = mValueObjectPool->obtainFloat(ec_bms_battcooltype);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_bms_livecounter_0x520Watcher() {
  float ec_bms_livecounter_0x520 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_livecounter_0x520");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_livecounter_0x520 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_bms_livecounter_0x520Req(ec_bms_livecounter_0x520),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_livecounter_0x520Req(float ec_bms_livecounter_0x520) {
    auto req = mValueObjectPool->obtainFloat(ec_bms_livecounter_0x520);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_bms_checksum_0x520Watcher() {
  float ec_bms_checksum_0x520 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_checksum_0x520");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_checksum_0x520 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_bms_checksum_0x520Req(ec_bms_checksum_0x520),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_checksum_0x520Req(float ec_bms_checksum_0x520) {
    auto req = mValueObjectPool->obtainFloat(ec_bms_checksum_0x520);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_thermalrunawayalarmWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bms_thermalrunawayalarm = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_thermalrunawayalarm");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_thermalrunawayalarm = mPropertyManager->getCProValue(mp);
      LOG(INFO) << "ec_bms_thermalrunawayalarm:"<<ec_bms_thermalrunawayalarm;
      mHal->onPropertyValue(*Create_ec_bms_thermalrunawayalarmReq(ec_bms_thermalrunawayalarm),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_thermalrunawayalarmReq(int32_t ec_bms_thermalrunawayalarm) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_thermalrunawayalarm);
    req->prop = toInt(VehicleProperty::GECKO_BMS_THERMALRUNAWAYALARM);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_bms_livecounter_0x522Watcher() {
  float ec_bms_livecounter_0x522 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_livecounter_0x522");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_livecounter_0x522 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_bms_livecounter_0x522Req(ec_bms_livecounter_0x522),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_livecounter_0x522Req(float ec_bms_livecounter_0x522) {
    auto req = mValueObjectPool->obtainFloat(ec_bms_livecounter_0x522);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_bms_checksum_0x522Watcher() {
  float ec_bms_checksum_0x522 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_checksum_0x522");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_checksum_0x522 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_bms_checksum_0x522Req(ec_bms_checksum_0x522),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_checksum_0x522Req(float ec_bms_checksum_0x522) {
    auto req = mValueObjectPool->obtainFloat(ec_bms_checksum_0x522);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_shif_faultWatcher() {
  float ec_vcu_shif_fault = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_shif_fault");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_shif_fault = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_vcu_shif_faultReq(ec_vcu_shif_fault),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_shif_faultReq(float ec_vcu_shif_fault) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_shif_fault);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_shift_positionWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int ec_vcu_shift_position = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_shift_position");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_shift_position = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      ALOGE("dxy----- ec_vcu_shift_position %d",ec_vcu_shift_position);
      mHal->onPropertyValue(*Create_ec_vcu_shift_positionReq(ec_vcu_shift_position),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_shift_positionReq(int32_t ec_vcu_shift_position) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_shift_position);
    req->prop = toInt(VehicleProperty::GEAR_SELECTION);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_actual_gearWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_actual_gear = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_actual_gear");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_actual_gear = static_cast<int32_t>(std::atoi(mp->valueMap[mPropertyManager->getCProValue(mp)].c_str()));
      ALOGE("dxy----- ec_vcu_actual_gear %d",ec_vcu_actual_gear);
      mHal->onPropertyValue(*Create_ec_vcu_actual_gearReq(ec_vcu_actual_gear),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_actual_gearReq(int32_t ec_vcu_actual_gear) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_actual_gear);
    req->prop = toInt(VehicleProperty::CURRENT_GEAR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_bp_statusWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int ec_vcu_bp_status = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_bp_status");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_bp_status = mPropertyManager->getCProValue(mp);
      ALOGE("dxy----- ec_vcu_bp_status %d",ec_vcu_bp_status);
      mHal->onPropertyValue(*Create_ec_vcu_bp_statusReq(ec_vcu_bp_status),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_bp_statusReq(int ec_vcu_bp_status) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_bp_status);
    req->prop = toInt(VehicleProperty::GECKO_VCU_BPSTATUS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_park_faultWatcher() {
  float ec_vcu_park_fault = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_park_fault");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_park_fault = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_vcu_park_faultReq(ec_vcu_park_fault),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_park_faultReq(float ec_vcu_park_fault) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_park_fault);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_park_stateWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_park_state = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_park_state");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_park_state = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_vcu_park_stateReq(ec_vcu_park_state),true);
      LOG(INFO) << "g ec_vcu_park_state: "<<ec_vcu_park_state;

      if(ec_vcu_park_state == 0x01){
        ConfigDBC* mp_spd = mPropertyManager->findCProperty("sc_ccm_vehicle_spd_dsp");
        float sc_ccm_vehicle_spd_dsp = mPropertyManager->getCProValue(mp_spd);

        if(sc_ccm_vehicle_spd_dsp >= 5 && sc_ccm_vehicle_spd_dsp < 255){
          //
          mHal->onPropertyValue(*Create_bc_motion_park_stateReq(1),true);
        }

        mHal->onPropertyValue(*Create_bc_park_chrg_cnctr_stsReq(0),true);
      } else {
        mHal->onPropertyValue(*Create_bc_motion_park_stateReq(0),true);

        // 
        ConfigDBC* mp_chrg = mPropertyManager->findCProperty("ec_vcu_chrg_cnctr_sts");
        int32_t ec_vcu_chrg_cnctr_sts = mPropertyManager->getCProValue(mp_chrg);
        if(ec_vcu_chrg_cnctr_sts != 0){
          //VCU_ParkState = 0 and CU_ChrgCnctrSts = 0
          LOG(INFO) << "VCU_ParkState = 0 and CU_ChrgCnctrSts != 0";
          mHal->onPropertyValue(*Create_bc_park_chrg_cnctr_stsReq(1),true);
        }
      }
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_park_stateReq(int32_t ec_vcu_park_state) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_park_state);
    req->prop = toInt(VehicleProperty::GECKO_VCU_PARKSTATE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_switch_gear_warnWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_switch_gear_warn = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_switch_gear_warn");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_switch_gear_warn = mPropertyManager->getCProValue(mp);
      ALOGE("dxy----- ec_vcu_switch_gear_warn %d",ec_vcu_switch_gear_warn);
      mHal->onPropertyValue(*Create_ec_vcu_switch_gear_warnReq(ec_vcu_switch_gear_warn),true);

  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_switch_gear_warnReq(int32_t ec_vcu_switch_gear_warn) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_switch_gear_warn);
    req->prop = toInt(VehicleProperty::GECKO_VCU_SWITCH_GEAR_WARN);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_delay_mon_modeWatcher() {
  float ec_vcu_delay_mon_mode = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_delay_mon_mode");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_delay_mon_mode = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_vcu_delay_mon_modeReq(ec_vcu_delay_mon_mode),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_delay_mon_modeReq(float ec_vcu_delay_mon_mode) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_delay_mon_mode);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_ap_statusWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int ec_vcu_ap_status = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_ap_status");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_ap_status = mPropertyManager->getCProValue(mp);
      ALOGE("dxy----- ec_vcu_ap_status %d",ec_vcu_ap_status);
      mHal->onPropertyValue(*Create_ec_vcu_ap_statusReq(ec_vcu_ap_status),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_ap_statusReq(int ec_vcu_ap_status) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_ap_status);
    req->prop = toInt(VehicleProperty::GECKO_VCU_APSTATUS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_brk_lamp_ctr_cmdWatcher() {
  float ec_vcu_brk_lamp_ctr_cmd = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_brk_lamp_ctr_cmd");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_brk_lamp_ctr_cmd = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_vcu_brk_lamp_ctr_cmdReq(ec_vcu_brk_lamp_ctr_cmd),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_brk_lamp_ctr_cmdReq(float ec_vcu_brk_lamp_ctr_cmd) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_brk_lamp_ctr_cmd);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_lock_veh_warnWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_lock_veh_warn = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_lock_veh_warn");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_lock_veh_warn = mPropertyManager->getCProValue(mp);
      //LOG(INFO) << "ec_vcu_lock_veh_warn:"<<ec_vcu_lock_veh_warn;
      ALOGE("dxy----- ec_vcu_lock_veh_warn %d",ec_vcu_lock_veh_warn);
      mHal->onPropertyValue(*Create_ec_vcu_lock_veh_warnReq(ec_vcu_lock_veh_warn),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_lock_veh_warnReq(int32_t ec_vcu_lock_veh_warn) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_lock_veh_warn);
    req->prop = toInt(VehicleProperty::GECKO_VCU_LOCK_VEH_WARN);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_creep_stsWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_creep_sts = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_creep_sts");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_creep_sts = mPropertyManager->getCProValue(mp);
      ALOGE("dxy----- ec_vcu_creep_sts %d",ec_vcu_creep_sts);
      mHal->onPropertyValue(*Create_ec_vcu_creep_stsReq(ec_vcu_creep_sts),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_creep_stsReq(int32_t ec_vcu_creep_sts) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_creep_sts);
    req->prop = toInt(VehicleProperty::GECKO_CREEP_STATE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_single_ped_stsWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_single_ped_sts = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_single_ped_sts");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_single_ped_sts = static_cast<int32_t>(std::atoi(mp->valueMap[mPropertyManager->getCProValue(mp)].c_str()));
      ALOGE("dxy----- ec_vcu_single_ped_sts %d",ec_vcu_single_ped_sts);
      mHal->onPropertyValue(*Create_ec_vcu_single_ped_stsReq(ec_vcu_single_ped_sts),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_single_ped_stsReq(int32_t ec_vcu_single_ped_sts) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_single_ped_sts);
    req->prop = toInt(VehicleProperty::GECKO_SINGLE_PED_STATE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_ap_faultWatcher() {
  float ec_vcu_ap_fault = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_ap_fault");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_ap_fault = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_vcu_ap_faultReq(ec_vcu_ap_fault),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_ap_faultReq(float ec_vcu_ap_fault) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_ap_fault);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_bp_faultWatcher() {
  float ec_vcu_bp_fault = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_bp_fault");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_bp_fault = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_vcu_bp_faultReq(ec_vcu_bp_fault),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_bp_faultReq(float ec_vcu_bp_fault) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_bp_fault);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_brk_pdl_posWatcher() {
  float ec_vcu_brk_pdl_pos = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_brk_pdl_pos");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_brk_pdl_pos = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_vcu_brk_pdl_posReq(ec_vcu_brk_pdl_pos),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_brk_pdl_posReq(float ec_vcu_brk_pdl_pos) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_brk_pdl_pos);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_livecounter_0x350Watcher() {
  float ec_vcu_livecounter_0x350 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_livecounter_0x350");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_livecounter_0x350 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_vcu_livecounter_0x350Req(ec_vcu_livecounter_0x350),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_livecounter_0x350Req(float ec_vcu_livecounter_0x350) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_livecounter_0x350);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_checksum_0x350Watcher() {
  float ec_vcu_checksum_0x350 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_checksum_0x350");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_checksum_0x350 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_vcu_checksum_0x350Req(ec_vcu_checksum_0x350),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_checksum_0x350Req(float ec_vcu_checksum_0x350) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_checksum_0x350);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_chrg_stsWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_chrg_sts = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_chrg_sts");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_chrg_sts = mPropertyManager->getCProValue(mp);
      //LOG(INFO) << "ec_vcu_chrg_sts:"<<ec_vcu_chrg_sts;
      mHal->onPropertyValue(*Create_ec_vcu_chrg_stsReq(ec_vcu_chrg_sts),true);
  }
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_chrg_stsReq(int32_t ec_vcu_chrg_sts) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_chrg_sts);
    req->prop = toInt(VehicleProperty::GECKO_VCU_CHRG_STS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

// void GarageModeServerSideHandlerImpl::monitorChargState(){
//     std::this_thread::sleep_for(std::chrono::milliseconds(800));
//     ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_chrg_sts");
//     while(!mShuttingDownFlag.load()){
//         mPropertyManager->getUpdateCState(mp);
//         std::unique_lock<std::mutex> lock(eVcuChrgStsMtx);
//         ecVcuChrgStsCv.notify_all();  // 
//   }
// }
//  
void GarageModeServerSideHandlerImpl::monitorTpmsTyretemperatureState(){
    ConfigDBC* mp = mPropertyManager->findCProperty("bc_tpms_tyretemperature");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        std::unique_lock<std::mutex> lock(bcTpmsTyretemperatureMtx);
        bcTpmsTyretemperatureCv.notify_all();  // 
  }
}


// 1
void GarageModeServerSideHandlerImpl::monitorTpmsTyrepressureFlState(){
    ConfigDBC* mp = mPropertyManager->findCProperty("bc_tpms_tyrepressure_fl");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        std::unique_lock<std::mutex> lock(bcTpmsTyrepressureFlMtx);
        bcTpmsTyrepressureFlCv.notify_all();  // 
  }
}

// 1
void GarageModeServerSideHandlerImpl::monitorTpmsTyrepressureFrState(){
    ConfigDBC* mp = mPropertyManager->findCProperty("bc_tpms_tyrepressure_fr");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        std::unique_lock<std::mutex> lock(bcTpmsTyrepressureFrMtx);
        bcTpmsTyrepressureFrCv.notify_all();  // 
  }
}

// 1
void GarageModeServerSideHandlerImpl::monitorTpmsTyrepressureRlState(){
    ConfigDBC* mp = mPropertyManager->findCProperty("bc_tpms_tyrepressure_rl");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        std::unique_lock<std::mutex> lock(bcTpmsTyrepressureRlMtx);
        bcTpmsTyrepressureRlCv.notify_all();  // 
  }
}

// 1
void GarageModeServerSideHandlerImpl::monitorTpmsTyrepressureRrState(){
    ConfigDBC* mp = mPropertyManager->findCProperty("bc_tpms_tyrepressure_rr");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        std::unique_lock<std::mutex> lock(bcTpmsTyrepressureRrMtx);
        bcTpmsTyrepressureRrCv.notify_all();  // 
  }
}

void GarageModeServerSideHandlerImpl::ec_vcu_pt_rdyWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_pt_rdy = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_pt_rdy");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_pt_rdy = mPropertyManager->getCProValue(mp);
      LOG(INFO) << "ec_vcu_pt_rdy:"<<ec_vcu_pt_rdy;
      mHal->onPropertyValue(*Create_ec_vcu_pt_rdyReq(ec_vcu_pt_rdy),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_pt_rdyReq(int32_t ec_vcu_pt_rdy) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_pt_rdy);
    req->prop = toInt(VehicleProperty::GECKO_VCU_PT_RDY);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_smart_dc_reqWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_smart_dc_req = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_smart_dc_req");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_smart_dc_req = mPropertyManager->getCProValue(mp);
      LOG(INFO) << "ec_vcu_smart_dc_req:"<<ec_vcu_smart_dc_req;
      mHal->onPropertyValue(*Create_ec_vcu_smart_dc_reqReq(ec_vcu_smart_dc_req),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_smart_dc_reqReq(int32_t ec_vcu_smart_dc_req) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_smart_dc_req);
    req->prop = toInt(VehicleProperty::GECKO_VCU_SMART_DC_REQ);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_chrg_soc_tar_spWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int ec_vcu_chrg_soc_tar_sp = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_chrg_soc_tar_sp");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_chrg_soc_tar_sp = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_vcu_chrg_soc_tar_spReq(ec_vcu_chrg_soc_tar_sp),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_chrg_soc_tar_spReq(int32_t ec_vcu_chrg_soc_tar_sp) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_chrg_soc_tar_sp);
    req->prop = toInt(VehicleProperty::GECKO_VCU_CHRG_SOC_TAR_SP);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_dis_chrg_stsWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_dis_chrg_sts = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_dis_chrg_sts");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_dis_chrg_sts = mPropertyManager->getCProValue(mp);
      //LOG(INFO) << "ec_vcu_dis_chrg_sts:"<<ec_vcu_dis_chrg_sts;
      mHal->onPropertyValue(*Create_ec_vcu_dis_chrg_stsReq(ec_vcu_dis_chrg_sts),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_dis_chrg_stsReq(int32_t ec_vcu_dis_chrg_sts) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_dis_chrg_sts);
    req->prop = toInt(VehicleProperty::GECKO_VCU_DIS_CHRG_STS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_average_energy_consum_vdWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_average_energy_consum_vd = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_average_energy_consum_vd");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_average_energy_consum_vd = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_vcu_average_energy_consum_vdReq(ec_vcu_average_energy_consum_vd),true);
  }
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_average_energy_consum_vdReq(int32_t ec_vcu_average_energy_consum_vd) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_average_energy_consum_vd);
    req->prop = toInt(VehicleProperty::GECKO_AVERAGE_ENERGY_CONSUM_VD);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_dc_chrg_rly_auxil_cntac_stsWatcher() {
  float ec_vcu_dc_chrg_rly_auxil_cntac_sts = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_dc_chrg_rly_auxil_cntac_sts");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_dc_chrg_rly_auxil_cntac_sts = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_vcu_dc_chrg_rly_auxil_cntac_stsReq(ec_vcu_dc_chrg_rly_auxil_cntac_sts),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_dc_chrg_rly_auxil_cntac_stsReq(float ec_vcu_dc_chrg_rly_auxil_cntac_sts) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_dc_chrg_rly_auxil_cntac_sts);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_braking_remindWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_braking_remind = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_braking_remind");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_braking_remind = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_vcu_braking_remindReq(ec_vcu_braking_remind),true);
      LOG(INFO)<<"gh ec_vcu_braking_remind:"<<ec_vcu_braking_remind;
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_braking_remindReq(int32_t ec_vcu_braking_remind) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_braking_remind);
    req->prop = toInt(VehicleProperty::GECKO_EV_BRAKING_REMIND);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_average_energy_consumptionWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  float ec_vcu_average_energy_consumption = 0.0;
//  Property* mp = mPropertyManager->findProperty("ec_vcu_average_energy_consumption");
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_average_energy_consumption");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_average_energy_consumption = getActualFloatValue(mPropertyManager->getCProValue(mp),0.1,0);

	  //
	  #if 0
	  if (energyConsumptionFlag) {
          //ALOGI("hqh---- ec_vcu_average_energy_consumption =%f", ec_vcu_average_energy_consumption);
          totalEnergyConsumption = ec_vcu_average_energy_consumption;
          mHal->onPropertyValue(*Create_power_on_average_energy_consumptionReq(totalEnergyConsumption),true);
          } else {
          mHal->onPropertyValue(*Create_power_on_average_energy_consumptionReq(-1024.0),true);
      }
      mHal->onPropertyValue(*Create_ec_vcu_average_energy_consumptionReq(ec_vcu_average_energy_consumption),true);
      std::chrono::milliseconds ms= std::chrono::duration_cast< std::chrono::milliseconds >(
        std::chrono::system_clock::now().time_since_epoch());
      power_on_average_energy_consumption_time = ms.count();
      #endif
      mHal->onPropertyValue(*Create_ec_vcu_average_energy_consumptionReq(ec_vcu_average_energy_consumption),true);
   }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_average_energy_consumptionReq(float ec_vcu_average_energy_consumption) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_average_energy_consumption);
    req->prop = toInt(VehicleProperty::GECKO_AVERAGE_ENERGY_CONSUMPTION);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_instant_energy_consumptionWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  float ec_vcu_instant_energy_consumption = 0.0;
//  Property* mp = mPropertyManager->findProperty("ec_vcu_instant_energy_consumption");
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_instant_energy_consumption");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      int32_t value = mPropertyManager->getCProValue(mp);
      if(value!=511) {
          ec_vcu_instant_energy_consumption = getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp),0.1, -51.1);
      } else {
          ec_vcu_instant_energy_consumption = 0.0;
      }
      consumption = ec_vcu_instant_energy_consumption;
      LOG(INFO) << "dxy---- ec_vcu_instant_energy_consumption:" << ec_vcu_instant_energy_consumption;
      mHal->onPropertyValue(*Create_ec_vcu_instant_energy_consumptionReq(ec_vcu_instant_energy_consumption),true);
      isEnergyConsumption = true;

  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_instant_energy_consumptionReq(float ec_vcu_instant_energy_consumption) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_instant_energy_consumption);
    req->prop = toInt(VehicleProperty::GECKO_INSTANCE_ENERGY_CONSUMPTION);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_instant_energy_consum_vdWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_instant_energy_consum_vd = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_instant_energy_consum_vd");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_instant_energy_consum_vd = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_vcu_instant_energy_consum_vdReq(ec_vcu_instant_energy_consum_vd),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_instant_energy_consum_vdReq(int32_t ec_vcu_instant_energy_consum_vd) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_instant_energy_consum_vd);
    req->prop = toInt(VehicleProperty::GECKO_INSTANT_ENERGY_CONSUM_VD);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}


void GarageModeServerSideHandlerImpl::ec_vcu_livecounter_0x351Watcher() {
  float ec_vcu_livecounter_0x351 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_livecounter_0x351");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_livecounter_0x351 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_vcu_livecounter_0x351Req(ec_vcu_livecounter_0x351),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_livecounter_0x351Req(float ec_vcu_livecounter_0x351) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_livecounter_0x351);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_checksum_0x351Watcher() {
  float ec_vcu_checksum_0x351 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_checksum_0x351");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_checksum_0x351 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_vcu_checksum_0x351Req(ec_vcu_checksum_0x351),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_checksum_0x351Req(float ec_vcu_checksum_0x351) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_checksum_0x351);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ccm_veh_tar_socWatcher() {
  float ec_ccm_veh_tar_soc = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccm_veh_tar_soc");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ccm_veh_tar_soc = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ccm_veh_tar_socReq(ec_ccm_veh_tar_soc),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccm_veh_tar_socReq(float ec_ccm_veh_tar_soc) {
    auto req = mValueObjectPool->obtainFloat(ec_ccm_veh_tar_soc);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ccm_batt_maintain_ctr_cmdWatcher() {
  float ec_ccm_batt_maintain_ctr_cmd = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccm_batt_maintain_ctr_cmd");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ccm_batt_maintain_ctr_cmd = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ccm_batt_maintain_ctr_cmdReq(ec_ccm_batt_maintain_ctr_cmd),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccm_batt_maintain_ctr_cmdReq(float ec_ccm_batt_maintain_ctr_cmd) {
    auto req = mValueObjectPool->obtainFloat(ec_ccm_batt_maintain_ctr_cmd);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ota_modelWatcher() {
  float ec_ota_model = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ota_model");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ota_model = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ota_modelReq(ec_ota_model),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ota_modelReq(float ec_ota_model) {
    auto req = mValueObjectPool->obtainFloat(ec_ota_model);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ccm_rechrgn_lv_reqWatcher() {
  float ec_ccm_rechrgn_lv_req = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccm_rechrgn_lv_req");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ccm_rechrgn_lv_req = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ccm_rechrgn_lv_reqReq(ec_ccm_rechrgn_lv_req),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccm_rechrgn_lv_reqReq(float ec_ccm_rechrgn_lv_req) {
    auto req = mValueObjectPool->obtainFloat(ec_ccm_rechrgn_lv_req);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ccm_driver_buckle_statusWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_ccm_driver_buckle_status = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccm_driver_buckle_status");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      //notice
      ec_ccm_driver_buckle_status = static_cast<int32_t> (mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_ccm_driver_buckle_statusReq(ec_ccm_driver_buckle_status, 1),true);
      mHal->onPropertyValue(*Create_ec_ccm_driver_buckle_statusReq(ec_ccm_driver_buckle_status, 4),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccm_driver_buckle_statusReq(int32_t ec_ccm_driver_buckle_status, int32_t areaId) {
    auto req = mValueObjectPool->obtainInt32(ec_ccm_driver_buckle_status);
    req->prop = toInt(VehicleProperty::SEAT_BELT_BUCKLED);
    req->areaId = areaId;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ccm_drive_mode_reqWatcher() {
  float ec_ccm_drive_mode_req = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccm_drive_mode_req");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ccm_drive_mode_req = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ccm_drive_mode_reqReq(ec_ccm_drive_mode_req),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccm_drive_mode_reqReq(float ec_ccm_drive_mode_req) {
    auto req = mValueObjectPool->obtainFloat(ec_ccm_drive_mode_req);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ccm_operat_licenceWatcher() {
  float ec_ccm_operat_licence = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccm_operat_licence");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ccm_operat_licence = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ccm_operat_licenceReq(ec_ccm_operat_licence),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccm_operat_licenceReq(float ec_ccm_operat_licence) {
    auto req = mValueObjectPool->obtainFloat(ec_ccm_operat_licence);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ccm_versionWatcher() {
  float ec_ccm_version = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccm_version");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ccm_version = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ccm_versionReq(ec_ccm_version),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccm_versionReq(float ec_ccm_version) {
    auto req = mValueObjectPool->obtainFloat(ec_ccm_version);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ccm_speed_limit_levelWatcher() {
  float ec_ccm_speed_limit_level = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccm_speed_limit_level");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ccm_speed_limit_level = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ccm_speed_limit_levelReq(ec_ccm_speed_limit_level),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccm_speed_limit_levelReq(float ec_ccm_speed_limit_level) {
    auto req = mValueObjectPool->obtainFloat(ec_ccm_speed_limit_level);
    req->prop = toInt(VehicleProperty::GECKO_MCU_SPEED_LIMIT_LEVEL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ccm_charging_conditionsWatcher() {
  float ec_ccm_charging_conditions = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccm_charging_conditions");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ccm_charging_conditions = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ccm_charging_conditionsReq(ec_ccm_charging_conditions),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccm_charging_conditionsReq(float ec_ccm_charging_conditions) {
    auto req = mValueObjectPool->obtainFloat(ec_ccm_charging_conditions);
    req->prop = toInt(VehicleProperty::GECKO_MCU_CHARGING_CONDIONS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_total_odometerWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  float ec_total_odometer = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_total_odometer");
  //  "gecko.total.mileage" 
   std::string totalMileageStr = android::base::GetProperty("gecko.total.mileage", "0.0");
   float floatTotalMileage = std::stof(totalMileageStr);
   LOG(INFO) << "dxy---- gecko.total.mileage:" <<floatTotalMileage;
  //  std::this_thread::sleep_for(std::chrono::milliseconds(1600));             // 10001600crash
  //  mHal->onPropertyValue(*Create_ec_total_odometerReq(floatTotalMileage),true);
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_total_odometer = getActualFloatValue(mPropertyManager->getCProValue(mp),0.1,0);
      mHal->onPropertyValue(*Create_ec_total_odometerReq(ec_total_odometer),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_total_odometerReq(float ec_total_odometer) {
    auto req = mValueObjectPool->obtainFloat(ec_total_odometer);
    req->prop = toInt(VehicleProperty::PERF_ODOMETER);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_power_on_milegeReq(float power_on_milege){
  auto req = mValueObjectPool->obtainFloat(power_on_milege);
  req->prop = toInt(VehicleProperty::GECKO_POWER_ON_MILEGE);
  req->areaId = 0;
  req->timestamp = elapsedRealtimeNano();
  req->status = VehiclePropertyStatus::AVAILABLE;
  return req;
}

void GarageModeServerSideHandlerImpl::mc_travel_short_rangeWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(6000));
  float mc_travel_short_range = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("mcu_short_travel_mileage");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      mc_travel_short_range = getActualFloatValue(mPropertyManager->getCProValue(mp), 0.1, 0);
      LOG(INFO) << "mcu_short_travel_mileage:"<< mc_travel_short_range;
      mHal->onPropertyValue(*Create_power_on_milegeReq(mc_travel_short_range),true);
  }
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_power_on_average_speedReq(int32_t power_on_average_speed){
  auto req = mValueObjectPool->obtainInt32(power_on_average_speed);
  req->prop = toInt(VehicleProperty::GECKO_POWER_ON_AVERAGE_SPEED);
  req->areaId = 0;
  req->timestamp = elapsedRealtimeNano();
  req->status = VehiclePropertyStatus::AVAILABLE;
  return req;
}
void GarageModeServerSideHandlerImpl::mc_travel_short_average_speedWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(6000));
  float mc_travel_short_av_spd = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("mcu_short_average_spd");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      mc_travel_short_av_spd = getActualFloatValue(mPropertyManager->getCProValue(mp), 0.1, 0);
      LOG(INFO) << "mcu_short_average_spd:"<< mc_travel_short_av_spd;
      mHal->onPropertyValue(*Create_power_on_average_speedReq(mc_travel_short_av_spd),true);
  }
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_power_on_average_energy_consumptionReq(float ec_total_odometer){
  auto req = mValueObjectPool->obtainFloat(ec_total_odometer);
  req->prop = toInt(VehicleProperty::GECKO_POWER_ON_AVERAGE_ENERGY_CONSUMPTION);
  req->areaId = 0;
  req->timestamp = elapsedRealtimeNano();
  req->status = VehiclePropertyStatus::AVAILABLE;
  return req;
}
void GarageModeServerSideHandlerImpl::mc_travel_short_average_pwr_consum_Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(6000));
  float mc_travel_short_pw_consum = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("mcu_short_average_consum");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      mc_travel_short_pw_consum = getActualFloatValue(mPropertyManager->getCProValue(mp), 0.1, 0);
      LOG(INFO) << "mcu_short_average_consum:"<< mc_travel_short_pw_consum;
      mHal->onPropertyValue(*Create_power_on_average_energy_consumptionReq(mc_travel_short_pw_consum),true);
  }
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_power_on_timeReq(int32_t power_on_time){
  auto req = mValueObjectPool->obtainInt32(power_on_time);
  req->prop = toInt(VehicleProperty::GECKO_POWER_ON_TIME);
  req->areaId = 0;
  req->timestamp = elapsedRealtimeNano();
  req->status = VehiclePropertyStatus::AVAILABLE;
  return req;
}
void GarageModeServerSideHandlerImpl::mc_travel_short_timeWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(6000));
  int32_t mc_short_travel_time = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("mcu_short_travel_time");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      mc_short_travel_time = mPropertyManager->getCProValue(mp);
      LOG(INFO) << "mcu_short_travel_time:"<< mc_short_travel_time;
      if(mc_short_travel_time <= 65535) {
           mHal->onPropertyValue(*Create_power_on_timeReq(mc_short_travel_time),true);
      }
  }
}


void GarageModeServerSideHandlerImpl::ec_ccm_target_chrg_currWatcher() {
  float ec_ccm_target_chrg_curr = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccm_target_chrg_curr");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ccm_target_chrg_curr = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ccm_target_chrg_currReq(ec_ccm_target_chrg_curr),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccm_target_chrg_currReq(float ec_ccm_target_chrg_curr) {
    auto req = mValueObjectPool->obtainFloat(ec_ccm_target_chrg_curr);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ccm_batt_maintain_stsWatcher() {
  float ec_ccm_batt_maintain_sts = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccm_batt_maintain_sts");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ccm_batt_maintain_sts = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ccm_batt_maintain_stsReq(ec_ccm_batt_maintain_sts),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccm_batt_maintain_stsReq(float ec_ccm_batt_maintain_sts) {
    auto req = mValueObjectPool->obtainFloat(ec_ccm_batt_maintain_sts);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ccm_livecounter_0x353Watcher() {
  float ec_ccm_livecounter_0x353 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccm_livecounter_0x353");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ccm_livecounter_0x353 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ccm_livecounter_0x353Req(ec_ccm_livecounter_0x353),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccm_livecounter_0x353Req(float ec_ccm_livecounter_0x353) {
    auto req = mValueObjectPool->obtainFloat(ec_ccm_livecounter_0x353);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ccm_checksum_0x353Watcher() {
  float ec_ccm_checksum_0x353 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccm_checksum_0x353");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ccm_checksum_0x353 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ccm_checksum_0x353Req(ec_ccm_checksum_0x353),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccm_checksum_0x353Req(float ec_ccm_checksum_0x353) {
    auto req = mValueObjectPool->obtainFloat(ec_ccm_checksum_0x353);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ccm_remt_ctrl_flagWatcher() {
  float ec_ccm_remt_ctrl_flag = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccm_remt_ctrl_flag");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ccm_remt_ctrl_flag = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ccm_remt_ctrl_flagReq(ec_ccm_remt_ctrl_flag),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccm_remt_ctrl_flagReq(float ec_ccm_remt_ctrl_flag) {
    auto req = mValueObjectPool->obtainFloat(ec_ccm_remt_ctrl_flag);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ccm_charging_requestWatcher() {
  float ec_ccm_charging_request = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccm_charging_request");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ccm_charging_request = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ccm_charging_requestReq(ec_ccm_charging_request),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccm_charging_requestReq(float ec_ccm_charging_request) {
    auto req = mValueObjectPool->obtainFloat(ec_ccm_charging_request);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ccm_chraging_modeWatcher() {
  float ec_ccm_chraging_mode = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccm_chraging_mode");
  if(!mp) return;  
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ccm_chraging_mode = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ccm_chraging_modeReq(ec_ccm_chraging_mode),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccm_chraging_modeReq(float ec_ccm_chraging_mode) {
    auto req = mValueObjectPool->obtainFloat(ec_ccm_chraging_mode);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ccm_energy_recov_level_cmdWatcher() {
  float ec_ccm_energy_recov_level_cmd = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccm_energy_recov_level_cmd");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ccm_energy_recov_level_cmd = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ccm_energy_recov_level_cmdReq(ec_ccm_energy_recov_level_cmd),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccm_energy_recov_level_cmdReq(float ec_ccm_energy_recov_level_cmd) {
    auto req = mValueObjectPool->obtainFloat(ec_ccm_energy_recov_level_cmd);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ccm_creep_ctr_cmdWatcher() {
  float ec_ccm_creep_ctr_cmd = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccm_creep_ctr_cmd");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ccm_creep_ctr_cmd = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ccm_creep_ctr_cmdReq(ec_ccm_creep_ctr_cmd),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccm_creep_ctr_cmdReq(float ec_ccm_creep_ctr_cmd) {
    auto req = mValueObjectPool->obtainFloat(ec_ccm_creep_ctr_cmd);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ccm_single_ped_ctr_cmdWatcher() {
  float ec_ccm_single_ped_ctr_cmd = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccm_single_ped_ctr_cmd");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ccm_single_ped_ctr_cmd = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ccm_single_ped_ctr_cmdReq(ec_ccm_single_ped_ctr_cmd),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccm_single_ped_ctr_cmdReq(float ec_ccm_single_ped_ctr_cmd) {
    auto req = mValueObjectPool->obtainFloat(ec_ccm_single_ped_ctr_cmd);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ccm_rema_range_dispWatcher() {
  float ec_ccm_rema_range_disp = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccm_rema_range_disp");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ccm_rema_range_disp = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ccm_rema_range_dispReq(ec_ccm_rema_range_disp),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccm_rema_range_dispReq(float ec_ccm_rema_range_disp) {
    auto req = mValueObjectPool->obtainFloat(ec_ccm_rema_range_disp);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ccm_rema_range_disp_vdWatcher() {
  float ec_ccm_rema_range_disp_vd = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccm_rema_range_disp_vd");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ccm_rema_range_disp_vd = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ccm_rema_range_disp_vdReq(ec_ccm_rema_range_disp_vd),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccm_rema_range_disp_vdReq(float ec_ccm_rema_range_disp_vd) {
    auto req = mValueObjectPool->obtainFloat(ec_ccm_rema_range_disp_vd);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ccm_livecounter_0x354Watcher() {
  float ec_ccm_livecounter_0x354 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccm_livecounter_0x354");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ccm_livecounter_0x354 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ccm_livecounter_0x354Req(ec_ccm_livecounter_0x354),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccm_livecounter_0x354Req(float ec_ccm_livecounter_0x354) {
    auto req = mValueObjectPool->obtainFloat(ec_ccm_livecounter_0x354);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ccm_checksum_0x354Watcher() {
  float ec_ccm_checksum_0x354 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccm_checksum_0x354");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ccm_checksum_0x354 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ccm_checksum_0x354Req(ec_ccm_checksum_0x354),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccm_checksum_0x354Req(float ec_ccm_checksum_0x354) {
    auto req = mValueObjectPool->obtainFloat(ec_ccm_checksum_0x354);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_drive_modeWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_drive_mode = 0;
//  Property* mp = mPropertyManager->findProperty("ec_vcu_drive_mode");
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_drive_mode");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_drive_mode = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_vcu_drive_modeReq(ec_vcu_drive_mode),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_drive_modeReq(int32_t ec_vcu_drive_mode) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_drive_mode);
    req->prop = toInt(VehicleProperty::GECKO_VEHICLE_DRIVE_MODE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_low_soc_warnWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_low_soc_warn = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_low_soc_warn");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_low_soc_warn = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      //mHal->onPropertyValue(*Create_ec_vcu_low_soc_warnReq(ec_vcu_low_soc_warn),true);
      mHal->onPropertyValue(*Create_ec_batterylowsignalReq(ec_vcu_low_soc_warn),true);
      ALOGE("ec_vcu_low_soc_warnWatcher ec_vcu_low_soc_warn:%d", ec_vcu_low_soc_warn);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_low_soc_warnReq(int32_t ec_vcu_low_soc_warn) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_low_soc_warn);
    req->prop = toInt(VehicleProperty::GECKO_VCU_LOW_SOC_WARN);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_can_timeout_faultWatcher() {
  float ec_vcu_can_timeout_fault = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_can_timeout_fault");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_can_timeout_fault = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_vcu_can_timeout_faultReq(ec_vcu_can_timeout_fault),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_can_timeout_faultReq(float ec_vcu_can_timeout_fault) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_can_timeout_fault);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_eas_ins_staWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_eas_ins_sta = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_eas_ins_sta");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_eas_ins_sta = mPropertyManager->getCProValue(mp);
      LOG(INFO) << "ec_vcu_eas_ins_sta:"<<ec_vcu_eas_ins_sta;
      mHal->onPropertyValue(*Create_ec_vcu_eas_ins_staReq(ec_vcu_eas_ins_sta),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_eas_ins_staReq(int32_t ec_vcu_eas_ins_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_eas_ins_sta);
    req->prop = toInt(VehicleProperty::GECKO_VCU_EAS_INS_STA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_dc_discharging_fail_warnWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_dc_discharging_fail_warn = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_dc_discharging_fail_warn");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_dc_discharging_fail_warn = mPropertyManager->getCProValue(mp);
      LOG(INFO) << "ec_vcu_dc_discharging_fail_warn:"<<ec_vcu_dc_discharging_fail_warn;
      mHal->onPropertyValue(*Create_ec_vcu_dc_discharging_fail_warnReq(ec_vcu_dc_discharging_fail_warn),true);

  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_dc_discharging_fail_warnReq(int32_t ec_vcu_dc_discharging_fail_warn) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_dc_discharging_fail_warn);
    req->prop = toInt(VehicleProperty::GECKO_VCU_DC_DISCHARGING_FAIL_WARN);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_dc_charging_fail_warnWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_dc_charging_fail_warn = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_dc_charging_fail_warn");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_dc_charging_fail_warn = mPropertyManager->getCProValue(mp);
      LOG(INFO) << "ec_vcu_dc_charging_fail_warn:"<<ec_vcu_dc_charging_fail_warn;
      mHal->onPropertyValue(*Create_ec_vcu_dc_charging_fail_warnReq(ec_vcu_dc_charging_fail_warn),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_dc_charging_fail_warnReq(int32_t ec_vcu_dc_charging_fail_warn) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_dc_charging_fail_warn);
    req->prop = toInt(VehicleProperty::GECKO_VCU_DC_CHARGING_FAIL_WARN);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_ac_charging_fail_warnWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_ac_charging_fail_warn = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_ac_charging_fail_warn");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_ac_charging_fail_warn = mPropertyManager->getCProValue(mp);
      LOG(INFO) << "ec_vcu_ac_charging_fail_warn:"<<ec_vcu_ac_charging_fail_warn;
      mHal->onPropertyValue(*Create_ec_vcu_ac_charging_fail_warnReq(ec_vcu_ac_charging_fail_warn),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_ac_charging_fail_warnReq(int32_t ec_vcu_ac_charging_fail_warn) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_ac_charging_fail_warn);
    req->prop = toInt(VehicleProperty::GECKO_VCU_AC_CHARGING_FAIL_WARN);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_12_v_charging_fail_warnWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_12_v_charging_fail_warn = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_12_v_charging_fail_warn");
  while(!mShuttingDownFlag.load()){
    mPropertyManager->getUpdateCState(mp);
    ec_vcu_12_v_charging_fail_warn = mPropertyManager->getCProValue(mp);
    //LOG(INFO) << "ec_vcu_12_v_charging_fail_warn:"<<ec_vcu_12_v_charging_fail_warn;
    mHal->onPropertyValue(*Create_ec_vcu_12_v_charging_fail_warnReq(ec_vcu_12_v_charging_fail_warn),true);

  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_12_v_charging_fail_warnReq(int32_t ec_vcu_12_v_charging_fail_warn) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_12_v_charging_fail_warn);
    req->prop = toInt(VehicleProperty::GECKO_VCU_12_V_CHARGING_FAIL_WARN);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_veh_unable_dri_warnWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_veh_unable_dri_warn = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_veh_unable_dri_warn");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_veh_unable_dri_warn = mPropertyManager->getCProValue(mp);
      LOG(INFO) << "ec_vcu_veh_unable_dri_warn:"<<ec_vcu_veh_unable_dri_warn;
      mHal->onPropertyValue(*Create_ec_vcu_veh_unable_dri_warnReq(ec_vcu_veh_unable_dri_warn),true);

  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_veh_unable_dri_warnReq(int32_t ec_vcu_veh_unable_dri_warn) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_veh_unable_dri_warn);
    req->prop = toInt(VehicleProperty::GECKO_VCU_VEH_UNABLE_DRI_WARN);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_brk_liquid_level_lowWatcher() {
  float ec_vcu_brk_liquid_level_low = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_brk_liquid_level_low");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_brk_liquid_level_low = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_vcu_brk_liquid_level_lowReq(ec_vcu_brk_liquid_level_low),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_brk_liquid_level_lowReq(float ec_vcu_brk_liquid_level_low) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_brk_liquid_level_low);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_fault_codeWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_fault_code {0};
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_fault_code");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_fault_code = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_vcu_fault_codeReq(ec_vcu_fault_code),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_fault_codeReq(int32_t ec_vcu_fault_code) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_fault_code);
    req->prop = toInt(VehicleProperty::GECKO_VCU_FAULT_CODE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_fault_treat_levelWatcher() {
  float ec_vcu_fault_treat_level = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_fault_treat_level");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_fault_treat_level = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_vcu_fault_treat_levelReq(ec_vcu_fault_treat_level),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_fault_treat_levelReq(float ec_vcu_fault_treat_level) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_fault_treat_level);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_drive_pwr_limWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_drive_pwr_lim = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_drive_pwr_lim");
  while(!mShuttingDownFlag.load()){
    mPropertyManager->getUpdateCState(mp);
    ec_vcu_drive_pwr_lim = mPropertyManager->getCProValue(mp);
    //LOG(INFO) << "ec_vcu_drive_pwr_lim:"<<ec_vcu_drive_pwr_lim;
    mHal->onPropertyValue(*Create_ec_vcu_drive_pwr_limReq(ec_vcu_drive_pwr_lim),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_drive_pwr_limReq(int32_t ec_vcu_drive_pwr_lim) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_drive_pwr_lim);
    req->prop = toInt(VehicleProperty::GECKO_VCU_DRIVE_PWR_LIM);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_mcu_errWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_mcu_err = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_mcu_err");
  while(!mShuttingDownFlag.load()){
    mPropertyManager->getUpdateCState(mp);
    ec_vcu_mcu_err = mPropertyManager->getCProValue(mp);
    //LOG(INFO) << "ec_vcu_mcu_err:"<<ec_vcu_mcu_err;
    mHal->onPropertyValue(*Create_ec_vcu_mcu_errReq(ec_vcu_mcu_err),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_mcu_errReq(int32_t ec_vcu_mcu_err) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_mcu_err);
    req->prop = toInt(VehicleProperty::GECKO_VCU_MCU_ERR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_hv_batt_errWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_hv_batt_err = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_hv_batt_err");
  while(!mShuttingDownFlag.load()){
    mPropertyManager->getUpdateCState(mp);
    ec_vcu_hv_batt_err = mPropertyManager->getCProValue(mp);
    //LOG(INFO) << "ec_vcu_hv_batt_err:"<<ec_vcu_hv_batt_err;
    mHal->onPropertyValue(*Create_ec_vcu_hv_batt_errReq(ec_vcu_hv_batt_err),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_hv_batt_errReq(int32_t ec_vcu_hv_batt_err) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_hv_batt_err);
    req->prop = toInt(VehicleProperty::GECKO_VCU_HV_BATT_ERR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_speed_limit_levelWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_speed_limit_level = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_speed_limit_level");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_speed_limit_level = static_cast<int32_t>(std::atoi(mp->valueMap[mPropertyManager->getCProValue(mp)].c_str()));
      mHal->onPropertyValue(*Create_ec_vcu_speed_limit_levelReq(ec_vcu_speed_limit_level),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_speed_limit_levelReq(int32_t ec_vcu_speed_limit_level) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_speed_limit_level);
    req->prop = toInt(VehicleProperty::GECKO_MCU_SPEED_LIMIT_LEVEL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_charging_conditionsWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_charging_conditions = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_charging_conditions");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_charging_conditions = static_cast<int32_t>(std::atoi(mp->valueMap[mPropertyManager->getCProValue(mp)].c_str()));
      mHal->onPropertyValue(*Create_ec_vcu_charging_conditionsReq(ec_vcu_charging_conditions),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_charging_conditionsReq(int32_t ec_vcu_charging_conditions) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_charging_conditions);
    req->prop = toInt(VehicleProperty::GECKO_MCU_CHARGING_CONDIONS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_livecounter_0x352Watcher() {
  float ec_vcu_livecounter_0x352 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_livecounter_0x352");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_livecounter_0x352 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_vcu_livecounter_0x352Req(ec_vcu_livecounter_0x352),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_livecounter_0x352Req(float ec_vcu_livecounter_0x352) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_livecounter_0x352);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_checksum_0x352Watcher() {
  float ec_vcu_checksum_0x352 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_checksum_0x352");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_checksum_0x352 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_vcu_checksum_0x352Req(ec_vcu_checksum_0x352),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_checksum_0x352Req(float ec_vcu_checksum_0x352) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_checksum_0x352);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_comp_neg_rel_staWatcher() {
  float ec_vcu_comp_neg_rel_sta = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_comp_neg_rel_sta");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_comp_neg_rel_sta = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_vcu_comp_neg_rel_staReq(ec_vcu_comp_neg_rel_sta),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_comp_neg_rel_staReq(float ec_vcu_comp_neg_rel_sta) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_comp_neg_rel_sta);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_comp_pos_rel_staWatcher() {
  float ec_vcu_comp_pos_rel_sta = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_comp_pos_rel_sta");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_comp_pos_rel_sta = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_vcu_comp_pos_rel_staReq(ec_vcu_comp_pos_rel_sta),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_comp_pos_rel_staReq(float ec_vcu_comp_pos_rel_sta) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_comp_pos_rel_sta);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_ipu_errWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_ipu_err = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_ipu_err");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_ipu_err = mPropertyManager->getCProValue(mp);
      LOG(INFO) << "ec_vcu_ipu_err:"<<ec_vcu_ipu_err;
      mHal->onPropertyValue(*Create_ec_vcu_ipu_errReq(ec_vcu_ipu_err),true);

  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_ipu_errReq(int32_t ec_vcu_ipu_err) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_ipu_err);
    req->prop = toInt(VehicleProperty::GECKO_VCU_IPU_ERR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_cooling_fail_warnWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_cooling_fail_warn = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_cooling_fail_warn");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_cooling_fail_warn = mPropertyManager->getCProValue(mp);
      LOG(INFO) << "ec_vcu_cooling_fail_warn:"<<ec_vcu_cooling_fail_warn;
      mHal->onPropertyValue(*Create_ec_vcu_cooling_fail_warnReq(ec_vcu_cooling_fail_warn),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_cooling_fail_warnReq(int32_t ec_vcu_cooling_fail_warn) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_cooling_fail_warn);
    req->prop = toInt(VehicleProperty::GECKO_VCU_COOLING_FAIL_WARN);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_lv_elec_sys_errWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_lv_elec_sys_err = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_lv_elec_sys_err");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_lv_elec_sys_err = mPropertyManager->getCProValue(mp);
      LOG(INFO) << "ec_vcu_lv_elec_sys_err:"<<ec_vcu_lv_elec_sys_err;
      mHal->onPropertyValue(*Create_ec_vcu_lv_elec_sys_errReq(ec_vcu_lv_elec_sys_err),true);
      mHal->onPropertyValue(*Create_electric_errReq(getElectricErr()),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_lv_elec_sys_errReq(int32_t ec_vcu_lv_elec_sys_err) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_lv_elec_sys_err);
    req->prop = toInt(VehicleProperty::GECKO_VCU_LV_ELEC_SYS_ERR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_ac_hv_sys_errWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_ac_hv_sys_err = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_ac_hv_sys_err");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_ac_hv_sys_err = mPropertyManager->getCProValue(mp);
      LOG(INFO) << "ec_vcu_ac_hv_sys_err:"<<ec_vcu_ac_hv_sys_err;
      mHal->onPropertyValue(*Create_ec_vcu_ac_hv_sys_errReq(ec_vcu_ac_hv_sys_err),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_ac_hv_sys_errReq(int32_t ec_vcu_ac_hv_sys_err) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_ac_hv_sys_err);
    req->prop = toInt(VehicleProperty::GECKO_VCU_AC_HV_SYS_ERR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_highpower_voltageWatcher() {
  float ec_vcu_highpower_voltage = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_highpower_voltage");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_highpower_voltage = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_vcu_highpower_voltageReq(ec_vcu_highpower_voltage),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_highpower_voltageReq(float ec_vcu_highpower_voltage) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_highpower_voltage);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_water_pump_relay_pin_stsWatcher() {
  float ec_vcu_water_pump_relay_pin_sts = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_water_pump_relay_pin_sts");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_water_pump_relay_pin_sts = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_vcu_water_pump_relay_pin_stsReq(ec_vcu_water_pump_relay_pin_sts),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_water_pump_relay_pin_stsReq(float ec_vcu_water_pump_relay_pin_sts) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_water_pump_relay_pin_sts);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_awake_obc_pin_stsWatcher() {
  float ec_vcu_awake_obc_pin_sts = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_awake_obc_pin_sts");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_awake_obc_pin_sts = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_vcu_awake_obc_pin_stsReq(ec_vcu_awake_obc_pin_sts),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_awake_obc_pin_stsReq(float ec_vcu_awake_obc_pin_sts) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_awake_obc_pin_sts);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_awake_bms_pin_stsWatcher() {
  float ec_vcu_awake_bms_pin_sts = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_awake_bms_pin_sts");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_awake_bms_pin_sts = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_vcu_awake_bms_pin_stsReq(ec_vcu_awake_bms_pin_sts),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_awake_bms_pin_stsReq(float ec_vcu_awake_bms_pin_sts) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_awake_bms_pin_sts);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_awake_mcu_pin_stsWatcher() {
  float ec_vcu_awake_mcu_pin_sts = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_awake_mcu_pin_sts");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_awake_mcu_pin_sts = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_vcu_awake_mcu_pin_stsReq(ec_vcu_awake_mcu_pin_sts),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_awake_mcu_pin_stsReq(float ec_vcu_awake_mcu_pin_sts) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_awake_mcu_pin_sts);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_main_relay_pin_stsWatcher() {
  float ec_vcu_main_relay_pin_sts = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_main_relay_pin_sts");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_main_relay_pin_sts = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_vcu_main_relay_pin_stsReq(ec_vcu_main_relay_pin_sts),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_main_relay_pin_stsReq(float ec_vcu_main_relay_pin_sts) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_main_relay_pin_sts);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_dc_chrg_awake_pin_stsWatcher() {
  float ec_vcu_dc_chrg_awake_pin_sts = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_dc_chrg_awake_pin_sts");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_dc_chrg_awake_pin_sts = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_vcu_dc_chrg_awake_pin_stsReq(ec_vcu_dc_chrg_awake_pin_sts),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_dc_chrg_awake_pin_stsReq(float ec_vcu_dc_chrg_awake_pin_sts) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_dc_chrg_awake_pin_sts);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_ac_chrg_awake_pin_stsWatcher() {
  float ec_vcu_ac_chrg_awake_pin_sts = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_ac_chrg_awake_pin_sts");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_ac_chrg_awake_pin_sts = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_vcu_ac_chrg_awake_pin_stsReq(ec_vcu_ac_chrg_awake_pin_sts),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_ac_chrg_awake_pin_stsReq(float ec_vcu_ac_chrg_awake_pin_sts) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_ac_chrg_awake_pin_sts);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_livecounter_0x215Watcher() {
  float ec_vcu_livecounter_0x215 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_livecounter_0x215");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_livecounter_0x215 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_vcu_livecounter_0x215Req(ec_vcu_livecounter_0x215),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_livecounter_0x215Req(float ec_vcu_livecounter_0x215) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_livecounter_0x215);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_checksum_0x215Watcher() {
  float ec_vcu_checksum_0x215 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_checksum_0x215");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_checksum_0x215 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_vcu_checksum_0x215Req(ec_vcu_checksum_0x215),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_checksum_0x215Req(float ec_vcu_checksum_0x215) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_checksum_0x215);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_pump_stateWatcher() {
  float ec_vcu_pump_state = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_pump_state");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_pump_state = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_vcu_pump_stateReq(ec_vcu_pump_state),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_pump_stateReq(float ec_vcu_pump_state) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_pump_state);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_mid_door_ajar_statusWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_mid_door_ajar_status = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_mid_door_ajar_status");
  ConfigDBC* mp_spd = mPropertyManager->findCProperty("sc_ccm_vehicle_spd_dsp");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_mid_door_ajar_status = mPropertyManager->getCProValue(mp);
      LOG(INFO) << "ec_vcu_mid_door_ajar_status:"<<ec_vcu_mid_door_ajar_status;
      if(ec_vcu_mid_door_ajar_status == 1){
        float speed = mPropertyManager->getCProValue(mp_spd);
        if(speed >= 3.0){
          mHal->onPropertyValue(*Create_ec_vcu_mid_door_ajar_statusReq(2),true);
        }else {
          mHal->onPropertyValue(*Create_ec_vcu_mid_door_ajar_statusReq(1),true);
        }
      }
      else{
        mHal->onPropertyValue(*Create_ec_vcu_mid_door_ajar_statusReq(ec_vcu_mid_door_ajar_status),true);
      }
      
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_mid_door_ajar_statusReq(int32_t ec_vcu_mid_door_ajar_status) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_mid_door_ajar_status);
    req->prop = toInt(VehicleProperty::GECKO_MID_DOOR_AJAR_STATUS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_actual_rema_range_vdWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_actual_rema_range_vd = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_actual_rema_range_vd");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_actual_rema_range_vd = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_vcu_actual_rema_range_vdReq(ec_vcu_actual_rema_range_vd),true);
  }
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_actual_rema_range_vdReq(int32_t ec_vcu_actual_rema_range_vd) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_actual_rema_range_vd);
    req->prop = toInt(VehicleProperty::GECKO_EV_VCU_ACTUAL_REMA_RANGE_VD);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_cltc_rema_range_vdWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_cltc_rema_range_vd = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_cltc_rema_range_vd");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_cltc_rema_range_vd = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_vcu_cltc_rema_range_vdReq(ec_vcu_cltc_rema_range_vd),true);
  }
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_cltc_rema_range_vdReq(int32_t ec_vcu_cltc_rema_range_vd) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_cltc_rema_range_vd);
    req->prop = toInt(VehicleProperty::GECKO_EV_VCU_CLTC_REMA_RANGE_VD);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_pt_cenableWatcher() {
  float ec_vcu_pt_cenable = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_pt_cenable");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_pt_cenable = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_vcu_pt_cenableReq(ec_vcu_pt_cenable),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_pt_cenableReq(float ec_vcu_pt_cenable) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_pt_cenable);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_accmenableWatcher() {
  float ec_vcu_accmenable = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_accmenable");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_accmenable = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_vcu_accmenableReq(ec_vcu_accmenable),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_accmenableReq(float ec_vcu_accmenable) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_accmenable);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::spdwatchDog() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    ConfigDBC* mp1 = mPropertyManager->findCProperty("sc_ccm_vehicle_spd_dsp");
    while(!mShuttingDownFlag.load()){
        std::unique_lock<std::mutex> lock(spdmtx);
        if(spdcv.wait_for(lock, std::chrono::seconds(monitorTime), [this]{ return fed; })) {  // 1
            fed = false;
            LOG(INFO) << "Dog has been fed.\n";
        } else {
            if(spdCanDisp) {
                mHal->onPropertyValue(*Create_ec_ccm_vehicle_spd_dspReq(-1.0),true);
                mPropertyManager->updateCPropertyValue(mp1,0);
                LOG(INFO) << "Dog bite event!\n";
            }
        }
    }
}


void GarageModeServerSideHandlerImpl::loopSendDynamicOrCTLC(){
    while(true){
        // 100hal  CLTC_RANGE_REMAINING  DYNAMIC_RANGE_REMAINING 
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
        StatusCode status = StatusCode::OK;
        VehiclePropValue requestProp = VehiclePropValue {};
        requestProp.prop = toInt(VehicleProperty::GECKO_REMA_RANGE_DISPLAY_MODE);
        requestProp.areaId = 0;
        auto value = mHal->get(requestProp, &status);

        if(value != nullptr){
            if(0 < value->value.int32Values.size()){
              LOG(INFO) << "dxy value->value.int32Values[0]" << value->value.int32Values[0];
            }
        }else{
          LOG(INFO) << "dxy value->value.int32Values[0] is null" ;
        }
        
    }
}


int GarageModeServerSideHandlerImpl::SpeedCalculate(float& speedvalue,float newvalue) {
  spdQueue.push_back(newvalue);
  if(spdQueue.size()<spdSaveCounter){
    return -1;
  }
  do{
    spdQueue.pop_front();
  }while(spdQueue.size()>spdSaveCounter);
  // 18
  if (spdQueue.size() == spdSaveCounter) {
    std::deque<float> tempQueue = spdQueue; // 
    std::sort(tempQueue.begin(), tempQueue.end()); // 
    tempQueue.pop_back(); // 
    tempQueue.pop_front(); // 

    // 
    float sum = 0;
    for (float value : tempQueue) {
      sum += value;
    }
    speedvalue = sum / tempQueue.size();
  }
  if(speedvalue > 5.0)
    speedvalue = speedvalue/0.98 + 1;
  return 0;
}

#if 0 // mcu
void GarageModeServerSideHandlerImpl::HandlePowerOnspd(float speed){
  if(powerOnSts == 0){
    return;
  }

  if(speed < 0){
      if(updateAverageSpd != -1024){
        mHal->onPropertyValue(*Create_power_on_average_speedReq(-1024),true);
      }
      updateAverageSpd = -1024;

      if(updatePowerOnMileage != -1024){
        mHal->onPropertyValue(*Create_power_on_milegeReq(-1024),true);
      }
      updatePowerOnMileage = -1024;

      ALOGI("HandlePowerOnspd speed < 0 speed=%f", speed);
      return;
  }

  if(begintravelMileage <= 0){
      ConfigDBC* travel = mPropertyManager->findCProperty("mcu_short_mileage");
      begintravelMileage = getActualFloatValue(mPropertyManager->getCProValue(travel), 0.1, 0);
      //ALOGI("HandlePowerOnspd begintravelMileage=%f", begintravelMileage);
  }

        //
      int64_t  currentMilliTime = elapsedRealtime(); // 
      // float current_time_total_kmeter =   mcu_vehicle_spd * 0.01;//0.01 
      if(speed >= 0 && (currentMilliTime - lastMilliTime) > 0 && (currentMilliTime - lastMilliTime) < 1000){
          // mcu_vehicle_spd * 0.01 * 1000 / 3600 /1000 
          float milliSecondsPerMeter = (speed  * 1000 / 3600)/1000;
          //  
          float mileageDuringTimePeriod  = (milliSecondsPerMeter * (currentMilliTime - lastMilliTime))/1000;
          
          // 
          powerOnMileage += mileageDuringTimePeriod;
          //ALOGI("powerOnMileage%f", powerOnMileage);

      }
      lastMilliTime = currentMilliTime;



  int64_t currentTime = elapsedRealtime();
  int64_t passTime = currentTime - powerOnTimestamp;
  float passHour = static_cast<float>(passTime)/(1000 *3600);
  int32_t averageSpd = static_cast<int>(powerOnMileage/passHour);
  

  // int32_t mileageMeter = powerOnMileage *1000;
  // int64_t passTimeSec = passTime /1000;
  // int32_t averageSpdMeter = mileageMeter/passTimeSec;
  // ALOGI("HandlePowerOnspd mileageMeter = %d passTimeSec =%ld averageSpdMeter=%d", 
  // mileageMeter,passTimeSec, averageSpdMeter);

  if((averageSpd < 256) && (averageSpd != updateAverageSpd)){
    mHal->onPropertyValue(*Create_power_on_average_speedReq(averageSpd),true);
    updateAverageSpd = averageSpd;
  }
  
  // ConfigDBC* odometer = mPropertyManager->findCProperty("ec_total_odometer");
  // int32_t TotalMileage = getActualFloatValue(mPropertyManager->getCProValue(odometer),1,0);
  // int32_t Mileage = TotalMileage - beginTotalMileage;

  ConfigDBC* travel = mPropertyManager->findCProperty("mcu_short_mileage");
  float travelMileage = getActualFloatValue(mPropertyManager->getCProValue(travel), 0.1, 0);
  float Mileage1 = travelMileage - begintravelMileage;

  // LOG(INFO)<<"travelMileage:"<<travelMileage<<" begintravelMileage:"<<begintravelMileage;
  // LOG(INFO)<<"powerOnMileage:"<<powerOnMileage<<" Mileage:"<<Mileage<<" travelMileage:"<<Mileage1<<" speed:"<<speed;

  if(((Mileage1 - updatePowerOnMileage) >= 0.05 || (Mileage1 - updatePowerOnMileage) < 0) && travelMileage >= 0){
    ALOGI("HandlePowerOnspd  Mileage1=%f", Mileage1);
    mHal->onPropertyValue(*Create_power_on_milegeReq(Mileage1),true);
    updatePowerOnMileage = Mileage1;
  }

  if(currentTime%9 == 0){
    ALOGI("HandlePowerOnspd currentTime = %jd powerOnTimestamp =%jd passTime=%jd passHour=%f averageSpd=%d Mileage1=%f, updatePowerOnMileage=%f,travelMileage=%f, begintravelMileage=%f, speed=%f", 
    currentTime,powerOnTimestamp, passTime, passHour, averageSpd, Mileage1,updatePowerOnMileage, travelMileage, begintravelMileage,speed);
  }
  
  //LOG(INFO)<<"powerOnMileage:"<<powerOnMileage<<" updatePowerOnMileage:"<<updatePowerOnMileage;
  

  std::chrono::milliseconds ms_start = std::chrono::duration_cast< std::chrono::milliseconds >(
        std::chrono::system_clock::now().time_since_epoch()
      );

  int64_t nowTimes = ms_start.count();

  power_on_average_speed_time = nowTimes;

}
#endif
// void GarageModeServerSideHandlerImpl::ec_vcu_vehicle_spdWatcher() {
//   std::this_thread::sleep_for(std::chrono::milliseconds(800));
//   float ec_vcu_vehicle_spd = 0.0;
//   float ec_vcu_vehicle_disp_spd = 0.0;
//   // int spd_disp_value = 0;
//   for(unsigned long i = 0;i<spdSaveCounter;i++){
//     spdQueue.push_back(0.0);
//   }
//   ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_vehicle_spd");
//   // ConfigDBC* mp1 = mPropertyManager->findCProperty("sc_ccm_vehicle_spd_dsp");
//   // ec_total_odometer
//   ConfigDBC* totalOdometerMp = mPropertyManager->findCProperty("sc_ccm_vehicle_spd_dsp");

//   int64_t  lastMilliTime = elapsedRealtime();
//   LOG(INFO) << "dxy----onSetProperty currentMilliTime = " << lastMilliTime;
//   float cumulativeDistance = 0.0;

//   while(!mShuttingDownFlag.load()){
//       mPropertyManager->getUpdateCState(mp);
//       spdCanDisp = true;
//       int32_t mcu_vehicle_spd =  mPropertyManager->getCProValue(mp);
//       if(-1024 == mcu_vehicle_spd){
//           mHal->onPropertyValue(*Create_ec_vcu_vehicle_spdReq(-1024.0),true);
//           mHal->onPropertyValue(*Create_ec_ccm_vehicle_spd_dspReq(-1024.0),true);
//           continue;
//       }
//       ec_vcu_vehicle_spd = getActualFloatValue(mcu_vehicle_spd,0.01,0);
//       ALOGI("dxy----ec_vcu_vehicle_spdWatcher ec_vcu_vehicle_spd = %f", ec_vcu_vehicle_spd);
// //      totalMileageCur = ec_vcu_vehicle_spd * 0.05625 * dt + TotalMileageEEPROM;
//       mHal->onPropertyValue(*Create_ec_vcu_vehicle_spdReq(ec_vcu_vehicle_spd),true);                      // 
//       /*
//         if(speedvalue > 5.0)
//           speedvalue = speedvalue/0.98 + 1;
//       */
//      ec_vcu_vehicle_disp_spd = ec_vcu_vehicle_spd;
//       if(ec_vcu_vehicle_disp_spd > 5){
//         ec_vcu_vehicle_disp_spd = ec_vcu_vehicle_disp_spd/0.98 + 1;
//       }

//       if(ec_vcu_vehicle_disp_spd > 255.0){
//           ec_vcu_vehicle_disp_spd = 255.0;
//         }
//       mHal->onPropertyValue(*Create_ec_ccm_vehicle_spd_dspReq(ec_vcu_vehicle_disp_spd),true);  


//       //
//       // if(SpeedCalculate(ec_vcu_vehicle_disp_spd,ec_vcu_vehicle_spd)==0){
//       //   ALOGI("dxy----ec_vcu_vehicle_spdWatcher ec_vcu_vehicle_disp_spd = %f", ec_vcu_vehicle_disp_spd);
//       //   if(ec_vcu_vehicle_disp_spd > 255.0){
//       //     ec_vcu_vehicle_disp_spd = 255.0;
//       //   }
//       //   mHal->onPropertyValue(*Create_ec_ccm_vehicle_spd_dspReq(ec_vcu_vehicle_disp_spd),true);
//       // }

//       //
//       int64_t  currentMilliTime = elapsedRealtime(); // 
//       // float current_time_total_kmeter =   mcu_vehicle_spd * 0.01;//0.01 
//       if(mcu_vehicle_spd >= 0 && (currentMilliTime - lastMilliTime) > 0 && (currentMilliTime - lastMilliTime) < 1000){
//           // mcu_vehicle_spd * 0.01 * 1000 / 3600 /1000 
//           float milliSecondsPerMeter = (mcu_vehicle_spd * 0.01 * 1000 / 3600)/1000;
//           //  
//           float mileageDuringTimePeriod  = (milliSecondsPerMeter * (currentMilliTime - lastMilliTime))/1000;
//           ALOGI("dxy----mileageDuringTimePeriod = %f", mileageDuringTimePeriod);
//           cumulativeDistance += mileageDuringTimePeriod;
//           // 
//           powerOnMileage += mileageDuringTimePeriod;
//           HandlePowerOnspd();
//           mHal->onPropertyValue(*Create_power_on_milegeReq(powerOnMileage),true);
//               std::chrono::milliseconds ms_start = std::chrono::duration_cast< std::chrono::milliseconds >(
//                 std::chrono::system_clock::now().time_since_epoch()
//               );
//           power_on_milege_time = ms_start.count();

//           if(0.1 <= cumulativeDistance){ 
//             //  "gecko.total.mileage" 
//             std::string totalMileageStr = android::base::GetProperty("gecko.total.mileage", "0.0");
//             //  totalMileageStr 
//             float totalMileage = std::stof(totalMileageStr);
//             //  totalMileage
//             totalMileage += cumulativeDistance;
            
//             // 0
//             cumulativeDistance = 0.0;
//             //  totalMileage 
//             std::string newTotalMileageStr = std::to_string(totalMileage);
//             //  "gecko.total.mileage"       
//             bool result = android::base::SetProperty("gecko.total.mileage", newTotalMileageStr);
//             ALOGI("dxy---- GECKO_POWER_ON_AVERAGE_ENERGY_CONSUMPTION result =%d", result);
//             if(result){
//               mHal->onPropertyValue(*Create_ec_total_odometerReq(totalMileage),true);
//               mPropertyManager->updateCPropertyValue(totalOdometerMp,static_cast<int>(totalMileage));
              
//             }
			
// 			//ALOGI("dxy---- GECKO_POWER_ON_AVERAGE_ENERGY_CONSUMPTION energyConsumptionFlag =%d", energyConsumptionFlag);
// 			ALOGI("dxy---- GECKO_POWER_ON_AVERAGE_ENERGY_CONSUMPTION energyConsumptionFlag =%d,powerOnMileage=%f,totalEnergyConsumption=%f", energyConsumptionFlag,powerOnMileage,totalEnergyConsumption);
// 			// if(energyConsumptionFlag) {
// 			// 	 float averageEnergy = 0.0;
// 			// 	 if(powerOnMileage != 0) {
//       //               averageEnergy = totalEnergyConsumption/powerOnMileage;
					
// 			// 	    ALOGI("dxy---- GECKO_POWER_ON_AVERAGE_ENERGY_CONSUMPTION averageEnergy =%f", averageEnergy);
// 			// 	    mHal->onPropertyValue(*Create_power_on_average_energy_consumptionReq(averageEnergy),true);
// 			// 	 }
// 			// }
//             ALOGI("dxy---- current_time_total_kmeter = %s ,powerOnMileage =%f", newTotalMileageStr.c_str(), powerOnMileage);
//           }
//       }
//       lastMilliTime = currentMilliTime;
//   }
// }

void GarageModeServerSideHandlerImpl::ec_vcu_vehicle_spdWatcher() {
  float ec_vcu_vehicle_spd = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_vehicle_spd");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_vehicle_spd = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_vcu_vehicle_spdReq(ec_vcu_vehicle_spd),true);
  }
}

void GarageModeServerSideHandlerImpl::ec_vcu_vehicle_spd_dspWatcher() {
  uint32_t sc_ccm_vehicle_spd_dsp = 0;
  float vcu_spd_value = 0.0f;
  ConfigDBC* mp = mPropertyManager->findCProperty("sc_ccm_vehicle_spd_dsp");
  ConfigDBC* mp_door = mPropertyManager->findCProperty("ec_vcu_mid_door_ajar_status");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      sc_ccm_vehicle_spd_dsp = mPropertyManager->getCProValue(mp);
      vcu_spd_value = (sc_ccm_vehicle_spd_dsp * 0.05625);
      sc_ccm_vehicle_spd_dsp = static_cast<uint32_t>(vcu_spd_value);
      if(0xffffffff==sc_ccm_vehicle_spd_dsp || sc_ccm_vehicle_spd_dsp > 255){
        sc_ccm_vehicle_spd_dsp = -1;
        mHal->onPropertyValue(*Create_ec_ccm_vehicle_spd_dspReq(-1024),true);
      }else{
        mHal->onPropertyValue(*Create_ec_ccm_vehicle_spd_dspReq((float)(sc_ccm_vehicle_spd_dsp)),true);
      }

      //HandlePowerOnspd(sc_ccm_vehicle_spd_dsp); //

      ConfigDBC* mp_park = mPropertyManager->findCProperty("ec_vcu_park_state");
      int32_t ec_vcu_park_state = mPropertyManager->getCProValue(mp_park);
      if(ec_vcu_park_state == 1 && sc_ccm_vehicle_spd_dsp >= 5 && sc_ccm_vehicle_spd_dsp <= 256){
        //
          mHal->onPropertyValue(*Create_bc_motion_park_stateReq(1),true);
      } 
      if(sc_ccm_vehicle_spd_dsp < 5) {
        //
          mHal->onPropertyValue(*Create_bc_motion_park_stateReq(0),true);
      }
      int32_t door_status = mPropertyManager->getCProValue(mp_door);
      if(door_status == 1)
      {
        if(sc_ccm_vehicle_spd_dsp >= 3.0){
          mHal->onPropertyValue(*Create_ec_vcu_mid_door_ajar_statusReq(2),true);
        }else {
          mHal->onPropertyValue(*Create_ec_vcu_mid_door_ajar_statusReq(1),true);
        }
      }
  }
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_vehicle_spdReq(float ec_vcu_vehicle_spd) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_vehicle_spd);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_actual_rema_rangeWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  float ec_vcu_actual_rema_range = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_actual_rema_range");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_actual_rema_range = getActualFloatValue(mPropertyManager->getCProValue(mp),1,0);
      mHal->onPropertyValue(*Create_ec_vcu_actual_rema_rangeReq(ec_vcu_actual_rema_range),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_actual_rema_rangeReq(float ec_vcu_actual_rema_range) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_actual_rema_range);
    req->prop = toInt(VehicleProperty::RANGE_REMAINING);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_cltc_rema_rangeWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  float ec_vcu_cltc_rema_range = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_cltc_rema_range");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_cltc_rema_range = getActualFloatValue(mPropertyManager->getCProValue(mp),1,0);
      mHal->onPropertyValue(*Create_ec_vcu_cltc_rema_rangeReq(ec_vcu_cltc_rema_range),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_cltc_rema_rangeReq(float ec_vcu_cltc_rema_range) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_cltc_rema_range);
    req->prop = toInt(VehicleProperty::GECKO_CLTC_RANGE_REMAINING);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bcm_mcu_display_rangeWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bcm_mcu_display_range {0};
  ConfigDBC* mp = mPropertyManager->findCProperty("gecko_bcm_mcu_display_range");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bcm_mcu_display_range = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_bcm_mcu_display_rangeReq(bcm_mcu_display_range),true);
  }
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bcm_mcu_display_rangeReq(int32_t bcm_mcu_display_range) {
    auto req = mValueObjectPool->obtainInt32(bcm_mcu_display_range);
    req->prop = toInt(VehicleProperty::GECKO_MCU_DISPLAY_RANGE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_livecounter_0x250Watcher() {
  float ec_vcu_livecounter_0x250 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_livecounter_0x250");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_livecounter_0x250 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_vcu_livecounter_0x250Req(ec_vcu_livecounter_0x250),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_livecounter_0x250Req(float ec_vcu_livecounter_0x250) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_livecounter_0x250);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_checksum_0x250Watcher() {
  float ec_vcu_checksum_0x250 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_checksum_0x250");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_checksum_0x250 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_vcu_checksum_0x250Req(ec_vcu_checksum_0x250),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_checksum_0x250Req(float ec_vcu_checksum_0x250) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_checksum_0x250);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_yearWatcher() {
  float ec_vcu_year = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_year");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_year = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_vcu_yearReq(ec_vcu_year),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_yearReq(float ec_vcu_year) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_year);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_monthWatcher() {
  float ec_vcu_month = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_month");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_month = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_vcu_monthReq(ec_vcu_month),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_monthReq(float ec_vcu_month) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_month);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_dayWatcher() {
  float ec_vcu_day = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_day");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_day = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_vcu_dayReq(ec_vcu_day),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_dayReq(float ec_vcu_day) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_day);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ccm_a_ckeyWatcher() {
  float ec_ccm_a_ckey = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccm_a_ckey");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ccm_a_ckey = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ccm_a_ckeyReq(ec_ccm_a_ckey),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccm_a_ckeyReq(float ec_ccm_a_ckey) {
    auto req = mValueObjectPool->obtainFloat(ec_ccm_a_ckey);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ccm_ac_havc_stateWatcher() {
  float ec_ccm_ac_havc_state = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccm_ac_havc_state");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ccm_ac_havc_state = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ccm_ac_havc_stateReq(ec_ccm_ac_havc_state),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccm_ac_havc_stateReq(float ec_ccm_ac_havc_state) {
    auto req = mValueObjectPool->obtainFloat(ec_ccm_ac_havc_state);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ccm_vehicle_spd_dspWatcher() {
  float ec_ccm_vehicle_spd_dsp = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccm_vehicle_spd_dsp");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ccm_vehicle_spd_dsp = getActualFloatValue(mPropertyManager->getCProValue(mp),1,0);
      //mHal->onPropertyValue(*Create_ec_ccm_vehicle_spd_dspReq(ec_ccm_vehicle_spd_dsp),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccm_vehicle_spd_dspReq(float ec_ccm_vehicle_spd_dsp) {
    auto req = mValueObjectPool->obtainFloat(ec_ccm_vehicle_spd_dsp);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED_DISPLAY);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ccm_livecounter_0x310Watcher() {
  float ec_ccm_livecounter_0x310 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccm_livecounter_0x310");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ccm_livecounter_0x310 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ccm_livecounter_0x310Req(ec_ccm_livecounter_0x310),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccm_livecounter_0x310Req(float ec_ccm_livecounter_0x310) {
    auto req = mValueObjectPool->obtainFloat(ec_ccm_livecounter_0x310);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ccm_checksum_0x310Watcher() {
  float ec_ccm_checksum_0x310 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccm_checksum_0x310");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ccm_checksum_0x310 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ccm_checksum_0x310Req(ec_ccm_checksum_0x310),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccm_checksum_0x310Req(float ec_ccm_checksum_0x310) {
    auto req = mValueObjectPool->obtainFloat(ec_ccm_checksum_0x310);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_b2_v_gbsn_frame_noWatcher() {
  float ec_b2_v_gbsn_frame_no = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_b2_v_gbsn_frame_no");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_b2_v_gbsn_frame_no = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_b2_v_gbsn_frame_noReq(ec_b2_v_gbsn_frame_no),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_b2_v_gbsn_frame_noReq(float ec_b2_v_gbsn_frame_no) {
    auto req = mValueObjectPool->obtainFloat(ec_b2_v_gbsn_frame_no);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_b2_v_gbsn_sys_code_lengthWatcher() {
  float ec_b2_v_gbsn_sys_code_length = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_b2_v_gbsn_sys_code_length");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_b2_v_gbsn_sys_code_length = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_b2_v_gbsn_sys_code_lengthReq(ec_b2_v_gbsn_sys_code_length),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_b2_v_gbsn_sys_code_lengthReq(float ec_b2_v_gbsn_sys_code_length) {
    auto req = mValueObjectPool->obtainFloat(ec_b2_v_gbsn_sys_code_length);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_b2_v_gbsn_sys_code_1_7_13_19Watcher() {
  float ec_b2_v_gbsn_sys_code_1_7_13_19 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_b2_v_gbsn_sys_code_1_7_13_19");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_b2_v_gbsn_sys_code_1_7_13_19 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_b2_v_gbsn_sys_code_1_7_13_19Req(ec_b2_v_gbsn_sys_code_1_7_13_19),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_b2_v_gbsn_sys_code_1_7_13_19Req(float ec_b2_v_gbsn_sys_code_1_7_13_19) {
    auto req = mValueObjectPool->obtainFloat(ec_b2_v_gbsn_sys_code_1_7_13_19);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_b2_v_gbsn_sys_code_2_8_14_20Watcher() {
  float ec_b2_v_gbsn_sys_code_2_8_14_20 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_b2_v_gbsn_sys_code_2_8_14_20");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_b2_v_gbsn_sys_code_2_8_14_20 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_b2_v_gbsn_sys_code_2_8_14_20Req(ec_b2_v_gbsn_sys_code_2_8_14_20),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_b2_v_gbsn_sys_code_2_8_14_20Req(float ec_b2_v_gbsn_sys_code_2_8_14_20) {
    auto req = mValueObjectPool->obtainFloat(ec_b2_v_gbsn_sys_code_2_8_14_20);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_b2_v_gbsn_sys_code_3_9_15_21Watcher() {
  float ec_b2_v_gbsn_sys_code_3_9_15_21 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_b2_v_gbsn_sys_code_3_9_15_21");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_b2_v_gbsn_sys_code_3_9_15_21 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_b2_v_gbsn_sys_code_3_9_15_21Req(ec_b2_v_gbsn_sys_code_3_9_15_21),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_b2_v_gbsn_sys_code_3_9_15_21Req(float ec_b2_v_gbsn_sys_code_3_9_15_21) {
    auto req = mValueObjectPool->obtainFloat(ec_b2_v_gbsn_sys_code_3_9_15_21);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_b2_v_gbsn_sys_code_4_10_16_22Watcher() {
  float ec_b2_v_gbsn_sys_code_4_10_16_22 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_b2_v_gbsn_sys_code_4_10_16_22");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_b2_v_gbsn_sys_code_4_10_16_22 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_b2_v_gbsn_sys_code_4_10_16_22Req(ec_b2_v_gbsn_sys_code_4_10_16_22),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_b2_v_gbsn_sys_code_4_10_16_22Req(float ec_b2_v_gbsn_sys_code_4_10_16_22) {
    auto req = mValueObjectPool->obtainFloat(ec_b2_v_gbsn_sys_code_4_10_16_22);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_b2_v_gbsn_sys_code_5_11_17_23Watcher() {
  float ec_b2_v_gbsn_sys_code_5_11_17_23 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_b2_v_gbsn_sys_code_5_11_17_23");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_b2_v_gbsn_sys_code_5_11_17_23 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_b2_v_gbsn_sys_code_5_11_17_23Req(ec_b2_v_gbsn_sys_code_5_11_17_23),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_b2_v_gbsn_sys_code_5_11_17_23Req(float ec_b2_v_gbsn_sys_code_5_11_17_23) {
    auto req = mValueObjectPool->obtainFloat(ec_b2_v_gbsn_sys_code_5_11_17_23);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_b2_v_gbsn_sys_code_6_12_18_24Watcher() {
  float ec_b2_v_gbsn_sys_code_6_12_18_24 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_b2_v_gbsn_sys_code_6_12_18_24");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_b2_v_gbsn_sys_code_6_12_18_24 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_b2_v_gbsn_sys_code_6_12_18_24Req(ec_b2_v_gbsn_sys_code_6_12_18_24),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_b2_v_gbsn_sys_code_6_12_18_24Req(float ec_b2_v_gbsn_sys_code_6_12_18_24) {
    auto req = mValueObjectPool->obtainFloat(ec_b2_v_gbsn_sys_code_6_12_18_24);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_work_reqWatcher() {
  float ec_vcu_work_req = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_work_req");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_work_req = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_vcu_work_reqReq(ec_vcu_work_req),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_work_reqReq(float ec_vcu_work_req) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_work_req);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_livecounter_0x661Watcher() {
  float ec_vcu_livecounter_0x661 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_livecounter_0x661");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_livecounter_0x661 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_vcu_livecounter_0x661Req(ec_vcu_livecounter_0x661),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_livecounter_0x661Req(float ec_vcu_livecounter_0x661) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_livecounter_0x661);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_checksum_0x661Watcher() {
  float ec_vcu_checksum_0x661 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_checksum_0x661");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_checksum_0x661 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_vcu_checksum_0x661Req(ec_vcu_checksum_0x661),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_checksum_0x661Req(float ec_vcu_checksum_0x661) {
    auto req = mValueObjectPool->obtainFloat(ec_vcu_checksum_0x661);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_str_work_reqWatcher() {
  float ec_str_work_req = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_str_work_req");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_str_work_req = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_str_work_reqReq(ec_str_work_req),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_str_work_reqReq(float ec_str_work_req) {
    auto req = mValueObjectPool->obtainFloat(ec_str_work_req);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ccm_nm_bitWatcher() {
  float ec_ccm_nm_bit = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccm_nm_bit");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ccm_nm_bit = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ccm_nm_bitReq(ec_ccm_nm_bit),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccm_nm_bitReq(float ec_ccm_nm_bit) {
    auto req = mValueObjectPool->obtainFloat(ec_ccm_nm_bit);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ccm_livecounter_0x66_cWatcher() {
  float ec_ccm_livecounter_0x66_c = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccm_livecounter_0x66_c");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ccm_livecounter_0x66_c = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ccm_livecounter_0x66_cReq(ec_ccm_livecounter_0x66_c),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccm_livecounter_0x66_cReq(float ec_ccm_livecounter_0x66_c) {
    auto req = mValueObjectPool->obtainFloat(ec_ccm_livecounter_0x66_c);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ccm_checksum_0x66_cWatcher() {
  float ec_ccm_checksum_0x66_c = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccm_checksum_0x66_c");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ccm_checksum_0x66_c = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ccm_checksum_0x66_cReq(ec_ccm_checksum_0x66_c),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccm_checksum_0x66_cReq(float ec_ccm_checksum_0x66_c) {
    auto req = mValueObjectPool->obtainFloat(ec_ccm_checksum_0x66_c);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_tbox_time_statusWatcher() {
  float ec_tbox_time_status = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_tbox_time_status");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_tbox_time_status = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_tbox_time_statusReq(ec_tbox_time_status),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_tbox_time_statusReq(float ec_tbox_time_status) {
    auto req = mValueObjectPool->obtainFloat(ec_tbox_time_status);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_tbox_yearWatcher() {
  float ec_tbox_year = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_tbox_year");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_tbox_year = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_tbox_yearReq(ec_tbox_year),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_tbox_yearReq(float ec_tbox_year) {
    auto req = mValueObjectPool->obtainFloat(ec_tbox_year);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_tbox_monthWatcher() {
  float ec_tbox_month = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_tbox_month");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_tbox_month = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_tbox_monthReq(ec_tbox_month),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_tbox_monthReq(float ec_tbox_month) {
    auto req = mValueObjectPool->obtainFloat(ec_tbox_month);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_tbox_dayWatcher() {
  float ec_tbox_day = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_tbox_day");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_tbox_day = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_tbox_dayReq(ec_tbox_day),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_tbox_dayReq(float ec_tbox_day) {
    auto req = mValueObjectPool->obtainFloat(ec_tbox_day);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_tbox_hourWatcher() {
  float ec_tbox_hour = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_tbox_hour");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_tbox_hour = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_tbox_hourReq(ec_tbox_hour),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_tbox_hourReq(float ec_tbox_hour) {
    auto req = mValueObjectPool->obtainFloat(ec_tbox_hour);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_tbox_minuteWatcher() {
  float ec_tbox_minute = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_tbox_minute");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_tbox_minute = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_tbox_minuteReq(ec_tbox_minute),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_tbox_minuteReq(float ec_tbox_minute) {
    auto req = mValueObjectPool->obtainFloat(ec_tbox_minute);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_tbox_secondWatcher() {
  float ec_tbox_second = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_tbox_second");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_tbox_second = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_tbox_secondReq(ec_tbox_second),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_tbox_secondReq(float ec_tbox_second) {
    auto req = mValueObjectPool->obtainFloat(ec_tbox_second);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ccm_soc_sofeware_numWatcher() {
  float ec_ccm_soc_sofeware_num = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccm_soc_sofeware_num");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ccm_soc_sofeware_num = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ccm_soc_sofeware_numReq(ec_ccm_soc_sofeware_num),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccm_soc_sofeware_numReq(float ec_ccm_soc_sofeware_num) {
    auto req = mValueObjectPool->obtainFloat(ec_ccm_soc_sofeware_num);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ccm_soc_hardware_numWatcher() {
  float ec_ccm_soc_hardware_num = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccm_soc_hardware_num");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ccm_soc_hardware_num = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ccm_soc_hardware_numReq(ec_ccm_soc_hardware_num),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccm_soc_hardware_numReq(float ec_ccm_soc_hardware_num) {
    auto req = mValueObjectPool->obtainFloat(ec_ccm_soc_hardware_num);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ccm_mcu_sofeware_numWatcher() {
  float ec_ccm_mcu_sofeware_num = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccm_mcu_sofeware_num");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ccm_mcu_sofeware_num = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ccm_mcu_sofeware_numReq(ec_ccm_mcu_sofeware_num),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccm_mcu_sofeware_numReq(float ec_ccm_mcu_sofeware_num) {
    auto req = mValueObjectPool->obtainFloat(ec_ccm_mcu_sofeware_num);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ccm_mcu_hardware_numWatcher() {
  float ec_ccm_mcu_hardware_num = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccm_mcu_hardware_num");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ccm_mcu_hardware_num = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ccm_mcu_hardware_numReq(ec_ccm_mcu_hardware_num),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccm_mcu_hardware_numReq(float ec_ccm_mcu_hardware_num) {
    auto req = mValueObjectPool->obtainFloat(ec_ccm_mcu_hardware_num);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_bms_batterysoc_virtualWatcher() {
  float ec_bms_batterysoc_virtual = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_batterysoc_virtual");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_batterysoc_virtual = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_bms_batterysoc_virtualReq(ec_bms_batterysoc_virtual),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_batterysoc_virtualReq(float ec_bms_batterysoc_virtual) {
    auto req = mValueObjectPool->obtainFloat(ec_bms_batterysoc_virtual);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_bms_livecounter_0x513Watcher() {
  float ec_bms_livecounter_0x513 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_livecounter_0x513");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_livecounter_0x513 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_bms_livecounter_0x513Req(ec_bms_livecounter_0x513),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_livecounter_0x513Req(float ec_bms_livecounter_0x513) {
    auto req = mValueObjectPool->obtainFloat(ec_bms_livecounter_0x513);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_bms_checksum_0x513Watcher() {
  float ec_bms_checksum_0x513 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_checksum_0x513");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_checksum_0x513 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_bms_checksum_0x513Req(ec_bms_checksum_0x513),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_checksum_0x513Req(float ec_bms_checksum_0x513) {
    auto req = mValueObjectPool->obtainFloat(ec_bms_checksum_0x513);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_tbox_cpu_temperature_lowWatcher() {
  float ec_tbox_cpu_temperature_low = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_tbox_cpu_temperature_low");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_tbox_cpu_temperature_low = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_tbox_cpu_temperature_lowReq(ec_tbox_cpu_temperature_low),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_tbox_cpu_temperature_lowReq(float ec_tbox_cpu_temperature_low) {
    auto req = mValueObjectPool->obtainFloat(ec_tbox_cpu_temperature_low);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_tbox_cpu_temperature_highWatcher() {
  float ec_tbox_cpu_temperature_high = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_tbox_cpu_temperature_high");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_tbox_cpu_temperature_high = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_tbox_cpu_temperature_highReq(ec_tbox_cpu_temperature_high),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_tbox_cpu_temperature_highReq(float ec_tbox_cpu_temperature_high) {
    auto req = mValueObjectPool->obtainFloat(ec_tbox_cpu_temperature_high);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_pcb_temperature_lowWatcher() {
  float ec_pcb_temperature_low = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_pcb_temperature_low");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_pcb_temperature_low = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_pcb_temperature_lowReq(ec_pcb_temperature_low),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_pcb_temperature_lowReq(float ec_pcb_temperature_low) {
    auto req = mValueObjectPool->obtainFloat(ec_pcb_temperature_low);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_pcb_temperature_highWatcher() {
  float ec_pcb_temperature_high = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_pcb_temperature_high");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_pcb_temperature_high = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_pcb_temperature_highReq(ec_pcb_temperature_high),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_pcb_temperature_highReq(float ec_pcb_temperature_high) {
    auto req = mValueObjectPool->obtainFloat(ec_pcb_temperature_high);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_main_power_supply_voltahe_lowWatcher() {
  float ec_main_power_supply_voltahe_low = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_main_power_supply_voltahe_low");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_main_power_supply_voltahe_low = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_main_power_supply_voltahe_lowReq(ec_main_power_supply_voltahe_low),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_main_power_supply_voltahe_lowReq(float ec_main_power_supply_voltahe_low) {
    auto req = mValueObjectPool->obtainFloat(ec_main_power_supply_voltahe_low);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_main_power_supply_voltahe_highWatcher() {
  float ec_main_power_supply_voltahe_high = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_main_power_supply_voltahe_high");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_main_power_supply_voltahe_high = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_main_power_supply_voltahe_highReq(ec_main_power_supply_voltahe_high),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_main_power_supply_voltahe_highReq(float ec_main_power_supply_voltahe_high) {
    auto req = mValueObjectPool->obtainFloat(ec_main_power_supply_voltahe_high);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_sim_card_not_presentWatcher() {
  float ec_sim_card_not_present = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_sim_card_not_present");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_sim_card_not_present = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_sim_card_not_presentReq(ec_sim_card_not_present),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_sim_card_not_presentReq(float ec_sim_card_not_present) {
    auto req = mValueObjectPool->obtainFloat(ec_sim_card_not_present);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_wifi_device_lostWatcher() {
  float ec_wifi_device_lost = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_wifi_device_lost");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_wifi_device_lost = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_wifi_device_lostReq(ec_wifi_device_lost),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_wifi_device_lostReq(float ec_wifi_device_lost) {
    auto req = mValueObjectPool->obtainFloat(ec_wifi_device_lost);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ccm_detects_eas_node_lossWatcher() {
  float ec_ccm_detects_eas_node_loss = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccm_detects_eas_node_loss");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ccm_detects_eas_node_loss = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ccm_detects_eas_node_lossReq(ec_ccm_detects_eas_node_loss),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccm_detects_eas_node_lossReq(float ec_ccm_detects_eas_node_loss) {
    auto req = mValueObjectPool->obtainFloat(ec_ccm_detects_eas_node_loss);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ccm_detects_bms_node_lossWatcher() {
  float ec_ccm_detects_bms_node_loss = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccm_detects_bms_node_loss");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ccm_detects_bms_node_loss = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ccm_detects_bms_node_lossReq(ec_ccm_detects_bms_node_loss),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccm_detects_bms_node_lossReq(float ec_ccm_detects_bms_node_loss) {
    auto req = mValueObjectPool->obtainFloat(ec_ccm_detects_bms_node_loss);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ccm_detects_ipu_node_lossWatcher() {
  float ec_ccm_detects_ipu_node_loss = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccm_detects_ipu_node_loss");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ccm_detects_ipu_node_loss = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ccm_detects_ipu_node_lossReq(ec_ccm_detects_ipu_node_loss),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccm_detects_ipu_node_lossReq(float ec_ccm_detects_ipu_node_loss) {
    auto req = mValueObjectPool->obtainFloat(ec_ccm_detects_ipu_node_loss);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ccm_detects_vcu_node_lossWatcher() {
  float ec_ccm_detects_vcu_node_loss = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccm_detects_vcu_node_loss");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ccm_detects_vcu_node_loss = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ccm_detects_vcu_node_lossReq(ec_ccm_detects_vcu_node_loss),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccm_detects_vcu_node_lossReq(float ec_ccm_detects_vcu_node_loss) {
    auto req = mValueObjectPool->obtainFloat(ec_ccm_detects_vcu_node_loss);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_private_can3_bus_offWatcher() {
  float ec_private_can3_bus_off = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_private_can3_bus_off");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_private_can3_bus_off = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_private_can3_bus_offReq(ec_private_can3_bus_off),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_private_can3_bus_offReq(float ec_private_can3_bus_off) {
    auto req = mValueObjectPool->obtainFloat(ec_private_can3_bus_off);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_private_can2_bus_offWatcher() {
  float ec_private_can2_bus_off = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_private_can2_bus_off");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_private_can2_bus_off = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_private_can2_bus_offReq(ec_private_can2_bus_off),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_private_can2_bus_offReq(float ec_private_can2_bus_off) {
    auto req = mValueObjectPool->obtainFloat(ec_private_can2_bus_off);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_private_can1_bus_offWatcher() {
  float ec_private_can1_bus_off = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_private_can1_bus_off");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_private_can1_bus_off = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_private_can1_bus_offReq(ec_private_can1_bus_off),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_private_can1_bus_offReq(float ec_private_can1_bus_off) {
    auto req = mValueObjectPool->obtainFloat(ec_private_can1_bus_off);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_detect_backup_battery_lostWatcher() {
  float ec_detect_backup_battery_lost = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_detect_backup_battery_lost");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_detect_backup_battery_lost = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_detect_backup_battery_lostReq(ec_detect_backup_battery_lost),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_detect_backup_battery_lostReq(float ec_detect_backup_battery_lost) {
    auto req = mValueObjectPool->obtainFloat(ec_detect_backup_battery_lost);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ccm_detects_acu_node_lossWatcher() {
  float ec_ccm_detects_acu_node_loss = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccm_detects_acu_node_loss");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ccm_detects_acu_node_loss = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ccm_detects_acu_node_lossReq(ec_ccm_detects_acu_node_loss),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccm_detects_acu_node_lossReq(float ec_ccm_detects_acu_node_loss) {
    auto req = mValueObjectPool->obtainFloat(ec_ccm_detects_acu_node_loss);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ccm_detects_bcm_node_lossWatcher() {
  float ec_ccm_detects_bcm_node_loss = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccm_detects_bcm_node_loss");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ccm_detects_bcm_node_loss = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ccm_detects_bcm_node_lossReq(ec_ccm_detects_bcm_node_loss),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccm_detects_bcm_node_lossReq(float ec_ccm_detects_bcm_node_loss) {
    auto req = mValueObjectPool->obtainFloat(ec_ccm_detects_bcm_node_loss);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ccm_detects_ac_node_lossWatcher() {
  float ec_ccm_detects_ac_node_loss = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccm_detects_ac_node_loss");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ccm_detects_ac_node_loss = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_ec_ccm_detects_ac_node_lossReq(ec_ccm_detects_ac_node_loss),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccm_detects_ac_node_lossReq(float ec_ccm_detects_ac_node_loss) {
    auto req = mValueObjectPool->obtainFloat(ec_ccm_detects_ac_node_loss);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_eas_motspdWatcher() {
  float bc_eas_motspd = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_eas_motspd");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_eas_motspd = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_eas_motspdReq(bc_eas_motspd),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_eas_motspdReq(float bc_eas_motspd) {
    auto req = mValueObjectPool->obtainFloat(bc_eas_motspd);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_eas_eashvil_staWatcher() {
  float bc_eas_eashvil_sta = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_eas_eashvil_sta");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_eas_eashvil_sta = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_eas_eashvil_staReq(bc_eas_eashvil_sta),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_eas_eashvil_staReq(float bc_eas_eashvil_sta) {
    auto req = mValueObjectPool->obtainFloat(bc_eas_eashvil_sta);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_eas_crtstsWatcher() {
  float bc_eas_crtsts = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_eas_crtsts");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_eas_crtsts = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_eas_crtstsReq(bc_eas_crtsts),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_eas_crtstsReq(float bc_eas_crtsts) {
    auto req = mValueObjectPool->obtainFloat(bc_eas_crtsts);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_eas_ip_mtempWatcher() {
  float bc_eas_ip_mtemp = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_eas_ip_mtemp");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_eas_ip_mtemp = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_eas_ip_mtempReq(bc_eas_ip_mtemp),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_eas_ip_mtempReq(float bc_eas_ip_mtemp) {
    auto req = mValueObjectPool->obtainFloat(bc_eas_ip_mtemp);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_eas_ctrlrstsWatcher() {
  float bc_eas_ctrlrsts = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_eas_ctrlrsts");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_eas_ctrlrsts = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_eas_ctrlrstsReq(bc_eas_ctrlrsts),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_eas_ctrlrstsReq(float bc_eas_ctrlrsts) {
    auto req = mValueObjectPool->obtainFloat(bc_eas_ctrlrsts);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_eas_ctrlrcrtWatcher() {
  float bc_eas_ctrlrcrt = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_eas_ctrlrcrt");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_eas_ctrlrcrt = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_eas_ctrlrcrtReq(bc_eas_ctrlrcrt),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_eas_ctrlrcrtReq(float bc_eas_ctrlrcrt) {
    auto req = mValueObjectPool->obtainFloat(bc_eas_ctrlrcrt);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_eas_ctrlrvoltWatcher() {
  float bc_eas_ctrlrvolt = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_eas_ctrlrvolt");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_eas_ctrlrvolt = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_eas_ctrlrvoltReq(bc_eas_ctrlrvolt),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_eas_ctrlrvoltReq(float bc_eas_ctrlrvolt) {
    auto req = mValueObjectPool->obtainFloat(bc_eas_ctrlrvolt);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ac_blower_levelWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_ac_blower_level = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ac_blower_level");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);

      bc_ac_blower_level = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_ac_blower_levelReq(bc_ac_blower_level),true);

  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ac_blower_levelReq(int32_t bc_ac_blower_level) {
    auto req = mValueObjectPool->obtainInt32(bc_ac_blower_level);
    req->prop = toInt(VehicleProperty::HVAC_FAN_SPEED);
    req->areaId = 117;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_ac_hybrid_eco_mode_staWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_ac_hybrid_eco_mode_sta = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ac_hybrid_eco_mode_sta");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ac_hybrid_eco_mode_sta = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_ac_hybrid_eco_mode_staReq(bc_ac_hybrid_eco_mode_sta),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ac_hybrid_eco_mode_staReq(int32_t bc_ac_hybrid_eco_mode_sta) {
    auto req = mValueObjectPool->obtainInt32(bc_ac_hybrid_eco_mode_sta);
    req->prop = toInt(VehicleProperty::GECKO_HVAC_HYBIRD_ECO_MODE);
    req->areaId = 117;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}



void GarageModeServerSideHandlerImpl::bc_ac_fan_reqWatcher() {
  float bc_ac_fan_req = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ac_fan_req");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ac_fan_req = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_ac_fan_reqReq(bc_ac_fan_req),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ac_fan_reqReq(float bc_ac_fan_req) {
    auto req = mValueObjectPool->obtainFloat(bc_ac_fan_req);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ac_fresh_reci_stateWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_ac_fresh_reci_state = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ac_fresh_reci_state");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ac_fresh_reci_state = static_cast<int32_t> (mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_bc_ac_fresh_reci_stateReq(bc_ac_fresh_reci_state),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ac_fresh_reci_stateReq(int32_t bc_ac_fresh_reci_state) {
    auto req = mValueObjectPool->obtainInt32(bc_ac_fresh_reci_state);
    ALOGW("dxy----Create_bc_ac_fresh_reci_stateReq bc_ac_fresh_reci_state=%d", bc_ac_fresh_reci_state);
    req->prop = toInt(VehicleProperty::HVAC_RECIRC_ON);
    req->areaId = 117;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ac_front_defrost_stateWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_ac_front_defrost_state = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ac_front_defrost_state");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ac_front_defrost_state = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_ac_front_defrost_stateReq(bc_ac_front_defrost_state, 1),true);
      mHal->onPropertyValue(*Create_bc_ac_front_defrost_stateReq(bc_ac_front_defrost_state, 2),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ac_front_defrost_stateReq(int32_t bc_ac_front_defrost_state, int32_t areaId) {
    auto req = mValueObjectPool->obtainInt32(bc_ac_front_defrost_state);
    ALOGW("dxy----Create_bc_ac_front_defrost_stateReq bc_ac_front_defrost_state=%d", bc_ac_front_defrost_state);
    req->prop = toInt(VehicleProperty::HVAC_DEFROSTER);
    req->areaId = areaId;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ac_heat_stateWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_ac_heat_state = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ac_heat_state");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ALOGW("zcy----bc_ac_heat_state mPropertyManager->getCProValue(mp) = %d", mPropertyManager->getCProValue(mp));

      bc_ac_heat_state = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_ac_heat_stateReq(bc_ac_heat_state),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ac_heat_stateReq(int32_t bc_ac_heat_state) {
    auto req = mValueObjectPool->obtainInt32(bc_ac_heat_state);
    req->prop = toInt(VehicleProperty::GECKO_HVAC_PTC_HEAT_ON);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}


void GarageModeServerSideHandlerImpl::bc_ac_havc_stateWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_ac_havc_state = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ac_havc_state");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ALOGW("dxy----bc_ac_heat_state mPropertyManager->getCProValue(mp) = %d", mPropertyManager->getCProValue(mp));
      bc_ac_havc_state = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_ac_havc_stateReq(bc_ac_havc_state),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ac_havc_stateReq(int32_t bc_ac_havc_state) {
    auto req = mValueObjectPool->obtainInt32(bc_ac_havc_state);
    ALOGW("dxy----Create_bc_ac_havc_stateReq bc_ac_havc_state = %d", bc_ac_havc_state);
    req->prop = toInt(VehicleProperty::HVAC_POWER_ON);
    req->areaId = 117;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ac_ai_rdistribution_modeWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_ac_ai_rdistribution_mode = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ac_ai_rdistribution_mode");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ac_ai_rdistribution_mode = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_ac_ai_rdistribution_modeReq(bc_ac_ai_rdistribution_mode),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ac_ai_rdistribution_modeReq(int32_t bc_ac_ai_rdistribution_mode) {
    auto req = mValueObjectPool->obtainInt32(bc_ac_ai_rdistribution_mode);
    ALOGW("zcy----Create_bc_ac_air_distribution_modeReq bc_ac_ai_rdistribution_mode=%d", bc_ac_ai_rdistribution_mode);
    req->prop = toInt(VehicleProperty::HVAC_FAN_DIRECTION);
    req->areaId = 117;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ac_a_cstateWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_ac_a_cstate = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ac_a_cstate");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ac_a_cstate = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_ac_a_cstateReq(bc_ac_a_cstate),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ac_a_cstateReq(int32_t bc_ac_a_cstate) {
    auto req = mValueObjectPool->obtainInt32(bc_ac_a_cstate);
    ALOGW("zcy----Create_bc_ac_a_cstateReq  bc_ac_a_cstate=%d", bc_ac_a_cstate);
    req->prop = toInt(VehicleProperty::HVAC_AC_ON);
    req->areaId = 117;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ac_left_set_temperatureWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  float bc_ac_left_set_temperature = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ac_left_set_temperature");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ac_left_set_temperature = getActualFloatValue(mPropertyManager->getCProValue(mp),1,0);
      mHal->onPropertyValue(*Create_bc_ac_left_set_temperatureReq(bc_ac_left_set_temperature, 49),true);
      mHal->onPropertyValue(*Create_bc_ac_left_set_temperatureReq(bc_ac_left_set_temperature, 68),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ac_left_set_temperatureReq(float bc_ac_left_set_temperature, int32_t areaId) {
    auto req = mValueObjectPool->obtainFloat(bc_ac_left_set_temperature);
    ALOGW("zcy----Create_bc_ac_left_set_temperatureReq  bc_ac_left_set_temperature=%f", bc_ac_left_set_temperature);
    req->prop = toInt(VehicleProperty::HVAC_TEMPERATURE_SET);
    req->areaId = areaId;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ac_fan_pwmWatcher() {
  float bc_ac_fan_pwm = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ac_fan_pwm");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ac_fan_pwm = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_ac_fan_pwmReq(bc_ac_fan_pwm),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ac_fan_pwmReq(float bc_ac_fan_pwm) {
    auto req = mValueObjectPool->obtainFloat(bc_ac_fan_pwm);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ac_fan_feed_back_voltageWatcher() {
  float bc_ac_fan_feed_back_voltage = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ac_fan_feed_back_voltage");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ac_fan_feed_back_voltage = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_ac_fan_feed_back_voltageReq(bc_ac_fan_feed_back_voltage),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ac_fan_feed_back_voltageReq(float bc_ac_fan_feed_back_voltage) {
    auto req = mValueObjectPool->obtainFloat(bc_ac_fan_feed_back_voltage);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ac_pt_ctempWatcher() {
  float bc_ac_pt_ctemp = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ac_pt_ctemp");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ac_pt_ctemp = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_ac_pt_ctempReq(bc_ac_pt_ctemp),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ac_pt_ctempReq(float bc_ac_pt_ctemp) {
    auto req = mValueObjectPool->obtainFloat(bc_ac_pt_ctemp);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_ac_fault_statusWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_ac_fault_status = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ac_fault_status");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ac_fault_status = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_bc_ac_fault_statusReq(bc_ac_fault_status),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ac_fault_statusReq(int32_t bc_ac_fault_status) {
    auto req = mValueObjectPool->obtainInt32(bc_ac_fault_status);
    req->prop = toInt(VehicleProperty::GECKO_HVAC_CONTROL_ERROR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ac_ptc_over_heatWatcher() {
  float bc_ac_ptc_over_heat = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ac_ptc_over_heat");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ac_ptc_over_heat = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_ac_ptc_over_heatReq(bc_ac_ptc_over_heat),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ac_ptc_over_heatReq(float bc_ac_ptc_over_heat) {
    auto req = mValueObjectPool->obtainFloat(bc_ac_ptc_over_heat);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ac_eas_speed_reqWatcher() {
  float bc_ac_eas_speed_req = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ac_eas_speed_req");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ac_eas_speed_req = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_ac_eas_speed_reqReq(bc_ac_eas_speed_req),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ac_eas_speed_reqReq(float bc_ac_eas_speed_req) {
    auto req = mValueObjectPool->obtainFloat(bc_ac_eas_speed_req);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ac_ptcp_power_reqWatcher() {
  float bc_ac_ptcp_power_req = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ac_ptcp_power_req");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ac_ptcp_power_req = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_ac_ptcp_power_reqReq(bc_ac_ptcp_power_req),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ac_ptcp_power_reqReq(float bc_ac_ptcp_power_req) {
    auto req = mValueObjectPool->obtainFloat(bc_ac_ptcp_power_req);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ac_press_swtich_stateWatcher() {
  float bc_ac_press_swtich_state = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ac_press_swtich_state");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ac_press_swtich_state = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_ac_press_swtich_stateReq(bc_ac_press_swtich_state),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ac_press_swtich_stateReq(float bc_ac_press_swtich_state) {
    auto req = mValueObjectPool->obtainFloat(bc_ac_press_swtich_state);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ac_livecounter_0x233Watcher() {
  float bc_ac_livecounter_0x233 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ac_livecounter_0x233");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ac_livecounter_0x233 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_ac_livecounter_0x233Req(bc_ac_livecounter_0x233),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ac_livecounter_0x233Req(float bc_ac_livecounter_0x233) {
    auto req = mValueObjectPool->obtainFloat(bc_ac_livecounter_0x233);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ac_checksum_0x233Watcher() {
  float bc_ac_checksum_0x233 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ac_checksum_0x233");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ac_checksum_0x233 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_ac_checksum_0x233Req(bc_ac_checksum_0x233),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ac_checksum_0x233Req(float bc_ac_checksum_0x233) {
    auto req = mValueObjectPool->obtainFloat(bc_ac_checksum_0x233);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ccm_fresh_reci_keyWatcher() {
  float bc_ccm_fresh_reci_key = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ccm_fresh_reci_key");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ccm_fresh_reci_key = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_ccm_fresh_reci_keyReq(bc_ccm_fresh_reci_key),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ccm_fresh_reci_keyReq(float bc_ccm_fresh_reci_key) {
    auto req = mValueObjectPool->obtainFloat(bc_ccm_fresh_reci_key);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ccm_front_defrost_keyWatcher() {
  float bc_ccm_front_defrost_key = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ccm_front_defrost_key");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ccm_front_defrost_key = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_ccm_front_defrost_keyReq(bc_ccm_front_defrost_key),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ccm_front_defrost_keyReq(float bc_ccm_front_defrost_key) {
    auto req = mValueObjectPool->obtainFloat(bc_ccm_front_defrost_key);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ccm_a_ckeyWatcher() {
  float bc_ccm_a_ckey = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ccm_a_ckey");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ccm_a_ckey = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_ccm_a_ckeyReq(bc_ccm_a_ckey),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ccm_a_ckeyReq(float bc_ccm_a_ckey) {
    auto req = mValueObjectPool->obtainFloat(bc_ccm_a_ckey);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ccm_blower_levelWatcher() {
  float bc_ccm_blower_level = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ccm_blower_level");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ccm_blower_level = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_ccm_blower_levelReq(bc_ccm_blower_level),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ccm_blower_levelReq(float bc_ccm_blower_level) {
    auto req = mValueObjectPool->obtainFloat(bc_ccm_blower_level);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ccm_ac_havc_stateWatcher() {
  float bc_ccm_ac_havc_state = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ccm_ac_havc_state");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ccm_ac_havc_state = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_ccm_ac_havc_stateReq(bc_ccm_ac_havc_state),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ccm_ac_havc_stateReq(float bc_ccm_ac_havc_state) {
    auto req = mValueObjectPool->obtainFloat(bc_ccm_ac_havc_state);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ccm_air_distribution_mode_reqWatcher() {
  float bc_ccm_air_distribution_mode_req = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ccm_air_distribution_mode_req");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ccm_air_distribution_mode_req = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_ccm_air_distribution_mode_reqReq(bc_ccm_air_distribution_mode_req),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ccm_air_distribution_mode_reqReq(float bc_ccm_air_distribution_mode_req) {
    auto req = mValueObjectPool->obtainFloat(bc_ccm_air_distribution_mode_req);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ccm_heat_keyWatcher() {
  float bc_ccm_heat_key = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ccm_heat_key");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ccm_heat_key = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_ccm_heat_keyReq(bc_ccm_heat_key),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ccm_heat_keyReq(float bc_ccm_heat_key) {
    auto req = mValueObjectPool->obtainFloat(bc_ccm_heat_key);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ccm_left_set_tempWatcher() {
  float bc_ccm_left_set_temp = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ccm_left_set_temp");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ccm_left_set_temp = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_ccm_left_set_tempReq(bc_ccm_left_set_temp),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ccm_left_set_tempReq(float bc_ccm_left_set_temp) {
    auto req = mValueObjectPool->obtainFloat(bc_ccm_left_set_temp);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ccm_avassetWatcher() {
  float bc_ccm_avasset = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ccm_avasset");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ccm_avasset = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_ccm_avassetReq(bc_ccm_avasset),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ccm_avassetReq(float bc_ccm_avasset) {
    auto req = mValueObjectPool->obtainFloat(bc_ccm_avasset);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ccm_livecounter_0x310Watcher() {
  float bc_ccm_livecounter_0x310 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ccm_livecounter_0x310");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ccm_livecounter_0x310 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_ccm_livecounter_0x310Req(bc_ccm_livecounter_0x310),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ccm_livecounter_0x310Req(float bc_ccm_livecounter_0x310) {
    auto req = mValueObjectPool->obtainFloat(bc_ccm_livecounter_0x310);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ccm_checksum_0x310Watcher() {
  float bc_ccm_checksum_0x310 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ccm_checksum_0x310");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ccm_checksum_0x310 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_ccm_checksum_0x310Req(bc_ccm_checksum_0x310),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ccm_checksum_0x310Req(float bc_ccm_checksum_0x310) {
    auto req = mValueObjectPool->obtainFloat(bc_ccm_checksum_0x310);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ccm_rear_fog_lamp_setWatcher() {
  float bc_ccm_rear_fog_lamp_set = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ccm_rear_fog_lamp_set");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ccm_rear_fog_lamp_set = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_ccm_rear_fog_lamp_setReq(bc_ccm_rear_fog_lamp_set),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ccm_rear_fog_lamp_setReq(float bc_ccm_rear_fog_lamp_set) {
    auto req = mValueObjectPool->obtainFloat(bc_ccm_rear_fog_lamp_set);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ccm_left_mirror_setWatcher() {
  float bc_ccm_left_mirror_set = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ccm_left_mirror_set");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ccm_left_mirror_set = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_ccm_left_mirror_setReq(bc_ccm_left_mirror_set),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ccm_left_mirror_setReq(float bc_ccm_left_mirror_set) {
    auto req = mValueObjectPool->obtainFloat(bc_ccm_left_mirror_set);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ccm_park_un_lock_reqWatcher() {
  float bc_ccm_park_un_lock_req = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ccm_park_un_lock_req");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ccm_park_un_lock_req = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_ccm_park_un_lock_reqReq(bc_ccm_park_un_lock_req),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ccm_park_un_lock_reqReq(float bc_ccm_park_un_lock_req) {
    auto req = mValueObjectPool->obtainFloat(bc_ccm_park_un_lock_req);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ccm_auto_lock_reqWatcher() {
  float bc_ccm_auto_lock_req = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ccm_auto_lock_req");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ccm_auto_lock_req = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_ccm_auto_lock_reqReq(bc_ccm_auto_lock_req),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ccm_auto_lock_reqReq(float bc_ccm_auto_lock_req) {
    auto req = mValueObjectPool->obtainFloat(bc_ccm_auto_lock_req);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ccm_auto_unlock_reqWatcher() {
  float bc_ccm_auto_unlock_req = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ccm_auto_unlock_req");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ccm_auto_unlock_req = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_ccm_auto_unlock_reqReq(bc_ccm_auto_unlock_req),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ccm_auto_unlock_reqReq(float bc_ccm_auto_unlock_req) {
    auto req = mValueObjectPool->obtainFloat(bc_ccm_auto_unlock_req);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ccm_remt_contr_lamp_ctr_cmdWatcher() {
  float bc_ccm_remt_contr_lamp_ctr_cmd = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ccm_remt_contr_lamp_ctr_cmd");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ccm_remt_contr_lamp_ctr_cmd = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_ccm_remt_contr_lamp_ctr_cmdReq(bc_ccm_remt_contr_lamp_ctr_cmd),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ccm_remt_contr_lamp_ctr_cmdReq(float bc_ccm_remt_contr_lamp_ctr_cmd) {
    auto req = mValueObjectPool->obtainFloat(bc_ccm_remt_contr_lamp_ctr_cmd);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ccu_remote_car_searchWatcher() {
  int32_t bc_ccu_remote_car_search = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ccu_remote_car_search");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ccu_remote_car_search = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_ccu_remote_car_searchReq(bc_ccu_remote_car_search),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ccu_remote_car_searchReq(int32_t bc_ccu_remote_car_search) {
    auto req = mValueObjectPool->obtainInt32(bc_ccu_remote_car_search);
    req->prop = toInt(VehicleProperty::GECKO_CCM_REMOTE_CAR_SEARCH);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ccu_remote_lockWatcher() {
  int32_t bc_ccu_remote_lock = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ccu_remote_lock");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ccu_remote_lock = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_ccu_remote_lockReq(bc_ccu_remote_lock),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ccu_remote_lockReq(int32_t bc_ccu_remote_lock) {
    auto req = mValueObjectPool->obtainInt32(bc_ccu_remote_lock);
    req->prop = toInt(VehicleProperty::GECKO_CCM_REMOTE_LOCK);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ccm_right_mirror_setWatcher() {
  float bc_ccm_right_mirror_set = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ccm_right_mirror_set");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ccm_right_mirror_set = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_ccm_right_mirror_setReq(bc_ccm_right_mirror_set),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ccm_right_mirror_setReq(float bc_ccm_right_mirror_set) {
    auto req = mValueObjectPool->obtainFloat(bc_ccm_right_mirror_set);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ccm_livecounter_0x311Watcher() {
  float bc_ccm_livecounter_0x311 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ccm_livecounter_0x311");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ccm_livecounter_0x311 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_ccm_livecounter_0x311Req(bc_ccm_livecounter_0x311),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ccm_livecounter_0x311Req(float bc_ccm_livecounter_0x311) {
    auto req = mValueObjectPool->obtainFloat(bc_ccm_livecounter_0x311);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ccm_checksum_0x311Watcher() {
  float bc_ccm_checksum_0x311 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ccm_checksum_0x311");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ccm_checksum_0x311 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_ccm_checksum_0x311Req(bc_ccm_checksum_0x311),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ccm_checksum_0x311Req(float bc_ccm_checksum_0x311) {
    auto req = mValueObjectPool->obtainFloat(bc_ccm_checksum_0x311);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_bcm_position_light_statusWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_position_light_status = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_position_light_status");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_position_light_status = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_bc_bcm_position_light_statusReq(bc_bcm_position_light_status),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_position_light_statusReq(int32_t bc_bcm_position_light_status) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_position_light_status);
    req->prop = toInt(VehicleProperty::CABIN_LIGHTS_STATE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_bcm_high_beam_statusWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_high_beam_status = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_high_beam_status");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_high_beam_status = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_bc_bcm_high_beam_statusReq(bc_bcm_high_beam_status),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_high_beam_statusReq(int32_t bc_bcm_high_beam_status) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_high_beam_status);
    req->prop = toInt(VehicleProperty::HIGH_BEAM_LIGHTS_STATE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_bcm_low_beam_statusWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_low_beam_status = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_low_beam_status");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_low_beam_status = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_bc_bcm_low_beam_statusReq(bc_bcm_low_beam_status),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_low_beam_statusReq(int32_t bc_bcm_low_beam_status) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_low_beam_status);
    req->prop = toInt(VehicleProperty::HEADLIGHTS_STATE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_bcm_turn_indcr_riWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_turn_indcr_ri = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_turn_indcr_ri");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_turn_indcr_ri = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      // ALOGW("dxy-- bc_bcm bc_bcm_turn_indcr_riWatcher value = %d", bc_bcm_turn_indcr_ri);
      if (bc_bcm_turn_indcr_ri != -1) {
          mHal->onPropertyValue(*Create_bc_bcm_turn_indcr_riReq(bc_bcm_turn_indcr_ri),true);
      }
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_turn_indcr_riReq(int32_t bc_bcm_turn_indcr_ri) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_turn_indcr_ri);
    ALOGW("dxy-- bc_bcm_turn_indcr_riReq value = %d", bc_bcm_turn_indcr_ri);
    req->prop = toInt(VehicleProperty::GECKO_RIGHT_TURN_SIGNAL_STATE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_bcm_turn_indcr_leWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_turn_indcr_le = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_turn_indcr_le");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_turn_indcr_le = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      // ALOGW("dxy-- bc_bcm going to set bc_bcm_turn_indcr_le value = %d", bc_bcm_turn_indcr_le);
      if (bc_bcm_turn_indcr_le != -1) {
          mHal->onPropertyValue(*Create_bc_bcm_turn_indcr_leReq(bc_bcm_turn_indcr_le),true);
      }
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_turn_indcr_leReq(int32_t bc_bcm_turn_indcr_le) {
    ALOGW("dxy-- bc_bcm_turn_indcr_leReq value = %d", bc_bcm_turn_indcr_le);
    auto req = mValueObjectPool->obtainInt32(bc_bcm_turn_indcr_le);
    req->prop = toInt(VehicleProperty::GECKO_LEFT_TURN_SIGNAL_STATE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_bcm_hazard_light_statusWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_hazard_light_status = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_hazard_light_status");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_hazard_light_status = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_bc_bcm_hazard_light_statusReq(bc_bcm_hazard_light_status),true);
  }
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_hazard_light_statusReq(int32_t bc_bcm_hazard_light_status) {
    ALOGW("dxy-- bc_bcm_hazard_light_statusReq value = %d", bc_bcm_hazard_light_status);
    auto req = mValueObjectPool->obtainInt32(bc_bcm_hazard_light_status);
    req->prop = toInt(VehicleProperty::HAZARD_LIGHTS_STATE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_position_light_warningWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_position_light_warning = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_position_light_warning");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_position_light_warning = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_bcm_position_light_warningReq(bc_bcm_position_light_warning),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_position_light_warningReq(int32_t bc_bcm_position_light_warning) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_position_light_warning);
    req->prop = toInt(VehicleProperty::GECKO_POSITION_LIGHT_WARNING);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_rl_door_ajar_statusWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_rl_door_ajar_status = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_rl_door_ajar_status");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_rl_door_ajar_status = static_cast<int32_t> (mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_bc_bcm_rl_door_ajar_statusReq(bc_bcm_rl_door_ajar_status),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_rl_door_ajar_statusReq(int32_t bc_bcm_rl_door_ajar_status) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_rl_door_ajar_status);
    req->prop = toInt(VehicleProperty::GECKO_RL_DOOR_STATE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_rr_door_ajar_statusWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_rr_door_ajar_status = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_rr_door_ajar_status");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_rr_door_ajar_status = static_cast<int32_t> (mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_bc_bcm_rr_door_ajar_statusReq(bc_bcm_rr_door_ajar_status),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_rr_door_ajar_statusReq(int32_t bc_bcm_rr_door_ajar_status) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_rr_door_ajar_status);
    req->prop = toInt(VehicleProperty::GECKO_RR_DOOR_STATE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_bcm_fr_door_ajar_statusWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_fr_door_ajar_status = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_fr_door_ajar_status");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_fr_door_ajar_status = static_cast<int32_t> (mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_bc_bcm_fr_door_ajar_statusReq(bc_bcm_fr_door_ajar_status),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_fr_door_ajar_statusReq(int32_t bc_bcm_fr_door_ajar_status) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_fr_door_ajar_status);
    req->prop = toInt(VehicleProperty::GECKO_FR_DOOR_STATE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_bcm_fl_door_ajar_statusWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_fl_door_ajar_status = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_fl_door_ajar_status");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_fl_door_ajar_status = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_bcm_fl_door_ajar_statusReq(bc_bcm_fl_door_ajar_status),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_fl_door_ajar_statusReq(int32_t bc_bcm_fl_door_ajar_status) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_fl_door_ajar_status);
    req->prop = toInt(VehicleProperty::GECKO_FL_DOOR_STATE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_bcm_rear_fog_light_statusWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_rear_fog_light_status = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_rear_fog_light_status");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_rear_fog_light_status = static_cast<int32_t> (mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_bc_bcm_rear_fog_light_statusReq(bc_bcm_rear_fog_light_status),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_rear_fog_light_statusReq(int32_t bc_bcm_rear_fog_light_status) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_rear_fog_light_status);
    req->prop = toInt(VehicleProperty::FOG_LIGHTS_STATE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_bcm_tr_cls_stWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_tr_cls_st = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_tr_cls_st");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_tr_cls_st = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_bcm_tr_cls_stReq(bc_bcm_tr_cls_st),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_tr_cls_stReq(int32_t bc_bcm_tr_cls_st) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_tr_cls_st);
    req->prop = toInt(VehicleProperty::GECKO_TR_CLS_ST);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_bcm_power_stsWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_power_sts = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_power_sts");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_power_sts = mPropertyManager->getCProValue(mp);

      //
      if((bc_bcm_power_sts == 1 || bc_bcm_power_sts == 2 || bc_bcm_power_sts == 3) &&  powerOnTimestamp == 0){
      //mcu
          //ConfigDBC* odometer = mPropertyManager->findCProperty("ec_total_odometer");
          //beginTotalMileage = getActualFloatValue(mPropertyManager->getCProValue(odometer),1,0);
    
          //ConfigDBC* travel = mPropertyManager->findCProperty("mcu_short_mileage");
          //begintravelMileage = getActualFloatValue(mPropertyManager->getCProValue(travel), 0.1, 0);
    
          //std::chrono::milliseconds ms_start = std::chrono::duration_cast< std::chrono::milliseconds >(
          //std::chrono::system_clock::now().time_since_epoch());
    
          //travelBeginTimes = ms_start.count();
          //travelBeginTimes = gTimes;
          //travelBeginTimes = elapsedRealtime();
          //powerOnTimestamp = elapsedRealtime();
		  ALOGI("bc_bcm_power_stsWatcher 1 powerOnTimestamp:%jd", powerOnTimestamp);
          //battery_low_signal();
          //mHal->onPropertyValue(*Create_power_on_timeReq(0), true);       
      }

      #if 0 //mcu
      if(bc_bcm_power_sts == 1 || bc_bcm_power_sts == 2 || bc_bcm_power_sts == 3) {
          energyConsumptionFlag = true;
          ConfigDBC* mp_average = mPropertyManager->findCProperty("ec_vcu_average_energy_consumption");
          totalEnergyConsumption = getActualFloatValue(mPropertyManager->getCProValue(mp_average),0.1,0);
          mHal->onPropertyValue(*Create_power_on_average_energy_consumptionReq(totalEnergyConsumption),true);
	  } 
      else if(bc_bcm_power_sts == 0) {
          energyConsumptionFlag = false;
      }
      #endif
      //
      lastPowerOnSts = powerOnSts;
      powerOnSts = bc_bcm_power_sts;

      //
      //BCM_PowerSts0x20x0
      #if 0 //mcu
      if(bc_bcm_power_sts == 0) {
        powerOnTimestamp = 0;
        powerOnMileage = 0.0;
	      totalEnergyConsumption = 0.0;
        travelTimes = 0;
        lastTravelTimes = 0;
        travelBeginTimes = 0;
        updateaverageEnergy = 0;
        //lastTimes = 0;

        averageEnergyConsumption = 0.0;
        energyCount = 0;

        updateAverageSpd = -1024;
        updatePowerOnMileage = -1024;

        ALOGI("bc_bcm_power_stsWatcher powerOnTimestamp:%jd, powerOnMileage:%f,totalEnergyConsumption:%f", powerOnTimestamp, powerOnMileage,totalEnergyConsumption);
        mHal->onPropertyValue(*Create_power_on_average_speedReq(-1024),true);
        mHal->onPropertyValue(*Create_power_on_milegeReq(-1024),true);
        mHal->onPropertyValue(*Create_power_on_average_energy_consumptionReq(-1024),true);
        mHal->onPropertyValue(*Create_power_on_timeReq(-1024), true);
      }
      #endif
      ALOGI("bc_bcm_power_stsWatcher powerOnTimestamp = %jd bc_bcm_power_sts:%d powerOnSts:%d lastPowerOnSts:%d", 
      powerOnTimestamp, bc_bcm_power_sts, powerOnSts, lastPowerOnSts);
      mHal->onPropertyValue(*Create_bc_bcm_power_stsReq(bc_bcm_power_sts),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_power_stsReq(int32_t bc_bcm_power_sts) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_power_sts);
    req->prop = toInt(VehicleProperty::IGNITION_STATE);
    ALOGW("cyzhao----bc_bcm_power_sts mPropertyManager->getCProValue(mp) = %d", bc_bcm_power_sts);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_bcm_dtc_fault_statusWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_dtc_fault_status = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_dtc_fault_status");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_dtc_fault_status = mPropertyManager->getCProValue(mp);
      LOG(INFO) << "bc_bcm_dtc_fault_status:"<<bc_bcm_dtc_fault_status;
      mHal->onPropertyValue(*Create_bc_bcm_dtc_fault_statusReq(bc_bcm_dtc_fault_status),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_dtc_fault_statusReq(int32_t bc_bcm_dtc_fault_status) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_dtc_fault_status);
    req->prop = toInt(VehicleProperty::GECKO_BCM_DTC_FAULT_STATUS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_drivelock_stWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_drivelock_st = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_drivelock_st");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_drivelock_st = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_bc_bcm_drivelock_stReq(bc_bcm_drivelock_st),true);
  }
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_drivelock_stReq(int32_t bc_bcm_drivelock_st) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_drivelock_st);
    req->prop = toInt(VehicleProperty::GECKO_BCM_DRIVELOCKST);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_bcm_reversinglight_stWatcher() {
  float bc_bcm_reversinglight_st = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_reversinglight_st");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_reversinglight_st = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_bcm_reversinglight_stReq(bc_bcm_reversinglight_st),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_reversinglight_stReq(float bc_bcm_reversinglight_st) {
    auto req = mValueObjectPool->obtainFloat(bc_bcm_reversinglight_st);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_brakelight_stWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_brakelight_st = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_brakelight_st");         //
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_brakelight_st = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_bc_bcm_brakelight_stReq(bc_bcm_brakelight_st),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_brakelight_stReq(int32_t bc_bcm_brakelight_st) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_brakelight_st);
    req->prop = toInt(VehicleProperty::GECKO_BC_BCM_BREAKELIGHT_ST);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_bcm_interiorlight_stWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_interiorlight_st = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_interiorlight_st");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_interiorlight_st =static_cast<int32_t> (mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_bc_bcm_interiorlight_stReq(bc_bcm_interiorlight_st),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_interiorlight_stReq(int32_t bc_bcm_interiorlight_st) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_interiorlight_st);
    req->prop = toInt(VehicleProperty::READING_LIGHTS_STATE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_ccm_open_door_warn_feedWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_ccm_open_door_warn_feed = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_ccm_open_door_warn_feed");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_ccm_open_door_warn_feed =static_cast<int32_t> (mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_bc_bcm_ccm_open_door_warn_feedReq(bc_bcm_ccm_open_door_warn_feed),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_ccm_open_door_warn_feedReq(int32_t bc_bcm_ccm_open_door_warn_feed) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_ccm_open_door_warn_feed);
    req->prop = toInt(VehicleProperty::GECKO_CCM_BCM_OPENDOOR_WARN_SET);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_right_mirror_set_ackWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_right_mirror_set_ack = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_right_mirror_set_ack");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      if(mPropertyManager->getCProValue(mp) >=0 && mPropertyManager->getCProValue(mp) <=7) {
          bc_bcm_right_mirror_set_ack = static_cast<int32_t>(std::atoi(mp->valueMap[mPropertyManager->getCProValue(mp)].c_str()));
          mHal->onPropertyValue(*Create_bc_bcm_right_mirror_set_ackReq(bc_bcm_right_mirror_set_ack),true);
      }
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_right_mirror_set_ackReq(int32_t bc_bcm_right_mirror_set_ack) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_right_mirror_set_ack);
    req->prop = toInt(VehicleProperty::GECKO_RIGHT_MIRROR_SET);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_bcm_left_mirror_set_ackWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_left_mirror_set_ack = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_left_mirror_set_ack");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      if (mPropertyManager->getCProValue(mp) >=0 && mPropertyManager->getCProValue(mp) <=7) {
          bc_bcm_left_mirror_set_ack = static_cast<int32_t>(std::atoi(mp->valueMap[mPropertyManager->getCProValue(mp)].c_str()));
          mHal->onPropertyValue(*Create_bc_bcm_left_mirror_set_ackReq(bc_bcm_left_mirror_set_ack),true);
      }
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_left_mirror_set_ackReq(int32_t bc_bcm_left_mirror_set_ack) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_left_mirror_set_ack);
    req->prop = toInt(VehicleProperty::GECKO_LEFT_MIRROR_SET);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_bcm_park_un_lock_ackWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_park_un_lock_ack = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_park_un_lock_ack");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_park_un_lock_ack = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_bcm_park_un_lock_ackReq(bc_bcm_park_un_lock_ack),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_park_un_lock_ackReq(int32_t bc_bcm_park_un_lock_ack) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_park_un_lock_ack);
    req->prop = toInt(VehicleProperty::GECKO_PARK_UNLOCK_SET);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_bcm_auto_lock_ackWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_auto_lock_ack = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_auto_lock_ack");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      if (mPropertyManager->getCProValue(mp) >=0 && mPropertyManager->getCProValue(mp) <=1) {
          bc_bcm_auto_lock_ack = mPropertyManager->getCProValue(mp);
          mHal->onPropertyValue(*Create_bc_bcm_auto_lock_ackReq(bc_bcm_auto_lock_ack),true);
      }
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_auto_lock_ackReq(int32_t bc_bcm_auto_lock_ack) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_auto_lock_ack);
    req->prop = toInt(VehicleProperty::GECKO_AUTO_LOCK_SET);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_bcm_auto_unlock_ackWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_auto_unlock_ack = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_auto_unlock_ack");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_auto_unlock_ack = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_bcm_auto_unlock_ackReq(bc_bcm_auto_unlock_ack),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_auto_unlock_ackReq(int32_t bc_bcm_auto_unlock_ack) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_auto_unlock_ack);
    req->prop = toInt(VehicleProperty::GECKO_AUTO_UNLOCK_SET);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_bcm_livecounter_0x330Watcher() {
  float bc_bcm_livecounter_0x330 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_livecounter_0x330");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_livecounter_0x330 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_bcm_livecounter_0x330Req(bc_bcm_livecounter_0x330),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_livecounter_0x330Req(float bc_bcm_livecounter_0x330) {
    auto req = mValueObjectPool->obtainFloat(bc_bcm_livecounter_0x330);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_bcm_checksum_0x330Watcher() {
  float bc_bcm_checksum_0x330 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_checksum_0x330");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_checksum_0x330 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_bcm_checksum_0x330Req(bc_bcm_checksum_0x330),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_checksum_0x330Req(float bc_bcm_checksum_0x330) {
    auto req = mValueObjectPool->obtainFloat(bc_bcm_checksum_0x330);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_bcm_high_beam_rly_errWatcher() {
  float bc_bcm_high_beam_rly_err = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_high_beam_rly_err");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_high_beam_rly_err = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_bcm_high_beam_rly_errReq(bc_bcm_high_beam_rly_err),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_high_beam_rly_errReq(float bc_bcm_high_beam_rly_err) {
    auto req = mValueObjectPool->obtainFloat(bc_bcm_high_beam_rly_err);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_bcm_turn_indcr_ri_errWatcher() {
  float bc_bcm_turn_indcr_ri_err = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_turn_indcr_ri_err");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_turn_indcr_ri_err = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_bcm_turn_indcr_ri_errReq(bc_bcm_turn_indcr_ri_err),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_turn_indcr_ri_errReq(float bc_bcm_turn_indcr_ri_err) {
    auto req = mValueObjectPool->obtainFloat(bc_bcm_turn_indcr_ri_err);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_bcm_turn_indcr_le_errWatcher() {
  float bc_bcm_turn_indcr_le_err = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_turn_indcr_le_err");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_turn_indcr_le_err = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_bcm_turn_indcr_le_errReq(bc_bcm_turn_indcr_le_err),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_turn_indcr_le_errReq(float bc_bcm_turn_indcr_le_err) {
    auto req = mValueObjectPool->obtainFloat(bc_bcm_turn_indcr_le_err);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_daytime_running_light_errWatcher() {
  float bc_bcm_daytime_running_light_err = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_daytime_running_light_err");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_daytime_running_light_err = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_bcm_daytime_running_light_errReq(bc_bcm_daytime_running_light_err),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_daytime_running_light_errReq(float bc_bcm_daytime_running_light_err) {
    auto req = mValueObjectPool->obtainFloat(bc_bcm_daytime_running_light_err);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_bcm_brakelight_errWatcher() {
  float bc_bcm_brakelight_err = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_brakelight_err");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_brakelight_err = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_bcm_brakelight_errReq(bc_bcm_brakelight_err),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_brakelight_errReq(float bc_bcm_brakelight_err) {
    auto req = mValueObjectPool->obtainFloat(bc_bcm_brakelight_err);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_bcm_reversinglight_errWatcher() {
  float bc_bcm_reversinglight_err = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_reversinglight_err");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_reversinglight_err = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_bcm_reversinglight_errReq(bc_bcm_reversinglight_err),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_reversinglight_errReq(float bc_bcm_reversinglight_err) {
    auto req = mValueObjectPool->obtainFloat(bc_bcm_reversinglight_err);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_bcm_rear_fog_light_errWatcher() {
  float bc_bcm_rear_fog_light_err = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_rear_fog_light_err");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_rear_fog_light_err = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_bcm_rear_fog_light_errReq(bc_bcm_rear_fog_light_err),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_rear_fog_light_errReq(float bc_bcm_rear_fog_light_err) {
    auto req = mValueObjectPool->obtainFloat(bc_bcm_rear_fog_light_err);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

int32_t GarageModeServerSideHandlerImpl::getElectricErr(){
  int32_t value = mPropertyManager->getCProValue(mPropertyManager->findCProperty("bc_bcm_loss_com_with_acu"));
  if(value == 1) return 1;

  value = mPropertyManager->getCProValue(mPropertyManager->findCProperty("bc_bcm_loss_com_with_ccm"));
  if(value == 1) return 1;

  value = mPropertyManager->getCProValue(mPropertyManager->findCProperty("bc_bcm_loss_com_with_vcu"));
  if(value == 1) return 1;

  value = mPropertyManager->getCProValue(mPropertyManager->findCProperty("cc_acu_gsensor_fault"));
  if(value == 1) return 1;

  value = mPropertyManager->getCProValue(mPropertyManager->findCProperty("ec_vcu_lv_elec_sys_err"));
  if(value == 1) return 1;
  
  return 0;
}

void GarageModeServerSideHandlerImpl::bc_bcm_loss_com_with_acuWatcher() {
  int32_t bc_bcm_loss_com_with_acu = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_loss_com_with_acu");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_loss_com_with_acu = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_electric_errReq(getElectricErr()),true);
      LOG(INFO) << "bc_bcm_loss_com_with_acu: "<< bc_bcm_loss_com_with_acu;
  }
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_electric_errReq(int32_t value){
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_ELECTRIC_ERR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_loss_com_with_acuReq(float bc_bcm_loss_com_with_acu) {
    auto req = mValueObjectPool->obtainFloat(bc_bcm_loss_com_with_acu);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_bcm_loss_com_with_ccmWatcher() {
  int32_t bc_bcm_loss_com_with_ccm = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_loss_com_with_ccm");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_loss_com_with_ccm = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_electric_errReq(getElectricErr()),true);
      LOG(INFO) << "bc_bcm_loss_com_with_ccm: "<< bc_bcm_loss_com_with_ccm;
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_loss_com_with_ccmReq(float bc_bcm_loss_com_with_ccm) {
    auto req = mValueObjectPool->obtainFloat(bc_bcm_loss_com_with_ccm);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_bcm_loss_com_with_vcuWatcher() {
  int32_t bc_bcm_loss_com_with_vcu = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_loss_com_with_vcu");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_loss_com_with_vcu = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_electric_errReq(getElectricErr()),true);
      LOG(INFO) << "bc_bcm_loss_com_with_vcu: "<< bc_bcm_loss_com_with_vcu;
      
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_loss_com_with_vcuReq(float bc_bcm_loss_com_with_vcu) {
    auto req = mValueObjectPool->obtainFloat(bc_bcm_loss_com_with_vcu);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_bcm_lv_batt_over_voltWatcher() {
  float bc_bcm_lv_batt_over_volt = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_lv_batt_over_volt");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_lv_batt_over_volt = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_bcm_lv_batt_over_voltReq(bc_bcm_lv_batt_over_volt),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_lv_batt_over_voltReq(float bc_bcm_lv_batt_over_volt) {
    auto req = mValueObjectPool->obtainFloat(bc_bcm_lv_batt_over_volt);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_bcm_lv_batt_under_voltWatcher() {
  float bc_bcm_lv_batt_under_volt = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_lv_batt_under_volt");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_lv_batt_under_volt = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_bcm_lv_batt_under_voltReq(bc_bcm_lv_batt_under_volt),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_lv_batt_under_voltReq(float bc_bcm_lv_batt_under_volt) {
    auto req = mValueObjectPool->obtainFloat(bc_bcm_lv_batt_under_volt);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_bcm_horn_rly_errWatcher() {
  float bc_bcm_horn_rly_err = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_horn_rly_err");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_horn_rly_err = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_bcm_horn_rly_errReq(bc_bcm_horn_rly_err),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_horn_rly_errReq(float bc_bcm_horn_rly_err) {
    auto req = mValueObjectPool->obtainFloat(bc_bcm_horn_rly_err);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_bcm_low_beam_rly_errWatcher() {
  float bc_bcm_low_beam_rly_err = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_low_beam_rly_err");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_low_beam_rly_err = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_bcm_low_beam_rly_errReq(bc_bcm_low_beam_rly_err),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_low_beam_rly_errReq(float bc_bcm_low_beam_rly_err) {
    auto req = mValueObjectPool->obtainFloat(bc_bcm_low_beam_rly_err);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_bcm_livecounter_0x331Watcher() {
  float bc_bcm_livecounter_0x331 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_livecounter_0x331");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_livecounter_0x331 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_bcm_livecounter_0x331Req(bc_bcm_livecounter_0x331),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_livecounter_0x331Req(float bc_bcm_livecounter_0x331) {
    auto req = mValueObjectPool->obtainFloat(bc_bcm_livecounter_0x331);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_bcm_checksum_0x331Watcher() {
  float bc_bcm_checksum_0x331 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_checksum_0x331");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_checksum_0x331 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_bcm_checksum_0x331Req(bc_bcm_checksum_0x331),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_checksum_0x331Req(float bc_bcm_checksum_0x331) {
    auto req = mValueObjectPool->obtainFloat(bc_bcm_checksum_0x331);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_pdc1_button_pressWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_pdc1_button_press = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_pdc1_button_press");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_pdc1_button_press = static_cast<int32_t> (mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_bc_pdc1_button_pressReq(bc_pdc1_button_press),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_pdc1_button_pressReq(int32_t bc_pdc1_button_press) {
    auto req = mValueObjectPool->obtainInt32(bc_pdc1_button_press);
    req->prop = toInt(VehicleProperty::GECKO_BD_PDC1_BUTTON_PRESS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_pdc1_modeWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_pdc1_mode = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_pdc1_mode");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_pdc1_mode = static_cast<int32_t> (mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_bc_pdc1_modeReq(bc_pdc1_mode),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_pdc1_modeReq(int32_t bc_pdc1_mode) {
    auto req = mValueObjectPool->obtainInt32(bc_pdc1_mode);
    req->prop = toInt(VehicleProperty::GECKO_BD_PDC1_MODE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_pdc1_buzzer_alarm_patternWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_pdc1_buzzer_alarm_pattern = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_pdc1_buzzer_alarm_pattern");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_pdc1_buzzer_alarm_pattern = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_pdc1_buzzer_alarm_patternReq(bc_pdc1_buzzer_alarm_pattern),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_pdc1_buzzer_alarm_patternReq(int32_t bc_pdc1_buzzer_alarm_pattern) {
    auto req = mValueObjectPool->obtainInt32(bc_pdc1_buzzer_alarm_pattern);
    req->prop = toInt(VehicleProperty::GECKO_PDC1_BUZZER_ALARM_PATTERN);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_pdc1_distance_rmWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_pdc1_distance_rm = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_pdc1_distance_rm");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_pdc1_distance_rm = static_cast<int32_t> (mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_bc_pdc1_distance_rmReq(bc_pdc1_distance_rm),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_pdc1_distance_rmReq(int32_t bc_pdc1_distance_rm) {
    auto req = mValueObjectPool->obtainInt32(bc_pdc1_distance_rm);
    req->prop = toInt(VehicleProperty::GECKO_BD_PDC1_DISTANCE_RM);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_pdc1_distance_rrmWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_pdc1_distance_rrm = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_pdc1_distance_rrm");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_pdc1_distance_rrm = static_cast<int32_t> (mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_bc_pdc1_distance_rrmReq(bc_pdc1_distance_rrm),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_pdc1_distance_rrmReq(int32_t bc_pdc1_distance_rrm) {
    auto req = mValueObjectPool->obtainInt32(bc_pdc1_distance_rrm);
    req->prop = toInt(VehicleProperty::GECKO_BD_PDC1_DISTANCE_RRM);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_pdc1_distance_rlWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_pdc1_distance_rl = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_pdc1_distance_rl");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_pdc1_distance_rl = static_cast<int32_t> (mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_bc_pdc1_distance_rlReq(bc_pdc1_distance_rl),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_pdc1_distance_rlReq(int32_t bc_pdc1_distance_rl) {
    auto req = mValueObjectPool->obtainInt32(bc_pdc1_distance_rl);
    req->prop = toInt(VehicleProperty::GECKO_BD_PDC1_DISTANCE_RL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_pdc1_distance_rrWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_pdc1_distance_rr = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_pdc1_distance_rr");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_pdc1_distance_rr = static_cast<int32_t> (mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_bc_pdc1_distance_rrReq(bc_pdc1_distance_rr),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_pdc1_distance_rrReq(int32_t bc_pdc1_distance_rr) {
    auto req = mValueObjectPool->obtainInt32(bc_pdc1_distance_rr);
    req->prop = toInt(VehicleProperty::GECKO_BD_PDC1_DISTANCE_RR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_pdc_livecounter_0x165Watcher() {
  float bc_pdc_livecounter_0x165 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_pdc_livecounter_0x165");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_pdc_livecounter_0x165 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_pdc_livecounter_0x165Req(bc_pdc_livecounter_0x165),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_pdc_livecounter_0x165Req(float bc_pdc_livecounter_0x165) {
    auto req = mValueObjectPool->obtainFloat(bc_pdc_livecounter_0x165);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_pdc_checksum_0x165Watcher() {
  float bc_pdc_checksum_0x165 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_pdc_checksum_0x165");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_pdc_checksum_0x165 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_pdc_checksum_0x165Req(bc_pdc_checksum_0x165),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_pdc_checksum_0x165Req(float bc_pdc_checksum_0x165) {
    auto req = mValueObjectPool->obtainFloat(bc_pdc_checksum_0x165);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_bcm_work_reqWatcher() {
  float bc_bcm_work_req = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_work_req");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_work_req = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_bcm_work_reqReq(bc_bcm_work_req),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_work_reqReq(float bc_bcm_work_req) {
    auto req = mValueObjectPool->obtainFloat(bc_bcm_work_req);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_bcm_livecounter_0x669Watcher() {
  float bc_bcm_livecounter_0x669 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_livecounter_0x669");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_livecounter_0x669 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_bcm_livecounter_0x669Req(bc_bcm_livecounter_0x669),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_livecounter_0x669Req(float bc_bcm_livecounter_0x669) {
    auto req = mValueObjectPool->obtainFloat(bc_bcm_livecounter_0x669);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_bcm_checksum_0x669Watcher() {
  float bc_bcm_checksum_0x669 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_checksum_0x669");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_checksum_0x669 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_bcm_checksum_0x669Req(bc_bcm_checksum_0x669),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_checksum_0x669Req(float bc_bcm_checksum_0x669) {
    auto req = mValueObjectPool->obtainFloat(bc_bcm_checksum_0x669);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_str_work_reqWatcher() {
  float bc_str_work_req = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_str_work_req");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_str_work_req = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_str_work_reqReq(bc_str_work_req),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_str_work_reqReq(float bc_str_work_req) {
    auto req = mValueObjectPool->obtainFloat(bc_str_work_req);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ccm_nm_bitWatcher() {
  float bc_ccm_nm_bit = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ccm_nm_bit");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ccm_nm_bit = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_ccm_nm_bitReq(bc_ccm_nm_bit),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ccm_nm_bitReq(float bc_ccm_nm_bit) {
    auto req = mValueObjectPool->obtainFloat(bc_ccm_nm_bit);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ccm_livecounter_0x66_bWatcher() {
  float bc_ccm_livecounter_0x66_b = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ccm_livecounter_0x66_b");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ccm_livecounter_0x66_b = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_ccm_livecounter_0x66_bReq(bc_ccm_livecounter_0x66_b),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ccm_livecounter_0x66_bReq(float bc_ccm_livecounter_0x66_b) {
    auto req = mValueObjectPool->obtainFloat(bc_ccm_livecounter_0x66_b);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ccm_checksum_0x66_bWatcher() {
  float bc_ccm_checksum_0x66_b = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ccm_checksum_0x66_b");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ccm_checksum_0x66_b = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_ccm_checksum_0x66_bReq(bc_ccm_checksum_0x66_b),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ccm_checksum_0x66_bReq(float bc_ccm_checksum_0x66_b) {
    auto req = mValueObjectPool->obtainFloat(bc_ccm_checksum_0x66_b);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}



void GarageModeServerSideHandlerImpl::bc_avas_stateWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_avas_state = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_avas_state");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_avas_state = static_cast<int32_t>(mPropertyManager->getCProValue(mp));;
      mHal->onPropertyValue(*Create_bc_avas_stateReq(bc_avas_state),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_avas_stateReq(int32_t bc_avas_state) {
    auto req = mValueObjectPool->obtainInt32(bc_avas_state);
    req->prop = toInt(VehicleProperty::GECKO_LOW_SPEED_PEDESTRIAN_WARNING);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_avas_livecounter_0x411Watcher() {
  float bc_avas_livecounter_0x411 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_avas_livecounter_0x411");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_avas_livecounter_0x411 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_avas_livecounter_0x411Req(bc_avas_livecounter_0x411),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_avas_livecounter_0x411Req(float bc_avas_livecounter_0x411) {
    auto req = mValueObjectPool->obtainFloat(bc_avas_livecounter_0x411);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_avas_checksum_0x411Watcher() {
  float bc_avas_checksum_0x411 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_avas_checksum_0x411");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_avas_checksum_0x411 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_avas_checksum_0x411Req(bc_avas_checksum_0x411),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_avas_checksum_0x411Req(float bc_avas_checksum_0x411) {
    auto req = mValueObjectPool->obtainFloat(bc_avas_checksum_0x411);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_bcm_ccm_reset_stWatcher() {
  float bc_bcm_ccm_reset_st = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_ccm_reset_st");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_ccm_reset_st = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_bcm_ccm_reset_stReq(bc_bcm_ccm_reset_st),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_ccm_reset_stReq(float bc_bcm_ccm_reset_st) {
    auto req = mValueObjectPool->obtainFloat(bc_bcm_ccm_reset_st);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ota_modelWatcher() {
  float bc_ota_model = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ota_model");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ota_model = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_ota_modelReq(bc_ota_model),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ota_modelReq(float bc_ota_model) {
    auto req = mValueObjectPool->obtainFloat(bc_ota_model);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ccm_bcm_open_door_warn_setWatcher() {
  float bc_ccm_bcm_open_door_warn_set = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ccm_bcm_open_door_warn_set");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ccm_bcm_open_door_warn_set = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_ccm_bcm_open_door_warn_setReq(bc_ccm_bcm_open_door_warn_set),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ccm_bcm_open_door_warn_setReq(float bc_ccm_bcm_open_door_warn_set) {
    auto req = mValueObjectPool->obtainFloat(bc_ccm_bcm_open_door_warn_set);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ccm_livecounter_0x353Watcher() {
  float bc_ccm_livecounter_0x353 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ccm_livecounter_0x353");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ccm_livecounter_0x353 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_ccm_livecounter_0x353Req(bc_ccm_livecounter_0x353),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ccm_livecounter_0x353Req(float bc_ccm_livecounter_0x353) {
    auto req = mValueObjectPool->obtainFloat(bc_ccm_livecounter_0x353);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ccm_checksum_0x353Watcher() {
  float bc_ccm_checksum_0x353 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ccm_checksum_0x353");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ccm_checksum_0x353 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_ccm_checksum_0x353Req(bc_ccm_checksum_0x353),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ccm_checksum_0x353Req(float bc_ccm_checksum_0x353) {
    auto req = mValueObjectPool->obtainFloat(bc_ccm_checksum_0x353);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ccm_tpms_learning_validWatcher() {
  float bc_ccm_tpms_learning_valid = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ccm_tpms_learning_valid");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ccm_tpms_learning_valid = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_ccm_tpms_learning_validReq(bc_ccm_tpms_learning_valid),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ccm_tpms_learning_validReq(float bc_ccm_tpms_learning_valid) {
    auto req = mValueObjectPool->obtainFloat(bc_ccm_tpms_learning_valid);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ccm_remt_ctrl_flagWatcher() {
  float bc_ccm_remt_ctrl_flag = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ccm_remt_ctrl_flag");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ccm_remt_ctrl_flag = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_ccm_remt_ctrl_flagReq(bc_ccm_remt_ctrl_flag),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ccm_remt_ctrl_flagReq(float bc_ccm_remt_ctrl_flag) {
    auto req = mValueObjectPool->obtainFloat(bc_ccm_remt_ctrl_flag);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ccm_livecounter_0x354Watcher() {
  float bc_ccm_livecounter_0x354 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ccm_livecounter_0x354");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ccm_livecounter_0x354 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_ccm_livecounter_0x354Req(bc_ccm_livecounter_0x354),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ccm_livecounter_0x354Req(float bc_ccm_livecounter_0x354) {
    auto req = mValueObjectPool->obtainFloat(bc_ccm_livecounter_0x354);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::bc_ccm_checksum_0x354Watcher() {
  float bc_ccm_checksum_0x354 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ccm_checksum_0x354");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ccm_checksum_0x354 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_bc_ccm_checksum_0x354Req(bc_ccm_checksum_0x354),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ccm_checksum_0x354Req(float bc_ccm_checksum_0x354) {
    auto req = mValueObjectPool->obtainFloat(bc_ccm_checksum_0x354);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_tpms_receiverstateWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_tpms_receiverstate = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_tpms_receiverstate");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_tpms_receiverstate = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_bc_tpms_receiverstateReq(bc_tpms_receiverstate),true);
  }
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_tpms_receiverstateReq(int32_t bc_tpms_receiverstate) {
    auto req = mValueObjectPool->obtainInt32(bc_tpms_receiverstate);
    req->prop = toInt(VehicleProperty::GECKO_TYRE_STATE);
    req->areaId = WHEEL_TYRE_RECEIVERSTATE;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_tpms_transducer_locationWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_tpms_transducer_location = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_tpms_transducer_location");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_tpms_transducer_location = static_cast<int32_t>(std::atoi(mp->valueMap[mPropertyManager->getCProValue(mp)].c_str()));
      mHal->onPropertyValue(*Create_bc_tpms_transducer_locationReq(bc_tpms_transducer_location),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_tpms_transducer_locationReq(int32_t bc_tpms_transducer_location) {
    auto req = mValueObjectPool->obtainInt32(bc_tpms_transducer_location);
    req->prop = toInt(VehicleProperty::GECKO_TRANSDUCER_LOCATION);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}


void GarageModeServerSideHandlerImpl::bc_tpms_tyrestate_frWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_tpms_tyrestate_fr = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_tpms_tyrestate_fr");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_tpms_tyrestate_fr = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_bc_tpms_tyrestate_frReq(bc_tpms_tyrestate_fr),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_tpms_tyrestate_frReq(int32_t bc_tpms_tyrestate_fr) {
    auto req = mValueObjectPool->obtainInt32(bc_tpms_tyrestate_fr);
    req->prop = toInt(VehicleProperty::GECKO_TYRE_STATE);
    req->areaId = WHEEL_FRONT_RIGHT;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}


void GarageModeServerSideHandlerImpl::bc_tpms_tyrestate_flWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_tpms_tyrestate_fl = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_tpms_tyrestate_fl");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_tpms_tyrestate_fl = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_bc_tpms_tyrestate_flReq(bc_tpms_tyrestate_fl),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_tpms_tyrestate_flReq(int32_t bc_tpms_tyrestate_fl) {
    auto req = mValueObjectPool->obtainInt32(bc_tpms_tyrestate_fl);
    req->prop = toInt(VehicleProperty::GECKO_TYRE_STATE);
    req->areaId = WHEEL_FRONT_LEFT;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_tpms_tyrestate_rlWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_tpms_tyrestate_rl = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_tpms_tyrestate_rl");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_tpms_tyrestate_rl = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_bc_tpms_tyrestate_rlReq(bc_tpms_tyrestate_rl),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_tpms_tyrestate_rlReq(int32_t bc_tpms_tyrestate_rl) {
    auto req = mValueObjectPool->obtainInt32(bc_tpms_tyrestate_rl);
    req->prop = toInt(VehicleProperty::GECKO_TYRE_STATE);
    req->areaId = WHEEL_REAR_LEFT;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_tpms_tyrestate_rrWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_tpms_tyrestate_rr = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_tpms_tyrestate_rr");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_tpms_tyrestate_rr = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_bc_tpms_tyrestate_rrReq(bc_tpms_tyrestate_rr),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_tpms_tyrestate_rrReq(int32_t bc_tpms_tyrestate_rr) {
    auto req = mValueObjectPool->obtainInt32(bc_tpms_tyrestate_rr);
    req->prop = toInt(VehicleProperty::GECKO_TYRE_STATE);
    req->areaId = WHEEL_REAR_RIGHT;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}


void GarageModeServerSideHandlerImpl::bc_tpms_tyretemperatureWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  float bc_tpms_tyretemperature = 0.0;
  int32_t current_tyre = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_tpms_tyretemperature");
  ConfigDBC* currentTyreCDBC = mPropertyManager->findCProperty("bc_tpms_transducer_location");
  // bc_tpms_transducer_location
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      // ID 
      current_tyre = static_cast<int32_t> (std::atoi(currentTyreCDBC->valueMap[mPropertyManager->getCProValue(currentTyreCDBC)].c_str()));
      LOG(INFO) << "dxy-- handler 1 atoi bc_tpms_transducer_location: "<<current_tyre;
      // 
      bc_tpms_tyretemperature = getActualFloatValue(static_cast<int32_t>(mPropertyManager->getCProValue(mp)),1,-40);
      LOG(INFO) << "dxy-- handler : bc_tpms_tyretemperature"<<bc_tpms_tyretemperature;
      mHal->onPropertyValue(*Create_bc_tpms_tyretemperatureReq(bc_tpms_tyretemperature,current_tyre),true);

      // std::unique_lock<std::mutex> lock(bcTpmsTyretemperatureMtx);
      // 1
      // if (bcTpmsTyretemperatureCv.wait_for(lock, std::chrono::seconds(monitorTime)) == std::cv_status::timeout) {
      //       mHal->onPropertyValue(*Create_bc_tpms_tyretemperatureReq(invalidValueFloat,1),true);
      //       mHal->onPropertyValue(*Create_bc_tpms_tyretemperatureReq(invalidValueFloat,2),true);
      //       mHal->onPropertyValue(*Create_bc_tpms_tyretemperatureReq(invalidValueFloat,4),true);
      //       mHal->onPropertyValue(*Create_bc_tpms_tyretemperatureReq(invalidValueFloat,8),true);
      // }else {
      //        std::cout << "bc_tpms_tyretemperature have value.\n" << std::endl;
      // }
      
      // -1024.0, --      
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_tpms_tyretemperatureReq(float bc_tpms_tyretemperature,int current_tyre) {
    auto req = mValueObjectPool->obtainInt32(static_cast<int32_t> (bc_tpms_tyretemperature));
    // LOG(INFO) << "dxy-- to insert  :areaId = "<< current_tyre << " bc_tpms_tyretemperature = "<<bc_tpms_tyretemperature << " id = " << toInt(VehicleProperty::GECKO_TYRE_TEMPERATURE);
    req->prop = toInt(VehicleProperty::GECKO_TYRE_TEMPERATURE);
    req->areaId = current_tyre;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}


void GarageModeServerSideHandlerImpl::bc_tpms_tyrepressure_flWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  float bc_tpms_tyrepressure_fl = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_tpms_tyrepressure_fl");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_tpms_tyrepressure_fl = getActualFloatValue(mPropertyManager->getCProValue(mp),0.03,0);
      mHal->onPropertyValue(*Create_bc_tpms_tyrepressure_flReq(bc_tpms_tyrepressure_fl),true);

  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_tpms_tyrepressure_flReq(float bc_tpms_tyrepressure_fl) {
    auto req = mValueObjectPool->obtainFloat(bc_tpms_tyrepressure_fl);
    req->prop = toInt(VehicleProperty::TIRE_PRESSURE);
    req->areaId = WHEEL_FRONT_LEFT;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_tpms_tyrepressure_frWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  float bc_tpms_tyrepressure_fr = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_tpms_tyrepressure_fr");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_tpms_tyrepressure_fr = getActualFloatValue(mPropertyManager->getCProValue(mp),0.03,0);
      mHal->onPropertyValue(*Create_bc_tpms_tyrepressure_frReq(bc_tpms_tyrepressure_fr),true);

  }
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_tpms_tyrepressure_frReq(float bc_tpms_tyrepressure_fr) {
    auto req = mValueObjectPool->obtainFloat(bc_tpms_tyrepressure_fr);
    req->prop = toInt(VehicleProperty::TIRE_PRESSURE);
    req->areaId = WHEEL_FRONT_RIGHT;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}


void GarageModeServerSideHandlerImpl::bc_tpms_tyrepressure_rrWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  float bc_tpms_tyrepressure_rr = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_tpms_tyrepressure_rr");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_tpms_tyrepressure_rr = getActualFloatValue(mPropertyManager->getCProValue(mp),0.03,0);
      mHal->onPropertyValue(*Create_bc_tpms_tyrepressure_rrReq(bc_tpms_tyrepressure_rr),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_tpms_tyrepressure_rrReq(float bc_tpms_tyrepressure_rr) {
    auto req = mValueObjectPool->obtainFloat(bc_tpms_tyrepressure_rr);
    req->prop = toInt(VehicleProperty::TIRE_PRESSURE);
    req->areaId = WHEEL_REAR_RIGHT;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_tpms_tyrepressure_rlWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  float bc_tpms_tyrepressure_rl = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_tpms_tyrepressure_rl");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_tpms_tyrepressure_rl = getActualFloatValue(mPropertyManager->getCProValue(mp),0.03,0);
      mHal->onPropertyValue(*Create_bc_tpms_tyrepressure_rlReq(bc_tpms_tyrepressure_rl),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_tpms_tyrepressure_rlReq(float bc_tpms_tyrepressure_rl) {
    auto req = mValueObjectPool->obtainFloat(bc_tpms_tyrepressure_rl);
    req->prop = toInt(VehicleProperty::TIRE_PRESSURE);
    req->areaId = WHEEL_REAR_LEFT;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_acu_gsensor_faultWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t cc_acu_gsensor_fault = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_acu_gsensor_fault");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_acu_gsensor_fault = mPropertyManager->getCProValue(mp);
      LOG(INFO) << "cc_acu_gsensor_fault:"<<cc_acu_gsensor_fault;
      mHal->onPropertyValue(*Create_cc_acu_gsensor_faultReq(cc_acu_gsensor_fault),true);
      mHal->onPropertyValue(*Create_electric_errReq(getElectricErr()),true);

  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_acu_gsensor_faultReq(int32_t cc_acu_gsensor_fault) {
    auto req = mValueObjectPool->obtainInt32(cc_acu_gsensor_fault);
    req->prop = toInt(VehicleProperty::GECKO_ACU_GSENSOR_FAULT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_acu_system_stsWatcher() {
  float cc_acu_system_sts = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_acu_system_sts");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_acu_system_sts = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_acu_system_stsReq(cc_acu_system_sts),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_acu_system_stsReq(float cc_acu_system_sts) {
    auto req = mValueObjectPool->obtainFloat(cc_acu_system_sts);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_acu_airb_warn_lamp_stWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t cc_acu_airb_warn_lamp_st = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_acu_airb_warn_lamp_st");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_acu_airb_warn_lamp_st = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_cc_acu_airb_warn_lamp_stReq(cc_acu_airb_warn_lamp_st),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_acu_airb_warn_lamp_stReq(int32_t cc_acu_airb_warn_lamp_st) {
    auto req = mValueObjectPool->obtainInt32(cc_acu_airb_warn_lamp_st);
    req->prop = toInt(VehicleProperty::GECKO_ACU_AIRB_WARN_LAMP_ST);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_acu_crash_outp_stsWatcher() {
  float cc_acu_crash_outp_sts = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_acu_crash_outp_sts");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_acu_crash_outp_sts = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_acu_crash_outp_stsReq(cc_acu_crash_outp_sts),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_acu_crash_outp_stsReq(float cc_acu_crash_outp_sts) {
    auto req = mValueObjectPool->obtainFloat(cc_acu_crash_outp_sts);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_acu_livecounter_0x133Watcher() {
  float cc_acu_livecounter_0x133 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_acu_livecounter_0x133");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_acu_livecounter_0x133 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_acu_livecounter_0x133Req(cc_acu_livecounter_0x133),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_acu_livecounter_0x133Req(float cc_acu_livecounter_0x133) {
    auto req = mValueObjectPool->obtainFloat(cc_acu_livecounter_0x133);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_acu_checksum_0x133Watcher() {
  float cc_acu_checksum_0x133 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_acu_checksum_0x133");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_acu_checksum_0x133 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_acu_checksum_0x133Req(cc_acu_checksum_0x133),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_acu_checksum_0x133Req(float cc_acu_checksum_0x133) {
    auto req = mValueObjectPool->obtainFloat(cc_acu_checksum_0x133);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::cc_abs_abs_fail_statusWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t cc_abs_abs_fail_status = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_abs_abs_fail_status");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_abs_abs_fail_status = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      LOG(INFO) << "dxy----cc_abs_abs_fail_status:"<<cc_abs_abs_fail_status;
      mHal->onPropertyValue(*Create_cc_abs_abs_fail_statusReq(cc_abs_abs_fail_status),true);
  }
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_abs_abs_fail_statusReq(int32_t cc_abs_abs_fail_status) {
    auto req = mValueObjectPool->obtainInt32(cc_abs_abs_fail_status);
    req->prop = toInt(VehicleProperty::GECKO_ABS_ABS_FAIL_STATUS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::cc_abs_llivecounter_0x171Watcher() {
  float cc_abs_llivecounter_0x171 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_abs_llivecounter_0x171");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_abs_llivecounter_0x171 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_abs_llivecounter_0x171Req(cc_abs_llivecounter_0x171),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_abs_llivecounter_0x171Req(float cc_abs_llivecounter_0x171) {
    auto req = mValueObjectPool->obtainFloat(cc_abs_llivecounter_0x171);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_abs_checksum_0x171Watcher() {
  float cc_abs_checksum_0x171 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_abs_checksum_0x171");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_abs_checksum_0x171 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_abs_checksum_0x171Req(cc_abs_checksum_0x171),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_abs_checksum_0x171Req(float cc_abs_checksum_0x171) {
    auto req = mValueObjectPool->obtainFloat(cc_abs_checksum_0x171);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_eps_run_stateWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t cc_eps_run_state = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_eps_run_state");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_eps_run_state = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_cc_eps_run_stateReq(cc_eps_run_state),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_eps_run_stateReq(int32_t cc_eps_run_state) {
    auto req = mValueObjectPool->obtainInt32(cc_eps_run_state);
    req->prop = toInt(VehicleProperty::GECKO_EPS_RUN_STATE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::cc_eps_livecounter_0x300Watcher() {
  float cc_eps_livecounter_0x300 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_eps_livecounter_0x300");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_eps_livecounter_0x300 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_eps_livecounter_0x300Req(cc_eps_livecounter_0x300),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_eps_livecounter_0x300Req(float cc_eps_livecounter_0x300) {
    auto req = mValueObjectPool->obtainFloat(cc_eps_livecounter_0x300);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_eps_checksum_0x300Watcher() {
  float cc_eps_checksum_0x300 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_eps_checksum_0x300");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_eps_checksum_0x300 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_eps_checksum_0x300Req(cc_eps_checksum_0x300),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_eps_checksum_0x300Req(float cc_eps_checksum_0x300) {
    auto req = mValueObjectPool->obtainFloat(cc_eps_checksum_0x300);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_eps_motor_curr_fltWatcher() {
  float cc_eps_motor_curr_flt = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_eps_motor_curr_flt");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_eps_motor_curr_flt = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_eps_motor_curr_fltReq(cc_eps_motor_curr_flt),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_eps_motor_curr_fltReq(float cc_eps_motor_curr_flt) {
    auto req = mValueObjectPool->obtainFloat(cc_eps_motor_curr_flt);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_eps_motor_volt_fltWatcher() {
  float cc_eps_motor_volt_flt = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_eps_motor_volt_flt");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_eps_motor_volt_flt = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_eps_motor_volt_fltReq(cc_eps_motor_volt_flt),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_eps_motor_volt_fltReq(float cc_eps_motor_volt_flt) {
    auto req = mValueObjectPool->obtainFloat(cc_eps_motor_volt_flt);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_eps_torq_snr_s_sig_out_rng_fltWatcher() {
  float cc_eps_torq_snr_s_sig_out_rng_flt = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_eps_torq_snr_s_sig_out_rng_flt");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_eps_torq_snr_s_sig_out_rng_flt = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_eps_torq_snr_s_sig_out_rng_fltReq(cc_eps_torq_snr_s_sig_out_rng_flt),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_eps_torq_snr_s_sig_out_rng_fltReq(float cc_eps_torq_snr_s_sig_out_rng_flt) {
    auto req = mValueObjectPool->obtainFloat(cc_eps_torq_snr_s_sig_out_rng_flt);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_eps_torq_snr_p_sig_out_rng_fltWatcher() {
  float cc_eps_torq_snr_p_sig_out_rng_flt = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_eps_torq_snr_p_sig_out_rng_flt");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_eps_torq_snr_p_sig_out_rng_flt = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_eps_torq_snr_p_sig_out_rng_fltReq(cc_eps_torq_snr_p_sig_out_rng_flt),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_eps_torq_snr_p_sig_out_rng_fltReq(float cc_eps_torq_snr_p_sig_out_rng_flt) {
    auto req = mValueObjectPool->obtainFloat(cc_eps_torq_snr_p_sig_out_rng_flt);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_eps_torq_snr_t1_t2_sig_sync_fltWatcher() {
  float cc_eps_torq_snr_t1_t2_sig_sync_flt = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_eps_torq_snr_t1_t2_sig_sync_flt");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_eps_torq_snr_t1_t2_sig_sync_flt = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_eps_torq_snr_t1_t2_sig_sync_fltReq(cc_eps_torq_snr_t1_t2_sig_sync_flt),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_eps_torq_snr_t1_t2_sig_sync_fltReq(float cc_eps_torq_snr_t1_t2_sig_sync_flt) {
    auto req = mValueObjectPool->obtainFloat(cc_eps_torq_snr_t1_t2_sig_sync_flt);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_eps_torq_snr_t1_sig_out_rng_fltWatcher() {
  float cc_eps_torq_snr_t1_sig_out_rng_flt = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_eps_torq_snr_t1_sig_out_rng_flt");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_eps_torq_snr_t1_sig_out_rng_flt = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_eps_torq_snr_t1_sig_out_rng_fltReq(cc_eps_torq_snr_t1_sig_out_rng_flt),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_eps_torq_snr_t1_sig_out_rng_fltReq(float cc_eps_torq_snr_t1_sig_out_rng_flt) {
    auto req = mValueObjectPool->obtainFloat(cc_eps_torq_snr_t1_sig_out_rng_flt);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_eps_torq_snr_t2_sig_out_rng_fltWatcher() {
  float cc_eps_torq_snr_t2_sig_out_rng_flt = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_eps_torq_snr_t2_sig_out_rng_flt");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_eps_torq_snr_t2_sig_out_rng_flt = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_eps_torq_snr_t2_sig_out_rng_fltReq(cc_eps_torq_snr_t2_sig_out_rng_flt),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_eps_torq_snr_t2_sig_out_rng_fltReq(float cc_eps_torq_snr_t2_sig_out_rng_flt) {
    auto req = mValueObjectPool->obtainFloat(cc_eps_torq_snr_t2_sig_out_rng_flt);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_eps_torq_snr5_v_fltWatcher() {
  float cc_eps_torq_snr5_v_flt = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_eps_torq_snr5_v_flt");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_eps_torq_snr5_v_flt = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_eps_torq_snr5_v_fltReq(cc_eps_torq_snr5_v_flt),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_eps_torq_snr5_v_fltReq(float cc_eps_torq_snr5_v_flt) {
    auto req = mValueObjectPool->obtainFloat(cc_eps_torq_snr5_v_flt);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_eps_can_bus_fltWatcher() {
  float cc_eps_can_bus_flt = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_eps_can_bus_flt");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_eps_can_bus_flt = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_eps_can_bus_fltReq(cc_eps_can_bus_flt),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_eps_can_bus_fltReq(float cc_eps_can_bus_flt) {
    auto req = mValueObjectPool->obtainFloat(cc_eps_can_bus_flt);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_eps_over_volt_fltWatcher() {
  float cc_eps_over_volt_flt = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_eps_over_volt_flt");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_eps_over_volt_flt = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_eps_over_volt_fltReq(cc_eps_over_volt_flt),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_eps_over_volt_fltReq(float cc_eps_over_volt_flt) {
    auto req = mValueObjectPool->obtainFloat(cc_eps_over_volt_flt);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_eps_under_volt_fltWatcher() {
  float cc_eps_under_volt_flt = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_eps_under_volt_flt");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_eps_under_volt_flt = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_eps_under_volt_fltReq(cc_eps_under_volt_flt),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_eps_under_volt_fltReq(float cc_eps_under_volt_flt) {
    auto req = mValueObjectPool->obtainFloat(cc_eps_under_volt_flt);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_eps_uncalibrated_angle_fltWatcher() {
  float cc_eps_uncalibrated_angle_flt = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_eps_uncalibrated_angle_flt");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_eps_uncalibrated_angle_flt = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_eps_uncalibrated_angle_fltReq(cc_eps_uncalibrated_angle_flt),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_eps_uncalibrated_angle_fltReq(float cc_eps_uncalibrated_angle_flt) {
    auto req = mValueObjectPool->obtainFloat(cc_eps_uncalibrated_angle_flt);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_eps_over_heat_fltWatcher() {
  float cc_eps_over_heat_flt = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_eps_over_heat_flt");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_eps_over_heat_flt = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_eps_over_heat_fltReq(cc_eps_over_heat_flt),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_eps_over_heat_fltReq(float cc_eps_over_heat_flt) {
    auto req = mValueObjectPool->obtainFloat(cc_eps_over_heat_flt);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_eps_relay_fltWatcher() {
  float cc_eps_relay_flt = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_eps_relay_flt");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_eps_relay_flt = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_eps_relay_fltReq(cc_eps_relay_flt),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_eps_relay_fltReq(float cc_eps_relay_flt) {
    auto req = mValueObjectPool->obtainFloat(cc_eps_relay_flt);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_eps_motor_curr_fellow_fltWatcher() {
  float cc_eps_motor_curr_fellow_flt = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_eps_motor_curr_fellow_flt");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_eps_motor_curr_fellow_flt = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_eps_motor_curr_fellow_fltReq(cc_eps_motor_curr_fellow_flt),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_eps_motor_curr_fellow_fltReq(float cc_eps_motor_curr_fellow_flt) {
    auto req = mValueObjectPool->obtainFloat(cc_eps_motor_curr_fellow_flt);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_eps_motor_drv_fltWatcher() {
  float cc_eps_motor_drv_flt = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_eps_motor_drv_flt");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_eps_motor_drv_flt = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_eps_motor_drv_fltReq(cc_eps_motor_drv_flt),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_eps_motor_drv_fltReq(float cc_eps_motor_drv_flt) {
    auto req = mValueObjectPool->obtainFloat(cc_eps_motor_drv_flt);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_eps_vcu_time_out_fltWatcher() {
  float cc_eps_vcu_time_out_flt = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_eps_vcu_time_out_flt");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_eps_vcu_time_out_flt = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_eps_vcu_time_out_fltReq(cc_eps_vcu_time_out_flt),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_eps_vcu_time_out_fltReq(float cc_eps_vcu_time_out_flt) {
    auto req = mValueObjectPool->obtainFloat(cc_eps_vcu_time_out_flt);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_eps_livecounter_0x301Watcher() {
  float cc_eps_livecounter_0x301 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_eps_livecounter_0x301");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_eps_livecounter_0x301 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_eps_livecounter_0x301Req(cc_eps_livecounter_0x301),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_eps_livecounter_0x301Req(float cc_eps_livecounter_0x301) {
    auto req = mValueObjectPool->obtainFloat(cc_eps_livecounter_0x301);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_eps_checksum_0x301Watcher() {
  float cc_eps_checksum_0x301 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_eps_checksum_0x301");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_eps_checksum_0x301 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_eps_checksum_0x301Req(cc_eps_checksum_0x301),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_eps_checksum_0x301Req(float cc_eps_checksum_0x301) {
    auto req = mValueObjectPool->obtainFloat(cc_eps_checksum_0x301);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_abs_wheel_speed_fr_no_signal_errWatcher() {
  float cc_abs_wheel_speed_fr_no_signal_err = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_abs_wheel_speed_fr_no_signal_err");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_abs_wheel_speed_fr_no_signal_err = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_abs_wheel_speed_fr_no_signal_errReq(cc_abs_wheel_speed_fr_no_signal_err),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_abs_wheel_speed_fr_no_signal_errReq(float cc_abs_wheel_speed_fr_no_signal_err) {
    auto req = mValueObjectPool->obtainFloat(cc_abs_wheel_speed_fr_no_signal_err);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_abs_wheel_speed_fr_interm_errWatcher() {
  float cc_abs_wheel_speed_fr_interm_err = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_abs_wheel_speed_fr_interm_err");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_abs_wheel_speed_fr_interm_err = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_abs_wheel_speed_fr_interm_errReq(cc_abs_wheel_speed_fr_interm_err),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_abs_wheel_speed_fr_interm_errReq(float cc_abs_wheel_speed_fr_interm_err) {
    auto req = mValueObjectPool->obtainFloat(cc_abs_wheel_speed_fr_interm_err);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_abs_wheel_speed_fr_open_short_errWatcher() {
  float cc_abs_wheel_speed_fr_open_short_err = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_abs_wheel_speed_fr_open_short_err");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_abs_wheel_speed_fr_open_short_err = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_abs_wheel_speed_fr_open_short_errReq(cc_abs_wheel_speed_fr_open_short_err),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_abs_wheel_speed_fr_open_short_errReq(float cc_abs_wheel_speed_fr_open_short_err) {
    auto req = mValueObjectPool->obtainFloat(cc_abs_wheel_speed_fr_open_short_err);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_abs_wheel_speed_fl_no_signal_errWatcher() {
  float cc_abs_wheel_speed_fl_no_signal_err = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_abs_wheel_speed_fl_no_signal_err");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_abs_wheel_speed_fl_no_signal_err = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_abs_wheel_speed_fl_no_signal_errReq(cc_abs_wheel_speed_fl_no_signal_err),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_abs_wheel_speed_fl_no_signal_errReq(float cc_abs_wheel_speed_fl_no_signal_err) {
    auto req = mValueObjectPool->obtainFloat(cc_abs_wheel_speed_fl_no_signal_err);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_abs_wheel_speed_fl_interm_errWatcher() {
  float cc_abs_wheel_speed_fl_interm_err = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_abs_wheel_speed_fl_interm_err");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_abs_wheel_speed_fl_interm_err = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_abs_wheel_speed_fl_interm_errReq(cc_abs_wheel_speed_fl_interm_err),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_abs_wheel_speed_fl_interm_errReq(float cc_abs_wheel_speed_fl_interm_err) {
    auto req = mValueObjectPool->obtainFloat(cc_abs_wheel_speed_fl_interm_err);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_abs_wheel_speed_fl_open_short_errWatcher() {
  float cc_abs_wheel_speed_fl_open_short_err = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_abs_wheel_speed_fl_open_short_err");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_abs_wheel_speed_fl_open_short_err = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_abs_wheel_speed_fl_open_short_errReq(cc_abs_wheel_speed_fl_open_short_err),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_abs_wheel_speed_fl_open_short_errReq(float cc_abs_wheel_speed_fl_open_short_err) {
    auto req = mValueObjectPool->obtainFloat(cc_abs_wheel_speed_fl_open_short_err);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_abs_power_undervoltWatcher() {
  float cc_abs_power_undervolt = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_abs_power_undervolt");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_abs_power_undervolt = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_abs_power_undervoltReq(cc_abs_power_undervolt),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_abs_power_undervoltReq(float cc_abs_power_undervolt) {
    auto req = mValueObjectPool->obtainFloat(cc_abs_power_undervolt);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_abs_power_overvoltWatcher() {
  float cc_abs_power_overvolt = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_abs_power_overvolt");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_abs_power_overvolt = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_abs_power_overvoltReq(cc_abs_power_overvolt),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_abs_power_overvoltReq(float cc_abs_power_overvolt) {
    auto req = mValueObjectPool->obtainFloat(cc_abs_power_overvolt);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_abs_valve_relay_errWatcher() {
  float cc_abs_valve_relay_err = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_abs_valve_relay_err");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_abs_valve_relay_err = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_abs_valve_relay_errReq(cc_abs_valve_relay_err),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_abs_valve_relay_errReq(float cc_abs_valve_relay_err) {
    auto req = mValueObjectPool->obtainFloat(cc_abs_valve_relay_err);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_abs_wheel_speed_freq_errWatcher() {
  float cc_abs_wheel_speed_freq_err = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_abs_wheel_speed_freq_err");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_abs_wheel_speed_freq_err = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_abs_wheel_speed_freq_errReq(cc_abs_wheel_speed_freq_err),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_abs_wheel_speed_freq_errReq(float cc_abs_wheel_speed_freq_err) {
    auto req = mValueObjectPool->obtainFloat(cc_abs_wheel_speed_freq_err);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_abs_wheel_speed_rr_no_signal_errWatcher() {
  float cc_abs_wheel_speed_rr_no_signal_err = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_abs_wheel_speed_rr_no_signal_err");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_abs_wheel_speed_rr_no_signal_err = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_abs_wheel_speed_rr_no_signal_errReq(cc_abs_wheel_speed_rr_no_signal_err),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_abs_wheel_speed_rr_no_signal_errReq(float cc_abs_wheel_speed_rr_no_signal_err) {
    auto req = mValueObjectPool->obtainFloat(cc_abs_wheel_speed_rr_no_signal_err);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_abs_wheel_speed_rr_interm_errWatcher() {
  float cc_abs_wheel_speed_rr_interm_err = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_abs_wheel_speed_rr_interm_err");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_abs_wheel_speed_rr_interm_err = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_abs_wheel_speed_rr_interm_errReq(cc_abs_wheel_speed_rr_interm_err),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_abs_wheel_speed_rr_interm_errReq(float cc_abs_wheel_speed_rr_interm_err) {
    auto req = mValueObjectPool->obtainFloat(cc_abs_wheel_speed_rr_interm_err);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_abs_wheel_speed_rr_open_short_errWatcher() {
  float cc_abs_wheel_speed_rr_open_short_err = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_abs_wheel_speed_rr_open_short_err");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_abs_wheel_speed_rr_open_short_err = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_abs_wheel_speed_rr_open_short_errReq(cc_abs_wheel_speed_rr_open_short_err),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_abs_wheel_speed_rr_open_short_errReq(float cc_abs_wheel_speed_rr_open_short_err) {
    auto req = mValueObjectPool->obtainFloat(cc_abs_wheel_speed_rr_open_short_err);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_abs_wheel_speed_rl_no_signal_errWatcher() {
  float cc_abs_wheel_speed_rl_no_signal_err = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_abs_wheel_speed_rl_no_signal_err");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_abs_wheel_speed_rl_no_signal_err = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_abs_wheel_speed_rl_no_signal_errReq(cc_abs_wheel_speed_rl_no_signal_err),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_abs_wheel_speed_rl_no_signal_errReq(float cc_abs_wheel_speed_rl_no_signal_err) {
    auto req = mValueObjectPool->obtainFloat(cc_abs_wheel_speed_rl_no_signal_err);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_abs_wheel_speed_rl_interm_errWatcher() {
  float cc_abs_wheel_speed_rl_interm_err = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_abs_wheel_speed_rl_interm_err");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_abs_wheel_speed_rl_interm_err = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_abs_wheel_speed_rl_interm_errReq(cc_abs_wheel_speed_rl_interm_err),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_abs_wheel_speed_rl_interm_errReq(float cc_abs_wheel_speed_rl_interm_err) {
    auto req = mValueObjectPool->obtainFloat(cc_abs_wheel_speed_rl_interm_err);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_abs_wheel_speed_rl_open_short_errWatcher() {
  float cc_abs_wheel_speed_rl_open_short_err = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_abs_wheel_speed_rl_open_short_err");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_abs_wheel_speed_rl_open_short_err = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_abs_wheel_speed_rl_open_short_errReq(cc_abs_wheel_speed_rl_open_short_err),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_abs_wheel_speed_rl_open_short_errReq(float cc_abs_wheel_speed_rl_open_short_err) {
    auto req = mValueObjectPool->obtainFloat(cc_abs_wheel_speed_rl_open_short_err);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_abs_outlet_valve_rr_errWatcher() {
  float cc_abs_outlet_valve_rr_err = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_abs_outlet_valve_rr_err");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_abs_outlet_valve_rr_err = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_abs_outlet_valve_rr_errReq(cc_abs_outlet_valve_rr_err),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_abs_outlet_valve_rr_errReq(float cc_abs_outlet_valve_rr_err) {
    auto req = mValueObjectPool->obtainFloat(cc_abs_outlet_valve_rr_err);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_abs_inlet_valve_rr_errWatcher() {
  float cc_abs_inlet_valve_rr_err = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_abs_inlet_valve_rr_err");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_abs_inlet_valve_rr_err = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_abs_inlet_valve_rr_errReq(cc_abs_inlet_valve_rr_err),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_abs_inlet_valve_rr_errReq(float cc_abs_inlet_valve_rr_err) {
    auto req = mValueObjectPool->obtainFloat(cc_abs_inlet_valve_rr_err);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_abs_outlet_valve_rl_errWatcher() {
  float cc_abs_outlet_valve_rl_err = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_abs_outlet_valve_rl_err");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_abs_outlet_valve_rl_err = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_abs_outlet_valve_rl_errReq(cc_abs_outlet_valve_rl_err),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_abs_outlet_valve_rl_errReq(float cc_abs_outlet_valve_rl_err) {
    auto req = mValueObjectPool->obtainFloat(cc_abs_outlet_valve_rl_err);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_abs_inlet_valve_rl_errWatcher() {
  float cc_abs_inlet_valve_rl_err = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_abs_inlet_valve_rl_err");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_abs_inlet_valve_rl_err = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_abs_inlet_valve_rl_errReq(cc_abs_inlet_valve_rl_err),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_abs_inlet_valve_rl_errReq(float cc_abs_inlet_valve_rl_err) {
    auto req = mValueObjectPool->obtainFloat(cc_abs_inlet_valve_rl_err);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_abs_outlet_valve_fr_errWatcher() {
  float cc_abs_outlet_valve_fr_err = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_abs_outlet_valve_fr_err");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_abs_outlet_valve_fr_err = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_abs_outlet_valve_fr_errReq(cc_abs_outlet_valve_fr_err),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_abs_outlet_valve_fr_errReq(float cc_abs_outlet_valve_fr_err) {
    auto req = mValueObjectPool->obtainFloat(cc_abs_outlet_valve_fr_err);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_abs_inlet_valve_fr_errWatcher() {
  float cc_abs_inlet_valve_fr_err = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_abs_inlet_valve_fr_err");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_abs_inlet_valve_fr_err = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_abs_inlet_valve_fr_errReq(cc_abs_inlet_valve_fr_err),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_abs_inlet_valve_fr_errReq(float cc_abs_inlet_valve_fr_err) {
    auto req = mValueObjectPool->obtainFloat(cc_abs_inlet_valve_fr_err);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_abs_outlet_valve_fl_errWatcher() {
  float cc_abs_outlet_valve_fl_err = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_abs_outlet_valve_fl_err");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_abs_outlet_valve_fl_err = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_abs_outlet_valve_fl_errReq(cc_abs_outlet_valve_fl_err),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_abs_outlet_valve_fl_errReq(float cc_abs_outlet_valve_fl_err) {
    auto req = mValueObjectPool->obtainFloat(cc_abs_outlet_valve_fl_err);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_abs_inlet_valve_fl_errWatcher() {
  float cc_abs_inlet_valve_fl_err = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_abs_inlet_valve_fl_err");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_abs_inlet_valve_fl_err = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_abs_inlet_valve_fl_errReq(cc_abs_inlet_valve_fl_err),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_abs_inlet_valve_fl_errReq(float cc_abs_inlet_valve_fl_err) {
    auto req = mValueObjectPool->obtainFloat(cc_abs_inlet_valve_fl_err);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_abs_current_max_fault_levelWatcher() {
  float cc_abs_current_max_fault_level = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_abs_current_max_fault_level");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_abs_current_max_fault_level = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_abs_current_max_fault_levelReq(cc_abs_current_max_fault_level),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_abs_current_max_fault_levelReq(float cc_abs_current_max_fault_level) {
    auto req = mValueObjectPool->obtainFloat(cc_abs_current_max_fault_level);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_abs_can_bus_off_errWatcher() {
  float cc_abs_can_bus_off_err = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_abs_can_bus_off_err");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_abs_can_bus_off_err = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_abs_can_bus_off_errReq(cc_abs_can_bus_off_err),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_abs_can_bus_off_errReq(float cc_abs_can_bus_off_err) {
    auto req = mValueObjectPool->obtainFloat(cc_abs_can_bus_off_err);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_abs_can_hardware_errWatcher() {
  float cc_abs_can_hardware_err = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_abs_can_hardware_err");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_abs_can_hardware_err = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_abs_can_hardware_errReq(cc_abs_can_hardware_err),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_abs_can_hardware_errReq(float cc_abs_can_hardware_err) {
    auto req = mValueObjectPool->obtainFloat(cc_abs_can_hardware_err);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_abs_ecu_hardware_errWatcher() {
  float cc_abs_ecu_hardware_err = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_abs_ecu_hardware_err");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_abs_ecu_hardware_err = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_abs_ecu_hardware_errReq(cc_abs_ecu_hardware_err),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_abs_ecu_hardware_errReq(float cc_abs_ecu_hardware_err) {
    auto req = mValueObjectPool->obtainFloat(cc_abs_ecu_hardware_err);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_abs_motor_relay_errWatcher() {
  float cc_abs_motor_relay_err = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_abs_motor_relay_err");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_abs_motor_relay_err = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_abs_motor_relay_errReq(cc_abs_motor_relay_err),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_abs_motor_relay_errReq(float cc_abs_motor_relay_err) {
    auto req = mValueObjectPool->obtainFloat(cc_abs_motor_relay_err);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_abs_motor_errWatcher() {
  float cc_abs_motor_err = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_abs_motor_err");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_abs_motor_err = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_abs_motor_errReq(cc_abs_motor_err),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_abs_motor_errReq(float cc_abs_motor_err) {
    auto req = mValueObjectPool->obtainFloat(cc_abs_motor_err);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_abs_valve_errWatcher() {
  float cc_abs_valve_err = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_abs_valve_err");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_abs_valve_err = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_abs_valve_errReq(cc_abs_valve_err),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_abs_valve_errReq(float cc_abs_valve_err) {
    auto req = mValueObjectPool->obtainFloat(cc_abs_valve_err);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_abs_livecounter_0x420Watcher() {
  float cc_abs_livecounter_0x420 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_abs_livecounter_0x420");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_abs_livecounter_0x420 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_abs_livecounter_0x420Req(cc_abs_livecounter_0x420),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_abs_livecounter_0x420Req(float cc_abs_livecounter_0x420) {
    auto req = mValueObjectPool->obtainFloat(cc_abs_livecounter_0x420);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::cc_abs_checksum_0x420Watcher() {
  float cc_abs_checksum_0x420 = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_abs_checksum_0x420");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_abs_checksum_0x420 = getActualFloatValue(mPropertyManager->getCProValue(mp),0,0);
      mHal->onPropertyValue(*Create_cc_abs_checksum_0x420Req(cc_abs_checksum_0x420),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_abs_checksum_0x420Req(float cc_abs_checksum_0x420) {
    auto req = mValueObjectPool->obtainFloat(cc_abs_checksum_0x420);
    req->prop = toInt(VehicleProperty::PERF_VEHICLE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::mc_lamplet_statusWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t mc_lamplet_status = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("mc_lamplet_status");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      mc_lamplet_status = static_cast<int32_t> (mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_mc_lamplet_statusReq(mc_lamplet_status),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_mc_lamplet_statusReq(int32_t mc_lamplet_status) {
    auto req = mValueObjectPool->obtainInt32(mc_lamplet_status);
    req->prop = toInt(VehicleProperty::GECKO_LAMPLET_STATUS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::mc_main_seat_pressure_statusWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t mc_main_seat_pressure_status = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("mc_main_seat_pressure_status");
  if(!mp) return;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      mc_main_seat_pressure_status = static_cast<int32_t> (mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_mc_main_seat_pressure_statusReq(mc_main_seat_pressure_status),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_mc_main_seat_pressure_statusReq(int32_t mc_main_seat_pressure_status) {
    auto req = mValueObjectPool->obtainInt32(mc_main_seat_pressure_status);
    req->prop = toInt(VehicleProperty::GECKO_MAIN_SEAT_PRESSURE_STATUS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::mc_brake_level_alarm_statusWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t mc_brake_level_alarm_status = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("mc_brake_level_alarm_status");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      mc_brake_level_alarm_status = static_cast<int32_t> (mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_mc_brake_level_alarm_statusReq(mc_brake_level_alarm_status),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_mc_brake_level_alarm_statusReq(int32_t mc_brake_level_alarm_status) {
    auto req = mValueObjectPool->obtainInt32(mc_brake_level_alarm_status);
    req->prop = toInt(VehicleProperty::GECKO_BRAKE_LEVEL_ALARM_STATUS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::mc_main_seat_safety_belt_statusWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t mc_main_seat_safety_belt_status = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("mc_main_seat_safety_belt_status");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      mc_main_seat_safety_belt_status = static_cast<int32_t> (mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_mc_main_seat_safety_belt_statusReq(mc_main_seat_safety_belt_status),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_mc_main_seat_safety_belt_statusReq(int32_t mc_main_seat_safety_belt_status) {
    auto req = mValueObjectPool->obtainInt32(mc_main_seat_safety_belt_status);
    req->prop = toInt(VehicleProperty::GECKO_MAIN_SEAT_SAFETY_BELT_STATUS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_srs_drv_seatbelt_buckle_validWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_srs_drv_seatbelt_buckle_valid = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_srs_drv_seatbelt_buckle_valid");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_srs_drv_seatbelt_buckle_valid = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_srs_drv_seatbelt_buckle_validReq(ec_srs_drv_seatbelt_buckle_valid),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_srs_drv_seatbelt_buckle_validReq(int32_t ec_srs_drv_seatbelt_buckle_valid) {
    auto req = mValueObjectPool->obtainInt32(ec_srs_drv_seatbelt_buckle_valid);
    req->prop = toInt(VehicleProperty::GECKO_MAIN_SEAT_SAFETY_BELT_VD);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_srs_mid_seat_belt_bucklestatusWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_srs_mid_seat_belt_bucklestatus = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_srs_mid_seat_belt_bucklestatus");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_srs_mid_seat_belt_bucklestatus = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_srs_mid_seat_belt_bucklestatusReq(ec_srs_mid_seat_belt_bucklestatus),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_srs_mid_seat_belt_bucklestatusReq(int32_t ec_srs_mid_seat_belt_bucklestatus) {
    auto req = mValueObjectPool->obtainInt32(ec_srs_mid_seat_belt_bucklestatus);
    req->prop = toInt(VehicleProperty::GECKO_SRS_MIDSEATBELTBUCKLESTATUS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_srs_mid_seat_belt_buckle_validWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_srs_mid_seat_belt_buckle_valid = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_srs_mid_seat_belt_buckle_valid");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_srs_mid_seat_belt_buckle_valid = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_srs_mid_seat_belt_buckle_validReq(ec_srs_mid_seat_belt_buckle_valid),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_srs_mid_seat_belt_buckle_validReq(int32_t ec_srs_mid_seat_belt_buckle_valid) {
    auto req = mValueObjectPool->obtainInt32(ec_srs_mid_seat_belt_buckle_valid);
    req->prop = toInt(VehicleProperty::GECKO_SRS_MIDSEATBELTBUCKLEVALID);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_srs_mid_seat_occupant_sensor_stsWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_srs_mid_seat_occupant_sensor_sts = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_srs_mid_seat_occupant_sensor_sts");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_srs_mid_seat_occupant_sensor_sts = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_srs_mid_seat_occupant_sensor_stsReq(ec_srs_mid_seat_occupant_sensor_sts),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_srs_mid_seat_occupant_sensor_stsReq(int32_t ec_srs_mid_seat_occupant_sensor_sts) {
    auto req = mValueObjectPool->obtainInt32(ec_srs_mid_seat_occupant_sensor_sts);
    req->prop = toInt(VehicleProperty::GECKO_SRS_MIDSEATOCCUPANTSENSORSTS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::mc_engine_statusWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t mc_engine_status = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("mc_engine_status");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      mc_engine_status = static_cast<int32_t> (mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_mc_engine_statusReq(mc_engine_status),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_mc_engine_statusReq(int32_t mc_engine_status) {
    auto req = mValueObjectPool->obtainInt32(mc_engine_status);
    req->prop = toInt(VehicleProperty::GECKO_ENGINE_STATUS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::mc_low_vol_battery_volWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  float mc_low_vol_battery_vol = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("mc_low_vol_battery_vol");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      mc_low_vol_battery_vol = getActualFloatValue(mPropertyManager->getCProValue(mp), 0.1, 0);
      mHal->onPropertyValue(*Create_mc_low_vol_battery_volReq(mc_low_vol_battery_vol),true);
      if(mc_low_vol_battery_vol < 1.0) {
          mPropertyManager->updateCAPropertyValue("sc_ccm_rechrgn_lv_req", "1");
      }
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_mc_low_vol_battery_volReq(float mc_low_vol_battery_vol) {
    auto req = mValueObjectPool->obtainFloat(mc_low_vol_battery_vol);
    req->prop = toInt(VehicleProperty::GECKO_LOW_VOL_BATTERY_VOL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::sc_ec_ccm_batt_maintain_ctr_cmdWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t sc_ec_ccm_batt_maintain_ctr_cmd = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("sc_ec_ccm_batt_maintain_ctr_cmd");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      sc_ec_ccm_batt_maintain_ctr_cmd = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_sc_ec_ccm_batt_maintain_ctr_cmdReq(sc_ec_ccm_batt_maintain_ctr_cmd),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_sc_ec_ccm_batt_maintain_ctr_cmdReq(int32_t sc_ec_ccm_batt_maintain_ctr_cmd) {
    auto req = mValueObjectPool->obtainInt32(sc_ec_ccm_batt_maintain_ctr_cmd);
    req->prop = toInt(VehicleProperty::GECKO_CCM_BATTMAINTAIN_CTR_CMD);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::sc_ec_ccm_batt_maintain_stsWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t sc_ec_ccm_batt_maintain_sts = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("sc_ec_ccm_batt_maintain_sts");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      sc_ec_ccm_batt_maintain_sts = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_sc_ec_ccm_batt_maintain_stsReq(sc_ec_ccm_batt_maintain_sts),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_sc_ec_ccm_batt_maintain_stsReq(int32_t sc_ec_ccm_batt_maintain_sts) {
    auto req = mValueObjectPool->obtainInt32(sc_ec_ccm_batt_maintain_sts);
    req->prop = toInt(VehicleProperty::GECKO_CCM_BATTMAINTAIN_STS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}


void GarageModeServerSideHandlerImpl::sc_ec_ccm_versionWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t sc_ec_ccm_version = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("sc_ec_ccm_version");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      sc_ec_ccm_version = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_sc_ec_ccm_versionReq(sc_ec_ccm_version),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_sc_ec_ccm_versionReq(int32_t sc_ec_ccm_version) {
    auto req = mValueObjectPool->obtainInt32(sc_ec_ccm_version);
    req->prop = toInt(VehicleProperty::GECKO_CCM_VERSION);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}


void GarageModeServerSideHandlerImpl::sc_ec_ccm_soc_sofeware_numWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t sc_ec_ccm_soc_sofeware_num = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("sc_ec_ccm_soc_sofeware_num");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      sc_ec_ccm_soc_sofeware_num = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_sc_ec_ccm_soc_sofeware_numReq(sc_ec_ccm_soc_sofeware_num),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_sc_ec_ccm_soc_sofeware_numReq(int32_t sc_ec_ccm_soc_sofeware_num) {
    auto req = mValueObjectPool->obtainInt32(sc_ec_ccm_soc_sofeware_num);
    req->prop = toInt(VehicleProperty::GECKO_CCM_SOC_SOFTWARE_NUM);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}


void GarageModeServerSideHandlerImpl::sc_ec_ccm_soc_hardware_numWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t sc_ec_ccm_soc_hardware_num = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("sc_ec_ccm_soc_hardware_num");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      sc_ec_ccm_soc_hardware_num = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_sc_ec_ccm_soc_hardware_numReq(sc_ec_ccm_soc_hardware_num),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_sc_ec_ccm_soc_hardware_numReq(int32_t sc_ec_ccm_soc_hardware_num) {
    auto req = mValueObjectPool->obtainInt32(sc_ec_ccm_soc_hardware_num);
    req->prop = toInt(VehicleProperty::GECKO_CCM_SOC_HARDWARE_NUM);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::sc_ec_ccm_mcu_software_numWatcher() {
  int32_t sc_ec_ccm_mcu_software_num = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("sc_ec_ccm_mcu_software_num");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      sc_ec_ccm_mcu_software_num = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_sc_ec_ccm_mcu_software_numReq(sc_ec_ccm_mcu_software_num),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_sc_ec_ccm_mcu_software_numReq(int32_t sc_ec_ccm_mcu_software_num) {
    auto req = mValueObjectPool->obtainInt32(sc_ec_ccm_mcu_software_num);
    req->prop = toInt(VehicleProperty::GECKO_CCM_MCU_SOFTWARE_NUM);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::sc_ec_ccm_mcu_hardware_numWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  std::string value = "";
  ConfigDBC* mp = mPropertyManager->findCProperty("sc_ec_ccm_mcu_hardware_num");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      value = mPropertyManager->getCProStrValue(mp);
      LOG(INFO) << "mcu_hardware_num:"<<value;
      android::base::SetProperty("gecko.mcu.hardware.version", value);
      android::base::SetProperty("gecko.soc.hardware.version", value);
      //mHal->onPropertyValue(*Create_sc_ec_ccm_mcu_hardware_numReq(sc_ec_ccm_mcu_hardware_num),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_sc_ec_ccm_mcu_hardware_numReq(int32_t sc_ec_ccm_mcu_hardware_num) {
    auto req = mValueObjectPool->obtainInt32(sc_ec_ccm_mcu_hardware_num);
    req->prop = toInt(VehicleProperty::GECKO_CCM_MCU_HARDWARE_NUM);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::sc_ec_ccm_target_chrg_currWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t sc_ec_ccm_target_chrg_curr = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("sc_ec_ccm_target_chrg_curr");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      sc_ec_ccm_target_chrg_curr = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_sc_ec_ccm_target_chrg_currReq(sc_ec_ccm_target_chrg_curr),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_sc_ec_ccm_target_chrg_currReq(int32_t sc_ec_ccm_target_chrg_curr) {
    auto req = mValueObjectPool->obtainInt32(sc_ec_ccm_target_chrg_curr);
    req->prop = toInt(VehicleProperty::GECKO_CCM_TARGET_CHRG_CURR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::sc_ccm_remote_lockWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t sc_ccm_remote_lock = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("sc_ccm_remote_lock");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      sc_ccm_remote_lock = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_sc_ccm_remote_lockReq(sc_ccm_remote_lock),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_sc_ccm_remote_lockReq(int32_t sc_ccm_remote_lock) {
    auto req = mValueObjectPool->obtainInt32(sc_ccm_remote_lock);
    req->prop = toInt(VehicleProperty::GECKO_CCM_REMOTE_LOCK);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::sc_ccm_remote_car_searchWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t sc_ccm_remote_car_search = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("sc_ccm_remote_car_search");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      sc_ccm_remote_car_search = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_sc_ccm_remote_car_searchReq(sc_ccm_remote_car_search),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_sc_ccm_remote_car_searchReq(int32_t sc_ccm_remote_car_search) {
    auto req = mValueObjectPool->obtainInt32(sc_ccm_remote_car_search);
    req->prop = toInt(VehicleProperty::GECKO_CCM_REMOTE_CAR_SEARCH);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::sc_ccm_remt_ctrl_flagWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t sc_ccm_remt_ctrl_flag = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("sc_ccm_remt_ctrl_flag");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      sc_ccm_remt_ctrl_flag = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_sc_ccm_remt_ctrl_flagReq(sc_ccm_remt_ctrl_flag),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_sc_ccm_remt_ctrl_flagReq(int32_t sc_ccm_remt_ctrl_flag) {
    auto req = mValueObjectPool->obtainInt32(sc_ccm_remt_ctrl_flag);
    req->prop = toInt(VehicleProperty::GECKO_CCM_REMT_CTR_FLAG);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::sc_ec_ccm_operat_licenceWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t sc_ec_ccm_operat_licence = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("sc_ec_ccm_operat_licence");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      sc_ec_ccm_operat_licence = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_sc_ec_ccm_operat_licenceReq(sc_ec_ccm_operat_licence),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_sc_ec_ccm_operat_licenceReq(int32_t sc_ec_ccm_operat_licence) {
    auto req = mValueObjectPool->obtainInt32(sc_ec_ccm_operat_licence);
    req->prop = toInt(VehicleProperty::GECKO_CCM_OPERAT_LICENCE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_bms_realtimealowdischapowerWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bms_realtimealowdischapower = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_realtimealowdischapower");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_realtimealowdischapower = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_bms_realtimealowdischapowerReq(ec_bms_realtimealowdischapower),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_realtimealowdischapowerReq(int32_t ec_bms_realtimealowdischapower) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_realtimealowdischapower);
    req->prop = toInt(VehicleProperty::GECKO_BMS_REALTIMEALOWDISCHAPOWER);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ipu_ipuhvil_staWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_ipu_ipuhvil_sta = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_ipuhvil_sta");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ipu_ipuhvil_sta = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_ipu_ipuhvil_staReq(ec_ipu_ipuhvil_sta),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_ipuhvil_staReq(int32_t ec_ipu_ipuhvil_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_ipuhvil_sta);
    req->prop = toInt(VehicleProperty::GECKO_IPU_IPUHVILSTA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ipu_mainrelayposistatusWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int ec_ipu_mainrelayposistatus = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_mainrelayposistatus");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ipu_mainrelayposistatus = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_ipu_mainrelayposistatusReq(ec_ipu_mainrelayposistatus),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_mainrelayposistatusReq(int ec_ipu_mainrelayposistatus) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_mainrelayposistatus);
    req->prop = toInt(VehicleProperty::GECKO_IPU_MAINRELAYPOSISTATUS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ipu_workstatusWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int ec_ipu_workstatus = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_workstatus");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ipu_workstatus = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_ipu_workstatusReq(ec_ipu_workstatus),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_workstatusReq(int ec_ipu_workstatus) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_workstatus);
    req->prop = toInt(VehicleProperty::GECKO_IPU_WORKSTATUS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_tqreqWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int ec_vcu_tqreq = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_tqreq");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_tqreq = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_vcu_tqreqReq(ec_vcu_tqreq),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_tqreqReq(int ec_vcu_tqreq) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_tqreq);
    req->prop = toInt(VehicleProperty::GECKO_VCU_TQREQ);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_bms_softwareversionWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int ec_bms_softwareversion = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_softwareversion");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_softwareversion = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_bms_softwareversionReq(ec_bms_softwareversion),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_softwareversionReq(int ec_bms_softwareversion) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_softwareversion);
    req->prop = toInt(VehicleProperty::GECKO_BMS_SOFTWAREVERSION);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ipu_hardware_numWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int ec_ipu_hardware_num = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_hardware_num");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ipu_hardware_num = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_ipu_hardware_numReq(ec_ipu_hardware_num),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_hardware_numReq(int ec_ipu_hardware_num) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_hardware_num);
    req->prop = toInt(VehicleProperty::GECKO_IPU_HARDWARE_NUM);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ipu_sofeware_numWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int ec_ipu_sofeware_num = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_sofeware_num");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ipu_sofeware_num = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_ipu_sofeware_numReq(ec_ipu_sofeware_num),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_sofeware_numReq(int ec_ipu_sofeware_num) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_sofeware_num);
    req->prop = toInt(VehicleProperty::GECKO_IPU_SOFEWARE_NUM);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_faultlevelWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_faultlevel = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_faultlevel");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_faultlevel = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_vcu_faultlevelReq(ec_vcu_faultlevel),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_faultlevelReq(int32_t ec_vcu_faultlevel) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_faultlevel);
    req->prop = toInt(VehicleProperty::GECKO_VCU_FAULTLEVE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_brak_sys_warnWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_brak_sys_warn = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_brak_sys_warn");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_brak_sys_warn = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_vcu_brak_sys_warnReq(ec_vcu_brak_sys_warn),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_brak_sys_warnReq(int32_t ec_vcu_brak_sys_warn) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_brak_sys_warn);
    req->prop = toInt(VehicleProperty::GECKO_VCU_BRAKSYSWARN);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_versionWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_version = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_version");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_version = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_vcu_versionReq(ec_vcu_version),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_versionReq(int32_t ec_vcu_version) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_version);
    req->prop = toInt(VehicleProperty::GECKO_MCU_CCM_VERSION);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_operat_licenceWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_operat_licence = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_operat_licence");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_operat_licence = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_vcu_operat_licenceReq(ec_vcu_operat_licence),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_operat_licenceReq(int32_t ec_vcu_operat_licence) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_operat_licence);
    req->prop = toInt(VehicleProperty::GECKO_VCU_OPERATLICENCE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_mot_water_pump_statusWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_mot_water_pump_status = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_mot_water_pump_status");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_mot_water_pump_status = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_vcu_mot_water_pump_statusReq(ec_vcu_mot_water_pump_status),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_mot_water_pump_statusReq(int32_t ec_vcu_mot_water_pump_status) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_mot_water_pump_status);
    req->prop = toInt(VehicleProperty::GECKO_VCU_MOTWATERPUMPSTATUS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_vacum_pump_faultWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_vacum_pump_fault = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_vacum_pump_fault");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_vacum_pump_fault = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_vcu_vacum_pump_faultReq(ec_vcu_vacum_pump_fault),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_vacum_pump_faultReq(int32_t ec_vcu_vacum_pump_fault) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_vacum_pump_fault);
    req->prop = toInt(VehicleProperty::GECKO_VCU_VACUMPUMPFAULT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_dc_chrg_rly_stsWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_dc_chrg_rly_sts = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_dc_chrg_rly_sts");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_dc_chrg_rly_sts = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_vcu_dc_chrg_rly_stsReq(ec_vcu_dc_chrg_rly_sts),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_dc_chrg_rly_stsReq(int32_t ec_vcu_dc_chrg_rly_sts) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_dc_chrg_rly_sts);
    req->prop = toInt(VehicleProperty::GECKO_VCU_DCCHRGRLYSTS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_chrg_cnctr_stsWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_chrg_cnctr_sts = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_chrg_cnctr_sts");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_chrg_cnctr_sts = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      LOG(INFO)<<"VCU_ChrgCnctrSts:"<<ec_vcu_chrg_cnctr_sts;
      mHal->onPropertyValue(*Create_ec_vcu_chrg_cnctr_stsReq(ec_vcu_chrg_cnctr_sts),true);

      ConfigDBC* mp_park = mPropertyManager->findCProperty("ec_vcu_park_state");
      int32_t ec_vcu_park_state = mPropertyManager->getCProValue(mp_park);

      if(ec_vcu_chrg_cnctr_sts != 0){
        //
        if(ec_vcu_park_state == 0){
          LOG(INFO)<<"VCU_ParkState = 0 and VCU_ChrgCnctrSts != 0";
          mHal->onPropertyValue(*Create_bc_park_chrg_cnctr_stsReq(1),true);
        }
      }else{
        LOG(INFO)<<"VCU_ParkState = 1 or 1 and VCU_ChrgCnctrSts = 0";
        mHal->onPropertyValue(*Create_bc_park_chrg_cnctr_stsReq(0),true);
      }
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_chrg_cnctr_stsReq(int32_t ec_vcu_chrg_cnctr_sts) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_chrg_cnctr_sts);
    req->prop = toInt(VehicleProperty::GECKO_VCU_CHRGCNCTRSTS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_chraging_mode_spWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_chraging_mode_sp = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_chraging_mode_sp");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_chraging_mode_sp = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_vcu_chraging_mode_spReq(ec_vcu_chraging_mode_sp),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_chraging_mode_spReq(int32_t ec_vcu_chraging_mode_sp) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_chraging_mode_sp);
    req->prop = toInt(VehicleProperty::GECKO_CHRAGINGMODESP);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_power_supply_voltagWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_power_supply_voltag = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_power_supply_voltag");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_power_supply_voltag = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_vcu_power_supply_voltagReq(ec_vcu_power_supply_voltag),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_power_supply_voltagReq(int32_t ec_vcu_power_supply_voltag) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_power_supply_voltag);
    req->prop = toInt(VehicleProperty::GECKO_VCU_POWERSUPPLYVOLTAG);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_ptc1_rel_staWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_ptc1_rel_sta = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_ptc1_rel_sta");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_ptc1_rel_sta = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_vcu_ptc1_rel_staReq(ec_vcu_ptc1_rel_sta),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_ptc1_rel_staReq(int32_t ec_vcu_ptc1_rel_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_ptc1_rel_sta);
    req->prop = toInt(VehicleProperty::GECKO_VCU_PTC1RELSTA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_ptc2_rel_staWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_ptc2_rel_sta = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_ptc2_rel_sta");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_ptc2_rel_sta = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_vcu_ptc2_rel_staReq(ec_vcu_ptc2_rel_sta),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_ptc2_rel_staReq(int32_t ec_vcu_ptc2_rel_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_ptc2_rel_sta);
    req->prop = toInt(VehicleProperty::GECKO_VCU_PTC2RELSTA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_water_pump_pwmWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_water_pump_pwm = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_water_pump_pwm");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_water_pump_pwm = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_vcu_water_pump_pwmReq(ec_vcu_water_pump_pwm),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_water_pump_pwmReq(int32_t ec_vcu_water_pump_pwm) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_water_pump_pwm);
    req->prop = toInt(VehicleProperty::GECKO_VCU_WATERPUMPPWM);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_fan_relay_pin_stsWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_fan_relay_pin_sts = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_fan_relay_pin_sts");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_fan_relay_pin_sts = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_vcu_fan_relay_pin_stsReq(ec_vcu_fan_relay_pin_sts),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_fan_relay_pin_stsReq(int32_t ec_vcu_fan_relay_pin_sts) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_fan_relay_pin_sts);
    req->prop = toInt(VehicleProperty::GECKO_VCU_FANRELAY_PINSTS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_mcu_err_codeWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_mcu_err_code = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_mcu_err_code");
  while(!mShuttingDownFlag.load()){
    mPropertyManager->getUpdateCState(mp);
    ec_mcu_err_code = mPropertyManager->getCProValue(mp);
    //LOG(INFO) << "ec_mcu_err_code:"<<ec_mcu_err_code;
    mHal->onPropertyValue(*Create_ec_mcu_err_codeReq(ec_mcu_err_code),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_mcu_err_codeReq(int32_t ec_mcu_err_code) {
    auto req = mValueObjectPool->obtainInt32(ec_mcu_err_code);
    req->prop = toInt(VehicleProperty::GECKO_MCU_ERR_CODE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_mcu_motoropermodeWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_mcu_motoropermode = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_mcu_motoropermode");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_mcu_motoropermode = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_mcu_motoropermodeReq(ec_mcu_motoropermode),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_mcu_motoropermodeReq(int32_t ec_mcu_motoropermode) {
    auto req = mValueObjectPool->obtainInt32(ec_mcu_motoropermode);
    req->prop = toInt(VehicleProperty::GECKO_MCU_MOTOROPERMODE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_mcu_igbt_overheat_warningWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_mcu_igbt_overheat_warning = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_mcu_igbt_overheat_warning");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_mcu_igbt_overheat_warning = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_mcu_igbt_overheat_warningReq(ec_mcu_igbt_overheat_warning),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_mcu_igbt_overheat_warningReq(int32_t ec_mcu_igbt_overheat_warning) {
    auto req = mValueObjectPool->obtainInt32(ec_mcu_igbt_overheat_warning);
    req->prop = toInt(VehicleProperty::GECKO_MCU_IGBT_OVERHEAT_WARNING);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_mcu_motor_overheat_warningWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_mcu_motor_overheat_warning = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_mcu_motor_overheat_warning");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_mcu_motor_overheat_warning = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_mcu_motor_overheat_warningReq(ec_mcu_motor_overheat_warning),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_mcu_motor_overheat_warningReq(int32_t ec_mcu_motor_overheat_warning) {
    auto req = mValueObjectPool->obtainInt32(ec_mcu_motor_overheat_warning);
    req->prop = toInt(VehicleProperty::GECKO_MCU_MOTOR_OVERHEAT_WARNING);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_mcu_motor_fault_total_numWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_mcu_motor_fault_total_num = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_mcu_motor_fault_total_num");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_mcu_motor_fault_total_num = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_mcu_motor_fault_total_numReq(ec_mcu_motor_fault_total_num),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_mcu_motor_fault_total_numReq(int32_t ec_mcu_motor_fault_total_num) {
    auto req = mValueObjectPool->obtainInt32(ec_mcu_motor_fault_total_num);
    req->prop = toInt(VehicleProperty::GECKO_MCU_MOTORFAULTTOTALNUM);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_ob_cinputvoltageWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_ipu_ob_cinputvoltage = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_ob_cinputvoltage");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ipu_ob_cinputvoltage = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_ipu_ob_cinputvoltageReq(ec_ipu_ob_cinputvoltage),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_ob_cinputvoltageReq(int32_t ec_ipu_ob_cinputvoltage) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_ob_cinputvoltage);
    req->prop = toInt(VehicleProperty::GECKO_IPU_OBCINPUTVOLTAGE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_ipu_c_pdutycycleWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int ec_ipu_c_pdutycycle = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_c_pdutycycle");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ipu_c_pdutycycle = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_ipu_c_pdutycycleReq(ec_ipu_c_pdutycycle),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_c_pdutycycleReq(int ec_ipu_c_pdutycycle) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_c_pdutycycle);
    req->prop = toInt(VehicleProperty::GECKO_IPU_CPDUTYCYCLE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_ob_cinputcurrentWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_ipu_ob_cinputcurrent = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_ob_cinputcurrent");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ipu_ob_cinputcurrent = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_ipu_ob_cinputcurrentReq(ec_ipu_ob_cinputcurrent),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_ob_cinputcurrentReq(int32_t ec_ipu_ob_cinputcurrent) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_ob_cinputcurrent);
    req->prop = toInt(VehicleProperty::GECKO_IPU_OBCINPUTCURRENT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_dcdc_over_tempWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_ipu_dcdc_over_temp = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_dcdc_over_temp");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ipu_dcdc_over_temp = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_ipu_dcdc_over_tempReq(ec_ipu_dcdc_over_temp),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_dcdc_over_tempReq(int32_t ec_ipu_dcdc_over_temp) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_dcdc_over_temp);
    req->prop = toInt(VehicleProperty::GECKO_IPU_DCDC_OVER_TEMP);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_deltatempWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bms_deltatemp = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_deltatemp");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_deltatemp = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_bms_deltatempReq(ec_bms_deltatemp),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_deltatempReq(int32_t ec_bms_deltatemp) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_deltatemp);
    req->prop = toInt(VehicleProperty::GECKO_BMS_DELTATEMP);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_overtempWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bms_overtemp = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_overtemp");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_overtemp = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_bms_overtempReq(ec_bms_overtemp),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_overtempReq(int32_t ec_bms_overtemp) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_overtemp);
    req->prop = toInt(VehicleProperty::GECKO_BMS_OVERTEMP);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_packovervoltWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bms_packovervolt = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_packovervolt");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_packovervolt = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_bms_packovervoltReq(ec_bms_packovervolt),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_packovervoltReq(int32_t ec_bms_packovervolt) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_packovervolt);
    req->prop = toInt(VehicleProperty::GECKO_BMS_PACKOVERVOLT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_packudvoltWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bms_packudvolt = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_packudvolt");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_packudvolt = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_bms_packudvoltReq(ec_bms_packudvolt),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_packudvoltReq(int32_t ec_bms_packudvolt) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_packudvolt);
    req->prop = toInt(VehicleProperty::GECKO_BMS_PACKUDVOLT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_packlowsocWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bms_packlowsoc = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_packlowsoc");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_packlowsoc = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_bms_packlowsocReq(ec_bms_packlowsoc),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_packlowsocReq(int32_t ec_bms_packlowsoc) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_packlowsoc);
    req->prop = toInt(VehicleProperty::GECKO_BMS_PACKLOWSOC);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_cellovervoltWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bms_cellovervolt = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_cellovervolt");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_cellovervolt = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_bms_cellovervoltReq(ec_bms_cellovervolt),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_cellovervoltReq(int32_t ec_bms_cellovervolt) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_cellovervolt);
    req->prop = toInt(VehicleProperty::GECKO_BMS_CELLOVERVOLT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_celludvoltWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bms_celludvolt = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_celludvolt");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_celludvolt = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_bms_celludvoltReq(ec_bms_celludvolt),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_celludvoltReq(int32_t ec_bms_celludvolt) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_celludvolt);
    req->prop = toInt(VehicleProperty::GECKO_BMS_CELLUDVOLT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_packhighsocWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bms_packhighsoc = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_packhighsoc");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_packhighsoc = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_bms_packhighsocReq(ec_bms_packhighsoc),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_packhighsocReq(int32_t ec_bms_packhighsoc) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_packhighsoc);
    req->prop = toInt(VehicleProperty::GECKO_BMS_PACKHIGHSOC);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_packfastchgsocWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bms_packfastchgsoc = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_packfastchgsoc");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_packfastchgsoc = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_bms_packfastchgsocReq(ec_bms_packfastchgsoc),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_packfastchgsocReq(int32_t ec_bms_packfastchgsoc) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_packfastchgsoc);
    req->prop = toInt(VehicleProperty::GECKO_BMS_PACKFASTCHGSOC);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_batsysnotmtcWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bms_batsysnotmtc = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_batsysnotmtc");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_batsysnotmtc = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_bms_batsysnotmtcReq(ec_bms_batsysnotmtc),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_batsysnotmtcReq(int32_t ec_bms_batsysnotmtc) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_batsysnotmtc);
    req->prop = toInt(VehicleProperty::GECKO_BMS_BATSYSNOTMTC);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_ucellinconWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bms_ucellincon = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_ucellincon");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_ucellincon = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_bms_ucellinconReq(ec_bms_ucellincon),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_ucellinconReq(int32_t ec_bms_ucellincon) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_ucellincon);
    req->prop = toInt(VehicleProperty::GECKO_BMS_UCELLINCON);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_lowinsresWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bms_lowinsres = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_lowinsres");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_lowinsres = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_bms_lowinsresReq(ec_bms_lowinsres),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_lowinsresReq(int32_t ec_bms_lowinsres) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_lowinsres);
    req->prop = toInt(VehicleProperty::GECKO_BMS_LOWINSRES);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_h_vilfaultWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bms_h_vilfault = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_h_vilfault");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_h_vilfault = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_bms_h_vilfaultReq(ec_bms_h_vilfault),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_h_vilfaultReq(int32_t ec_bms_h_vilfault) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_h_vilfault);
    req->prop = toInt(VehicleProperty::GECKO_BMS_HVILFAULT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_packoverchargeWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bms_packovercharge = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_packovercharge");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_packovercharge = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_bms_packoverchargeReq(ec_bms_packovercharge),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_packoverchargeReq(int32_t ec_bms_packovercharge) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_packovercharge);
    req->prop = toInt(VehicleProperty::GECKO_BMS_PACKOVERCHARGE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_batt_fault_total_numWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bms_batt_fault_total_num = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_batt_fault_total_num");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_batt_fault_total_num = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_bms_batt_fault_total_numReq(ec_bms_batt_fault_total_num),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_batt_fault_total_numReq(int32_t ec_bms_batt_fault_total_num) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_batt_fault_total_num);
    req->prop = toInt(VehicleProperty::GECKO_BMS_BATTFAULTTOTALNUM);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_fault_codeWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bms_fault_code = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_fault_code");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_fault_code = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_bms_fault_codeReq(ec_bms_fault_code),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_fault_codeReq(int32_t ec_bms_fault_code) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_fault_code);
    req->prop = toInt(VehicleProperty::GECKO_BMS_FAULTCODE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_b2_v_v_frame_noWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_b2_v_v_frame_no = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_b2_v_v_frame_no");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_b2_v_v_frame_no = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_b2_v_v_frame_noReq(ec_b2_v_v_frame_no),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_b2_v_v_frame_noReq(int32_t ec_b2_v_v_frame_no) {
    auto req = mValueObjectPool->obtainInt32(ec_b2_v_v_frame_no);
    req->prop = toInt(VehicleProperty::GECKO_B2V_V_FRAMENO);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_b2_v_v_cell_volt_n1Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_b2_v_v_cell_volt_n1 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_b2_v_v_cell_volt_n1");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_b2_v_v_cell_volt_n1 = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_b2_v_v_cell_volt_n1Req(ec_b2_v_v_cell_volt_n1),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_b2_v_v_cell_volt_n1Req(int32_t ec_b2_v_v_cell_volt_n1) {
    auto req = mValueObjectPool->obtainInt32(ec_b2_v_v_cell_volt_n1);
    req->prop = toInt(VehicleProperty::GECKO_B2V_V_CELL_VOLTN1);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_b2_v_v_cell_volt_n2Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_b2_v_v_cell_volt_n2 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_b2_v_v_cell_volt_n2");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_b2_v_v_cell_volt_n2 = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_b2_v_v_cell_volt_n2Req(ec_b2_v_v_cell_volt_n2),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_b2_v_v_cell_volt_n2Req(int32_t ec_b2_v_v_cell_volt_n2) {
    auto req = mValueObjectPool->obtainInt32(ec_b2_v_v_cell_volt_n2);
    req->prop = toInt(VehicleProperty::GECKO_B2V_V_CELL_VOLTN2);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_b2_v_v_cell_volt_n3Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_b2_v_v_cell_volt_n3 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_b2_v_v_cell_volt_n3");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_b2_v_v_cell_volt_n3 = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_b2_v_v_cell_volt_n3Req(ec_b2_v_v_cell_volt_n3),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_b2_v_v_cell_volt_n3Req(int32_t ec_b2_v_v_cell_volt_n3) {
    auto req = mValueObjectPool->obtainInt32(ec_b2_v_v_cell_volt_n3);
    req->prop = toInt(VehicleProperty::GECKO_B2V_V_CELL_VOLTN3);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_b2_v_t_frame_noWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_b2_v_t_frame_no = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_b2_v_t_frame_no");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_b2_v_t_frame_no = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_b2_v_t_frame_noReq(ec_b2_v_t_frame_no),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_b2_v_t_frame_noReq(int32_t ec_b2_v_t_frame_no) {
    auto req = mValueObjectPool->obtainInt32(ec_b2_v_t_frame_no);
    req->prop = toInt(VehicleProperty::GECKO_B2V_T_FRAMENO);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_b2_v_t_cell_temp_n1Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_b2_v_t_cell_temp_n1 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_b2_v_t_cell_temp_n1");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_b2_v_t_cell_temp_n1 = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_b2_v_t_cell_temp_n1Req(ec_b2_v_t_cell_temp_n1),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_b2_v_t_cell_temp_n1Req(int32_t ec_b2_v_t_cell_temp_n1) {
    auto req = mValueObjectPool->obtainInt32(ec_b2_v_t_cell_temp_n1);
    req->prop = toInt(VehicleProperty::GECKO_B2V_T_CELL_TEMPN1);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_b2_v_t_cell_temp_n2Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_b2_v_t_cell_temp_n2 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_b2_v_t_cell_temp_n2");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_b2_v_t_cell_temp_n2 = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_b2_v_t_cell_temp_n2Req(ec_b2_v_t_cell_temp_n2),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_b2_v_t_cell_temp_n2Req(int32_t ec_b2_v_t_cell_temp_n2) {
    auto req = mValueObjectPool->obtainInt32(ec_b2_v_t_cell_temp_n2);
    req->prop = toInt(VehicleProperty::GECKO_B2V_T_CELL_TEMPN2);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_b2_v_t_cell_temp_n3Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_b2_v_t_cell_temp_n3 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_b2_v_t_cell_temp_n3");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_b2_v_t_cell_temp_n3 = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_b2_v_t_cell_temp_n3Req(ec_b2_v_t_cell_temp_n3),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_b2_v_t_cell_temp_n3Req(int32_t ec_b2_v_t_cell_temp_n3) {
    auto req = mValueObjectPool->obtainInt32(ec_b2_v_t_cell_temp_n3);
    req->prop = toInt(VehicleProperty::GECKO_B2V_T_CELL_TEMPN3);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_b2_v_t_cell_temp_n4Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_b2_v_t_cell_temp_n4 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_b2_v_t_cell_temp_n4");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_b2_v_t_cell_temp_n4 = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_b2_v_t_cell_temp_n4Req(ec_b2_v_t_cell_temp_n4),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_b2_v_t_cell_temp_n4Req(int32_t ec_b2_v_t_cell_temp_n4) {
    auto req = mValueObjectPool->obtainInt32(ec_b2_v_t_cell_temp_n4);
    req->prop = toInt(VehicleProperty::GECKO_B2V_T_CELL_TEMPN4);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_b2_v_t_cell_temp_n5Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_b2_v_t_cell_temp_n5 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_b2_v_t_cell_temp_n5");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_b2_v_t_cell_temp_n5 = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_b2_v_t_cell_temp_n5Req(ec_b2_v_t_cell_temp_n5),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_b2_v_t_cell_temp_n5Req(int32_t ec_b2_v_t_cell_temp_n5) {
    auto req = mValueObjectPool->obtainInt32(ec_b2_v_t_cell_temp_n5);
    req->prop = toInt(VehicleProperty::GECKO_B2V_T_CELL_TEMPN5);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_b2_v_t_cell_temp_n6Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_b2_v_t_cell_temp_n6 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_b2_v_t_cell_temp_n6");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_b2_v_t_cell_temp_n6 = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_b2_v_t_cell_temp_n6Req(ec_b2_v_t_cell_temp_n6),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_b2_v_t_cell_temp_n6Req(int32_t ec_b2_v_t_cell_temp_n6) {
    auto req = mValueObjectPool->obtainInt32(ec_b2_v_t_cell_temp_n6);
    req->prop = toInt(VehicleProperty::GECKO_B2V_T_CELL_TEMPN6);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_b2_v_t_cell_temp_n7Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_b2_v_t_cell_temp_n7 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_b2_v_t_cell_temp_n7");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_b2_v_t_cell_temp_n7 = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_b2_v_t_cell_temp_n7Req(ec_b2_v_t_cell_temp_n7),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_b2_v_t_cell_temp_n7Req(int32_t ec_b2_v_t_cell_temp_n7) {
    auto req = mValueObjectPool->obtainInt32(ec_b2_v_t_cell_temp_n7);
    req->prop = toInt(VehicleProperty::GECKO_B2V_T_CELL_TEMPN7);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_hardware_numWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_hardware_num = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_hardware_num");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_hardware_num = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_vcu_hardware_numReq(ec_vcu_hardware_num),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_hardware_numReq(int32_t ec_vcu_hardware_num) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_hardware_num);
    req->prop = toInt(VehicleProperty::GECKO_VCU_HARDWARE_NUM);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_sofeware_numWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_sofeware_num = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_sofeware_num");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_sofeware_num = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_vcu_sofeware_numReq(ec_vcu_sofeware_num),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_sofeware_numReq(int32_t sc_ec_ccm_operat_licence) {
    auto req = mValueObjectPool->obtainInt32(sc_ec_ccm_operat_licence);
    req->prop = toInt(VehicleProperty::GECKO_VCU_SOFEWARE_NUM);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_igonWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_igon = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_igon");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_igon = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_vcu_igonReq(ec_vcu_igon),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_igonReq(int32_t ec_vcu_igon) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_igon);
    req->prop = toInt(VehicleProperty::GECKO_VCU_IGON);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_hvpowerWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_hvpower = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_hvpower");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_hvpower = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_vcu_hvpowerReq(ec_vcu_hvpower),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_hvpowerReq(int32_t ec_vcu_hvpower) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_hvpower);
    req->prop = toInt(VehicleProperty::GECKO_VCU_HVPOWER);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_heatrelaystatusWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bms_heatrelaystatus = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_heatrelaystatus");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_heatrelaystatus = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_bms_heatrelaystatusReq(ec_bms_heatrelaystatus),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_heatrelaystatusReq(int32_t ec_bms_heatrelaystatus) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_heatrelaystatus);
    req->prop = toInt(VehicleProperty::GECKO_BMS_HEATRELAYSTATUS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_single_chrg_energyWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bms_single_chrg_energy = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_single_chrg_energy");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_single_chrg_energy = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_bms_single_chrg_energyReq(ec_bms_single_chrg_energy),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_single_chrg_energyReq(int32_t ec_bms_single_chrg_energy) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_single_chrg_energy);
    req->prop = toInt(VehicleProperty::GECKO_BMS_SINGLECHRGENERGY);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_batt_info4_dc_charg_req_currWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bms_batt_info4_dc_charg_req_curr = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_batt_info4_dc_charg_req_curr");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_batt_info4_dc_charg_req_curr = getActualFloatValue(mPropertyManager->getCProValue(mp), 0.1, 0);
      mHal->onPropertyValue(*Create_ec_bms_batt_info4_dc_charg_req_currReq(ec_bms_batt_info4_dc_charg_req_curr),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_batt_info4_dc_charg_req_currReq(float ec_bms_batt_info4_dc_charg_req_curr) {
    auto req = mValueObjectPool->obtainFloat(ec_bms_batt_info4_dc_charg_req_curr);
    req->prop = toInt(VehicleProperty::GECKO_BMS_BATTINFO4_DCCHARGREQCURR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_batt_info4_dc_charg_req_volWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bms_batt_info4_dc_charg_req_vol = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_batt_info4_dc_charg_req_vol");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_batt_info4_dc_charg_req_vol = getActualFloatValue(mPropertyManager->getCProValue(mp), 0.1, 0);
      mHal->onPropertyValue(*Create_ec_bms_batt_info4_dc_charg_req_volReq(ec_bms_batt_info4_dc_charg_req_vol),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_batt_info4_dc_charg_req_volReq(float ec_bms_batt_info4_dc_charg_req_vol) {
    auto req = mValueObjectPool->obtainFloat(ec_bms_batt_info4_dc_charg_req_vol);
    req->prop = toInt(VehicleProperty::GECKO_BMS_BATTINFO4_DCCHARGREQVOL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_batt_info4_mach_put_currWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bms_batt_info4_mach_put_curr = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_batt_info4_mach_put_curr");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_batt_info4_mach_put_curr = getActualFloatValue(mPropertyManager->getCProValue(mp), 0.1, 0);
      mHal->onPropertyValue(*Create_ec_bms_batt_info4_mach_put_currReq(ec_bms_batt_info4_mach_put_curr),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_batt_info4_mach_put_currReq(float ec_bms_batt_info4_mach_put_curr) {
    auto req = mValueObjectPool->obtainFloat(ec_bms_batt_info4_mach_put_curr);
    req->prop = toInt(VehicleProperty::GECKO_BMS_BATTINFO4_MACHPUTCURR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_batt_info4_mach_put_voltWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bms_batt_info4_mach_put_volt = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_batt_info4_mach_put_volt");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_batt_info4_mach_put_volt = getActualFloatValue(mPropertyManager->getCProValue(mp), 0.1, 0);
      mHal->onPropertyValue(*Create_ec_bms_batt_info4_mach_put_voltReq(ec_bms_batt_info4_mach_put_volt),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_batt_info4_mach_put_voltReq(float ec_bms_batt_info4_mach_put_volt) {
    auto req = mValueObjectPool->obtainFloat(ec_bms_batt_info4_mach_put_volt);
    req->prop = toInt(VehicleProperty::GECKO_BMS_BATTINFO4_MACHPUTVOLT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_eas_crtpwrWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_eas_crtpwr = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_eas_crtpwr");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_eas_crtpwr = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_bc_eas_crtpwrReq(bc_eas_crtpwr),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_eas_crtpwrReq(int32_t bc_eas_crtpwr) {
    auto req = mValueObjectPool->obtainInt32(bc_eas_crtpwr);
    req->prop = toInt(VehicleProperty::GECKO_EAS_CRTPWR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_veh_alrm_sys_stWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_veh_alrm_sys_st = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_veh_alrm_sys_st");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_veh_alrm_sys_st = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_bc_bcm_veh_alrm_sys_stReq(bc_bcm_veh_alrm_sys_st),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_veh_alrm_sys_stReq(int32_t bc_bcm_veh_alrm_sys_st) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_veh_alrm_sys_st);
    req->prop = toInt(VehicleProperty::GECKO_BCM_VEHALRMSYSST);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::mc_key_previous_songWatcher(){
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t mc_key_previous_song = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("mc_key_previous_song");
  while(!mShuttingDownFlag.load()){
    mPropertyManager->getUpdateCState(mp);
    // mc_key_previous_song = mPropertyManager->getCProValue(mp);
    // LOG(INFO) << "mc_key_previous_song:"<<mc_key_previous_song;
    // mHal->onPropertyValue(*Create_mcu_steering_002_customWatcher(mc_key_previous_song, CustomInputType::key_previous_song),true);

    mc_key_previous_song = mPropertyManager->getCProValue(mp);
    LOG(INFO) << "mc_key_previous_song:"<<mc_key_previous_song;
    mHal->onPropertyValue(*Create_mcu_steering_002_keyWatcher(mc_key_previous_song, KeyCodeType::KEYCODE_MEDIA_PREVIOUS),true);
  }
}

void GarageModeServerSideHandlerImpl::mc_key_next_songWatcher(){
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t mc_key_next_song = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("mc_key_next_song");
  while(!mShuttingDownFlag.load()){
    mPropertyManager->getUpdateCState(mp);
    mc_key_next_song = mPropertyManager->getCProValue(mp);
    LOG(INFO) << "mc_key_next_song:"<<mc_key_next_song;
    mHal->onPropertyValue(*Create_mcu_steering_002_keyWatcher(mc_key_next_song, KeyCodeType::KEYCODE_MEDIA_NEXT),true);
  }
}


void GarageModeServerSideHandlerImpl::mc_key_volume_upWatcher(){
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
     int32_t mc_key_volume_up = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("mc_key_volume_up");
  while(!mShuttingDownFlag.load()){
    mPropertyManager->getUpdateCState(mp);
    mc_key_volume_up = mPropertyManager->getCProValue(mp);
    LOG(INFO) << "mc_key_volume_up:"<<mc_key_volume_up;
    mHal->onPropertyValue(*Create_mcu_steering_002_keyWatcher(mc_key_volume_up, KeyCodeType::KEYCODE_VOLUME_UP),true);
  }
}

void GarageModeServerSideHandlerImpl::mc_key_volume_dowmWatcher(){
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
     int32_t mc_key_volume_dowm = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("mc_key_volume_dowm");
  while(!mShuttingDownFlag.load()){
    mPropertyManager->getUpdateCState(mp);
    mc_key_volume_dowm = mPropertyManager->getCProValue(mp);
    LOG(INFO) << "mc_key_volume_dowm:"<<mc_key_volume_dowm;
    mHal->onPropertyValue(*Create_mcu_steering_002_keyWatcher(mc_key_volume_dowm, KeyCodeType::KEYCODE_VOLUME_DOWN),true);
  }
}

void GarageModeServerSideHandlerImpl::mc_key_mode_muteWatcher(){
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
     int32_t mc_key_mode_mute = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("mc_key_mode_mute");
  while(!mShuttingDownFlag.load()){
    mPropertyManager->getUpdateCState(mp);
    mc_key_mode_mute = mPropertyManager->getCProValue(mp);
    LOG(INFO) << "mc_key_mode_mute:"<<mc_key_mode_mute;
    mHal->onPropertyValue(*Create_mcu_steering_002_keyWatcher(mc_key_mode_mute, KeyCodeType::KEYCODE_VOLUME_MUTE),true);
  }
}

void GarageModeServerSideHandlerImpl::mc_key_telephoneWatcher(){
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
     int32_t mc_key_telephone = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("mc_key_telephone");
  while(!mShuttingDownFlag.load()){
    mPropertyManager->getUpdateCState(mp);
    mc_key_telephone = mPropertyManager->getCProValue(mp);
    LOG(INFO) << "mc_key_telephone:"<<mc_key_telephone;
    mHal->onPropertyValue(*Create_mcu_steering_002_keyWatcher(mc_key_telephone, KeyCodeType::KEYCODE_CALL),true);
  }
}

void GarageModeServerSideHandlerImpl::mc_key_voiceWatcher(){
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
     int32_t mc_key_voice = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("mc_key_voice");
  while(!mShuttingDownFlag.load()){
    mPropertyManager->getUpdateCState(mp);
    mc_key_voice = mPropertyManager->getCProValue(mp);
    LOG(INFO) << "mc_key_voice:"<<mc_key_voice;
    mHal->onPropertyValue(*Create_mcu_steering_002_keyWatcher(mc_key_voice, KeyCodeType::KEYCODE_0),true);
  }
}

void GarageModeServerSideHandlerImpl::mc_key_homeWatcher(){
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
     int32_t mc_key_home = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("mc_key_home");
  while(!mShuttingDownFlag.load()){
    mPropertyManager->getUpdateCState(mp);
    mc_key_home = mPropertyManager->getCProValue(mp);
    LOG(INFO) << "mc_key_home:"<<mc_key_home;
    mHal->onPropertyValue(*Create_mcu_steering_002_keyWatcher(mc_key_home, KeyCodeType::KEYCODE_HOME),true);
  }
}

void GarageModeServerSideHandlerImpl::mc_key_distanceWatcher(){
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
     int32_t mc_key_distance = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("mc_key_distance");
  while(!mShuttingDownFlag.load()){
    mPropertyManager->getUpdateCState(mp);
    mc_key_distance = mPropertyManager->getCProValue(mp);
    LOG(INFO) << "mc_key_distance:"<<mc_key_distance;
    mHal->onPropertyValue(*Create_mcu_steering_002_keyWatcher(mc_key_distance, KeyCodeType::KEYCODE_DISTANCE),true);
  }
}


void GarageModeServerSideHandlerImpl::mc_key_speedupWatcher(){
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
     int32_t mc_key_speedup = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("mc_key_speedup");
  while(!mShuttingDownFlag.load()){
    mPropertyManager->getUpdateCState(mp);
    mc_key_speedup = mPropertyManager->getCProValue(mp);
    LOG(INFO) << "mc_key_speedup:"<<mc_key_speedup;
    mHal->onPropertyValue(*Create_mcu_steering_002_keyWatcher(mc_key_speedup, KeyCodeType::KEYCODE_SPEED_UP),true);
  }
}

void GarageModeServerSideHandlerImpl::mc_key_speeddownWatcher(){
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
     int32_t mc_key_speeddown = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("mc_key_speeddown");
  while(!mShuttingDownFlag.load()){
    mPropertyManager->getUpdateCState(mp);
    mc_key_speeddown = mPropertyManager->getCProValue(mp);
    LOG(INFO) << "mc_key_speeddown:"<<mc_key_speeddown;
    mHal->onPropertyValue(*Create_mcu_steering_002_keyWatcher(mc_key_speeddown, KeyCodeType::KEYCODE_SPEED_DOWN),true);
  }
}

void GarageModeServerSideHandlerImpl::mc_key_pagedownWatcher(){
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
     int32_t mc_key_pagedown = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("mc_key_pagedown");
  while(!mShuttingDownFlag.load()){
    mPropertyManager->getUpdateCState(mp);
    mc_key_pagedown = mPropertyManager->getCProValue(mp);
    LOG(INFO) << "mc_key_pagedown:"<<mc_key_pagedown;
    mHal->onPropertyValue(*Create_mcu_steering_002_keyWatcher(mc_key_pagedown, KeyCodeType::KEYCODE_PAGE_DOWN),true);
  }
}

void GarageModeServerSideHandlerImpl::mc_key_pageupWatcher(){
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
     int32_t mc_key_pageup = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("mc_key_pageup");
  while(!mShuttingDownFlag.load()){
    mPropertyManager->getUpdateCState(mp);
    mc_key_pageup = mPropertyManager->getCProValue(mp);
    LOG(INFO) << "mc_key_pageup:"<<mc_key_pageup;
    mHal->onPropertyValue(*Create_mcu_steering_002_keyWatcher(mc_key_pageup, KeyCodeType::KEYCODE_PAGE_UP),true);
  }
}

void GarageModeServerSideHandlerImpl::mc_key_okayWatcher(){
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
     int32_t mc_key_okay = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("mc_key_okay");
  while(!mShuttingDownFlag.load()){
    mPropertyManager->getUpdateCState(mp);
    mc_key_okay = mPropertyManager->getCProValue(mp);
    LOG(INFO) << "mc_key_okay:"<<mc_key_okay;
    mHal->onPropertyValue(*Create_mcu_steering_002_keyWatcher(mc_key_okay, KeyCodeType::KEYCODE_OKAY),true);
  }
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_mcu_steering_002_keyWatcher(int32_t mcu_steering_002_action, KeyCodeType mcu_steering_002_keycode){
    auto keyEvent = mValueObjectPool->obtain(VehiclePropertyType::INT32_VEC, 3);
    int32_t targetDisplay = 0;
    keyEvent->prop = toInt(VehicleProperty::HW_KEY_INPUT);
    keyEvent->areaId = 0;
    keyEvent->timestamp = elapsedRealtimeNano();
    keyEvent->status = VehiclePropertyStatus::AVAILABLE;
    keyEvent->value.int32Values[0] = mcu_steering_002_action;
    keyEvent->value.int32Values[1] = static_cast<int32_t>(mcu_steering_002_keycode);
    keyEvent->value.int32Values[2] = targetDisplay;
    return keyEvent;
}

void GarageModeServerSideHandlerImpl::mc_key_customWatcher(){
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t mc_key_custom = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("mc_key_custom");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        mc_key_custom = mPropertyManager->getCProValue(mp);
        LOG(INFO) << "mc_key_custom:"<<mc_key_custom;
        mHal->onPropertyValue(*Create_mcu_steering_002_keyWatcher(mc_key_custom, KeyCodeType::KEYCODE_MENU),true);
    }
}

void GarageModeServerSideHandlerImpl::mc_key_long_volume_upWatcher(){
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t mc_key_long_volume_up = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("mc_key_long_volume_up");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        mc_key_long_volume_up = mPropertyManager->getCProValue(mp);
        LOG(INFO) << "mc_key_long_volume_up:"<<mc_key_long_volume_up;
        mHal->onPropertyValue(*Create_mcu_steering_002_customWatcher(mc_key_long_volume_up, CustomInputType::key_long_volume_up),true);
    }
}

void GarageModeServerSideHandlerImpl::mc_key_long_volume_dowmWatcher(){
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t mc_key_long_volume_dowm = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("mc_key_long_volume_dowm");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        mc_key_long_volume_dowm = mPropertyManager->getCProValue(mp);
        LOG(INFO) << "mc_key_long_volume_dowm:"<<mc_key_long_volume_dowm;
        mHal->onPropertyValue(*Create_mcu_steering_002_customWatcher(mc_key_long_volume_dowm, CustomInputType::key_long_volume_dowm),true);
    }
}

void GarageModeServerSideHandlerImpl::mc_key_long_telephoneWatcher(){
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t mc_key_long_telephone = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("mc_key_long_telephone");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        mc_key_long_telephone = mPropertyManager->getCProValue(mp);
        LOG(INFO) << "mc_key_long_telephone:"<<mc_key_long_telephone;
        mHal->onPropertyValue(*Create_mcu_steering_002_customWatcher(mc_key_long_telephone, CustomInputType::key_long_telephone),true);
    }
}

void GarageModeServerSideHandlerImpl::mc_key_long_customWatcher(){
    int32_t mc_key_long_custom = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("mc_key_long_custom");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        mc_key_long_custom = mPropertyManager->getCProValue(mp);
        LOG(INFO) << "mc_key_long_custom:"<<mc_key_long_custom;
        mHal->onPropertyValue(*Create_mcu_steering_002_customWatcher(mc_key_long_custom, CustomInputType::key_long_custom),true);
    }
}

void GarageModeServerSideHandlerImpl::mc_key_long_previous_songWatcher(){
    int32_t mc_key_long_previous_song = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("mc_key_long_previous_song");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        mc_key_long_previous_song = mPropertyManager->getCProValue(mp);
        LOG(INFO) << "mc_key_long_previous_song:"<<mc_key_long_previous_song;
        mHal->onPropertyValue(*Create_mcu_steering_002_customWatcher(mc_key_long_previous_song, CustomInputType::key_long_previous_song),true);
    }
}
void GarageModeServerSideHandlerImpl::mc_key_long_next_songWatcher(){
    int32_t mc_key_long_next_song = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("mc_key_long_next_song");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        mc_key_long_next_song = mPropertyManager->getCProValue(mp);
        LOG(INFO) << "mc_key_long_next_song:"<<mc_key_long_next_song;
        mHal->onPropertyValue(*Create_mcu_steering_002_customWatcher(mc_key_long_next_song, CustomInputType::key_long_next_song),true);
    }
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_mcu_steering_002_customWatcher(int32_t mcu_steering_002_action, CustomInputType mcu_steering_002_keycode){
    auto keyEvent = mValueObjectPool->obtain(VehiclePropertyType::INT32_VEC, 3);
    int32_t targetDisplay = 0;
    keyEvent->prop = toInt(VehicleProperty::HW_CUSTOM_INPUT);
    keyEvent->areaId = 0;
    keyEvent->timestamp = elapsedRealtimeNano();
    keyEvent->status = VehiclePropertyStatus::AVAILABLE;
    keyEvent->value.int32Values[0] = static_cast<int32_t>(mcu_steering_002_keycode);
    keyEvent->value.int32Values[1] = targetDisplay;
    keyEvent->value.int32Values[2] = 0;
    LOG(INFO) << "mcu_steering_002_action:"<<mcu_steering_002_action;
    return keyEvent;
}

void GarageModeServerSideHandlerImpl::mc_light_levelWatcher(){
    int32_t mc_light_level = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("mc_light_level");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        mc_light_level = mPropertyManager->getCProValue(mp);
        LOG(INFO) << "mc_light_level:"<<mc_light_level;
        mHal->onPropertyValue(*Create_mc_light_levelReq(mc_light_level),true);
    }
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_mc_light_levelReq(int32_t mc_light_level){
    auto req = mValueObjectPool->obtainInt32(mc_light_level);
    req->prop = toInt(VehicleProperty::GECKO_CCM_SCREEN_BRIGHTNESS_ADJUST);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

std::unique_ptr<GarageModeServerSideHandler> makeGarageModeServerSideHandler(
        VehiclePropValuePool* valueObjectPool,PropertyManager* pm, EmulatedVehicleHalIface* hal) {
    return std::make_unique<GarageModeServerSideHandlerImpl>(valueObjectPool, pm, hal);
}

void GarageModeServerSideHandlerImpl::ccm_appointment_mode(){
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t appointment_mode_type = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("appointment_mode");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        appointment_mode_type = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
        LOG(INFO) << "appointment_mode:"<<appointment_mode_type;
        mHal->onPropertyValue(*Create_appointment_modeReq(appointment_mode_type),true);
    }
}
void GarageModeServerSideHandlerImpl::ccm_chraging_begin_time_hour(){
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t chraging_begin_time_hour = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("chraging_begin_time_hour");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        chraging_begin_time_hour = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
        LOG(INFO) << "chraging_begin_time_hour:"<<chraging_begin_time_hour;
        mHal->onPropertyValue(*Create_chraging_begin_time_hourReq(chraging_begin_time_hour),true);
    }
}

void GarageModeServerSideHandlerImpl::ccm_chraging_begin_time_minute()
{
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t chraging_begin_time_minute = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("chraging_begin_time_minute");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        chraging_begin_time_minute = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
        LOG(INFO) << "chraging_begin_time_minute:"<<chraging_begin_time_minute;
        mHal->onPropertyValue(*Create_chraging_begin_time_minuteReq(chraging_begin_time_minute),true);
    }
}

void GarageModeServerSideHandlerImpl::ccm_chraging_end_time_hour()
{
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t chraging_end_time_hour = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("chraging_end_time_hour");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        chraging_end_time_hour = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
        LOG(INFO) << "chraging_end_time_hour:"<<chraging_end_time_hour;
        mHal->onPropertyValue(*Create_chraging_end_time_hourReq(chraging_end_time_hour),true);
    }
}

void GarageModeServerSideHandlerImpl::ccm_chraging_end_time_minute()
{
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t chraging_end_time_minute = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("chraging_end_time_minute");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        chraging_end_time_minute = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
        LOG(INFO) << "chraging_end_time_minute:"<<chraging_end_time_minute;
        mHal->onPropertyValue(*Create_chraging_end_time_minuteReq(chraging_end_time_minute),true);
    }
}

void GarageModeServerSideHandlerImpl::ccm_chraging_sunday_loop()
{
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    ConfigDBC* mp = mPropertyManager->findCProperty("sunday_loop");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        chraging_sunday_loop = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
        LOG(INFO) << "chraging_sunday_loop:"<<chraging_sunday_loop;
        mHal->onPropertyValue(*Create_chraging_loopReq(),true);
    }
}

void GarageModeServerSideHandlerImpl::ccm_chraging_monday_loop()
{   
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    ConfigDBC* mp = mPropertyManager->findCProperty("monday_loop");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        chraging_monday_loop = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
        LOG(INFO) << "chraging_monday_loop:"<<chraging_monday_loop;
        mHal->onPropertyValue(*Create_chraging_loopReq(),true);
    }
}

void GarageModeServerSideHandlerImpl::ccm_chraging_tuesday_loop()
{ 
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    ConfigDBC* mp = mPropertyManager->findCProperty("tuesday_loop");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        chraging_tuesday_loop = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
        LOG(INFO) << "chraging_tuesday_loop:"<<chraging_tuesday_loop;
        mHal->onPropertyValue(*Create_chraging_loopReq(),true);
    }
}

void GarageModeServerSideHandlerImpl::ccm_chraging_wednesday_loop()
{   
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    ConfigDBC* mp = mPropertyManager->findCProperty("wednesday_loop");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        chraging_wednesday_loop = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
        LOG(INFO) << "chraging_wednesday_loop:"<<chraging_wednesday_loop;
        mHal->onPropertyValue(*Create_chraging_loopReq(),true);
    }
}

void GarageModeServerSideHandlerImpl::ccm_chraging_thursday_loop()
{
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    ConfigDBC* mp = mPropertyManager->findCProperty("thursday_loop");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        chraging_thursday_loop = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
        LOG(INFO) << "chraging_thursday_loop:"<<chraging_thursday_loop;
        mHal->onPropertyValue(*Create_chraging_loopReq(),true);
    }
}

void GarageModeServerSideHandlerImpl::ccm_chraging_friday_loop()
{   
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    ConfigDBC* mp = mPropertyManager->findCProperty("friday_loop");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        chraging_friday_loop = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
        LOG(INFO) << "chraging_friday_loop:"<<chraging_friday_loop;
        mHal->onPropertyValue(*Create_chraging_loopReq(),true);
    }
}

void GarageModeServerSideHandlerImpl::ccm_chraging_saturday_loop()
{
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    ConfigDBC* mp = mPropertyManager->findCProperty("saturday_loop");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        chraging_saturday_loop = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
        LOG(INFO) << "chraging_saturday_loop:"<<chraging_saturday_loop;
        mHal->onPropertyValue(*Create_chraging_loopReq(),true);
    }
}

void GarageModeServerSideHandlerImpl::ccm_chraging_target_soc()
{
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t chraging_target_soc = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("chraging_target_soc");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        chraging_target_soc = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
        LOG(INFO) << "chraging_target_soc:"<<chraging_target_soc;
        mHal->onPropertyValue(*Create_chraging_target_socReq(chraging_target_soc),true);
    }
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_appointment_modeReq(int32_t appointment_mode_type){
    auto req = mValueObjectPool->obtainInt32(appointment_mode_type);
    req->prop = toInt(VehicleProperty::GECKO_CCM_APPOINTMENT_MODE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_chraging_begin_time_hourReq(int32_t chraging_begin_time_hour){
    auto req = mValueObjectPool->obtainInt32(chraging_begin_time_hour);
    req->prop = toInt(VehicleProperty::GECKO_CCM_CHRAGING_BEGIN_TIME_HOUR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_chraging_begin_time_minuteReq(int32_t chraging_begin_time_minute){
    auto req = mValueObjectPool->obtainInt32(chraging_begin_time_minute);
    req->prop = toInt(VehicleProperty::GECKO_CCM_CHRAGING_BEGIN_TIME_MINUTE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_chraging_end_time_hourReq(int32_t chraging_end_time_hour){
    auto req = mValueObjectPool->obtainInt32(chraging_end_time_hour);
    req->prop = toInt(VehicleProperty::GECKO_CCM_CHRAGING_END_TIME_HOUR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_chraging_end_time_minuteReq(int32_t chraging_end_time_minute){
    auto req = mValueObjectPool->obtainInt32(chraging_end_time_minute);
    req->prop = toInt(VehicleProperty::GECKO_CCM_CHRAGING_END_TIME_MINUTE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_chraging_loopReq(){
    auto req = mValueObjectPool->obtain(VehiclePropertyType::INT32_VEC, 7);
    req->prop = toInt(VehicleProperty::GECKO_CCM_CHRAGING_LOOP);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    req->value.int32Values[0] = chraging_sunday_loop;
    req->value.int32Values[1] = chraging_monday_loop;
    req->value.int32Values[2] = chraging_tuesday_loop;
    req->value.int32Values[3] = chraging_wednesday_loop;
    req->value.int32Values[4] = chraging_thursday_loop;
    req->value.int32Values[5] = chraging_friday_loop;
    req->value.int32Values[6] = chraging_saturday_loop;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_chraging_target_socReq(int32_t chraging_target_soc){
    auto req = mValueObjectPool->obtainInt32(chraging_target_soc);
    req->prop = toInt(VehicleProperty::GECKO_CCM_CHRAGING_TARGET_SOC);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_obc_output_voltageWatcher()
{
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ipu_obc_output_voltage = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_obc_output_voltage");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ipu_obc_output_voltage = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
        //LOG(INFO) << "ipu_obc_output_voltage:"<<ipu_obc_output_voltage;
        mHal->onPropertyValue(*Create_ec_ipu_obc_output_voltageReq(ipu_obc_output_voltage),true);
    }
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_obc_output_voltageReq(int32_t ipu_obc_output_voltage){
    auto req = mValueObjectPool->obtainInt32(ipu_obc_output_voltage);
    req->prop = toInt(VehicleProperty::GECKO_IPU_OBC_OUTPUT_VOLTAGE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}


void GarageModeServerSideHandlerImpl::ec_bms_mainrelaynega_statusWatcher()
{
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_mainrelaynega_status = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_mainrelaynega_status");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_mainrelaynega_status = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
        //LOG(INFO) << "ec_bms_mainrelaynega_status:"<<ec_bms_mainrelaynega_status;
        mHal->onPropertyValue(*Create_ec_bms_mainrelaynega_statusReq(ec_bms_mainrelaynega_status),true);
    }
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_mainrelaynega_statusReq(int32_t ec_bms_mainrelaynega_status)
{
    auto req = mValueObjectPool->obtainInt32(ec_bms_mainrelaynega_status);
    req->prop = toInt(VehicleProperty::GECKO_BMS_MAINRELAYNEGA_STATUS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_obc_output_currentWatcher()
{
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ipu_obc_output_current = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_obc_output_current");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ipu_obc_output_current = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
        //LOG(INFO) << "ec_ipu_obc_output_current:"<<ec_ipu_obc_output_current;
        mHal->onPropertyValue(*Create_ec_ipu_obc_output_currentReq(ec_ipu_obc_output_current),true);
    }
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_obc_output_currentReq(int32_t ec_ipu_obc_output_current)
{
    auto req = mValueObjectPool->obtainInt32(ec_ipu_obc_output_current);
    req->prop = toInt(VehicleProperty::GECKO_IPU_OBC_OUTPUT_CURRENT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_batterysohWatcher()
{
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_batterysoh = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_batterysoh");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        // ec_bms_batterysoh = static_cast<int32_t>(getActualFloatValue(mPropertyManager->getCProValue(mp), 0.1, 0));
        ec_bms_batterysoh = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
        LOG(INFO) << "ec_bms_batterysoh:"<<ec_bms_batterysoh;
        mHal->onPropertyValue(*Create_ec_bms_batterysohReq(ec_bms_batterysoh),true);
    }
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_batterysohReq(int32_t ec_bms_batterysoh)
{
    auto req = mValueObjectPool->obtainInt32(ec_bms_batterysoh);
    req->prop = toInt(VehicleProperty::GECKO_BMS_BATTERYSOH);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_soeWatcher()
{
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_soe = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_soe");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        // ec_bms_soe = static_cast<int32_t>(getActualFloatValue(mPropertyManager->getCProValue(mp), 0.1, 0));
        ec_bms_soe = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
        //LOG(INFO) << "ec_bms_soe:"<<ec_bms_soe;
        mHal->onPropertyValue(*Create_ec_bms_soeReq(ec_bms_soe),true);
    }
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_soeReq(int32_t ec_bms_soe)
{
    auto req = mValueObjectPool->obtainInt32(ec_bms_soe);
    req->prop = toInt(VehicleProperty::GECKO_BMS_SOE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_hv_batt_stWatcher()
{
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_hv_batt_st = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_hv_batt_st");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_hv_batt_st = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
        //LOG(INFO) << "ec_bms_hv_batt_st:"<<ec_bms_hv_batt_st;
        mHal->onPropertyValue(*Create_ec_bms_hv_batt_stReq(ec_bms_hv_batt_st),true);
    }
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_hv_batt_stReq(int32_t ec_bms_hv_batt_st)
{
    auto req = mValueObjectPool->obtainInt32(ec_bms_hv_batt_st);
    req->prop = toInt(VehicleProperty::GECKO_BMS_HVBATTST);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_initstatusWatcher()
{   std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_initstatus = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_initstatus");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_initstatus = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
        //LOG(INFO) << "ec_bms_initstatus:"<<ec_bms_initstatus;
        mHal->onPropertyValue(*Create_ec_bms_initstatusReq(ec_bms_initstatus),true);
    }
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_initstatusReq(int32_t ec_bms_initstatus)
{
    auto req = mValueObjectPool->obtainInt32(ec_bms_initstatus);
    req->prop = toInt(VehicleProperty::GECKO_BMS_INITSTATUS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bcm_rear_fog_light_errWatcher()
{   
    int32_t bc_bcm_rear_fog_light_err = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_rear_fog_light_err");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        bc_bcm_rear_fog_light_err = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
        LOG(INFO) << "bc_bcm_rear_fog_light_err:"<<bc_bcm_rear_fog_light_err;
        mHal->onPropertyValue(*Create_bc_bcm_rear_fog_light_errReq(bc_bcm_rear_fog_light_err),true);
    }
}  
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_rear_fog_light_errReq(int32_t value)  
{
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_BCM_REAR_FOG_LIGHT_ERR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
} 

void GarageModeServerSideHandlerImpl::bcm_reversinglight_errWatcher()
{   
    int32_t bcm_reversinglight_err = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_reversinglight_err");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        bcm_reversinglight_err = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
        LOG(INFO) << "bcm_reversinglight_err:"<<bcm_reversinglight_err;
        mHal->onPropertyValue(*Create_bc_bcm_reversinglight_errReq(bcm_reversinglight_err),true);
    }
}      
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_reversinglight_errReq(int32_t value)
{
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_BCM_REVERSINGLIGHT_ERR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}    

void GarageModeServerSideHandlerImpl::bcm_brakelight_errWatcher()
{   
    int32_t bcm_brakelight_err = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_brakelight_err");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        bcm_brakelight_err = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
        LOG(INFO) << "bcm_brakelight_err:"<<bcm_brakelight_err;
        mHal->onPropertyValue(*Create_bc_bcm_brakelight_errReq(bcm_brakelight_err),true);
    }
}        
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_brakelight_errReq(int32_t value)
{
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_BCM_BRAKELIGHT_ERR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}    

void GarageModeServerSideHandlerImpl::bcm_daytime_running_light_errWatcher()
{   
    int32_t bcm_daytime_running_light_err = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_daytime_running_light_err");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        bcm_daytime_running_light_err = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
        LOG(INFO) << "bcm_daytime_running_light_err:"<<bcm_daytime_running_light_err;
        mHal->onPropertyValue(*Create_bc_bcm_daytime_running_light_errReq(bcm_daytime_running_light_err),true);
    }
}  
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_daytime_running_light_errReq(int32_t value)
{
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_BCM_DAYTIME_RUNNING_LIGHT_ERR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
} 

void GarageModeServerSideHandlerImpl::bcm_position_light_errWatcher()
{   
    int32_t bcm_position_light_err = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_position_light_err");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        bcm_position_light_err = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
        LOG(INFO) << "bcm_position_light_err:"<<bcm_position_light_err;
        mHal->onPropertyValue(*Create_bc_bcm_position_light_errReq(bcm_position_light_err),true);
    }
}      
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_position_light_errReq(int32_t value)
{
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_BCM_POSITION_LIGHT_ERR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}    

void GarageModeServerSideHandlerImpl::bcm_turn_indcr_le_errWatcher()
{   
    int32_t bcm_turn_indcr_le_err = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_turn_indcr_le_err");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        bcm_turn_indcr_le_err = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
        LOG(INFO) << "bcm_turn_indcr_le_err:"<<bcm_turn_indcr_le_err;
        mHal->onPropertyValue(*Create_bc_bcm_turn_indcr_le_errReq(bcm_turn_indcr_le_err),true);
    }
}        
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_turn_indcr_le_errReq(int32_t value)
{
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_BCM_TURN_INDCR_LE_ERR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}   

void GarageModeServerSideHandlerImpl::bcm_turn_indcr_ri_errWatcher()
{   
    int32_t bcm_turn_indcr_ri_err = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_turn_indcr_ri_err");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        bcm_turn_indcr_ri_err = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
        LOG(INFO) << "bcm_turn_indcr_ri_err:"<<bcm_turn_indcr_ri_err;
        mHal->onPropertyValue(*Create_bc_bcm_turn_indcr_ri_errReq(bcm_turn_indcr_ri_err),true);
    }
}     
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_turn_indcr_ri_errReq(int32_t value)
{
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_BCM_TURN_INDCR_RI_ERR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}  

void GarageModeServerSideHandlerImpl::bcm_high_beam_rly_errWatcher()
{   
    int32_t bcm_high_beam_rly_err = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_high_beam_rly_err");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        bcm_high_beam_rly_err = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
        LOG(INFO) << "bcm_high_beam_rly_err:"<<bcm_high_beam_rly_err;
        mHal->onPropertyValue(*Create_bc_bcm_high_beam_rly_errReq(bcm_high_beam_rly_err),true);
    }
}   
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_high_beam_rly_errReq(int32_t value)
{
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_BCM_HIGH_BEAM_RLY_ERR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}    

void GarageModeServerSideHandlerImpl::bcm_low_beam_rly_errWatcher()
{   
    int32_t bcm_low_beam_rly_err = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_low_beam_rly_err");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        bcm_low_beam_rly_err = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
        LOG(INFO) << "bcm_low_beam_rly_err:"<<bcm_low_beam_rly_err;
        mHal->onPropertyValue(*Create_bc_bcm_low_beam_rly_errReq(bcm_low_beam_rly_err),true);
    }
}      
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_low_beam_rly_errReq(int32_t value)
{
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_BCM_LOW_BEAM_RLY_ERR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}  

   
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_motion_park_stateReq(int32_t value)
{
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_MOTION_PARK_STATE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}   

 
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_park_chrg_cnctr_stsReq(int32_t value)
{
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_PARK_CHRG_CNCTR_STS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
} 

void GarageModeServerSideHandlerImpl::mcu_voiume_navigationWatcher()
{   
    int32_t value = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("gecko_mcu_voiume_navigation");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        value = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
        LOG(INFO) << "gecko_mcu_voiume_navigation:"<<value;
        mHal->onPropertyValue(*Create_mcu_voiume_navigationReq(value),true);
    }
} 
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_mcu_voiume_navigationReq(int32_t value)
{
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_MCU_VOIUME_NAVIGATION);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
} 
void GarageModeServerSideHandlerImpl::mcu_voiume_voicWatcher()
{   
    int32_t value = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("gecko_mcu_voiume_voic");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        value = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
        LOG(INFO) << "gecko_mcu_voiume_voic:"<<value;
        mHal->onPropertyValue(*Create_mcu_voiume_voicReq(value),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_mcu_voiume_voicReq(int32_t value)
{
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_MCU_VOIUME_VOIC);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
} 
void GarageModeServerSideHandlerImpl::mcu_voiume_multimediaWatcher()
{   
    int32_t value = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("gecko_mcu_voiume_multimedia");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        value = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
        LOG(INFO) << "gecko_mcu_voiume_multimedia:"<<value;
        mHal->onPropertyValue(*Create_mcu_voiume_multimediaReq(value),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_mcu_voiume_multimediaReq(int32_t value)
{
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_MCU_VOIUME_MULTIMEDIA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
} 
void GarageModeServerSideHandlerImpl::mcu_voiume_phoneWatcher()
{   
    int32_t value = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("gecko_mcu_voiume_phone");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        value = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
        LOG(INFO) << "gecko_mcu_voiume_phone:"<<value;
        mHal->onPropertyValue(*Create_mcu_voiume_phoneReq(value),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_mcu_voiume_phoneReq(int32_t value)
{
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_MCU_VOIUME_PHONE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
} 
void GarageModeServerSideHandlerImpl::mcu_voiume_alarmWatcher()
{   
    int32_t value = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("gecko_mcu_voiume_alarm");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        value = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
        LOG(INFO) << "gecko_mcu_voiume_alarm:"<<value;
        mHal->onPropertyValue(*Create_mcu_voiume_alarmReq(value),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_mcu_voiume_alarmReq(int32_t value)
{
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_MCU_VOIUME_ALARM);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
} 
void GarageModeServerSideHandlerImpl::mcu_voiume_keyWatcher()
{   
    int32_t value = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("gecko_mcu_voiume_key");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        value = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
        LOG(INFO) << "gecko_mcu_voiume_key:"<<value;
        mHal->onPropertyValue(*Create_mcu_voiume_keyReq(value),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_mcu_voiume_keyReq(int32_t value)
{
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_MCU_VOIUME_KEY);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
} 

void GarageModeServerSideHandlerImpl::mcu_info_vin1Watcher()
{
    std::string value = "";
    Property*mp = mPropertyManager->findProperty("mc_mcu_info_vin1");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateState(mp);
        value = mPropertyManager->getProValue(mp);
        LOG(INFO) << "mc_mcu_info_vin1:"<<value;
        mHal->onPropertyValue(*Create_mcu_info_vin1Req(value),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_mcu_info_vin1Req(std::string value)
{
    memcpy(mVehicleInfoVin, value.c_str(), value.length());
    const char* mInfoVin = mVehicleInfoVin;
    auto req = mValueObjectPool->obtainString(mInfoVin);
    req->prop = toInt(VehicleProperty::INFO_VIN);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::mcu_info_vin2Watcher()
{
    std::string value = "";
    Property*mp = mPropertyManager->findProperty("mc_mcu_info_vin2");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateState(mp);
        value = mPropertyManager->getProValue(mp);
        LOG(INFO) << "mc_mcu_info_vin2:"<<value;
        mHal->onPropertyValue(*Create_mcu_info_vin2Req(value),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_mcu_info_vin2Req(std::string value)
{
    memcpy(mVehicleInfoVin+7, value.c_str(), value.length());
    const char* mInfoVin = mVehicleInfoVin;
    auto req = mValueObjectPool->obtainString(mInfoVin);
    req->prop = toInt(VehicleProperty::INFO_VIN);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::mcu_info_vin3Watcher()
{
    std::string value = "";
    Property*mp = mPropertyManager->findProperty("mc_mcu_info_vin3");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateState(mp);
        value = mPropertyManager->getProValue(mp);
        LOG(INFO) << "mc_mcu_info_vin3:"<<value;
        mHal->onPropertyValue(*Create_mcu_info_vin3Req(value),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_mcu_info_vin3Req(std::string value)
{
    memcpy(mVehicleInfoVin+14, value.c_str(), value.length() -5);
    const char* mInfoVin = mVehicleInfoVin;
    auto req = mValueObjectPool->obtainString(mInfoVin);
    req->prop = toInt(VehicleProperty::INFO_VIN);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::mcu_info_vinWatcher()
{
    std::string value = "";
    ConfigDBC*mp = mPropertyManager->findCProperty("gecko_vin");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        value = mPropertyManager->getCProStrValue(mp);
        LOG(INFO) << "mc_mcu_info_vin:"<<value;
        android::base::SetProperty("gecko.vin", value);    //dumpprop
//        mHal->onPropertyValue(*Create_mcu_info_vinReq(value),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_mcu_info_vinReq(std::string value)
{
    auto req = mValueObjectPool->obtainString(value.c_str());
    req->prop = toInt(VehicleProperty::INFO_VIN);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::rangeModeSet()
{
    int32_t value = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("sc_rema_range_display_mode");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        value = std::stoi(mPropertyManager->getCProStrValue(mp).c_str());
        mHal->onPropertyValue(*Creat_range_modeReq(value),true);
    }
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Creat_range_modeReq(int32_t value)
{
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_REMA_RANGE_DISPLAY_MODE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::gecko_headlighthSet()
{
    int32_t headlighth = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("gecko_headlighth");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        headlighth = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
        LOG(INFO) << "dxy-- gecko_headlighthSet value = "<< headlighth;
        mHal->onPropertyValue(*Creat_gecko_headlighthReq(headlighth),true);
    }
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Creat_gecko_headlighthReq(int32_t value)
{
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_HIGH_BEAM_LIGHTS_LEVEL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::mcu_info_sn1Watcher()
{
    std::string value = "";
    Property*mp = mPropertyManager->findProperty("mc_mcu_info_sn1");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateState(mp);
        value = mPropertyManager->getProValue(mp);
        LOG(INFO) << "mc_mcu_info_sn1:"<<value;
        mHal->onPropertyValue(*Create_mcu_info_sn1Req(value),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_mcu_info_sn1Req(std::string value)
{
    memcpy(mVehicleInfoSn, value.c_str(), value.length());
    int size = sizeof(mVehicleInfoSn) / sizeof(char);
    std::string str(mVehicleInfoSn, size);
    android::base::SetProperty("gecko.serial.number", str);
    const char* mInfoSn = mVehicleInfoSn;
    auto req = mValueObjectPool->obtainString(mInfoSn);
    req->prop = toInt(VehicleProperty::GECKO_VEHICLE_INFO_SN);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::mcu_info_sn2Watcher()
{
    std::string value = "";
    Property*mp = mPropertyManager->findProperty("mc_mcu_info_sn2");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateState(mp);
        value = mPropertyManager->getProValue(mp);
        LOG(INFO) << "mc_mcu_info_sn2:"<<value;
        mHal->onPropertyValue(*Create_mcu_info_sn2Req(value),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_mcu_info_sn2Req(std::string value)
{
    memcpy(mVehicleInfoSn+7, value.c_str(), value.length());
    int size = sizeof(mVehicleInfoSn) / sizeof(char);
    std::string str(mVehicleInfoSn, size);
    android::base::SetProperty("gecko.serial.number", str);
    const char* mInfoSn = mVehicleInfoSn;
    auto req = mValueObjectPool->obtainString(mInfoSn);
    req->prop = toInt(VehicleProperty::GECKO_VEHICLE_INFO_SN);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::mcu_info_sn3Watcher()
{
    std::string value = "";
    Property*mp = mPropertyManager->findProperty("mc_mcu_info_sn3");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateState(mp);
        value = mPropertyManager->getProValue(mp);
        LOG(INFO) << "mc_mcu_info_sn3:"<<value;
        mHal->onPropertyValue(*Create_mcu_info_sn3Req(value),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_mcu_info_sn3Req(std::string value)
{
    memcpy(mVehicleInfoSn+14, value.c_str(), value.length() - 2);
    int size = sizeof(mVehicleInfoSn) / sizeof(char);
    std::string str(mVehicleInfoSn, size);
    android::base::SetProperty("gecko.serial.number", str);
    const char* mInfoSn = mVehicleInfoSn;
    auto req = mValueObjectPool->obtainString(mInfoSn);
    req->prop = toInt(VehicleProperty::GECKO_VEHICLE_INFO_SN);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::mcu_info_versionWatcher()
{
    std::string value = "";
    ConfigDBC*mp = mPropertyManager->findCProperty("gecko_mcu_version");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        value = mPropertyManager->getCProStrValue(mp);
        LOG(INFO) << "mc_mcu_info_version:"<<value;
        android::base::SetProperty("gecko.mcu.version", value);
        //mHal->onPropertyValue(*Create_mcu_info_versionReq(value),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_mcu_info_versionReq(std::string value)
{
    memcpy(mVehicleInfoVersion, value.c_str(), value.length());
    int size = sizeof(mVehicleInfoVersion) / sizeof(char);
    std::string str(mVehicleInfoVersion, size);
    android::base::SetProperty("gecko.mcu.version", str);
    const char* mInfoVersion = mVehicleInfoVersion;
    auto req = mValueObjectPool->obtainString(mInfoVersion);
    req->prop = toInt(VehicleProperty::GECKO_VEHICLE_INFO_VERSION);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::mc_travel_rangeWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  float mc_travel_range = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("mc_travel_range");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      mc_travel_range = getActualFloatValue(mPropertyManager->getCProValue(mp), 0.1, 0);
      LOG(INFO) << "mc_travel_range:"<< mc_travel_range;
      mHal->onPropertyValue(*Create_mc_travel_rangeReq(mc_travel_range),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_mc_travel_rangeReq(float mc_travel_range) {
    auto req = mValueObjectPool->obtainFloat(mc_travel_range);
    req->prop = toInt(VehicleProperty::GECKO_MCU_TRAVEL_RANGE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::mc_travel_timeWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t mc_travel_time = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("mc_travel_time");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      mc_travel_time = mPropertyManager->getCProValue(mp);
      LOG(INFO) << "mc_travel_time:"<< mc_travel_time;
      mHal->onPropertyValue(*Create_mc_travel_timeReq(mc_travel_time),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_mc_travel_timeReq(int32_t mc_travel_time) {
    auto req = mValueObjectPool->obtainInt32(mc_travel_time);
    req->prop = toInt(VehicleProperty::GECKO_MCU_TRAVEL_TIME);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::mc_average_energy_consumptionWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  float mc_average_energy_consumption = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("mc_average_energy_consumption");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      mc_average_energy_consumption = getActualFloatValue(static_cast<int32_t>(mPropertyManager->getCProValue(mp)),0.1,0);
      mHal->onPropertyValue(*Create_mc_average_energy_consumptionReq(mc_average_energy_consumption),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_mc_average_energy_consumptionReq(float mc_average_energy_consumption) {
    auto req = mValueObjectPool->obtainFloat(mc_average_energy_consumption);
    req->prop = toInt(VehicleProperty::GECKO_MCU_AVERAGE_ENERGY_CONSUMPTION);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_wipr_intl_time_set_fbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_wipr_intl_time_set_fb = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_wipr_intl_time_set_fb");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_wipr_intl_time_set_fb = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_bcm_wipr_intl_time_set_fbReq(bc_bcm_wipr_intl_time_set_fb),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_wipr_intl_time_set_fbReq(int32_t bc_bcm_wipr_intl_time_set_fb) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_wipr_intl_time_set_fb);
    req->prop = toInt(VehicleProperty::GECKO_WIPER_INTERVAL_TIME);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_flwr_me_hm_ctrl_fbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_flwr_me_hm_ctrl_fb = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_flwr_me_hm_ctrl_fb");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_flwr_me_hm_ctrl_fb = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_bcm_flwr_me_hm_ctrl_fbReq(bc_bcm_flwr_me_hm_ctrl_fb),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_flwr_me_hm_ctrl_fbReq(int32_t bc_bcm_flwr_me_hm_ctrl_fb) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_flwr_me_hm_ctrl_fb);
    req->prop = toInt(VehicleProperty::GECKO_ACCOMPANY_BACK_HOME_DURATION);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_illmnd_unlock_sts_fbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_illmnd_unlock_sts_fb = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_illmnd_unlock_sts_fb");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_illmnd_unlock_sts_fb = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_bcm_illmnd_unlock_sts_fbReq(bc_bcm_illmnd_unlock_sts_fb),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_illmnd_unlock_sts_fbReq(int32_t bc_bcm_illmnd_unlock_sts_fb) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_illmnd_unlock_sts_fb);
    req->prop = toInt(VehicleProperty::GECKO_WELCOME_UNLOCK_STATUS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_illmnd_lock_sts_fbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_illmnd_lock_sts_fb = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_illmnd_lock_sts_fb");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_illmnd_lock_sts_fb = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_bcm_illmnd_lock_sts_fbReq(bc_bcm_illmnd_lock_sts_fb),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_illmnd_lock_sts_fbReq(int32_t bc_bcm_illmnd_lock_sts_fb) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_illmnd_lock_sts_fb);
    req->prop = toInt(VehicleProperty::GECKO_ILLMND_LOCK_STATUS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_lock_horn_on_st_fbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_lock_horn_on_st_fb = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_lock_horn_on_st_fb");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_lock_horn_on_st_fb = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_bcm_lock_horn_on_st_fbReq(bc_bcm_lock_horn_on_st_fb),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_lock_horn_on_st_fbReq(int32_t bc_bcm_lock_horn_on_st_fb) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_lock_horn_on_st_fb);
    req->prop = toInt(VehicleProperty::GECKO_LOCK_HORN_ENABLE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_esc_disableWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_esc_esc_disable = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_esc_disable");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_esc_esc_disable = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_esc_esc_disableReq(ec_esc_esc_disable),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_esc_disableReq(int32_t ec_esc_esc_disable) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_esc_disable);
    req->prop = toInt(VehicleProperty::GECKO_VEHICLE_STABILITY_ON);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ehb_avh_appld_stWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_ehb_avh_appld_st = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ehb_avh_appld_st");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ehb_avh_appld_st = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_ehb_avh_appld_stReq(ec_ehb_avh_appld_st),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ehb_avh_appld_stReq(int32_t ec_ehb_avh_appld_st) {
    auto req = mValueObjectPool->obtainInt32(ec_ehb_avh_appld_st);
    req->prop = toInt(VehicleProperty::GECKO_AUTO_PARKING_ON);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ehb_epb_system_stateWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_ehb_epb_system_state = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ehb_epb_system_state");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ehb_epb_system_state = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_ehb_epb_system_stateReq(ec_ehb_epb_system_state),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ehb_epb_system_stateReq(int32_t ec_ehb_epb_system_state) {
    auto req = mValueObjectPool->obtainInt32(ec_ehb_epb_system_state);
    req->prop = toInt(VehicleProperty::GECKO_ELECTRONIC_PARKING_MODE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ehb_brk_dis_wip_acWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_ehb_brk_dis_wip_ac = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ehb_brk_dis_wip_ac");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ehb_brk_dis_wip_ac = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_ehb_brk_dis_wip_acReq(ec_ehb_brk_dis_wip_ac),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ehb_brk_dis_wip_acReq(int32_t ec_ehb_brk_dis_wip_ac) {
    auto req = mValueObjectPool->obtainInt32(ec_ehb_brk_dis_wip_ac);
    req->prop = toInt(VehicleProperty::GECKO_BRAKE_DISC_WIPING_ON);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_elec_steer_mode_staWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_elec_steer_mode_sta = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_elec_steer_mode_sta");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_elec_steer_mode_sta = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_elec_steer_mode_staReq(ec_elec_steer_mode_sta),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_elec_steer_mode_staReq(int32_t ec_elec_steer_mode_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_elec_steer_mode_sta);
    req->prop = toInt(VehicleProperty::GECKO_POWER_STEERING_MODE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_veh_act_recuperate_pwrWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_veh_act_recuperate_pwr = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_veh_act_recuperate_pwr");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_veh_act_recuperate_pwr = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_veh_act_recuperate_pwrReq(bc_veh_act_recuperate_pwr),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_veh_act_recuperate_pwrReq(int32_t bc_veh_act_recuperate_pwr) {
    auto req = mValueObjectPool->obtainInt32(bc_veh_act_recuperate_pwr);
    req->prop = toInt(VehicleProperty::GECKO_CCM_ENERGY_RECOV_LEVEL_CMD);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vehicle_driving_pwrWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vehicle_driving_pwr = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vehicle_driving_pwr");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vehicle_driving_pwr = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_vehicle_driving_pwrReq(ec_vehicle_driving_pwr),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vehicle_driving_pwrReq(int32_t ec_vehicle_driving_pwr) {
    auto req = mValueObjectPool->obtainInt32(ec_vehicle_driving_pwr);
    req->prop = toInt(VehicleProperty::GECKO_DRIVING_POWER_ST);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_srs_passenger_airbag_sta_rsvrWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_srs_passenger_airbag_sta_rsvr = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_srs_passenger_airbag_sta_rsvr");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_srs_passenger_airbag_sta_rsvr = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_srs_passenger_airbag_sta_rsvrReq(ec_srs_passenger_airbag_sta_rsvr),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_srs_passenger_airbag_sta_rsvrReq(int32_t ec_srs_passenger_airbag_sta_rsvr) {
    auto req = mValueObjectPool->obtainInt32(ec_srs_passenger_airbag_sta_rsvr);
    req->prop = toInt(VehicleProperty::GECKO_SRS_PASSENGER_AIRBAG_STATUS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_front_fog_light_statusWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_front_fog_light_status = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_front_fog_light_status");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_front_fog_light_status = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_bc_bcm_front_fog_light_statusReq(bc_bcm_front_fog_light_status),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_front_fog_light_statusReq(int32_t bc_bcm_front_fog_light_status) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_front_fog_light_status);
    req->prop = toInt(VehicleProperty::GECKO_FRONT_FOG_LIGHT_STATUS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_key_lo_batt_lvl_warnWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_key_lo_batt_lvl_warn = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_key_lo_batt_lvl_warn");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_key_lo_batt_lvl_warn = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_bc_bcm_key_lo_batt_lvl_warnReq(bc_bcm_key_lo_batt_lvl_warn),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_key_lo_batt_lvl_warnReq(int32_t bc_bcm_key_lo_batt_lvl_warn) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_key_lo_batt_lvl_warn);
    req->prop = toInt(VehicleProperty::GECKO_KEY_LOW_BATT_LVL_WARN);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_warn_no_key_foundWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_warn_no_key_found = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_warn_no_key_found");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_warn_no_key_found = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_bc_bcm_warn_no_key_foundReq(bc_bcm_warn_no_key_found),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_warn_no_key_foundReq(int32_t bc_bcm_warn_no_key_found) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_warn_no_key_found);
    req->prop = toInt(VehicleProperty::GECKO_WARN_NO_KEY_FOUND);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_auto_lamp_statusWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_auto_lamp_status = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_auto_lamp_status");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_auto_lamp_status = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_bc_bcm_auto_lamp_statusReq(bc_bcm_auto_lamp_status),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_auto_lamp_statusReq(int32_t bc_bcm_auto_lamp_status) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_auto_lamp_status);
    req->prop = toInt(VehicleProperty::GECKO_AUTO_LAMP_STATUS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_indication_shiftto_neutralWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_indication_shiftto_neutral = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_indication_shiftto_neutral");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_indication_shiftto_neutral = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_bc_bcm_indication_shiftto_neutralReq(bc_bcm_indication_shiftto_neutral),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_indication_shiftto_neutralReq(int32_t bc_bcm_indication_shiftto_neutral) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_indication_shiftto_neutral);
    req->prop = toInt(VehicleProperty::GECKO_INDICATION_SHIFTTO_NEUTRAL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_12_v_bat_low_vol_staWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_12_v_bat_low_vol_sta = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_12_v_bat_low_vol_sta");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_12_v_bat_low_vol_sta = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_vcu_12_v_bat_low_vol_staReq(ec_vcu_12_v_bat_low_vol_sta),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_12_v_bat_low_vol_staReq(int32_t ec_vcu_12_v_bat_low_vol_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_12_v_bat_low_vol_sta);
    req->prop = toInt(VehicleProperty::GECKO_12V_BAT_LOW_VOL_STA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_sibs_kl30_voltageWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_sibs_kl30_voltage = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_sibs_kl30_voltage");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_sibs_kl30_voltage = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_vcu_sibs_kl30_voltageReq(ec_vcu_sibs_kl30_voltage),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_sibs_kl30_voltageReq(int32_t ec_vcu_sibs_kl30_voltage) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_sibs_kl30_voltage);
    req->prop = toInt(VehicleProperty::GECKO_SIBS_KL30_VOLTAGE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_srs_airbag_warning_lamp_stsWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_srs_airbag_warning_lamp_sts = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_srs_airbag_warning_lamp_sts");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_srs_airbag_warning_lamp_sts = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_srs_airbag_warning_lamp_stsReq(ec_srs_airbag_warning_lamp_sts),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_srs_airbag_warning_lamp_stsReq(int32_t ec_srs_airbag_warning_lamp_sts) {
    auto req = mValueObjectPool->obtainInt32(ec_srs_airbag_warning_lamp_sts);
    req->prop = toInt(VehicleProperty::GECKO_SRS_AIRBAG_WARNING_LAMP_STATUS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_obc_inlet_connect_staWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_ipu_obc_inlet_connect_sta = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_obc_inlet_connect_sta");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ipu_obc_inlet_connect_sta = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_ipu_obc_inlet_connect_staReq(ec_ipu_obc_inlet_connect_sta),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_obc_inlet_connect_staReq(int32_t ec_ipu_obc_inlet_connect_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_obc_inlet_connect_sta);
    req->prop = toInt(VehicleProperty::GECKO_IPU_OBC_INLET_CONNECT_STA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_dcs_inlet_connect_staWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bms_dcs_inlet_connect_sta = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_dcs_inlet_connect_sta");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_dcs_inlet_connect_sta = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_bms_dcs_inlet_connect_staReq(ec_bms_dcs_inlet_connect_sta),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_dcs_inlet_connect_staReq(int32_t ec_bms_dcs_inlet_connect_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_dcs_inlet_connect_sta);
    req->prop = toInt(VehicleProperty::GECKO_BMS_DCS_INLET_CONNECT_STA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}


void GarageModeServerSideHandlerImpl::ec_bms_pwr_train_connect_staWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bms_pwr_train_connect_sta = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_pwr_train_connect_sta");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_pwr_train_connect_sta = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_bms_pwr_train_connect_staReq(ec_bms_pwr_train_connect_sta),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_pwr_train_connect_staReq(int32_t ec_bms_pwr_train_connect_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_pwr_train_connect_sta);
    req->prop = toInt(VehicleProperty::GECKO_BMS_PWR_TRAIN_CONNECT_STA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ehb_brake_liquid_level_warnWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_ehb_brake_liquid_level_warn = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ehb_brake_liquid_level_warn");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ehb_brake_liquid_level_warn = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_ehb_brake_liquid_level_warnReq(ec_ehb_brake_liquid_level_warn),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ehb_brake_liquid_level_warnReq(int32_t ec_ehb_brake_liquid_level_warn) {
    auto req = mValueObjectPool->obtainInt32(ec_ehb_brake_liquid_level_warn);
    req->prop = toInt(VehicleProperty::GECKO_EHB_BRAKE_LIQUID_LEVEL_WARN);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_ebd_failedWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_esc_ebd_failed = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_ebd_failed");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_esc_ebd_failed = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_esc_ebd_failedReq(ec_esc_ebd_failed),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_ebd_failedReq(int32_t ec_esc_ebd_failed) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_ebd_failed);
    req->prop = toInt(VehicleProperty::GECKO_ESC_EBD_FAILED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_vhcl_p_gear_errorWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_vhcl_p_gear_error = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_vhcl_p_gear_error");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_vhcl_p_gear_error = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_vcu_vhcl_p_gear_errorReq(ec_vcu_vhcl_p_gear_error),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_vhcl_p_gear_errorReq(int32_t ec_vcu_vhcl_p_gear_error) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_vhcl_p_gear_error);
    req->prop = toInt(VehicleProperty::GECKO_VCU_VHCL_P_GEAR_ERROR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_motor_high_temp_wrningWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_motor_high_temp_wrning = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_motor_high_temp_wrning");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_motor_high_temp_wrning = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_vcu_motor_high_temp_wrningReq(ec_vcu_motor_high_temp_wrning),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_motor_high_temp_wrningReq(int32_t ec_vcu_motor_high_temp_wrning) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_motor_high_temp_wrning);
    req->prop = toInt(VehicleProperty::GECKO_VCU_MOTOR_HIGH_TEMP_WRNING);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_mcu_high_temp_wrningWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_mcu_high_temp_wrning = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_mcu_high_temp_wrning");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_mcu_high_temp_wrning = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_vcu_mcu_high_temp_wrningReq(ec_vcu_mcu_high_temp_wrning),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_mcu_high_temp_wrningReq(int32_t ec_vcu_mcu_high_temp_wrning) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_mcu_high_temp_wrning);
    req->prop = toInt(VehicleProperty::GECKO_VCU_MCU_HIGH_TEMP_WRNING);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_pcu_fail_staWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_pcu_fail_sta = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_pcu_fail_sta");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_pcu_fail_sta = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_vcu_pcu_fail_staReq(ec_vcu_pcu_fail_sta),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_pcu_fail_staReq(int32_t ec_vcu_pcu_fail_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_pcu_fail_sta);
    req->prop = toInt(VehicleProperty::GECKO_VCU_PCU_FAIL_STA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ehb_epb_warn_lamp_staWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_ehb_epb_warn_lamp_sta = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ehb_epb_warn_lamp_sta");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ehb_epb_warn_lamp_sta = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_ehb_epb_warn_lamp_staReq(ec_ehb_epb_warn_lamp_sta),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ehb_epb_warn_lamp_staReq(int32_t ec_ehb_epb_warn_lamp_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_ehb_epb_warn_lamp_sta);
    req->prop = toInt(VehicleProperty::GECKO_EHB_EPB_WARN_LAMP_STA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ehb_avh_disp_msgWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_ehb_avh_disp_msg = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ehb_avh_disp_msg");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ehb_avh_disp_msg = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_ehb_avh_disp_msgReq(ec_ehb_avh_disp_msg),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ehb_avh_disp_msgReq(int32_t ec_ehb_avh_disp_msg) {
    auto req = mValueObjectPool->obtainInt32(ec_ehb_avh_disp_msg);
    req->prop = toInt(VehicleProperty::GECKO_EHB_AVH_DISP_MSG);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ehb_epb_display_msg_idWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_ehb_epb_display_msg_id = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ehb_epb_display_msg_id");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ehb_epb_display_msg_id = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_ehb_epb_display_msg_idReq(ec_ehb_epb_display_msg_id),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ehb_epb_display_msg_idReq(int32_t ec_ehb_epb_display_msg_id) {
    auto req = mValueObjectPool->obtainInt32(ec_ehb_epb_display_msg_id);
    req->prop = toInt(VehicleProperty::GECKO_EHB_EPB_DISPLAY_MSGID);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ehb_avh_lamp_reqWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_ehb_avh_lamp_req = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ehb_avh_lamp_req");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ehb_avh_lamp_req = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_ehb_avh_lamp_reqReq(ec_ehb_avh_lamp_req),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ehb_avh_lamp_reqReq(int32_t ec_ehb_avh_lamp_req) {
    auto req = mValueObjectPool->obtainInt32(ec_ehb_avh_lamp_req);
    req->prop = toInt(VehicleProperty::GECKO_EHB_AVH_LAMP_REQ);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_esp_active_staWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_esc_esp_active_sta = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_esp_active_sta");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_esc_esp_active_sta = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_esc_esp_active_staReq(ec_esc_esp_active_sta),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_esp_active_staReq(int32_t ec_esc_esp_active_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_esp_active_sta);
    req->prop = toInt(VehicleProperty::GECKO_ESC_ESP_ACTIVE_STA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_tcs_active_staWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_esc_tcs_active_sta = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_tcs_active_sta");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_esc_tcs_active_sta = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_esc_tcs_active_staReq(ec_esc_tcs_active_sta),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_tcs_active_staReq(int32_t ec_esc_tcs_active_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_tcs_active_sta);
    req->prop = toInt(VehicleProperty::GECKO_ESC_TCS_ACTIVE_STA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_es_cor_tcs_failedWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_esc_es_cor_tcs_failed = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_es_cor_tcs_failed");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_esc_es_cor_tcs_failed = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_esc_es_cor_tcs_failedReq(ec_esc_es_cor_tcs_failed),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_es_cor_tcs_failedReq(int32_t ec_esc_es_cor_tcs_failed) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_es_cor_tcs_failed);
    req->prop = toInt(VehicleProperty::GECKO_ESC_ES_COR_TCS_FAILED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_hdc_statusWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_hdc_status = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_hdc_status");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_hdc_status = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_vcu_hdc_statusReq(ec_vcu_hdc_status),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_hdc_statusReq(int32_t ec_vcu_hdc_status) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_hdc_status);
    req->prop = toInt(VehicleProperty::GECKO_VCU_HDC_STATUS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_motor_actual_power_typeWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_motor_actual_power_type = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_motor_actual_power_type");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_motor_actual_power_type = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_vcu_motor_actual_power_typeReq(ec_vcu_motor_actual_power_type),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_motor_actual_power_typeReq(int32_t ec_vcu_motor_actual_power_type) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_motor_actual_power_type);
    req->prop = toInt(VehicleProperty::GECKO_VCU_MOTOR_ACTUAL_POWER_TYPE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_motor_actual_powerWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_motor_actual_power = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_motor_actual_power");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_motor_actual_power = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_vcu_motor_actual_powerReq(ec_vcu_motor_actual_power),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_motor_actual_powerReq(int32_t ec_vcu_motor_actual_power) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_motor_actual_power);
    req->prop = toInt(VehicleProperty::GECKO_VCU_MOTOR_ACTUAL_POWER);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_reserve_powerWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_reserve_power = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_reserve_power");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_reserve_power = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_vcu_reserve_powerReq(ec_vcu_reserve_power),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_reserve_powerReq(int32_t ec_vcu_reserve_power) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_reserve_power);
    req->prop = toInt(VehicleProperty::GECKO_VCU_RESERVE_POWER);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_dcs_act_oprt_modeWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bms_dcs_act_oprt_mode = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_dcs_act_oprt_mode");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_dcs_act_oprt_mode = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_bms_dcs_act_oprt_modeReq(ec_bms_dcs_act_oprt_mode),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_dcs_act_oprt_modeReq(int32_t ec_bms_dcs_act_oprt_mode) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_dcs_act_oprt_mode);
    req->prop = toInt(VehicleProperty::GECKO_BMS_DCS_ACT_OPRT_MODE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_obc_actl_oprt_modeWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_ipu_obc_actl_oprt_mode = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_obc_actl_oprt_mode");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ipu_obc_actl_oprt_mode = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_ipu_obc_actl_oprt_modeReq(ec_ipu_obc_actl_oprt_mode),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_obc_actl_oprt_modeReq(int32_t ec_ipu_obc_actl_oprt_mode) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_obc_actl_oprt_mode);
    req->prop = toInt(VehicleProperty::GECKO_IPU_OBC_ACTL_OPRT_MODE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_obc_oprt_cmd_to_icuWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_obc_oprt_cmd_to_icu = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_obc_oprt_cmd_to_icu");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_obc_oprt_cmd_to_icu = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_vcu_obc_oprt_cmd_to_icuReq(ec_vcu_obc_oprt_cmd_to_icu),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_obc_oprt_cmd_to_icuReq(int32_t ec_vcu_obc_oprt_cmd_to_icu) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_obc_oprt_cmd_to_icu);
    req->prop = toInt(VehicleProperty::GECKO_VCU_OBC_OPRT_CMD_TO_ICU);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_srs_pass_seat_occupant_sensor_stsWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_srs_pass_seat_occupant_sensor_sts = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_srs_pass_seat_occupant_sensor_sts");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_srs_pass_seat_occupant_sensor_sts = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_srs_pass_seat_occupant_sensor_stsReq(ec_srs_pass_seat_occupant_sensor_sts),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_srs_pass_seat_occupant_sensor_stsReq(int32_t ec_srs_pass_seat_occupant_sensor_sts) {
    auto req = mValueObjectPool->obtainInt32(ec_srs_pass_seat_occupant_sensor_sts);
    req->prop = toInt(VehicleProperty::GECKO_SRS_PASS_SEAT_OCCUPANT_SENSOR_STS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_srs_pass_seatbelt_buckle_validWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_srs_pass_seatbelt_buckle_valid = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_srs_pass_seatbelt_buckle_valid");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_srs_pass_seatbelt_buckle_valid = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_srs_pass_seatbelt_buckle_validReq(ec_srs_pass_seatbelt_buckle_valid),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_srs_pass_seatbelt_buckle_validReq(int32_t ec_srs_pass_seatbelt_buckle_valid) {
    auto req = mValueObjectPool->obtainInt32(ec_srs_pass_seatbelt_buckle_valid);
    req->prop = toInt(VehicleProperty::GECKO_SRS_PASS_SEATBELT_BUCKLE_VALID);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_srs_pass_seatbelt_bucklestatusWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_srs_pass_seatbelt_bucklestatus = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_srs_pass_seatbelt_bucklestatus");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_srs_pass_seatbelt_bucklestatus = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_ec_srs_pass_seatbelt_bucklestatusReq(ec_srs_pass_seatbelt_bucklestatus),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_srs_pass_seatbelt_bucklestatusReq(int32_t ec_srs_pass_seatbelt_bucklestatus) {
    auto req = mValueObjectPool->obtainInt32(ec_srs_pass_seatbelt_bucklestatus);
    req->prop = toInt(VehicleProperty::GECKO_SRS_PASS_SEATBELT_BUCKLE_STATUS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_indication_key_closerWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_indication_key_closer = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_indication_key_closer");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_indication_key_closer = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_bc_bcm_indication_key_closerReq(bc_bcm_indication_key_closer),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_indication_key_closerReq(int32_t bc_bcm_indication_key_closer) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_indication_key_closer);
    req->prop = toInt(VehicleProperty::GECKO_BCM_INDICATION_KEY_CLOSER);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_warn_key_out_reminderWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_warn_key_out_reminder = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_warn_key_out_reminder");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_warn_key_out_reminder = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_bc_bcm_warn_key_out_reminderReq(bc_bcm_warn_key_out_reminder),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_warn_key_out_reminderReq(int32_t bc_bcm_warn_key_out_reminder) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_warn_key_out_reminder);
    req->prop = toInt(VehicleProperty::GECKO_BCM_WARN_KEY_OUT_REMINDER);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_light_intensityWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_light_intensity = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_light_intensity");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_light_intensity = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_bc_bcm_light_intensityReq(bc_bcm_light_intensity),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_light_intensityReq(int32_t bc_bcm_light_intensity) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_light_intensity);
    req->prop = toInt(VehicleProperty::GECKO_BCM_LIGHT_INTENSITY);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_ac_envir_temp_vWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_ac_envir_temp_v = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ac_envir_temp_v");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ac_envir_temp_v = static_cast<int32_t>(mPropertyManager->getCProValue(mp));
      mHal->onPropertyValue(*Create_bc_ac_envir_temp_vReq(bc_ac_envir_temp_v),true);
  }
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ac_envir_temp_vReq(int32_t bc_ac_envir_temp_v) {
    auto req = mValueObjectPool->obtainInt32(bc_ac_envir_temp_v);
    req->prop = toInt(VehicleProperty::GECKO_AC_ENVIR_TEMPV);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_ac_envir_tempWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  float bc_ac_envir_temp = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ac_envir_temp");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ac_envir_temp = getActualFloatValue(mPropertyManager->getCProValue(mp), 0.5, -40);
      mHal->onPropertyValue(*Create_bc_ac_envir_tempReq(bc_ac_envir_temp),true);
  }
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ac_envir_tempReq(float bc_ac_envir_temp) {
    auto req = mValueObjectPool->obtainFloat(bc_ac_envir_temp);
    req->prop = toInt(VehicleProperty::GECKO_AC_ENVIR_TEMP);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::config_query_sim_cardWatcher()
{
  std::this_thread::sleep_for(std::chrono::milliseconds(8000));
  int32_t value = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("config_query_sim_card");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      value = mPropertyManager->getCProValue(mp);
      LOG(INFO) << "config_query_sim_card:"<< value;
      mHal->onPropertyValue(*Create_config_queryReq(1),true);
  }
}

void GarageModeServerSideHandlerImpl::config_query_4g_strengthWatcher()
{
  std::this_thread::sleep_for(std::chrono::milliseconds(8000));
  int32_t value = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("config_query_4g_strength");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      value = mPropertyManager->getCProValue(mp);
      LOG(INFO) << "config_query_4g_strength:"<< value;
      mHal->onPropertyValue(*Create_config_queryReq(3),true);
  }
}

void GarageModeServerSideHandlerImpl::config_query_wifi_strengthWatcher()
{
  std::this_thread::sleep_for(std::chrono::milliseconds(8000));
  int32_t value = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("config_query_wifi_strength");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      value = mPropertyManager->getCProValue(mp);
      LOG(INFO) << "config_query_wifi_strength:"<< value;
      mHal->onPropertyValue(*Create_config_queryReq(4),true);
  }
}

void GarageModeServerSideHandlerImpl::config_query_wifi_statusWatcher()
{
  std::this_thread::sleep_for(std::chrono::milliseconds(8000));
  int32_t value = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("config_query_wifi_status");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      value = mPropertyManager->getCProValue(mp);
      LOG(INFO) << "config_query_wifi_status:"<< value;
      mHal->onPropertyValue(*Create_config_queryReq(5),true);
  }
}

void GarageModeServerSideHandlerImpl::config_query_gps_lonWatcher()
{
  std::this_thread::sleep_for(std::chrono::milliseconds(8000));
  int32_t value = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("config_query_gps_lon");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      value = mPropertyManager->getCProValue(mp);
      LOG(INFO) << "config_query_gps_lon:"<< value;
      mHal->onPropertyValue(*Create_config_queryReq(6),true);
  }
}

void GarageModeServerSideHandlerImpl::config_query_gps_latWatcher()
{
  std::this_thread::sleep_for(std::chrono::milliseconds(8000));
  int32_t value = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("config_query_gps_lat");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      value = mPropertyManager->getCProValue(mp);
      LOG(INFO) << "config_query_gps_lat:"<< value;
      mHal->onPropertyValue(*Create_config_queryReq(7),true);
  }
}


recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_config_queryReq(int32_t value)
{
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_CONFIG_QUERY);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::vcu_chraging_mode_sp_reqWatcher()
{
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t value = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("vcu_chraging_mode_sp_req");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      value = mPropertyManager->getCProValue(mp);
      LOG(INFO) << "vcu_chraging_mode_sp_req:"<< value;
      mHal->onPropertyValue(*Create_vcu_chraging_mode_sp_reqReq(value),true);

      mPropertyManager->updateCPropertyValue("ec_vcu_chraging_mode_sp", value - 1);
  }
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_vcu_chraging_mode_sp_reqReq(int32_t value)
{
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_VCU_CHRAGING_MODE_SP_REQ);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_rmi_active_staWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_esc_rmi_active_sta = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_rmi_active_sta");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_esc_rmi_active_sta = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_esc_rmi_active_staReq(ec_esc_rmi_active_sta),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_rmi_active_staReq(int32_t ec_esc_rmi_active_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_rmi_active_sta);
    req->prop = toInt(VehicleProperty::GECKO_ESC_RMIACTIVESTA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_slope_percent_vWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_esc_slope_percent_v = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_slope_percent_v");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_esc_slope_percent_v = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_esc_slope_percent_vReq(ec_esc_slope_percent_v),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_slope_percent_vReq(int32_t ec_esc_slope_percent_v) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_slope_percent_v);
    req->prop = toInt(VehicleProperty::GECKO_ESC_SLOPEPERCENTV);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_slope_percentWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_esc_slope_percent = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_slope_percent");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_esc_slope_percent = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_esc_slope_percentReq(ec_esc_slope_percent),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_slope_percentReq(int32_t ec_esc_slope_percent) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_slope_percent);
    req->prop = toInt(VehicleProperty::GECKO_ESC_SLOPEPERCENT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ehb_epb_flt_stsWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_ehb_epb_flt_sts = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ehb_epb_flt_sts");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ehb_epb_flt_sts = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_ehb_epb_flt_stsReq(ec_ehb_epb_flt_sts),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ehb_epb_flt_stsReq(int32_t ec_ehb_epb_flt_sts) {
    auto req = mValueObjectPool->obtainInt32(ec_ehb_epb_flt_sts);
    req->prop = toInt(VehicleProperty::GECKO_EHB_EPB_FLTSTS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ehb_epb_switch_stsWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_ehb_epb_switch_sts = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ehb_epb_switch_sts");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ehb_epb_switch_sts = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_ehb_epb_switch_stsReq(ec_ehb_epb_switch_sts),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ehb_epb_switch_stsReq(int32_t ec_ehb_epb_switch_sts) {
    auto req = mValueObjectPool->obtainInt32(ec_ehb_epb_switch_sts);
    req->prop = toInt(VehicleProperty::GECKO_EHB_EPB_SWITCHSTS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ehb_failure_stsWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_ehb_failure_sts = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ehb_failure_sts");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ehb_failure_sts = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_ehb_failure_stsReq(ec_ehb_failure_sts),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ehb_failure_stsReq(int32_t ec_ehb_failure_sts) {
    auto req = mValueObjectPool->obtainInt32(ec_ehb_failure_sts);
    req->prop = toInt(VehicleProperty::GECKO_EHB_FAILURESTS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_vcu_vhcl_actl_gear_pos_vWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_vhcl_actl_gear_pos_v = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_vhcl_actl_gear_pos_v");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_vhcl_actl_gear_pos_v = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_vcu_vhcl_actl_gear_pos_vReq(ec_vcu_vhcl_actl_gear_pos_v),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_vhcl_actl_gear_pos_vReq(int32_t ec_vcu_vhcl_actl_gear_pos_v) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_vhcl_actl_gear_pos_v);
    req->prop = toInt(VehicleProperty::GECKO_VCU_VHCLACTLGEARPOSV);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bcm_sys_pwr_mode_vWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bcm_sys_pwr_mode_v = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bcm_sys_pwr_mode_v");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bcm_sys_pwr_mode_v = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_bcm_sys_pwr_mode_vReq(ec_bcm_sys_pwr_mode_v),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bcm_sys_pwr_mode_vReq(int32_t ec_bcm_sys_pwr_mode_v) {
    auto req = mValueObjectPool->obtainInt32(ec_bcm_sys_pwr_mode_v);
    req->prop = toInt(VehicleProperty::GECKO_BCM_SYSPWRMODEV);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bcm_sys_pwr_modeWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bcm_sys_pwr_mode = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bcm_sys_pwr_mode");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bcm_sys_pwr_mode = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_bcm_sys_pwr_modeReq(ec_bcm_sys_pwr_mode),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bcm_sys_pwr_modeReq(int32_t ec_bcm_sys_pwr_mode) {
    auto req = mValueObjectPool->obtainInt32(ec_bcm_sys_pwr_mode);
    req->prop = toInt(VehicleProperty::GECKO_BCM_SYSPWRMODE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bcm_sys_power_stsWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bcm_sys_power_sts = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bcm_sys_power_sts");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bcm_sys_power_sts = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_bcm_sys_power_stsReq(ec_bcm_sys_power_sts),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bcm_sys_power_stsReq(int32_t ec_bcm_sys_power_sts) {
    auto req = mValueObjectPool->obtainInt32(ec_bcm_sys_power_sts);
    req->prop = toInt(VehicleProperty::GECKO_BCM_SYSPOWERSTS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bcm_central_lock_stsWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bcm_central_lock_sts = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bcm_central_lock_sts");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bcm_central_lock_sts = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_bcm_central_lock_stsReq(ec_bcm_central_lock_sts),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bcm_central_lock_stsReq(int32_t ec_bcm_central_lock_sts) {
    auto req = mValueObjectPool->obtainInt32(ec_bcm_central_lock_sts);
    req->prop = toInt(VehicleProperty::GECKO_BCM_CENTRALLOCKSTS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bcm_door_lock_sta_flWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bcm_door_lock_sta_fl = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bcm_door_lock_sta_fl");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bcm_door_lock_sta_fl = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_bcm_door_lock_sta_flReq(ec_bcm_door_lock_sta_fl),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bcm_door_lock_sta_flReq(int32_t ec_bcm_door_lock_sta_fl) {
    auto req = mValueObjectPool->obtainInt32(ec_bcm_door_lock_sta_fl);
    req->prop = toInt(VehicleProperty::GECKO_BCM_DOORLOCKSTA_FL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_pwr_recup_intensityWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_pwr_recup_intensity = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_pwr_recup_intensity");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_pwr_recup_intensity = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_vcu_pwr_recup_intensityReq(ec_vcu_pwr_recup_intensity),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_pwr_recup_intensityReq(int32_t ec_vcu_pwr_recup_intensity) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_pwr_recup_intensity);
    req->prop = toInt(VehicleProperty::GECKO_VCU_PWRRECUPINTENSITY);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}


void GarageModeServerSideHandlerImpl::ec_ccu_diag_tester_onlineWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_ccu_diag_tester_online = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccu_diag_tester_online");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ccu_diag_tester_online = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_ccu_diag_tester_onlineReq(ec_ccu_diag_tester_online),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccu_diag_tester_onlineReq(int32_t ec_ccu_diag_tester_online) {
    auto req = mValueObjectPool->obtainInt32(ec_ccu_diag_tester_online);
    req->prop = toInt(VehicleProperty::GECKO_CCU_DIAGTESTERONLINE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bcm_back_ladjval_fbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bcm_back_ladjval_fb = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bcm_back_ladjval_fb");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bcm_back_ladjval_fb = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_bcm_back_ladjval_fbReq(ec_bcm_back_ladjval_fb),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bcm_back_ladjval_fbReq(int32_t ec_bcm_back_ladjval_fb) {
    auto req = mValueObjectPool->obtainInt32(ec_bcm_back_ladjval_fb);
    req->prop = toInt(VehicleProperty::GECKO_BCM_BACKLADJVALLFB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_day_run_li_fault_fbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_day_run_li_fault_fb = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_day_run_li_fault_fb");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_day_run_li_fault_fb = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_bcm_day_run_li_fault_fbReq(bc_bcm_day_run_li_fault_fb),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_day_run_li_fault_fbReq(int32_t bc_bcm_day_run_li_fault_fb) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_day_run_li_fault_fb);
    req->prop = toInt(VehicleProperty::GECKO_BCM_DAYRUNLIFAULTFB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_reverse_li_fault_fbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_reverse_li_fault_fb = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_reverse_li_fault_fb");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_reverse_li_fault_fb = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_bcm_reverse_li_fault_fbReq(bc_bcm_reverse_li_fault_fb),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_reverse_li_fault_fbReq(int32_t bc_bcm_reverse_li_fault_fb) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_reverse_li_fault_fb);
    req->prop = toInt(VehicleProperty::GECKO_BCM_REVERSELIFAULTFB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_brake_li_fault_fbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_brake_li_fault_fb = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_brake_li_fault_fb");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_brake_li_fault_fb = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_bcm_brake_li_fault_fbReq(bc_bcm_brake_li_fault_fb),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_brake_li_fault_fbReq(int32_t bc_bcm_brake_li_fault_fb) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_brake_li_fault_fb);
    req->prop = toInt(VehicleProperty::GECKO_BCM_BRAKELIFAULTFB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_back_li_fault_fbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_back_li_fault_fb = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_back_li_fault_fb");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_back_li_fault_fb = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_bcm_back_li_fault_fbReq(bc_bcm_back_li_fault_fb),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_back_li_fault_fbReq(int32_t bc_bcm_back_li_fault_fb) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_back_li_fault_fb);
    req->prop = toInt(VehicleProperty::GECKO_BCM_BACKLIFAULTFB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_pos_li_fault_fbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_pos_li_fault_fb = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_pos_li_fault_fb");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_pos_li_fault_fb = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_bcm_pos_li_fault_fbReq(bc_bcm_pos_li_fault_fb),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_pos_li_fault_fbReq(int32_t bc_bcm_pos_li_fault_fb) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_pos_li_fault_fb);
    req->prop = toInt(VehicleProperty::GECKO_BCM_POSLIFAULTFB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_front_fog_li_fault_fbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_front_fog_li_fault_fb = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_front_fog_li_fault_fb");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_front_fog_li_fault_fb = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_bcm_front_fog_li_fault_fbReq(bc_bcm_front_fog_li_fault_fb),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_front_fog_li_fault_fbReq(int32_t bc_bcm_front_fog_li_fault_fb) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_front_fog_li_fault_fb);
    req->prop = toInt(VehicleProperty::GECKO_BCM_FRONTFOGLIFAULTFB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_rear_fog_li_fault_fbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_rear_fog_li_fault_fb = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_rear_fog_li_fault_fb");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_rear_fog_li_fault_fb = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_bcm_rear_fog_li_fault_fbReq(bc_bcm_rear_fog_li_fault_fb),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_rear_fog_li_fault_fbReq(int32_t bc_bcm_rear_fog_li_fault_fb) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_rear_fog_li_fault_fb);
    req->prop = toInt(VehicleProperty::GECKO_BCM_REARFOGLIFAULTFB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_rf_init_staWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_rf_init_sta = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_rf_init_sta");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_rf_init_sta = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_bcm_rf_init_staReq(bc_bcm_rf_init_sta),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_rf_init_staReq(int32_t bc_bcm_rf_init_sta) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_rf_init_sta);
    req->prop = toInt(VehicleProperty::GECKO_BCM_RFINITSTA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_logo_active_flagWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_logo_active_flag = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_logo_active_flag");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_logo_active_flag = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_bcm_logo_active_flagReq(bc_bcm_logo_active_flag),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_logo_active_flagReq(int32_t bc_bcm_logo_active_flag) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_logo_active_flag);
    req->prop = toInt(VehicleProperty::GECKO_BCM_LOGOACTIVEFLAG);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_mai_drvr_seat_stsWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_mai_drvr_seat_sts = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_mai_drvr_seat_sts");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_mai_drvr_seat_sts = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_bcm_mai_drvr_seat_stsReq(bc_bcm_mai_drvr_seat_sts),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_mai_drvr_seat_stsReq(int32_t bc_bcm_mai_drvr_seat_sts) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_mai_drvr_seat_sts);
    req->prop = toInt(VehicleProperty::GECKO_BCM_MAIDRVARSEATSTS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_mai_drvr_seat_tempWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_mai_drvr_seat_temp = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_mai_drvr_seat_temp");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_mai_drvr_seat_temp = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_bcm_mai_drvr_seat_tempReq(bc_bcm_mai_drvr_seat_temp),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_mai_drvr_seat_tempReq(int32_t bc_bcm_mai_drvr_seat_temp) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_mai_drvr_seat_temp);
    req->prop = toInt(VehicleProperty::GECKO_BCM_MAIDRVARSEATTEMP);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_rear_mirror_heat_stsWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_rear_mirror_heat_sts = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_rear_mirror_heat_sts");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_rear_mirror_heat_sts = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_bcm_rear_mirror_heat_stsReq(bc_bcm_rear_mirror_heat_sts),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_rear_mirror_heat_stsReq(int32_t bc_bcm_rear_mirror_heat_sts) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_rear_mirror_heat_sts);
    req->prop = toInt(VehicleProperty::GECKO_BCM_REARMIRRORHEATSTS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_steer_whl_heat_stsWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_steer_whl_heat_sts = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_steer_whl_heat_sts");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_steer_whl_heat_sts = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_bcm_steer_whl_heat_stsReq(bc_bcm_steer_whl_heat_sts),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_steer_whl_heat_stsReq(int32_t bc_bcm_steer_whl_heat_sts) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_steer_whl_heat_sts);
    req->prop = toInt(VehicleProperty::GECKO_BCM_STEERWHLHEATSTS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_steer_whl_tempWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_steer_whl_temp = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_steer_whl_temp");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_steer_whl_temp = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_bcm_steer_whl_tempReq(bc_bcm_steer_whl_temp),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_steer_whl_tempReq(int32_t bc_bcm_steer_whl_temp) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_steer_whl_temp);
    req->prop = toInt(VehicleProperty::GECKO_BCM_STEERWHLTEMP);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_illmnd_entry_sts_fbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_illmnd_entry_sts_fb = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_illmnd_entry_sts_fb");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_illmnd_entry_sts_fb = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_bcm_illmnd_entry_sts_fbReq(bc_bcm_illmnd_entry_sts_fb),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_illmnd_entry_sts_fbReq(int32_t bc_bcm_illmnd_entry_sts_fb) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_illmnd_entry_sts_fb);
    req->prop = toInt(VehicleProperty::GECKO_BCM_ILLMNDENTRYSTSF);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_pass_lf_ant_diag_statusWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_pass_lf_ant_diag_status = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_pass_lf_ant_diag_status");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_pass_lf_ant_diag_status = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_pass_lf_ant_diag_statusReq(bc_pass_lf_ant_diag_status),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_pass_lf_ant_diag_statusReq(int32_t bc_pass_lf_ant_diag_status) {
    auto req = mValueObjectPool->obtainInt32(bc_pass_lf_ant_diag_status);
    req->prop = toInt(VehicleProperty::GECKO_PASSLFANT_DIAGSTATUS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_int_lf_ant_diag_statusWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_int_lf_ant_diag_status = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_int_lf_ant_diag_status");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_int_lf_ant_diag_status = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_int_lf_ant_diag_statusReq(bc_int_lf_ant_diag_status),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_int_lf_ant_diag_statusReq(int32_t bc_int_lf_ant_diag_status) {
    auto req = mValueObjectPool->obtainInt32(bc_int_lf_ant_diag_status);
    req->prop = toInt(VehicleProperty::GECKO_INTLFANT_DIAGSTATUS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_lf_init_staWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_lf_init_sta = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_lf_init_sta");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_lf_init_sta = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_bcm_lf_init_staReq(bc_bcm_lf_init_sta),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_lf_init_staReq(int32_t bc_bcm_lf_init_sta) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_lf_init_sta);
    req->prop = toInt(VehicleProperty::GECKO_BCM_LFINITSTA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_drv_lf_ant_diag_statusWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_drv_lf_ant_diag_status = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_drv_lf_ant_diag_status");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_drv_lf_ant_diag_status = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_drv_lf_ant_diag_statusReq(bc_drv_lf_ant_diag_status),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_drv_lf_ant_diag_statusReq(int32_t bc_drv_lf_ant_diag_status) {
    auto req = mValueObjectPool->obtainInt32(bc_drv_lf_ant_diag_status);
    req->prop = toInt(VehicleProperty::GECKO_DRVLFANT_DIAGSTATUS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_chg_wiper_mt_md_sw_set_fbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_chg_wiper_mt_md_sw_set_fb = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_chg_wiper_mt_md_sw_set_fb");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_chg_wiper_mt_md_sw_set_fb = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_bcm_chg_wiper_mt_md_sw_set_fbReq(bc_bcm_chg_wiper_mt_md_sw_set_fb),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_chg_wiper_mt_md_sw_set_fbReq(int32_t bc_bcm_chg_wiper_mt_md_sw_set_fb) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_chg_wiper_mt_md_sw_set_fb);
    req->prop = toInt(VehicleProperty::GECKO_BCM_CHGWIPERMTRMDSWSETF);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_park_auto_unlock_set_fbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_park_auto_unlock_set_fb = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_park_auto_unlock_set_fb");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_park_auto_unlock_set_fb = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_bcm_park_auto_unlock_set_fbReq(bc_bcm_park_auto_unlock_set_fb),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_park_auto_unlock_set_fbReq(int32_t bc_bcm_park_auto_unlock_set_fb) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_park_auto_unlock_set_fb);
    req->prop = toInt(VehicleProperty::GECKO_BCM_PARKAUTOUNLOCKSETFB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_overspd_cntrl_lock_set_fbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_overspd_cntrl_lock_set_fb = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_overspd_cntrl_lock_set_fb");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_overspd_cntrl_lock_set_fb = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_bcm_overspd_cntrl_lock_set_fbReq(bc_bcm_overspd_cntrl_lock_set_fb),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_overspd_cntrl_lock_set_fbReq(int32_t bc_bcm_overspd_cntrl_lock_set_fb) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_overspd_cntrl_lock_set_fb);
    req->prop = toInt(VehicleProperty::GECKO_BCM_OVERSPDCNTRLLOCKSETF);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_trunk_lock_staWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_trunk_lock_sta = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_trunk_lock_sta");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_trunk_lock_sta = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_bcm_trunk_lock_staReq(bc_bcm_trunk_lock_sta),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_trunk_lock_staReq(int32_t bc_bcm_trunk_lock_sta) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_trunk_lock_sta);
    req->prop = toInt(VehicleProperty::GECKO_BCM_TRUNKLOCKSTA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_trunk_lock_sw_ctrl_fbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_trunk_lock_sw_ctrl_fb = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_trunk_lock_sw_ctrl_fb");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_trunk_lock_sw_ctrl_fb = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_bcm_trunk_lock_sw_ctrl_fbReq(bc_bcm_trunk_lock_sw_ctrl_fb),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_trunk_lock_sw_ctrl_fbReq(int32_t bc_bcm_trunk_lock_sw_ctrl_fb) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_trunk_lock_sw_ctrl_fb);
    req->prop = toInt(VehicleProperty::GECKO_BCM_TRUNKLOCKSWCTRLF);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_ps_authent_resWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_ps_authent_res = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_ps_authent_res");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_ps_authent_res = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_bcm_ps_authent_resReq(bc_bcm_ps_authent_res),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_ps_authent_resReq(int32_t bc_bcm_ps_authent_res) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_ps_authent_res);
    req->prop = toInt(VehicleProperty::GECKO_BCM_PSAUTHENTRES);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_key_in_car_staWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_key_in_car_sta = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_key_in_car_sta");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_key_in_car_sta = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_bcm_key_in_car_staReq(bc_bcm_key_in_car_sta),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_key_in_car_staReq(int32_t bc_bcm_key_in_car_sta) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_key_in_car_sta);
    req->prop = toInt(VehicleProperty::GECKO_BCM_KEYINCARSTA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}


void GarageModeServerSideHandlerImpl::bc_bcm_body_warn_stsWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_body_warn_sts = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_body_warn_sts");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_body_warn_sts = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_bcm_body_warn_stsReq(bc_bcm_body_warn_sts),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_body_warn_stsReq(int32_t bc_bcm_body_warn_sts) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_body_warn_sts);
    req->prop = toInt(VehicleProperty::GECKO_BCM_BODYWARNSTS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_drv_pass_win_sw_sigWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_drv_pass_win_sw_sig = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_drv_pass_win_sw_sig");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_drv_pass_win_sw_sig = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_bcm_drv_pass_win_sw_sigReq(bc_bcm_drv_pass_win_sw_sig),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_drv_pass_win_sw_sigReq(int32_t bc_bcm_drv_pass_win_sw_sig) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_drv_pass_win_sw_sig);
    req->prop = toInt(VehicleProperty::GECKO_BCM_DRVPASSWINSWSIG);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_pas_wdw_initWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_pas_wdw_init = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_pas_wdw_init");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_pas_wdw_init = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_bcm_pas_wdw_initReq(bc_bcm_pas_wdw_init),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_pas_wdw_initReq(int32_t bc_bcm_pas_wdw_init) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_pas_wdw_init);
    req->prop = toInt(VehicleProperty::GECKO_BCM_PAS_WDW_INIT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_front_wash_stsWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_front_wash_sts = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_front_wash_sts");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_front_wash_sts = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_bcm_front_wash_stsReq(bc_bcm_front_wash_sts),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_front_wash_stsReq(int32_t bc_bcm_front_wash_sts) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_front_wash_sts);
    req->prop = toInt(VehicleProperty::GECKO_BCM_FRONTWASHSTS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_wash_liquid_level_warnWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_wash_liquid_level_warn = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_wash_liquid_level_warn");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_wash_liquid_level_warn = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_bcm_wash_liquid_level_warnReq(bc_bcm_wash_liquid_level_warn),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_wash_liquid_level_warnReq(int32_t bc_bcm_wash_liquid_level_warn) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_wash_liquid_level_warn);
    req->prop = toInt(VehicleProperty::GECKO_BCM_WASHLIQUIDLEVELWARN);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_fl_windowmotor_flagsWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_fl_windowmotor_flags = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_fl_windowmotor_flags");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_fl_windowmotor_flags = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_bcm_fl_windowmotor_flagsReq(bc_bcm_fl_windowmotor_flags),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_fl_windowmotor_flagsReq(int32_t bc_bcm_fl_windowmotor_flags) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_fl_windowmotor_flags);
    req->prop = toInt(VehicleProperty::GECKO_BCM_FLWINDOWMOTORFLAGS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_fr_windowmotor_flagsWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_fr_windowmotor_flags = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_fr_windowmotor_flags");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_fr_windowmotor_flags = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_bcm_fr_windowmotor_flagsReq(bc_bcm_fr_windowmotor_flags),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_fr_windowmotor_flagsReq(int32_t bc_bcm_fr_windowmotor_flags) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_fr_windowmotor_flags);
    req->prop = toInt(VehicleProperty::GECKO_BCM_FRWINDOWMOTORFLAGS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_tpms_reset_stsWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_tpms_reset_sts = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_tpms_reset_sts");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_tpms_reset_sts = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_bcm_tpms_reset_stsReq(bc_bcm_tpms_reset_sts),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_tpms_reset_stsReq(int32_t bc_bcm_tpms_reset_sts) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_tpms_reset_sts);
    req->prop = toInt(VehicleProperty::GECKO_BCM_TPMSRESETSTS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_ajar_sta_hoodWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_ajar_sta_hood = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_ajar_sta_hood");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_ajar_sta_hood = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_bcm_ajar_sta_hoodReq(bc_bcm_ajar_sta_hood),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_ajar_sta_hoodReq(int32_t bc_bcm_ajar_sta_hood) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_ajar_sta_hood);
    req->prop = toInt(VehicleProperty::GECKO_BCM_AJARSTA_HOOD);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_light_sw_sigWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_light_sw_sig = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_light_sw_sig");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_light_sw_sig = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_bcm_light_sw_sigReq(bc_bcm_light_sw_sig),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_light_sw_sigReq(int32_t bc_bcm_light_sw_sig) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_light_sw_sig);
    req->prop = toInt(VehicleProperty::GECKO_BCM_LIGHTSWSIG);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_vcu_cruise_ctr_tgt_spd_for_bacWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_vcu_cruise_ctr_tgt_spd_for_bac = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_vcu_cruise_ctr_tgt_spd_for_bac");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_vcu_cruise_ctr_tgt_spd_for_bac = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_vcu_cruise_ctr_tgt_spd_for_bacReq(bc_vcu_cruise_ctr_tgt_spd_for_bac),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_vcu_cruise_ctr_tgt_spd_for_bacReq(int32_t bc_vcu_cruise_ctr_tgt_spd_for_bac) {
    auto req = mValueObjectPool->obtainInt32(bc_vcu_cruise_ctr_tgt_spd_for_bac);
    req->prop = toInt(VehicleProperty::GECKO_VCU_CRUISECTRGTSPD_FORBAC);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_vcu_cruise_ctrl_sta_for_bacWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_vcu_cruise_ctrl_sta_for_bac = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_vcu_cruise_ctrl_sta_for_bac");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_vcu_cruise_ctrl_sta_for_bac = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_vcu_cruise_ctrl_sta_for_bacReq(bc_vcu_cruise_ctrl_sta_for_bac),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_vcu_cruise_ctrl_sta_for_bacReq(int32_t bc_vcu_cruise_ctrl_sta_for_bac) {
    auto req = mValueObjectPool->obtainInt32(bc_vcu_cruise_ctrl_sta_for_bac);
    req->prop = toInt(VehicleProperty::GECKO_VCU_CRUISECTRLSTA_FORBAC);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_vcu_wgh_distbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_vcu_wgh_distb = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_vcu_wgh_distb");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_vcu_wgh_distb = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_vcu_wgh_distbReq(bc_vcu_wgh_distb),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_vcu_wgh_distbReq(int32_t bc_vcu_wgh_distb) {
    auto req = mValueObjectPool->obtainInt32(bc_vcu_wgh_distb);
    req->prop = toInt(VehicleProperty::GECKO_VCU_WGHDISTB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_vcu_wgh_estWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_vcu_wgh_est = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_vcu_wgh_est");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_vcu_wgh_est = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_vcu_wgh_estReq(bc_vcu_wgh_est),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_vcu_wgh_estReq(int32_t bc_vcu_wgh_est) {
    auto req = mValueObjectPool->obtainInt32(bc_vcu_wgh_est);
    req->prop = toInt(VehicleProperty::GECKO_VCU_WGHEST);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_vcu_wgh_confdenceWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_vcu_wgh_confdence = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_vcu_wgh_confdence");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_vcu_wgh_confdence = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_vcu_wgh_confdenceReq(bc_vcu_wgh_confdence),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_vcu_wgh_confdenceReq(int32_t bc_vcu_wgh_confdence) {
    auto req = mValueObjectPool->obtainInt32(bc_vcu_wgh_confdence);
    req->prop = toInt(VehicleProperty::GECKO_VCU_WGHCONFIDENCE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_vcu_vesion_set_fbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_vcu_vesion_set_fb = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_vcu_vesion_set_fb");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_vcu_vesion_set_fb = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_vcu_vesion_set_fbReq(bc_vcu_vesion_set_fb),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_vcu_vesion_set_fbReq(int32_t bc_vcu_vesion_set_fb) {
    auto req = mValueObjectPool->obtainInt32(bc_vcu_vesion_set_fb);
    req->prop = toInt(VehicleProperty::GECKO_VCU_VERSIONSETFB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_vcu_version_fbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_vcu_version_fb = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_vcu_version_fb");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_vcu_version_fb = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_vcu_version_fbReq(bc_vcu_version_fb),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_vcu_version_fbReq(int32_t bc_vcu_version_fb) {
    auto req = mValueObjectPool->obtainInt32(bc_vcu_version_fb);
    req->prop = toInt(VehicleProperty::GECKO_VCU_VERSIONFB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_vcu_operat_licence_fbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_vcu_operat_licence_fb = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_vcu_operat_licence_fb");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_vcu_operat_licence_fb = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_vcu_operat_licence_fbReq(bc_vcu_operat_licence_fb),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_vcu_operat_licence_fbReq(int32_t bc_vcu_operat_licence_fb) {
    auto req = mValueObjectPool->obtainInt32(bc_vcu_operat_licence_fb);
    req->prop = toInt(VehicleProperty::GECKO_VCU_OPERATLICENCEFB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_vcu_speed_limit_level_fbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_vcu_speed_limit_level_fb = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_vcu_speed_limit_level_fb");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_vcu_speed_limit_level_fb = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_vcu_speed_limit_level_fbReq(bc_vcu_speed_limit_level_fb),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_vcu_speed_limit_level_fbReq(int32_t bc_vcu_speed_limit_level_fb) {
    auto req = mValueObjectPool->obtainInt32(bc_vcu_speed_limit_level_fb);
    req->prop = toInt(VehicleProperty::GECKO_CCM_SPEED_LIMIT_LEVEL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_ccu_remote_power_lock_fbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_ccu_remote_power_lock_fb = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ccu_remote_power_lock_fb");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ccu_remote_power_lock_fb = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_ccu_remote_power_lock_fbReq(bc_ccu_remote_power_lock_fb),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ccu_remote_power_lock_fbReq(int32_t bc_ccu_remote_power_lock_fb) {
    auto req = mValueObjectPool->obtainInt32(bc_ccu_remote_power_lock_fb);
    req->prop = toInt(VehicleProperty::GECKO_CCU_REMOTEPOWERLOCKFB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_ac_remt_ctrl_fbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_ac_remt_ctrl_fb = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ac_remt_ctrl_fb");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ac_remt_ctrl_fb = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_ac_remt_ctrl_fbReq(bc_ac_remt_ctrl_fb),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ac_remt_ctrl_fbReq(int32_t bc_ac_remt_ctrl_fb) {
    auto req = mValueObjectPool->obtainInt32(bc_ac_remt_ctrl_fb);
    req->prop = toInt(VehicleProperty::GECKO_AC_REMTCNTLFB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_ac_temp_set_fbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_ac_temp_set_fb = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ac_temp_set_fb");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ac_temp_set_fb = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_ac_temp_set_fbReq(bc_ac_temp_set_fb),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ac_temp_set_fbReq(int32_t bc_ac_temp_set_fb) {
    auto req = mValueObjectPool->obtainInt32(bc_ac_temp_set_fb);
    req->prop = toInt(VehicleProperty::GECKO_AC_TEMPSETFB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_ac_remote_defrost_ctl_fbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_ac_remote_defrost_ctl_fb = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ac_remote_defrost_ctl_fb");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ac_remote_defrost_ctl_fb = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_ac_remote_defrost_ctl_fbReq(bc_ac_remote_defrost_ctl_fb),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ac_remote_defrost_ctl_fbReq(int32_t bc_ac_remote_defrost_ctl_fb) {
    auto req = mValueObjectPool->obtainInt32(bc_ac_remote_defrost_ctl_fb);
    req->prop = toInt(VehicleProperty::GECKO_AC_REMOTEDFROSTCTLFB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_ac_ac_unlock_vent_set_fbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_ac_ac_unlock_vent_set_fb = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ac_ac_unlock_vent_set_fb");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ac_ac_unlock_vent_set_fb = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_ac_ac_unlock_vent_set_fbReq(bc_ac_ac_unlock_vent_set_fb),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ac_ac_unlock_vent_set_fbReq(int32_t bc_ac_ac_unlock_vent_set_fb) {
    auto req = mValueObjectPool->obtainInt32(bc_ac_ac_unlock_vent_set_fb);
    req->prop = toInt(VehicleProperty::GECKO_AC_ACUNLOCKVENTSETFB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_ccu_open_ventilation_fbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_ccu_open_ventilation_fb = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ccu_open_ventilation_fb");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ccu_open_ventilation_fb = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_ccu_open_ventilation_fbReq(bc_ccu_open_ventilation_fb),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ccu_open_ventilation_fbReq(int32_t bc_ccu_open_ventilation_fb) {
    auto req = mValueObjectPool->obtainInt32(bc_ccu_open_ventilation_fb);
    req->prop = toInt(VehicleProperty::GECKO_CCU_OPENVENTILATIONFB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_vcu_ac_chrg_modeWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_vcu_ac_chrg_mode = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_vcu_ac_chrg_mode");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_vcu_ac_chrg_mode = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_vcu_ac_chrg_modeReq(bc_vcu_ac_chrg_mode),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_vcu_ac_chrg_modeReq(int32_t bc_vcu_ac_chrg_mode) {
    auto req = mValueObjectPool->obtainInt32(bc_vcu_ac_chrg_mode);
    req->prop = toInt(VehicleProperty::GECKO_VCU_ACCHRGMODE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_vcu_ac_chrg_max_currWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_vcu_ac_chrg_max_curr = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_vcu_ac_chrg_max_curr");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_vcu_ac_chrg_max_curr = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_vcu_ac_chrg_max_currReq(bc_vcu_ac_chrg_max_curr),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_vcu_ac_chrg_max_currReq(int32_t bc_vcu_ac_chrg_max_curr) {
    auto req = mValueObjectPool->obtainInt32(bc_vcu_ac_chrg_max_curr);
    req->prop = toInt(VehicleProperty::GECKO_VCU_ACCHRGMAXCURR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_vcu_sibs_fb_rtc_wup_flgWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_vcu_sibs_fb_rtc_wup_flg = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_vcu_sibs_fb_rtc_wup_flg");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_vcu_sibs_fb_rtc_wup_flg = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_vcu_sibs_fb_rtc_wup_flgReq(bc_vcu_sibs_fb_rtc_wup_flg),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_vcu_sibs_fb_rtc_wup_flgReq(int32_t bc_vcu_sibs_fb_rtc_wup_flg) {
    auto req = mValueObjectPool->obtainInt32(bc_vcu_sibs_fb_rtc_wup_flg);
    req->prop = toInt(VehicleProperty::GECKO_VCU_SIBS_FBRTCWUPFLG);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_vcu_sibs_bms_bat_soc_allowWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_vcu_sibs_bms_bat_soc_allow = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_vcu_sibs_bms_bat_soc_allow");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_vcu_sibs_bms_bat_soc_allow = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_vcu_sibs_bms_bat_soc_allowReq(bc_vcu_sibs_bms_bat_soc_allow),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_vcu_sibs_bms_bat_soc_allowReq(int32_t bc_vcu_sibs_bms_bat_soc_allow) {
    auto req = mValueObjectPool->obtainInt32(bc_vcu_sibs_bms_bat_soc_allow);
    req->prop = toInt(VehicleProperty::GECKO_VCU_SIBS_BMSBATSOCALLOW);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_vcu_sibs_wup_volt_allowWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_vcu_sibs_wup_volt_allow = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_vcu_sibs_wup_volt_allow");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_vcu_sibs_wup_volt_allow = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_vcu_sibs_wup_volt_allowReq(bc_vcu_sibs_wup_volt_allow),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_vcu_sibs_wup_volt_allowReq(int32_t bc_vcu_sibs_wup_volt_allow) {
    auto req = mValueObjectPool->obtainInt32(bc_vcu_sibs_wup_volt_allow);
    req->prop = toInt(VehicleProperty::GECKO_VCU_SIBS_WUPVOLTALLOW);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_vcu_sibs_rtc_chrg_stWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_vcu_sibs_rtc_chrg_st = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_vcu_sibs_rtc_chrg_st");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_vcu_sibs_rtc_chrg_st = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_vcu_sibs_rtc_chrg_stReq(bc_vcu_sibs_rtc_chrg_st),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_vcu_sibs_rtc_chrg_stReq(int32_t bc_vcu_sibs_rtc_chrg_st) {
    auto req = mValueObjectPool->obtainInt32(bc_vcu_sibs_rtc_chrg_st);
    req->prop = toInt(VehicleProperty::GECKO_VCU_SIBS_RTCCHRGST);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_vcu_sibs_rtcwu_chg_fail_numWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_vcu_sibs_rtcwu_chg_fail_num = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_vcu_sibs_rtcwu_chg_fail_num");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_vcu_sibs_rtcwu_chg_fail_num = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_vcu_sibs_rtcwu_chg_fail_numReq(bc_vcu_sibs_rtcwu_chg_fail_num),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_vcu_sibs_rtcwu_chg_fail_numReq(int32_t bc_vcu_sibs_rtcwu_chg_fail_num) {
    auto req = mValueObjectPool->obtainInt32(bc_vcu_sibs_rtcwu_chg_fail_num);
    req->prop = toInt(VehicleProperty::GECKO_VCU_SIBS_RTCWUCHGFAILNUM);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_vcu_sibs_chg_num_allowWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_vcu_sibs_chg_num_allow = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_vcu_sibs_chg_num_allow");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_vcu_sibs_chg_num_allow = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_vcu_sibs_chg_num_allowReq(bc_vcu_sibs_chg_num_allow),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_vcu_sibs_chg_num_allowReq(int32_t bc_vcu_sibs_chg_num_allow) {
    auto req = mValueObjectPool->obtainInt32(bc_vcu_sibs_chg_num_allow);
    req->prop = toInt(VehicleProperty::GECKO_VCU_SIBS_CHGNUMALLOW);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_vcu_sibs_rtcwu_chg_numWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_vcu_sibs_rtcwu_chg_num = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_vcu_sibs_rtcwu_chg_num");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_vcu_sibs_rtcwu_chg_num = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_vcu_sibs_rtcwu_chg_numReq(bc_vcu_sibs_rtcwu_chg_num),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_vcu_sibs_rtcwu_chg_numReq(int32_t bc_vcu_sibs_rtcwu_chg_num) {
    auto req = mValueObjectPool->obtainInt32(bc_vcu_sibs_rtcwu_chg_num);
    req->prop = toInt(VehicleProperty::GECKO_VCU_SIBS_RTCWUCHGNUM);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_vcu_sibs_kl30_voltageWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  float bc_vcu_sibs_kl30_voltage = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_vcu_sibs_kl30_voltage");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_vcu_sibs_kl30_voltage = getActualFloatValue(mPropertyManager->getCProValue(mp),0.1,0);
      mHal->onPropertyValue(*Create_bc_vcu_sibs_kl30_voltageReq(bc_vcu_sibs_kl30_voltage),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_vcu_sibs_kl30_voltageReq(float bc_vcu_sibs_kl30_voltage) {
    auto req = mValueObjectPool->obtainFloat(bc_vcu_sibs_kl30_voltage);
    req->prop = toInt(VehicleProperty::GECKO_VCU_SIBS_KL30VOLTAGE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_vcu_lock_veh_warmWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_vcu_lock_veh_warm = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_vcu_lock_veh_warm");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_vcu_lock_veh_warm = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_vcu_lock_veh_warmReq(bc_vcu_lock_veh_warm),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_vcu_lock_veh_warmReq(int32_t bc_vcu_lock_veh_warm) {
    auto req = mValueObjectPool->obtainInt32(bc_vcu_lock_veh_warm);
    req->prop = toInt(VehicleProperty::GECKO_VCU_LOCKVEHWARM);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_vcu_shift_key_stagnationWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_vcu_shift_key_stagnation = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_vcu_shift_key_stagnation");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_vcu_shift_key_stagnation = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_vcu_shift_key_stagnationReq(bc_vcu_shift_key_stagnation),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_vcu_shift_key_stagnationReq(int32_t bc_vcu_shift_key_stagnation) {
    auto req = mValueObjectPool->obtainInt32(bc_vcu_shift_key_stagnation);
    req->prop = toInt(VehicleProperty::GECKO_VCU_SHIFTKYSTAGNATION);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_vcu_cc_key_stagnationWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_vcu_cc_key_stagnation = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_vcu_cc_key_stagnation");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_vcu_cc_key_stagnation = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_vcu_cc_key_stagnationReq(bc_vcu_cc_key_stagnation),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_vcu_cc_key_stagnationReq(int32_t bc_vcu_cc_key_stagnation) {
    auto req = mValueObjectPool->obtainInt32(bc_vcu_cc_key_stagnation);
    req->prop = toInt(VehicleProperty::GECKO_VCU_CCKYSTAGNATION);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_vcu_drive_mode_key_stagnationWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_vcu_drive_mode_key_stagnation = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_vcu_drive_mode_key_stagnation");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_vcu_drive_mode_key_stagnation = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_vcu_drive_mode_key_stagnationReq(bc_vcu_drive_mode_key_stagnation),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_vcu_drive_mode_key_stagnationReq(int32_t bc_vcu_drive_mode_key_stagnation) {
    auto req = mValueObjectPool->obtainInt32(bc_vcu_drive_mode_key_stagnation);
    req->prop = toInt(VehicleProperty::GECKO_VCU_DRIVEMODEKYSTAGNATION);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_vcu_vhcl_speed_fast_warnWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_vcu_vhcl_speed_fast_warn = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_vcu_vhcl_speed_fast_warn");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_vcu_vhcl_speed_fast_warn = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_vcu_vhcl_speed_fast_warnReq(bc_vcu_vhcl_speed_fast_warn),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_vcu_vhcl_speed_fast_warnReq(int32_t bc_vcu_vhcl_speed_fast_warn) {
    auto req = mValueObjectPool->obtainInt32(bc_vcu_vhcl_speed_fast_warn);
    req->prop = toInt(VehicleProperty::GECKO_VCU_VHCLSPEEDFASTWARN);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_vcu_info_dispWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_vcu_info_disp = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_vcu_info_disp");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_vcu_info_disp = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_vcu_info_dispReq(bc_vcu_info_disp),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_vcu_info_dispReq(int32_t bc_vcu_info_disp) {
    auto req = mValueObjectPool->obtainInt32(bc_vcu_info_disp);
    req->prop = toInt(VehicleProperty::GECKO_VCU_INFODISP);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::cc_eps_sws_hod_hands_off_stsWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t cc_eps_sws_hod_hands_off_sts = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_eps_sws_hod_hands_off_sts");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_eps_sws_hod_hands_off_sts = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_cc_eps_sws_hod_hands_off_stsReq(cc_eps_sws_hod_hands_off_sts),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_eps_sws_hod_hands_off_stsReq(int32_t cc_eps_sws_hod_hands_off_sts) {
    auto req = mValueObjectPool->obtainInt32(cc_eps_sws_hod_hands_off_sts);
    req->prop = toInt(VehicleProperty::GECKO_EPS_SWS_HODHANDSOFFSTS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::cc_eps_mode_set_inhibit_fbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t cc_eps_mode_set_inhibit_fb = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_eps_mode_set_inhibit_fb");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_eps_mode_set_inhibit_fb = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_cc_eps_mode_set_inhibit_fbReq(cc_eps_mode_set_inhibit_fb),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_eps_mode_set_inhibit_fbReq(int32_t cc_eps_mode_set_inhibit_fb) {
    auto req = mValueObjectPool->obtainInt32(cc_eps_mode_set_inhibit_fb);
    req->prop = toInt(VehicleProperty::GECKO_EPS_MODESETINHIBITFB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::cc_eps_basic_elec_steer_failedWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t cc_eps_basic_elec_steer_failed = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("cc_eps_basic_elec_steer_failed");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      cc_eps_basic_elec_steer_failed = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_cc_eps_basic_elec_steer_failedReq(cc_eps_basic_elec_steer_failed),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_cc_eps_basic_elec_steer_failedReq(int32_t cc_eps_basic_elec_steer_failed) {
    auto req = mValueObjectPool->obtainInt32(cc_eps_basic_elec_steer_failed);
    req->prop = toInt(VehicleProperty::GECKO_EPS_BASICELECSTEERFAILED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_icu_icu_trip_b_odometerWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_icu_icu_trip_b_odometer = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_icu_icu_trip_b_odometer");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_icu_icu_trip_b_odometer = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_icu_icu_trip_b_odometerReq(ec_icu_icu_trip_b_odometer),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_icu_icu_trip_b_odometerReq(int32_t ec_icu_icu_trip_b_odometer) {
    auto req = mValueObjectPool->obtainInt32(ec_icu_icu_trip_b_odometer);
    req->prop = toInt(VehicleProperty::GECKO_ICU_ICUTRIPBODOMETER);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_icu_icu_trip_a_odometerWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_icu_icu_trip_a_odometer = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_icu_icu_trip_a_odometer");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_icu_icu_trip_a_odometer = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_icu_icu_trip_a_odometerReq(ec_icu_icu_trip_a_odometer),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_icu_icu_trip_a_odometerReq(int32_t ec_icu_icu_trip_a_odometer) {
    auto req = mValueObjectPool->obtainInt32(ec_icu_icu_trip_a_odometer);
    req->prop = toInt(VehicleProperty::GECKO_ICU_ICUTRIPAODOMETER);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_icu_vehicle_speed_displayed_vWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_icu_vehicle_speed_displayed_v = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_icu_vehicle_speed_displayed_v");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_icu_vehicle_speed_displayed_v = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_icu_vehicle_speed_displayed_vReq(ec_icu_vehicle_speed_displayed_v),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_icu_vehicle_speed_displayed_vReq(int32_t ec_icu_vehicle_speed_displayed_v) {
    auto req = mValueObjectPool->obtainInt32(ec_icu_vehicle_speed_displayed_v);
    req->prop = toInt(VehicleProperty::GECKO_ICU_VEHICLESPEEDDISPLAYEDV);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_dcs_actl_chrg_voltageWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bms_dcs_actl_chrg_voltage = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_dcs_actl_chrg_voltage");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_dcs_actl_chrg_voltage = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_bms_dcs_actl_chrg_voltageReq(ec_bms_dcs_actl_chrg_voltage),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_dcs_actl_chrg_voltageReq(int32_t ec_bms_dcs_actl_chrg_voltage) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_dcs_actl_chrg_voltage);
    req->prop = toInt(VehicleProperty::GECKO_BMS_DCS_ACTLCHRGVOLTAGE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_thermalrunaway_wrnWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bms_thermalrunaway_wrn = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_thermalrunaway_wrn");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_thermalrunaway_wrn = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_bms_thermalrunaway_wrnReq(ec_bms_thermalrunaway_wrn),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_thermalrunaway_wrnReq(int32_t ec_bms_thermalrunaway_wrn) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_thermalrunaway_wrn);
    req->prop = toInt(VehicleProperty::GECKO_BMS_THERMALRUNAWAYWRN);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_insulation_wrning_distgshWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bms_insulation_wrning_distgsh = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_insulation_wrning_distgsh");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_insulation_wrning_distgsh = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_bms_insulation_wrning_distgshReq(ec_bms_insulation_wrning_distgsh),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_insulation_wrning_distgshReq(int32_t ec_bms_insulation_wrning_distgsh) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_insulation_wrning_distgsh);
    req->prop = toInt(VehicleProperty::GECKO_BMS_INSULATION_WRNING_DISTGSH);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_srs_crash_output_stsWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_srs_crash_output_sts = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_srs_crash_output_sts");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_srs_crash_output_sts = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_srs_crash_output_stsReq(ec_srs_crash_output_sts),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_srs_crash_output_stsReq(int32_t ec_srs_crash_output_sts) {
    auto req = mValueObjectPool->obtainInt32(ec_srs_crash_output_sts);
    req->prop = toInt(VehicleProperty::GECKO_SRS_CRASHOUTPUTSTS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_obc_inlelt_actl_powerWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_ipu_obc_inlelt_actl_power = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_obc_inlelt_actl_power");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ipu_obc_inlelt_actl_power = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_ipu_obc_inlelt_actl_powerReq(ec_ipu_obc_inlelt_actl_power),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_obc_inlelt_actl_powerReq(int32_t ec_ipu_obc_inlelt_actl_power) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_obc_inlelt_actl_power);
    req->prop = toInt(VehicleProperty::GECKO_IPU_OBC_INLELTACTLPOWER);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_pp_fmr_distWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_pp_fmr_dist = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_pp_fmr_dist");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_pp_fmr_dist = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_pp_fmr_distReq(bc_pp_fmr_dist),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_pp_fmr_distReq(int32_t bc_pp_fmr_dist) {
    auto req = mValueObjectPool->obtainInt32(bc_pp_fmr_dist);
    req->prop = toInt(VehicleProperty::GECKO_PP_FMRDIST);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_fcm_laterallimitWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_fcm_laterallimit = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_laterallimit");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_fcm_laterallimit = mPropertyManager->getCProValue(mp);
      LOG(INFO)<<"bc_fcm_laterallimit: "<<bc_fcm_laterallimit;
      mHal->onPropertyValue(*Create_bc_fcm_laterallimitReq(bc_fcm_laterallimit),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_laterallimitReq(int32_t bc_fcm_laterallimit) {
    auto req = mValueObjectPool->obtainInt32(bc_fcm_laterallimit);
    req->prop = toInt(VehicleProperty::GECKO_FCM_LATERALLIMIT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_fcm_ldw_audio_warnWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_fcm_ldw_audio_warn = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_ldw_audio_warn");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_fcm_ldw_audio_warn = mPropertyManager->getCProValue(mp);
      LOG(INFO)<<"bc_fcm_ldw_audio_warn: "<<bc_fcm_ldw_audio_warn;
      mHal->onPropertyValue(*Create_bc_fcm_ldw_audio_warnReq(bc_fcm_ldw_audio_warn),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_ldw_audio_warnReq(int32_t bc_fcm_ldw_audio_warn) {
    auto req = mValueObjectPool->obtainInt32(bc_fcm_ldw_audio_warn);
    req->prop = toInt(VehicleProperty::GECKO_FCM_LDWAUDIOWARN);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_fcm_raeb_work_stsWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_fcm_raeb_work_sts = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_raeb_work_sts");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_fcm_raeb_work_sts = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_fcm_raeb_work_stsReq(bc_fcm_raeb_work_sts),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_raeb_work_stsReq(int32_t bc_fcm_raeb_work_sts) {
    auto req = mValueObjectPool->obtainInt32(bc_fcm_raeb_work_sts);
    req->prop = toInt(VehicleProperty::GECKO_FCM_RAEB_WORKSTS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_fcm_aeb_obj_idWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_fcm_aeb_obj_id = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_aeb_obj_id");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_fcm_aeb_obj_id = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_fcm_aeb_obj_idReq(bc_fcm_aeb_obj_id),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_aeb_obj_idReq(int32_t bc_fcm_aeb_obj_id) {
    auto req = mValueObjectPool->obtainInt32(bc_fcm_aeb_obj_id);
    req->prop = toInt(VehicleProperty::GECKO_FCM_AEBOBJID);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_fcm_v_set_disWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_fcm_v_set_dis = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_v_set_dis");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_fcm_v_set_dis = mPropertyManager->getCProValue(mp);
      LOG(INFO)<<"bc_fcm_v_set_dis: "<<bc_fcm_v_set_dis;
      mHal->onPropertyValue(*Create_bc_fcm_v_set_disReq(bc_fcm_v_set_dis),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_v_set_disReq(int32_t bc_fcm_v_set_dis) {
    auto req = mValueObjectPool->obtainInt32(bc_fcm_v_set_dis);
    req->prop = toInt(VehicleProperty::GECKO_FCM_VSETDIS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_fcm_ldw_alert_method_set_fbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_fcm_ldw_alert_method_set_fb = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_ldw_alert_method_set_fb");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_fcm_ldw_alert_method_set_fb = mPropertyManager->getCProValue(mp);
      LOG(INFO)<<"bc_fcm_ldw_alert_method_set_fb: "<<bc_fcm_ldw_alert_method_set_fb;
      mHal->onPropertyValue(*Create_bc_fcm_ldw_alert_method_set_fbReq(bc_fcm_ldw_alert_method_set_fb),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_ldw_alert_method_set_fbReq(int32_t bc_fcm_ldw_alert_method_set_fb) {
    auto req = mValueObjectPool->obtainInt32(bc_fcm_ldw_alert_method_set_fb);
    req->prop = toInt(VehicleProperty::GECKO_FCM_LDWALERTMETHODSETFB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_fcm_ri_line_color_fctWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_fcm_ri_line_color_fct = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_ri_line_color_fct");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_fcm_ri_line_color_fct = mPropertyManager->getCProValue(mp);
      LOG(INFO) << "bc_fcm_ri_line_color_fct: " << bc_fcm_ri_line_color_fct;
      mHal->onPropertyValue(*Create_bc_fcm_ri_line_color_fctReq(bc_fcm_ri_line_color_fct),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_ri_line_color_fctReq(int32_t bc_fcm_ri_line_color_fct) {
    auto req = mValueObjectPool->obtainInt32(bc_fcm_ri_line_color_fct);
    req->prop = toInt(VehicleProperty::GECKO_FCM_RILINECOLORFCT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_fcm_lka_set_fbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_fcm_lka_set_fb = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_lka_set_fb");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_fcm_lka_set_fb = mPropertyManager->getCProValue(mp);
      LOG(INFO)<<"bc_fcm_lka_set_fb: "<<bc_fcm_lka_set_fb;
      mHal->onPropertyValue(*Create_bc_fcm_lka_set_fbReq(bc_fcm_lka_set_fb),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_lka_set_fbReq(int32_t bc_fcm_lka_set_fb) {
    auto req = mValueObjectPool->obtainInt32(bc_fcm_lka_set_fb);
    req->prop = toInt(VehicleProperty::GECKO_FCM_LKASETFB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_fcm_le_line_color_fctWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_fcm_le_line_color_fct = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_le_line_color_fct");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_fcm_le_line_color_fct = mPropertyManager->getCProValue(mp);
      LOG(INFO)<<"bc_fcm_le_line_color_fct: "<<bc_fcm_le_line_color_fct;
      mHal->onPropertyValue(*Create_bc_fcm_le_line_color_fctReq(bc_fcm_le_line_color_fct),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_le_line_color_fctReq(int32_t bc_fcm_le_line_color_fct) {
    auto req = mValueObjectPool->obtainInt32(bc_fcm_le_line_color_fct);
    req->prop = toInt(VehicleProperty::GECKO_FCM_LELINECOLORFCT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_fcm_lka_stsWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_fcm_lka_sts = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_lka_sts");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_fcm_lka_sts = mPropertyManager->getCProValue(mp);
      LOG(INFO)<<"bc_fcm_lka_sts: "<<bc_fcm_lka_sts;
      mHal->onPropertyValue(*Create_bc_fcm_lka_stsReq(bc_fcm_lka_sts),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_lka_stsReq(int32_t bc_fcm_lka_sts) {
    auto req = mValueObjectPool->obtainInt32(bc_fcm_lka_sts);
    req->prop = toInt(VehicleProperty::GECKO_FCM_LKASTS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_fcm_ldw_set_fbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_fcm_ldw_set_fb = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_ldw_set_fb");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_fcm_ldw_set_fb = mPropertyManager->getCProValue(mp);
      LOG(INFO)<<"bc_fcm_ldw_set_fb = " << bc_fcm_ldw_set_fb;
      mHal->onPropertyValue(*Create_bc_fcm_ldw_set_fbReq(bc_fcm_ldw_set_fb),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_ldw_set_fbReq(int32_t bc_fcm_ldw_set_fb) {
    auto req = mValueObjectPool->obtainInt32(bc_fcm_ldw_set_fb);
    req->prop = toInt(VehicleProperty::GECKO_FCM_LDWSETFB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_fcm_ldw_stsWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_fcm_ldw_sts = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_ldw_sts");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_fcm_ldw_sts = mPropertyManager->getCProValue(mp);
      LOG(INFO) << "bc_fcm_ldw_sts: " << bc_fcm_ldw_sts;
      mHal->onPropertyValue(*Create_bc_fcm_ldw_stsReq(bc_fcm_ldw_sts),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_ldw_stsReq(int32_t bc_fcm_ldw_sts) {
    auto req = mValueObjectPool->obtainInt32(bc_fcm_ldw_sts);
    req->prop = toInt(VehicleProperty::GECKO_FCM_LDWSTS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_fcm_text_info_lka1Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_fcm_text_info_lka1 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_text_info_lka1");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_fcm_text_info_lka1 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_fcm_text_info_lka1Req(bc_fcm_text_info_lka1),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_text_info_lka1Req(int32_t bc_fcm_text_info_lka1) {
    auto req = mValueObjectPool->obtainInt32(bc_fcm_text_info_lka1);
    req->prop = toInt(VehicleProperty::GECKO_FCM_TEXTINFOLKA1);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_fcm_pcw_latent_warnWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_fcm_pcw_latent_warn = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_pcw_latent_warn");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_fcm_pcw_latent_warn = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_fcm_pcw_latent_warnReq(bc_fcm_pcw_latent_warn),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_pcw_latent_warnReq(int32_t bc_fcm_pcw_latent_warn) {
    auto req = mValueObjectPool->obtainInt32(bc_fcm_pcw_latent_warn);
    req->prop = toInt(VehicleProperty::GECKO_FCM_PCWLATENTWARN);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_fcm_pcw_pre_warnWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_fcm_pcw_pre_warn = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_pcw_pre_warn");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_fcm_pcw_pre_warn = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_fcm_pcw_pre_warnReq(bc_fcm_pcw_pre_warn),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_pcw_pre_warnReq(int32_t bc_fcm_pcw_pre_warn) {
    auto req = mValueObjectPool->obtainInt32(bc_fcm_pcw_pre_warn);
    req->prop = toInt(VehicleProperty::GECKO_FCM_PCWPREWARN);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_fcm_acc_mode_hmiWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_fcm_acc_mode_hmi = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_acc_mode_hmi");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_fcm_acc_mode_hmi = mPropertyManager->getCProValue(mp);
      LOG(INFO)<<"bc_fcm_acc_mode_hmi: "<<bc_fcm_acc_mode_hmi;
      mHal->onPropertyValue(*Create_bc_fcm_acc_mode_hmiReq(bc_fcm_acc_mode_hmi),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_acc_mode_hmiReq(int32_t bc_fcm_acc_mode_hmi) {
    auto req = mValueObjectPool->obtainInt32(bc_fcm_acc_mode_hmi);
    req->prop = toInt(VehicleProperty::GECKO_FCM_ACCMODEHMI);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_fcm_adas_quit_reasWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_fcm_adas_quit_reas = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_adas_quit_reas");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_fcm_adas_quit_reas = mPropertyManager->getCProValue(mp);
      LOG(INFO)<<"bc_fcm_adas_quit_reas: "<<bc_fcm_adas_quit_reas;
      mHal->onPropertyValue(*Create_bc_fcm_adas_quit_reasReq(bc_fcm_adas_quit_reas),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_adas_quit_reasReq(int32_t bc_fcm_adas_quit_reas) {
    auto req = mValueObjectPool->obtainInt32(bc_fcm_adas_quit_reas);
    req->prop = toInt(VehicleProperty::GECKO_FCM_ADASQUITREAS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_fcm_ica_set_fbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_fcm_ica_set_fb = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_ica_set_fb");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_fcm_ica_set_fb = mPropertyManager->getCProValue(mp);
      LOG(INFO)<<"bc_fcm_ica_set_fb: "<<bc_fcm_ica_set_fb;
      mHal->onPropertyValue(*Create_bc_fcm_ica_set_fbReq(bc_fcm_ica_set_fb),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_ica_set_fbReq(int32_t bc_fcm_ica_set_fb) {
    auto req = mValueObjectPool->obtainInt32(bc_fcm_ica_set_fb);
    req->prop = toInt(VehicleProperty::GECKO_FCM_ICASETFB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}


void GarageModeServerSideHandlerImpl::bc_fcm_ica_truck_set_fbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_fcm_ica_truck_set_fb = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_ica_truck_set_fb");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_fcm_ica_truck_set_fb = mPropertyManager->getCProValue(mp);
      LOG(INFO)<<"bc_fcm_ica_truck_set_fb: "<<bc_fcm_ica_truck_set_fb;
      mHal->onPropertyValue(*Create_bc_fcm_ica_truck_set_fbReq(bc_fcm_ica_truck_set_fb),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_ica_truck_set_fbReq(int32_t bc_fcm_ica_truck_set_fb) {
    auto req = mValueObjectPool->obtainInt32(bc_fcm_ica_truck_set_fb);
    req->prop = toInt(VehicleProperty::GECKO_FCM_ICATRUCKSETFB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_fcm_acc_startWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_fcm_acc_start = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_acc_start");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_fcm_acc_start = mPropertyManager->getCProValue(mp);
      LOG(INFO)<<"bc_fcm_acc_start: " << bc_fcm_acc_start;
      mHal->onPropertyValue(*Create_bc_fcm_acc_startReq(bc_fcm_acc_start),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_acc_startReq(int32_t bc_fcm_acc_start) {
    auto req = mValueObjectPool->obtainInt32(bc_fcm_acc_start);
    req->prop = toInt(VehicleProperty::GECKO_FCM_ACCSTART);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_fcm_adas_not_avl_reasWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_fcm_adas_not_avl_reas = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_adas_not_avl_reas");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_fcm_adas_not_avl_reas = mPropertyManager->getCProValue(mp);
      LOG(INFO)<<"bc_fcm_adas_not_avl_reas: "<<bc_fcm_adas_not_avl_reas;
      mHal->onPropertyValue(*Create_bc_fcm_adas_not_avl_reasReq(bc_fcm_adas_not_avl_reas),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_adas_not_avl_reasReq(int32_t bc_fcm_adas_not_avl_reas) {
    auto req = mValueObjectPool->obtainInt32(bc_fcm_adas_not_avl_reas);
    req->prop = toInt(VehicleProperty::GECKO_FCM_ADASNOTAVLREAS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_fcm_tar_obj_accWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_fcm_tar_obj_acc = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_tar_obj_acc");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_fcm_tar_obj_acc = mPropertyManager->getCProValue(mp);
      LOG(INFO)<<"bc_fcm_tar_obj_acc: "<<bc_fcm_tar_obj_acc;
      mHal->onPropertyValue(*Create_bc_fcm_tar_obj_accReq(bc_fcm_tar_obj_acc),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_tar_obj_accReq(int32_t bc_fcm_tar_obj_acc) {
    auto req = mValueObjectPool->obtainInt32(bc_fcm_tar_obj_acc);
    req->prop = toInt(VehicleProperty::GECKO_FCM_TAROBJACC);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_fcm_act_drv_asst_sts_hmiWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_fcm_act_drv_asst_sts_hmi = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_act_drv_asst_sts_hmi");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_fcm_act_drv_asst_sts_hmi = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_fcm_act_drv_asst_sts_hmiReq(bc_fcm_act_drv_asst_sts_hmi),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_act_drv_asst_sts_hmiReq(int32_t bc_fcm_act_drv_asst_sts_hmi) {
    auto req = mValueObjectPool->obtainInt32(bc_fcm_act_drv_asst_sts_hmi);
    req->prop = toInt(VehicleProperty::GECKO_FCM_ACTDRVASSTSTSHMI);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_fcm_lka_audio_warningWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_fcm_lka_audio_warning = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_lka_audio_warning");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_fcm_lka_audio_warning = mPropertyManager->getCProValue(mp);
      LOG(INFO) << "bc_fcm_lka_audio_warningWatcher: " << bc_fcm_lka_audio_warning;
      mHal->onPropertyValue(*Create_bc_fcm_lka_audio_warningReq(bc_fcm_lka_audio_warning),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_lka_audio_warningReq(int32_t bc_fcm_lka_audio_warning) {
    auto req = mValueObjectPool->obtainInt32(bc_fcm_lka_audio_warning);
    req->prop = toInt(VehicleProperty::GECKO_FCM_LKA_AUDIOWARNING);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_fcm_fault_text_infoWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_fcm_fault_text_info = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_fault_text_info");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_fcm_fault_text_info = mPropertyManager->getCProValue(mp);
      LOG(INFO)<<"bc_fcm_fault_text_info = " << bc_fcm_fault_text_info;
      mHal->onPropertyValue(*Create_bc_fcm_fault_text_infoReq(bc_fcm_fault_text_info),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_fault_text_infoReq(int32_t bc_fcm_fault_text_info) {
    auto req = mValueObjectPool->obtainInt32(bc_fcm_fault_text_info);
    req->prop = toInt(VehicleProperty::GECKO_FCM_FAULTTEXTINFO);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_fcm_audio_warn_hands_offWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_fcm_audio_warn_hands_off = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_audio_warn_hands_off");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_fcm_audio_warn_hands_off = mPropertyManager->getCProValue(mp);
      LOG(INFO)<<"bc_fcm_audio_warn_hands_off: " << bc_fcm_audio_warn_hands_off;
      mHal->onPropertyValue(*Create_bc_fcm_audio_warn_hands_offReq(bc_fcm_audio_warn_hands_off),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_audio_warn_hands_offReq(int32_t bc_fcm_audio_warn_hands_off) {
    auto req = mValueObjectPool->obtainInt32(bc_fcm_audio_warn_hands_off);
    req->prop = toInt(VehicleProperty::GECKO_FCM_AUDIOWARNHANDSOFF);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_fcm_slif_oper_stsWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_fcm_slif_oper_sts = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_slif_oper_sts");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_fcm_slif_oper_sts = mPropertyManager->getCProValue(mp);
      LOG(INFO)<<"bc_fcm_slif_oper_sts: " << bc_fcm_slif_oper_sts;
      mHal->onPropertyValue(*Create_bc_fcm_slif_oper_stsReq(bc_fcm_slif_oper_sts),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_slif_oper_stsReq(int32_t bc_fcm_slif_oper_sts) {
    auto req = mValueObjectPool->obtainInt32(bc_fcm_slif_oper_sts);
    req->prop = toInt(VehicleProperty::GECKO_FCM_SLIFOPERSTS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_fcm_tsr_spd_limWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_fcm_tsr_spd_lim = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_tsr_spd_lim");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_fcm_tsr_spd_lim = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_fcm_tsr_spd_limReq(bc_fcm_tsr_spd_lim),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_tsr_spd_limReq(int32_t bc_fcm_tsr_spd_lim) {
    auto req = mValueObjectPool->obtainInt32(bc_fcm_tsr_spd_lim);
    req->prop = toInt(VehicleProperty::GECKO_FCM_TSRSPDLIM);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_fcm_tsr_set_fbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_fcm_tsr_set_fb = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_tsr_set_fb");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_fcm_tsr_set_fb = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_fcm_tsr_set_fbReq(bc_fcm_tsr_set_fb),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_tsr_set_fbReq(int32_t bc_fcm_tsr_set_fb) {
    auto req = mValueObjectPool->obtainInt32(bc_fcm_tsr_set_fb);
    req->prop = toInt(VehicleProperty::GECKO_FCM_TSR_SETFB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_fcm_tsr_lat_dstWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_fcm_tsr_lat_dst = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_tsr_lat_dst");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_fcm_tsr_lat_dst = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_fcm_tsr_lat_dstReq(bc_fcm_tsr_lat_dst),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_tsr_lat_dstReq(int32_t bc_fcm_tsr_lat_dst) {
    auto req = mValueObjectPool->obtainInt32(bc_fcm_tsr_lat_dst);
    req->prop = toInt(VehicleProperty::GECKO_FCM_TSR_LATDST);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_fcm_tsr_lgt_dstWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_fcm_tsr_lgt_dst = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_tsr_lgt_dst");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_fcm_tsr_lgt_dst = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_fcm_tsr_lgt_dstReq(bc_fcm_tsr_lgt_dst),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_tsr_lgt_dstReq(int32_t bc_fcm_tsr_lgt_dst) {
    auto req = mValueObjectPool->obtainInt32(bc_fcm_tsr_lgt_dst);
    req->prop = toInt(VehicleProperty::GECKO_FCM_TSRLGTDST);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_fcm_trfc_signWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_fcm_trfc_sign = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_trfc_sign");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_fcm_trfc_sign = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_fcm_trfc_signReq(bc_fcm_trfc_sign),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_trfc_signReq(int32_t bc_fcm_trfc_sign) {
    auto req = mValueObjectPool->obtainInt32(bc_fcm_trfc_sign);
    req->prop = toInt(VehicleProperty::GECKO_FCM_TRFCSIGN);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_fcm_slif_set_fbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_fcm_slif_set_fb = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_slif_set_fb");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_fcm_slif_set_fb = mPropertyManager->getCProValue(mp);
      LOG(INFO) << "bc_fcm_slif_set_fb = " << bc_fcm_slif_set_fb;
      mHal->onPropertyValue(*Create_bc_fcm_slif_set_fbReq(bc_fcm_slif_set_fb),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_slif_set_fbReq(int32_t bc_fcm_slif_set_fb) {
    auto req = mValueObjectPool->obtainInt32(bc_fcm_slif_set_fb);
    req->prop = toInt(VehicleProperty::GECKO_FCM_SLIFSETFB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_fcm_elk_right_modeWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_fcm_elk_right_mode = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_elk_right_mode");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_fcm_elk_right_mode = mPropertyManager->getCProValue(mp);
      LOG(INFO) << "bc_fcm_elk_right_mode = " << bc_fcm_elk_right_mode;
      mHal->onPropertyValue(*Create_bc_fcm_elk_right_modeReq(bc_fcm_elk_right_mode),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_elk_right_modeReq(int32_t bc_fcm_elk_right_mode) {
    auto req = mValueObjectPool->obtainInt32(bc_fcm_elk_right_mode);
    req->prop = toInt(VehicleProperty::GECKO_FCM_ELKRIGHTMODE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_fcm_elk_left_modeWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_fcm_elk_left_mode = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_elk_left_mode");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_fcm_elk_left_mode = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_fcm_elk_left_modeReq(bc_fcm_elk_left_mode),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_elk_left_modeReq(int32_t bc_fcm_elk_left_mode) {
    auto req = mValueObjectPool->obtainInt32(bc_fcm_elk_left_mode);
    req->prop = toInt(VehicleProperty::GECKO_FCM_ELKLEFTMODE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_fcm_fcm_intializationWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_fcm_fcm_intialization = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_fcm_intialization");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_fcm_fcm_intialization = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_fcm_fcm_intializationReq(bc_fcm_fcm_intialization),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_fcm_intializationReq(int32_t bc_fcm_fcm_intialization) {
    auto req = mValueObjectPool->obtainInt32(bc_fcm_fcm_intialization);
    req->prop = toInt(VehicleProperty::GECKO_FCM_FCM_INITIALIZATION);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_fcm_slwf_set_fbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_fcm_slwf_set_fb = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_slwf_set_fb");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_fcm_slwf_set_fb = mPropertyManager->getCProValue(mp);
      LOG(INFO)<<"bc_fcm_slwf_set_fb = " << bc_fcm_slwf_set_fb;
      mHal->onPropertyValue(*Create_bc_fcm_slwf_set_fbReq(bc_fcm_slwf_set_fb),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_slwf_set_fbReq(int32_t bc_fcm_slwf_set_fb) {
    auto req = mValueObjectPool->obtainInt32(bc_fcm_slwf_set_fb);
    req->prop = toInt(VehicleProperty::GECKO_FCM_SLWFSETFB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_fcm_tsr_spd_lim_stsWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_fcm_tsr_spd_lim_sts = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_tsr_spd_lim_sts");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_fcm_tsr_spd_lim_sts = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_fcm_tsr_spd_lim_stsReq(bc_fcm_tsr_spd_lim_sts),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_tsr_spd_lim_stsReq(int32_t bc_fcm_tsr_spd_lim_sts) {
    auto req = mValueObjectPool->obtainInt32(bc_fcm_tsr_spd_lim_sts);
    req->prop = toInt(VehicleProperty::GECKO_FCM_TSRSPDLIMSTS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_fcm_tsr_spd_lim_warn_auWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_fcm_tsr_spd_lim_warn_au = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_tsr_spd_lim_warn_au");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_fcm_tsr_spd_lim_warn_au = mPropertyManager->getCProValue(mp);
      LOG(INFO)<<"bc_fcm_tsr_spd_lim_warn_au: "<<bc_fcm_tsr_spd_lim_warn_au;
      mHal->onPropertyValue(*Create_bc_fcm_tsr_spd_lim_warn_auReq(bc_fcm_tsr_spd_lim_warn_au),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_tsr_spd_lim_warn_auReq(int32_t bc_fcm_tsr_spd_lim_warn_au) {
    auto req = mValueObjectPool->obtainInt32(bc_fcm_tsr_spd_lim_warn_au);
    req->prop = toInt(VehicleProperty::GECKO_FCM_TSRSPDLIMWARNAU);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_fcm_tsr_spd_lim_warnWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_fcm_tsr_spd_lim_warn = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_tsr_spd_lim_warn");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_fcm_tsr_spd_lim_warn = mPropertyManager->getCProValue(mp);
      LOG(INFO)<<"bc_fcm_tsr_spd_lim_warn: "<<bc_fcm_tsr_spd_lim_warn;
      mHal->onPropertyValue(*Create_bc_fcm_tsr_spd_lim_warnReq(bc_fcm_tsr_spd_lim_warn),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_tsr_spd_lim_warnReq(int32_t bc_fcm_tsr_spd_lim_warn) {
    auto req = mValueObjectPool->obtainInt32(bc_fcm_tsr_spd_lim_warn);
    req->prop = toInt(VehicleProperty::GECKO_FCM_TSRSPDLIMWARN);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_fcm_hma_set_fbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_fcm_hma_set_fb = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_hma_set_fb");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_fcm_hma_set_fb = mPropertyManager->getCProValue(mp);
      LOG(INFO)<<"bc_fcm_hma_set_fb: " << bc_fcm_hma_set_fb;
      mHal->onPropertyValue(*Create_bc_fcm_hma_set_fbReq(bc_fcm_hma_set_fb),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_hma_set_fbReq(int32_t bc_fcm_hma_set_fb) {
    auto req = mValueObjectPool->obtainInt32(bc_fcm_hma_set_fb);
    req->prop = toInt(VehicleProperty::GECKO_FCM_HMASETFB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_fcm_aeb_set_fbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_fcm_aeb_set_fb = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_aeb_set_fb");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_fcm_aeb_set_fb = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_fcm_aeb_set_fbReq(bc_fcm_aeb_set_fb),true);
      mHal->onPropertyValue(*Create_bc_fcm_aeb_and_fcw_fbReq(GetFcwAebValue()),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_aeb_set_fbReq(int32_t bc_fcm_aeb_set_fb) {
    auto req = mValueObjectPool->obtainInt32(bc_fcm_aeb_set_fb);
    req->prop = toInt(VehicleProperty::GECKO_FCM_AEBSETFB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_fcm_elk_set_fbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_fcm_elk_set_fb = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_elk_set_fb");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_fcm_elk_set_fb = mPropertyManager->getCProValue(mp);
      LOG(INFO)<<"bc_fcm_elk_set_fb: "<<bc_fcm_elk_set_fb;
      mHal->onPropertyValue(*Create_bc_fcm_elk_set_fbReq(bc_fcm_elk_set_fb),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_elk_set_fbReq(int32_t bc_fcm_elk_set_fb) {
    auto req = mValueObjectPool->obtainInt32(bc_fcm_elk_set_fb);
    req->prop = toInt(VehicleProperty::GECKO_FCM_ELKSETFB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_pp_sw_fdbkWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_pp_sw_fdbk = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_pp_sw_fdbk");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_pp_sw_fdbk = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_pp_sw_fdbkReq(bc_pp_sw_fdbk),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_pp_sw_fdbkReq(int32_t bc_pp_sw_fdbk) {
    auto req = mValueObjectPool->obtainInt32(bc_pp_sw_fdbk);
    req->prop = toInt(VehicleProperty::GECKO_PP_SWFDBK);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_pp_staWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_pp_sta = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_pp_sta");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_pp_sta = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_pp_staReq(bc_pp_sta),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_pp_staReq(int32_t bc_pp_sta) {
    auto req = mValueObjectPool->obtainInt32(bc_pp_sta);
    req->prop = toInt(VehicleProperty::GECKO_PP_STA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_pp_sdwrsr_distWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_pp_sdwrsr_dist = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_pp_sdwrsr_dist");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_pp_sdwrsr_dist = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_pp_sdwrsr_distReq(bc_pp_sdwrsr_dist),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_pp_sdwrsr_distReq(int32_t bc_pp_sdwrsr_dist) {
    auto req = mValueObjectPool->obtainInt32(bc_pp_sdwrsr_dist);
    req->prop = toInt(VehicleProperty::GECKO_PP_SDWRSRDIST);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_pp_sensor_fault_sts_frWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_pp_sensor_fault_sts_fr = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_pp_sensor_fault_sts_fr");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_pp_sensor_fault_sts_fr = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_pp_sensor_fault_sts_frReq(bc_pp_sensor_fault_sts_fr),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_pp_sensor_fault_sts_frReq(int32_t bc_pp_sensor_fault_sts_fr) {
    auto req = mValueObjectPool->obtainInt32(bc_pp_sensor_fault_sts_fr);
    req->prop = toInt(VehicleProperty::GECKO_PP_SENSORFAULTSTSFR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_pp_sensor_fault_sts_frmWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_pp_sensor_fault_sts_frm = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_pp_sensor_fault_sts_frm");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_pp_sensor_fault_sts_frm = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_pp_sensor_fault_sts_frmReq(bc_pp_sensor_fault_sts_frm),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_pp_sensor_fault_sts_frmReq(int32_t bc_pp_sensor_fault_sts_frm) {
    auto req = mValueObjectPool->obtainInt32(bc_pp_sensor_fault_sts_frm);
    req->prop = toInt(VehicleProperty::GECKO_PP_SENSORFAULTSTSFRM);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_pp_sdwfsr_mid_distWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_pp_sdwfsr_mid_dist = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_pp_sdwfsr_mid_dist");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_pp_sdwfsr_mid_dist = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_pp_sdwfsr_mid_distReq(bc_pp_sdwfsr_mid_dist),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_pp_sdwfsr_mid_distReq(int32_t bc_pp_sdwfsr_mid_dist) {
    auto req = mValueObjectPool->obtainInt32(bc_pp_sdwfsr_mid_dist);
    req->prop = toInt(VehicleProperty::GECKO_PP_SDWFSRMIDDIST);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_pp_sdwfsl_mid_distWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_pp_sdwfsl_mid_dist = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_pp_sdwfsl_mid_dist");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_pp_sdwfsl_mid_dist = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_pp_sdwfsl_mid_distReq(bc_pp_sdwfsl_mid_dist),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_pp_sdwfsl_mid_distReq(int32_t bc_pp_sdwfsl_mid_dist) {
    auto req = mValueObjectPool->obtainInt32(bc_pp_sdwfsl_mid_dist);
    req->prop = toInt(VehicleProperty::GECKO_PP_SDWFSLMIDDIST);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_pp_sdwfsl_distWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_pp_sdwfsl_dist = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_pp_sdwfsl_dist");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_pp_sdwfsl_dist = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_pp_sdwfsl_distReq(bc_pp_sdwfsl_dist),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_pp_sdwfsl_distReq(int32_t bc_pp_sdwfsl_dist) {
    auto req = mValueObjectPool->obtainInt32(bc_pp_sdwfsl_dist);
    req->prop = toInt(VehicleProperty::GECKO_PP_SDWFSLDIST);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_door_lock_operation_recordWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_bcm_door_lock_operation_record = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_door_lock_operation_record");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_bcm_door_lock_operation_record = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_bcm_door_lock_operation_recordReq(bc_bcm_door_lock_operation_record),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_door_lock_operation_recordReq(int32_t bc_bcm_door_lock_operation_record) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_door_lock_operation_record);
    req->prop = toInt(VehicleProperty::GECKO_BCM_DOORLOCKOPERATIONRECORD);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_tmps_abnm_prsr_warnWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_tmps_abnm_prsr_warn = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_tmps_abnm_prsr_warn");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_tmps_abnm_prsr_warn = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_tmps_abnm_prsr_warnReq(bc_tmps_abnm_prsr_warn),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_tmps_abnm_prsr_warnReq(int32_t bc_tmps_abnm_prsr_warn) {
    auto req = mValueObjectPool->obtainInt32(bc_tmps_abnm_prsr_warn);
    req->prop = toInt(VehicleProperty::GECKO_TMPS_ABNMPRSRWARN);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_ac_indoor_tempWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_ac_indoor_temp = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ac_indoor_temp");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ac_indoor_temp = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_ac_indoor_tempReq(bc_ac_indoor_temp),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ac_indoor_tempReq(int32_t bc_ac_indoor_temp) {
    auto req = mValueObjectPool->obtainInt32(bc_ac_indoor_temp);
    req->prop = toInt(VehicleProperty::GECKO_AC_INDOORTEMP);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_pp_fl_distWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_pp_fl_dist = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_pp_fl_dist");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_pp_fl_dist = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_pp_fl_distReq(bc_pp_fl_dist),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_pp_fl_distReq(int32_t bc_pp_fl_dist) {
    auto req = mValueObjectPool->obtainInt32(bc_pp_fl_dist);
    req->prop = toInt(VehicleProperty::GECKO_PP_FLDIST);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_pp_fr_distWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_pp_fr_dist = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_pp_fr_dist");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_pp_fr_dist = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_pp_fr_distReq(bc_pp_fr_dist),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_pp_fr_distReq(int32_t bc_pp_fr_dist) {
    auto req = mValueObjectPool->obtainInt32(bc_pp_fr_dist);
    req->prop = toInt(VehicleProperty::GECKO_PP_FRDIST);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_pp_fml_distWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_pp_fml_dist = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_pp_fml_dist");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_pp_fml_dist = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_pp_fml_distReq(bc_pp_fml_dist),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_pp_fml_distReq(int32_t bc_pp_fml_dist) {
    auto req = mValueObjectPool->obtainInt32(bc_pp_fml_dist);
    req->prop = toInt(VehicleProperty::GECKO_PP_FMLDIST);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_inv_antithft_auth_rsltWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_inv_antithft_auth_rslt = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_inv_antithft_auth_rslt");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_inv_antithft_auth_rslt = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_inv_antithft_auth_rsltReq(ec_inv_antithft_auth_rslt),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_inv_antithft_auth_rsltReq(int32_t ec_inv_antithft_auth_rslt) {
    auto req = mValueObjectPool->obtainInt32(ec_inv_antithft_auth_rslt);
    req->prop = toInt(VehicleProperty::GECKO_INV_ANTITHFTAUTHRSLT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_ac_auto_blower_mode_staWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_ac_auto_blower_mode_sta = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ac_auto_blower_mode_sta");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ac_auto_blower_mode_sta = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_ac_auto_blower_mode_staReq(bc_ac_auto_blower_mode_sta),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ac_auto_blower_mode_staReq(int32_t bc_ac_auto_blower_mode_sta) {
    auto req = mValueObjectPool->obtainInt32(bc_ac_auto_blower_mode_sta);
    req->prop = toInt(VehicleProperty::GECKO_AC_AUTOBLOWERMODESTA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

int GarageModeServerSideHandlerImpl::GetFcwAebValue() {
  int ret =0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_fcw_set_fb");
  int32_t fcw_set_fb = mPropertyManager->getCProValue(mp);

  ConfigDBC* mp_aeb = mPropertyManager->findCProperty("bc_fcm_aeb_set_fb");
  int32_t aeb_set_fb = mPropertyManager->getCProValue(mp_aeb);

  if(fcw_set_fb == 1 && aeb_set_fb == 0){
    ret = 0;
  }else if(fcw_set_fb == 2 && aeb_set_fb == 0){
    ret = 1;
  }else if(fcw_set_fb == 1 && aeb_set_fb == 1){
    ret = 2;
  }else if(fcw_set_fb == 2 && aeb_set_fb == 1){
    ret = 3;
  }else if(fcw_set_fb == 0 && aeb_set_fb == 0){
    ret = 4;
  }else if(fcw_set_fb == 0 && aeb_set_fb == 1){
    ret = 5;
  }else if(fcw_set_fb == 3 && aeb_set_fb == 0){
    ret = 6;
  }else if(fcw_set_fb == 3 && aeb_set_fb == 1){
    ret = 7;
  }else if(fcw_set_fb == -1024 || aeb_set_fb == -1024) {
    ret = -1024;
  } 

  LOG(INFO) << "bc_fcm_fcw_set_fb:" << fcw_set_fb<<"  bc_fcm_aeb_set_fb:"<< aeb_set_fb<<"  ret:"<<ret;
  return ret;
}

void GarageModeServerSideHandlerImpl::bc_fcm_fcw_set_fbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_fcw_set_fb");
  int32_t bc_fcm_fcw_set_fb = 0;
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_fcm_fcw_set_fb = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_fcm_fcw_set_fbReq(bc_fcm_fcw_set_fb),true);
      mHal->onPropertyValue(*Create_bc_fcm_aeb_and_fcw_fbReq(GetFcwAebValue()),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_fcw_set_fbReq(int32_t bc_fcm_fcw_set_fb) {
    auto req = mValueObjectPool->obtainInt32(bc_fcm_fcw_set_fb);
    req->prop = toInt(VehicleProperty::GECKO_FCM_FCWSETFB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_aeb_and_fcw_fbReq(int32_t value) {
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_FCM_AEBFCW_SETFB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_ac_extd_defrost_actv_reqWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_ac_extd_defrost_actv_req = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_ac_extd_defrost_actv_req");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_ac_extd_defrost_actv_req = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_ac_extd_defrost_actv_reqReq(bc_ac_extd_defrost_actv_req),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ac_extd_defrost_actv_reqReq(int32_t bc_ac_extd_defrost_actv_req) {
    auto req = mValueObjectPool->obtainInt32(bc_ac_extd_defrost_actv_req);
    req->prop = toInt(VehicleProperty::GECKO_AC_EXTDDEFROSTACTVREQ);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_scs_left_swt_vdWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_scs_left_swt_vd = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_scs_left_swt_vd");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_scs_left_swt_vd = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_scs_left_swt_vdReq(ec_scs_left_swt_vd),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_scs_left_swt_vdReq(int32_t ec_scs_left_swt_vd) {
    auto req = mValueObjectPool->obtainInt32(ec_scs_left_swt_vd);
    req->prop = toInt(VehicleProperty::GECKO_SCS_LEFTSWTVD);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_scs_left_1_swtWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_scs_left_1_swt = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_scs_left_1_swt");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_scs_left_1_swt = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_scs_left_1_swtReq(ec_scs_left_1_swt),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_scs_left_1_swtReq(int32_t ec_scs_left_1_swt) {
    auto req = mValueObjectPool->obtainInt32(ec_scs_left_1_swt);
    req->prop = toInt(VehicleProperty::GECKO_SCS_LEFT_1SWT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_scs_left_2_swtWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_scs_left_2_swt = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_scs_left_2_swt");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_scs_left_2_swt = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_scs_left_1_swtReq(ec_scs_left_2_swt),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_scs_left_2_swtReq(int32_t ec_scs_left_2_swt) {
    auto req = mValueObjectPool->obtainInt32(ec_scs_left_2_swt);
    req->prop = toInt(VehicleProperty::GECKO_SCS_LEFT_2SWT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_scs_left_3_swtWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_scs_left_3_swt = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_scs_left_3_swt");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_scs_left_3_swt = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_scs_left_3_swtReq(ec_scs_left_3_swt),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_scs_left_3_swtReq(int32_t ec_scs_left_3_swt) {
    auto req = mValueObjectPool->obtainInt32(ec_scs_left_3_swt);
    req->prop = toInt(VehicleProperty::GECKO_SCS_LEFT_3SWT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_scs_left_4_swtWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_scs_left_4_swt = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_scs_left_4_swt");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_scs_left_4_swt = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_scs_left_4_swtReq(ec_scs_left_4_swt),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_scs_left_4_swtReq(int32_t ec_scs_left_4_swt) {
    auto req = mValueObjectPool->obtainInt32(ec_scs_left_4_swt);
    req->prop = toInt(VehicleProperty::GECKO_SCS_LEFT_4SWT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_scs_left_5_swtWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_scs_left_5_swt = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_scs_left_5_swt");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_scs_left_5_swt = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_scs_left_5_swtReq(ec_scs_left_5_swt),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_scs_left_5_swtReq(int32_t ec_scs_left_5_swt) {
    auto req = mValueObjectPool->obtainInt32(ec_scs_left_5_swt);
    req->prop = toInt(VehicleProperty::GECKO_SCS_LEFT_5SWT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_scs_left_6_swtWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_scs_left_6_swt = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_scs_left_6_swt");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_scs_left_6_swt = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_scs_left_6_swtReq(ec_scs_left_6_swt),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_scs_left_6_swtReq(int32_t ec_scs_left_6_swt) {
    auto req = mValueObjectPool->obtainInt32(ec_scs_left_6_swt);
    req->prop = toInt(VehicleProperty::GECKO_SCS_LEFT_6SWT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_scs_left_7_swtWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_scs_left_7_swt = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_scs_left_7_swt");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_scs_left_7_swt = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_scs_left_7_swtReq(ec_scs_left_7_swt),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_scs_left_7_swtReq(int32_t ec_scs_left_7_swt) {
    auto req = mValueObjectPool->obtainInt32(ec_scs_left_7_swt);
    req->prop = toInt(VehicleProperty::GECKO_SCS_LEFT_7SWT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_scs_left_8_swtWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_scs_left_8_swt = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_scs_left_8_swt");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_scs_left_8_swt = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_scs_left_8_swtReq(ec_scs_left_8_swt),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_scs_left_8_swtReq(int32_t ec_scs_left_8_swt) {
    auto req = mValueObjectPool->obtainInt32(ec_scs_left_8_swt);
    req->prop = toInt(VehicleProperty::GECKO_SCS_LEFT_8SWT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_avas_state_rolling_counterWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_avas_state_rolling_counter = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_avas_state_rolling_counter");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_avas_state_rolling_counter = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_avas_state_rolling_counterReq(ec_avas_state_rolling_counter),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_avas_state_rolling_counterReq(int32_t ec_avas_state_rolling_counter) {
    auto req = mValueObjectPool->obtainInt32(ec_avas_state_rolling_counter);
    req->prop = toInt(VehicleProperty::GECKO_AVAS_STATE_ROLLINGCOUNTER);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_current_over_wrningWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bms_current_over_wrning = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_current_over_wrning");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_current_over_wrning = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_bms_current_over_wrningReq(ec_bms_current_over_wrning),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_current_over_wrningReq(int32_t ec_bms_current_over_wrning) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_current_over_wrning);
    req->prop = toInt(VehicleProperty::GECKO_BMS_CURRENTOVERWRNING);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_battery_sub_sys_numWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bms_battery_sub_sys_num = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_battery_sub_sys_num");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_battery_sub_sys_num = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_bms_battery_sub_sys_numReq(ec_bms_battery_sub_sys_num),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_battery_sub_sys_numReq(int32_t ec_bms_battery_sub_sys_num) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_battery_sub_sys_num);
    req->prop = toInt(VehicleProperty::GECKO_BMS_BATTERYSUBSYSNUM);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_battery_sub_sys_codWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bms_battery_sub_sys_cod = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_battery_sub_sys_cod");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_battery_sub_sys_cod = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_bms_battery_sub_sys_codReq(ec_bms_battery_sub_sys_cod),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_battery_sub_sys_codReq(int32_t ec_bms_battery_sub_sys_cod) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_battery_sub_sys_cod);
    req->prop = toInt(VehicleProperty::GECKO_BMS_BATTERYSUBSYSCOD);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_battery_dtc_numWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bms_battery_dtc_num = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_battery_dtc_num");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_battery_dtc_num = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_bms_battery_dtc_numReq(ec_bms_battery_dtc_num),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_battery_dtc_numReq(int32_t ec_bms_battery_dtc_num) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_battery_dtc_num);
    req->prop = toInt(VehicleProperty::GECKO_BMS_BATTERYDTC_NUM);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_battery_dtc_listWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bms_battery_dtc_list = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_battery_dtc_list");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_battery_dtc_list = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_bms_battery_dtc_listReq(ec_bms_battery_dtc_list),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_battery_dtc_listReq(int32_t ec_bms_battery_dtc_list) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_battery_dtc_list);
    req->prop = toInt(VehicleProperty::GECKO_BMS_BATTERYDTC_LIST);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_battery_dtc_indexWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bms_battery_dtc_index = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_battery_dtc_index");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_battery_dtc_index = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_bms_battery_dtc_indexReq(ec_bms_battery_dtc_index),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_battery_dtc_indexReq(int32_t ec_bms_battery_dtc_index) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_battery_dtc_index);
    req->prop = toInt(VehicleProperty::GECKO_BMS_BATTERYDTC_INDEX);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_inv_1_rolling_counterWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_inv_1_rolling_counter = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_inv_1_rolling_counter");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_inv_1_rolling_counter = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_inv_1_rolling_counterReq(ec_inv_1_rolling_counter),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_inv_1_rolling_counterReq(int32_t ec_inv_1_rolling_counter) {
    auto req = mValueObjectPool->obtainInt32(ec_inv_1_rolling_counter);
    req->prop = toInt(VehicleProperty::GECKO_INV_1_ROLLINGCOUNTER);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_inv_4_err_bitsWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_inv_4_err_bits = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_inv_4_err_bits");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_inv_4_err_bits = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_inv_4_err_bitsReq(ec_inv_4_err_bits),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_inv_4_err_bitsReq(int32_t ec_inv_4_err_bits) {
    auto req = mValueObjectPool->obtainInt32(ec_inv_4_err_bits);
    req->prop = toInt(VehicleProperty::GECKO_INV_4_ERRBITS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_inv_4_rolling_counterWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_inv_4_rolling_counter = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_inv_4_rolling_counter");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_inv_4_rolling_counter = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_inv_4_rolling_counterReq(ec_inv_4_rolling_counter),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_inv_4_rolling_counterReq(int32_t ec_inv_4_rolling_counter) {
    auto req = mValueObjectPool->obtainInt32(ec_inv_4_rolling_counter);
    req->prop = toInt(VehicleProperty::GECKO_INV_4_ROLLINGCOUNTER);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_scs_right_swt_vdWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_scs_right_swt_vd = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_scs_right_swt_vd");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_scs_right_swt_vd = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_scs_right_swt_vdReq(ec_scs_right_swt_vd),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_scs_right_swt_vdReq(int32_t ec_scs_right_swt_vd) {
    auto req = mValueObjectPool->obtainInt32(ec_scs_right_swt_vd);
    req->prop = toInt(VehicleProperty::GECKO_SCS_RIGHTSWTVD);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_scs_right_14_swtWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_scs_right_14_swt = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_scs_right_14_swt");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_scs_right_14_swt = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_scs_right_14_swtReq(ec_scs_right_14_swt),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_scs_right_14_swtReq(int32_t ec_scs_right_14_swt) {
    auto req = mValueObjectPool->obtainInt32(ec_scs_right_14_swt);
    req->prop = toInt(VehicleProperty::GECKO_SCS_RIGHT_14SWT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_scs_right_15_swtWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_scs_right_15_swt = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_scs_right_15_swt");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_scs_right_15_swt = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_scs_right_15_swtReq(ec_scs_right_15_swt),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_scs_right_15_swtReq(int32_t ec_scs_right_15_swt) {
    auto req = mValueObjectPool->obtainInt32(ec_scs_right_15_swt);
    req->prop = toInt(VehicleProperty::GECKO_SCS_RIGHT_15SWT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_scs_right_16_swtWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_scs_right_16_swt = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_scs_right_16_swt");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_scs_right_16_swt = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_scs_right_16_swtReq(ec_scs_right_16_swt),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_scs_right_16_swtReq(int32_t ec_scs_right_16_swt) {
    auto req = mValueObjectPool->obtainInt32(ec_scs_right_16_swt);
    req->prop = toInt(VehicleProperty::GECKO_SCS_RIGHT_16SWT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_crrr_bsd_warn_rightWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_crrr_bsd_warn_right = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_crrr_bsd_warn_right");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_crrr_bsd_warn_right = mPropertyManager->getCProValue(mp);
      LOG(INFO) << "ec_crrr_bsd_warn_right: " << ec_crrr_bsd_warn_right;
      mHal->onPropertyValue(*Create_ec_crrr_bsd_warn_rightReq(ec_crrr_bsd_warn_right),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_crrr_bsd_warn_rightReq(int32_t ec_crrr_bsd_warn_right) {
    auto req = mValueObjectPool->obtainInt32(ec_crrr_bsd_warn_right);
    req->prop = toInt(VehicleProperty::GECKO_CRRR_BSD_WARN_RIGHT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_crrr_bsd_warn_leftWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_crrr_bsd_warn_left = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_crrr_bsd_warn_left");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_crrr_bsd_warn_left = mPropertyManager->getCProValue(mp);
      LOG(INFO) << "ec_crrr_bsd_warn_left: " << ec_crrr_bsd_warn_left;
      mHal->onPropertyValue(*Create_ec_crrr_bsd_warn_leftReq(ec_crrr_bsd_warn_left),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_crrr_bsd_warn_leftReq(int32_t ec_crrr_bsd_warn_left) {
    auto req = mValueObjectPool->obtainInt32(ec_crrr_bsd_warn_left);
    req->prop = toInt(VehicleProperty::GECKO_CRRR_BSD_WARN_LEFT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_crrr_bsd_set_fbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_crrr_bsd_set_fb = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_crrr_bsd_set_fb");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_crrr_bsd_set_fb = mPropertyManager->getCProValue(mp);
      LOG(INFO)<<"ec_crrr_bsd_set_fb = " << ec_crrr_bsd_set_fb;
      mHal->onPropertyValue(*Create_ec_crrr_bsd_set_fbReq(ec_crrr_bsd_set_fb),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_crrr_bsd_set_fbReq(int32_t ec_crrr_bsd_set_fb) {
    auto req = mValueObjectPool->obtainInt32(ec_crrr_bsd_set_fb);
    req->prop = toInt(VehicleProperty::GECKO_CRRR_BSD_SETFB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_crrr_rcta_warn_rightWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_crrr_rcta_warn_right = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_crrr_rcta_warn_right");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_crrr_rcta_warn_right = mPropertyManager->getCProValue(mp);
      LOG(INFO)<<"ec_crrr_rcta_warn_right = " << ec_crrr_rcta_warn_right;
      mHal->onPropertyValue(*Create_ec_crrr_rcta_warn_rightReq(ec_crrr_rcta_warn_right),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_crrr_rcta_warn_rightReq(int32_t ec_crrr_rcta_warn_right) {
    auto req = mValueObjectPool->obtainInt32(ec_crrr_rcta_warn_right);
    req->prop = toInt(VehicleProperty::GECKO_CRRR_RCTA_WARN_RIGHT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_crrr_rcta_warn_leftWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_crrr_rcta_warn_left = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_crrr_rcta_warn_left");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_crrr_rcta_warn_left = mPropertyManager->getCProValue(mp);
      LOG(INFO)<<"ec_crrr_rcta_warn_left = " << ec_crrr_rcta_warn_left;
      mHal->onPropertyValue(*Create_ec_crrr_rcta_warn_leftReq(ec_crrr_rcta_warn_left),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_crrr_rcta_warn_leftReq(int32_t ec_crrr_rcta_warn_left) {
    auto req = mValueObjectPool->obtainInt32(ec_crrr_rcta_warn_left);
    req->prop = toInt(VehicleProperty::GECKO_CRRR_RCTA_WARN_LEFT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_crrr_rcta_set_fbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_crrr_rcta_set_fb = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_crrr_rcta_set_fb");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_crrr_rcta_set_fb = mPropertyManager->getCProValue(mp);
      LOG(INFO)<< "ec_crrr_rcta_set_fbWatcher: " << ec_crrr_rcta_set_fb;
      mHal->onPropertyValue(*Create_ec_crrr_rcta_set_fbReq(ec_crrr_rcta_set_fb),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_crrr_rcta_set_fbReq(int32_t ec_crrr_rcta_set_fb) {
    auto req = mValueObjectPool->obtainInt32(ec_crrr_rcta_set_fb);
    req->prop = toInt(VehicleProperty::GECKO_CRRR_RCTA_SETFB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_crrr_rcw_warningWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_crrr_rcw_warning = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_crrr_rcw_warning");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_crrr_rcw_warning = mPropertyManager->getCProValue(mp);
      LOG(INFO)<< "ec_crrr_rcw_warning: " << ec_crrr_rcw_warning;
      mHal->onPropertyValue(*Create_ec_crrr_rcw_warningReq(ec_crrr_rcw_warning),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_crrr_rcw_warningReq(int32_t ec_crrr_rcw_warning) {
    auto req = mValueObjectPool->obtainInt32(ec_crrr_rcw_warning);
    req->prop = toInt(VehicleProperty::GECKO_CRRR_RCW_WARNING);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_crrr_rcw_set_fbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_crrr_rcw_set_fb = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_crrr_rcw_set_fb");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_crrr_rcw_set_fb = mPropertyManager->getCProValue(mp);
      LOG(INFO)<<"ec_crrr_rcw_set_fb: " << ec_crrr_rcw_set_fb;
      mHal->onPropertyValue(*Create_ec_crrr_rcw_set_fbReq(ec_crrr_rcw_set_fb),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_crrr_rcw_set_fbReq(int32_t ec_crrr_rcw_set_fb) {
    auto req = mValueObjectPool->obtainInt32(ec_crrr_rcw_set_fb);
    req->prop = toInt(VehicleProperty::GECKO_CRRR_RCW_SETFB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_crrr_rear_corner_failureWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_crrr_rear_corner_failure = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_crrr_rear_corner_failure");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_crrr_rear_corner_failure = mPropertyManager->getCProValue(mp);
      LOG(INFO)<<"ec_crrr_rear_corner_failure: " << ec_crrr_rear_corner_failure;
      mHal->onPropertyValue(*Create_ec_crrr_rear_corner_failureReq(ec_crrr_rear_corner_failure),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_crrr_rear_corner_failureReq(int32_t ec_crrr_rear_corner_failure) {
    auto req = mValueObjectPool->obtainInt32(ec_crrr_rear_corner_failure);
    req->prop = toInt(VehicleProperty::GECKO_CRRR_REARCORNERFAILURE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_crrr_rear_corner_blindnessWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_crrr_rear_corner_blindness = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_crrr_rear_corner_blindness");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_crrr_rear_corner_blindness = mPropertyManager->getCProValue(mp);
      LOG(INFO)<<"ec_crrr_rear_corner_blindness = " << ec_crrr_rear_corner_blindness;
      mHal->onPropertyValue(*Create_ec_crrr_rear_corner_blindnessReq(ec_crrr_rear_corner_blindness),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_crrr_rear_corner_blindnessReq(int32_t ec_crrr_rear_corner_blindness) {
    auto req = mValueObjectPool->obtainInt32(ec_crrr_rear_corner_blindness);
    req->prop = toInt(VehicleProperty::GECKO_CRRR_REARCORNERBLINDNESS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_crrr_dow_set_fbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_crrr_dow_set_fb = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_crrr_dow_set_fb");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_crrr_dow_set_fb = mPropertyManager->getCProValue(mp);
      LOG(INFO)<<"ec_crrr_dow_set_fb: " << ec_crrr_dow_set_fb;
      mHal->onPropertyValue(*Create_ec_crrr_dow_set_fbReq(ec_crrr_dow_set_fb),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_crrr_dow_set_fbReq(int32_t ec_crrr_dow_set_fb) {
    auto req = mValueObjectPool->obtainInt32(ec_crrr_dow_set_fb);
    req->prop = toInt(VehicleProperty::GECKO_CRRR_DOWSETFB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_crrr_dow_warn_frWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_crrr_dow_warn_fr = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_crrr_dow_warn_fr");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_crrr_dow_warn_fr = mPropertyManager->getCProValue(mp);
      LOG(INFO)<<"ec_crrr_dow_warn_fr: " << ec_crrr_dow_warn_fr;
      mHal->onPropertyValue(*Create_ec_crrr_dow_warn_frReq(ec_crrr_dow_warn_fr),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_crrr_dow_warn_frReq(int32_t ec_crrr_dow_warn_fr) {
    auto req = mValueObjectPool->obtainInt32(ec_crrr_dow_warn_fr);
    req->prop = toInt(VehicleProperty::GECKO_CRRR_DOWWARNFR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_crrr_dow_warn_flWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_crrr_dow_warn_fl = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_crrr_dow_warn_fl");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_crrr_dow_warn_fl = mPropertyManager->getCProValue(mp);
      LOG(INFO) << "ec_crrr_dow_warn_fl = " << ec_crrr_dow_warn_fl;
      mHal->onPropertyValue(*Create_ec_crrr_dow_warn_flReq(ec_crrr_dow_warn_fl),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_crrr_dow_warn_flReq(int32_t ec_crrr_dow_warn_fl) {
    auto req = mValueObjectPool->obtainInt32(ec_crrr_dow_warn_fl);
    req->prop = toInt(VehicleProperty::GECKO_CRRR_DOWWARNFL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_crrr_dow_warn_rrWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_crrr_dow_warn_rr = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_crrr_dow_warn_rr");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_crrr_dow_warn_rr = mPropertyManager->getCProValue(mp);
      LOG(INFO) << "ec_crrr_dow_warn_rr = " << ec_crrr_dow_warn_rr;
      mHal->onPropertyValue(*Create_ec_crrr_dow_warn_rrReq(ec_crrr_dow_warn_rr),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_crrr_dow_warn_rrReq(int32_t ec_crrr_dow_warn_rr) {
    auto req = mValueObjectPool->obtainInt32(ec_crrr_dow_warn_rr);
    req->prop = toInt(VehicleProperty::GECKO_CRRR_DOWWARNRR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_crrr_dow_warn_rlWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_crrr_dow_warn_rl = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_crrr_dow_warn_rl");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_crrr_dow_warn_rl = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_crrr_dow_warn_rlReq(ec_crrr_dow_warn_rl),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_crrr_dow_warn_rlReq(int32_t ec_crrr_dow_warn_rl) {
    auto req = mValueObjectPool->obtainInt32(ec_crrr_dow_warn_rl);
    req->prop = toInt(VehicleProperty::GECKO_CRRR_DOWWARNRL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_crrr_dow_warn_rightWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_crrr_dow_warn_right = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_crrr_dow_warn_right");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_crrr_dow_warn_right = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_crrr_dow_warn_rightReq(ec_crrr_dow_warn_right),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_crrr_dow_warn_rightReq(int32_t ec_crrr_dow_warn_right) {
    auto req = mValueObjectPool->obtainInt32(ec_crrr_dow_warn_right);
    req->prop = toInt(VehicleProperty::GECKO_CRRR_DOW_WARN_RIGHT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_crrr_dow_warn_leftWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_crrr_dow_warn_left = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_crrr_dow_warn_left");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_crrr_dow_warn_left = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_crrr_dow_warn_leftReq(ec_crrr_dow_warn_left),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_crrr_dow_warn_leftReq(int32_t ec_crrr_dow_warn_left) {
    auto req = mValueObjectPool->obtainInt32(ec_crrr_dow_warn_left);
    req->prop = toInt(VehicleProperty::GECKO_CRRR_DOW_WARN_LEFT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_typ1Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_typ1 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_typ1");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_typ1 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_typ1Req(ec_fcm_obj_typ1),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_typ1Req(int32_t ec_fcm_obj_typ1) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_typ1);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJTYP1);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_lat_dst1Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_lat_dst1 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_lat_dst1");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_lat_dst1 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.1, -6.4));
      LOG(INFO) << "ec_fcm_obj_lat_dst1: " << ec_fcm_obj_lat_dst1;
      mHal->onPropertyValue(*Create_ec_fcm_obj_lat_dst1Req(ec_fcm_obj_lat_dst1),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_lat_dst1Req(int32_t ec_fcm_obj_lat_dst1) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_lat_dst1);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJLATDST1);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_lgt_dst1Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_lgt_dst1 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_lgt_dst1");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_lgt_dst1 = round(getActualFloatValue(mPropertyManager->getCProValue(mp), 0.5, -100));
      LOG(INFO)<<"ec_fcm_obj_lgt_dst1: "<<ec_fcm_obj_lgt_dst1;
      mHal->onPropertyValue(*Create_ec_fcm_obj_lgt_dst1Req(ec_fcm_obj_lgt_dst1),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_lgt_dst1Req(int32_t ec_fcm_obj_lgt_dst1) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_lgt_dst1);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJLGTDST1);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_lgt_rel_spd1Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_lgt_rel_spd1 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_lgt_rel_spd1");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_lgt_rel_spd1 = round(getActualFloatValue(mPropertyManager->getCProValue(mp), 5, -130));
      mHal->onPropertyValue(*Create_ec_fcm_lgt_rel_spd1Req(ec_fcm_lgt_rel_spd1),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_lgt_rel_spd1Req(int32_t ec_fcm_lgt_rel_spd1) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_lgt_rel_spd1);
    req->prop = toInt(VehicleProperty::GECKO_FCM_LGTRELSPD1);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_posn_agl1Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_posn_agl1 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_posn_agl1");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_posn_agl1 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.01, -3.14));
      mHal->onPropertyValue(*Create_ec_fcm_obj_posn_agl1Req(ec_fcm_obj_posn_agl1),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_posn_agl1Req(int32_t ec_fcm_obj_posn_agl1) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_posn_agl1);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJPOSNAGL1);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_dir1Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_movmt_dir1 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_movmt_dir1");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_movmt_dir1 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_movmt_dir1Req(ec_fcm_obj_movmt_dir1),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_movmt_dir1Req(int32_t ec_fcm_obj_movmt_dir1) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_movmt_dir1);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJMOVMTDIR1);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_sta1Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_movmt_sta1 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_movmt_sta1");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_movmt_sta1 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_movmt_sta1Req(ec_fcm_obj_movmt_sta1),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_movmt_sta1Req(int32_t ec_fcm_obj_movmt_sta1) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_movmt_sta1);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJMOVMTSTA1);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_fcm_obj_typ2Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_typ2 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_typ2");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_typ2 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_typ2Req(ec_fcm_obj_typ2),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_typ2Req(int32_t ec_fcm_obj_typ2) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_typ2);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJTYP2);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_lat_dst2Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_lat_dst2 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_lat_dst2");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_lat_dst2 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.1, -6.4));
      mHal->onPropertyValue(*Create_ec_fcm_obj_lat_dst2Req(ec_fcm_obj_lat_dst2),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_lat_dst2Req(int32_t ec_fcm_obj_lat_dst2) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_lat_dst2);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJLATDST2);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_lgt_dst2Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_lgt_dst2 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_lgt_dst2");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_lgt_dst2 = round(getActualFloatValue(mPropertyManager->getCProValue(mp), 0.5, -100));
      mHal->onPropertyValue(*Create_ec_fcm_obj_lgt_dst2Req(ec_fcm_obj_lgt_dst2),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_lgt_dst2Req(int32_t ec_fcm_obj_lgt_dst2) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_lgt_dst2);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJLGTDST2);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_lgt_rel_spd2Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_lgt_rel_spd2 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_lgt_rel_spd2");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_lgt_rel_spd2 = round(getActualFloatValue(mPropertyManager->getCProValue(mp), 5, -130));
      mHal->onPropertyValue(*Create_ec_fcm_lgt_rel_spd2Req(ec_fcm_lgt_rel_spd2),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_lgt_rel_spd2Req(int32_t ec_fcm_lgt_rel_spd2) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_lgt_rel_spd2);
    req->prop = toInt(VehicleProperty::GECKO_FCM_LGTRELSPD2);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_posn_agl2Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_posn_agl2 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_posn_agl2");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_posn_agl2 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.01, -3.14));
      mHal->onPropertyValue(*Create_ec_fcm_obj_posn_agl2Req(ec_fcm_obj_posn_agl2),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_posn_agl2Req(int32_t ec_fcm_obj_posn_agl2) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_posn_agl2);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJPOSNAGL2);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_dir2Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_movmt_dir2 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_movmt_dir2");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_movmt_dir2 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_movmt_dir2Req(ec_fcm_obj_movmt_dir2),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_movmt_dir2Req(int32_t ec_fcm_obj_movmt_dir2) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_movmt_dir2);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJMOVMTDIR2);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_sta2Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_movmt_sta2 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_movmt_sta2");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_movmt_sta2 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_movmt_sta2Req(ec_fcm_obj_movmt_sta2),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_movmt_sta2Req(int32_t ec_fcm_obj_movmt_sta2) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_movmt_sta2);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJMOVMTSTA2);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_typ3Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_typ3 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_typ3");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_typ3 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_typ3Req(ec_fcm_obj_typ3),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_typ3Req(int32_t ec_fcm_obj_typ3) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_typ3);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJTYP3);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_lat_dst3Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_lat_dst3 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_lat_dst3");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_lat_dst3 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.1, -6.4));
      mHal->onPropertyValue(*Create_ec_fcm_obj_lat_dst3Req(ec_fcm_obj_lat_dst3),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_lat_dst3Req(int32_t ec_fcm_obj_lat_dst3) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_lat_dst3);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJLATDST3);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_lgt_dst3Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_lgt_dst3 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_lgt_dst3");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_lgt_dst3 = round(getActualFloatValue(mPropertyManager->getCProValue(mp), 0.5, -100));
      mHal->onPropertyValue(*Create_ec_fcm_obj_lgt_dst3Req(ec_fcm_obj_lgt_dst3),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_lgt_dst3Req(int32_t ec_fcm_obj_lgt_dst3) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_lgt_dst3);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJLGTDST3);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_lgt_rel_spd3Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_lgt_rel_spd3 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_lgt_rel_spd3");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_lgt_rel_spd3 = round(getActualFloatValue(mPropertyManager->getCProValue(mp), 5, -130));
      mHal->onPropertyValue(*Create_ec_fcm_lgt_rel_spd3Req(ec_fcm_lgt_rel_spd3),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_lgt_rel_spd3Req(int32_t ec_fcm_lgt_rel_spd3) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_lgt_rel_spd3);
    req->prop = toInt(VehicleProperty::GECKO_FCM_LGTRELSPD3);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_posn_agl3Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_posn_agl3 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_posn_agl3");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_posn_agl3 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.01, -3.14));
      mHal->onPropertyValue(*Create_ec_fcm_obj_posn_agl3Req(ec_fcm_obj_posn_agl3),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_posn_agl3Req(int32_t ec_fcm_obj_posn_agl3) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_posn_agl3);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJPOSNAGL3);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_dir3Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_movmt_dir3 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_movmt_dir3");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_movmt_dir3 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_movmt_dir3Req(ec_fcm_obj_movmt_dir3),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_movmt_dir3Req(int32_t ec_fcm_obj_movmt_dir3) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_movmt_dir3);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJMOVMTDIR3);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_sta3Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_movmt_sta3 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_movmt_sta3");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_movmt_sta3 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_movmt_sta3Req(ec_fcm_obj_movmt_sta3),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_movmt_sta3Req(int32_t ec_fcm_obj_movmt_sta3) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_movmt_sta3);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJMOVMTSTA3);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_typ4Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_typ4 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_typ4");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_typ4 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_typ4Req(ec_fcm_obj_typ4),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_typ4Req(int32_t ec_fcm_obj_typ4) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_typ4);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJTYP4);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_lat_dst4Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_lat_dst4 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_lat_dst4");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_lat_dst4 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.1, -6.4));
      mHal->onPropertyValue(*Create_ec_fcm_obj_lat_dst4Req(ec_fcm_obj_lat_dst4),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_lat_dst4Req(int32_t ec_fcm_obj_lat_dst4) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_lat_dst4);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJLATDST4);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_lgt_dst4Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_lgt_dst4 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_lgt_dst4");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_lgt_dst4 = round(getActualFloatValue(mPropertyManager->getCProValue(mp), 0.5, -100));
      mHal->onPropertyValue(*Create_ec_fcm_obj_lgt_dst4Req(ec_fcm_obj_lgt_dst4),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_lgt_dst4Req(int32_t ec_fcm_obj_lgt_dst4) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_lgt_dst4);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJLGTDST4);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_lgt_rel_spd4Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_lgt_rel_spd4 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_lgt_rel_spd4");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_lgt_rel_spd4 = round(getActualFloatValue(mPropertyManager->getCProValue(mp), 5, -130));
      mHal->onPropertyValue(*Create_ec_fcm_lgt_rel_spd4Req(ec_fcm_lgt_rel_spd4),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_lgt_rel_spd4Req(int32_t ec_fcm_lgt_rel_spd4) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_lgt_rel_spd4);
    req->prop = toInt(VehicleProperty::GECKO_FCM_LGTRELSPD4);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_posn_agl4Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_posn_agl4 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_posn_agl4");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_posn_agl4 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.01, -3.14));
      mHal->onPropertyValue(*Create_ec_fcm_obj_posn_agl4Req(ec_fcm_obj_posn_agl4),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_posn_agl4Req(int32_t ec_fcm_obj_posn_agl4) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_posn_agl4);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJPOSNAGL4);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_dir4Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_movmt_dir4 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_movmt_dir4");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_movmt_dir4 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_movmt_dir4Req(ec_fcm_obj_movmt_dir4),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_movmt_dir4Req(int32_t ec_fcm_obj_movmt_dir4) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_movmt_dir4);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJMOVMTDIR4);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_sta4Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_movmt_sta4 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_movmt_sta4");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_movmt_sta4 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_movmt_sta4Req(ec_fcm_obj_movmt_sta4),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_movmt_sta4Req(int32_t ec_fcm_obj_movmt_sta4) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_movmt_sta4);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJMOVMTSTA4);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_typ5Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_typ5 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_typ5");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_typ5 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_typ5Req(ec_fcm_obj_typ5),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_typ5Req(int32_t ec_fcm_obj_typ5) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_typ5);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJTYP5);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_lat_dst5Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_lat_dst5 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_lat_dst5");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_lat_dst5 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.1, -6.4));
      mHal->onPropertyValue(*Create_ec_fcm_obj_lat_dst5Req(ec_fcm_obj_lat_dst5),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_lat_dst5Req(int32_t ec_fcm_obj_lat_dst5) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_lat_dst5);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJLATDST5);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_lgt_dst5Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_lgt_dst5 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_lgt_dst5");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_lgt_dst5 = round(getActualFloatValue(mPropertyManager->getCProValue(mp), 0.5, -100));
      mHal->onPropertyValue(*Create_ec_fcm_obj_lgt_dst5Req(ec_fcm_obj_lgt_dst5),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_lgt_dst5Req(int32_t ec_fcm_obj_lgt_dst5) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_lgt_dst5);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJLGTDST5);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_lgt_rel_spd5Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_lgt_rel_spd5 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_lgt_rel_spd5");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_lgt_rel_spd5 = round(getActualFloatValue(mPropertyManager->getCProValue(mp), 5, -130));
      mHal->onPropertyValue(*Create_ec_fcm_lgt_rel_spd5Req(ec_fcm_lgt_rel_spd5),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_lgt_rel_spd5Req(int32_t ec_fcm_lgt_rel_spd5) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_lgt_rel_spd5);
    req->prop = toInt(VehicleProperty::GECKO_FCM_LGTRELSPD5);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_posn_agl5Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_posn_agl5 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_posn_agl5");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_posn_agl5 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.01, -3.14));
      mHal->onPropertyValue(*Create_ec_fcm_obj_posn_agl5Req(ec_fcm_obj_posn_agl5),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_posn_agl5Req(int32_t ec_fcm_obj_posn_agl5) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_posn_agl5);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJPOSNAGL5);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_dir5Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_movmt_dir5 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_movmt_dir5");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_movmt_dir5 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_movmt_dir5Req(ec_fcm_obj_movmt_dir5),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_movmt_dir5Req(int32_t ec_fcm_obj_movmt_dir5) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_movmt_dir5);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJMOVMTDIR5);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_sta5Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_movmt_sta5 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_movmt_sta5");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_movmt_sta5 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_movmt_sta5Req(ec_fcm_obj_movmt_sta5),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_movmt_sta5Req(int32_t ec_fcm_obj_movmt_sta5) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_movmt_sta5);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJMOVMTSTA5);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_typ6Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_typ6 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_typ6");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_typ6 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_typ6Req(ec_fcm_obj_typ6),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_typ6Req(int32_t ec_fcm_obj_typ6) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_typ6);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJTYP6);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_lat_dst6Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_lat_dst6 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_lat_dst6");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_lat_dst6 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.1, -6.4));
      mHal->onPropertyValue(*Create_ec_fcm_obj_lat_dst6Req(ec_fcm_obj_lat_dst6),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_lat_dst6Req(int32_t ec_fcm_obj_lat_dst6) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_lat_dst6);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJLATDST6);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_lgt_dst6Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_lgt_dst6 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_lgt_dst6");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_lgt_dst6 = round(getActualFloatValue(mPropertyManager->getCProValue(mp), 0.5, -100));
      mHal->onPropertyValue(*Create_ec_fcm_obj_lgt_dst6Req(ec_fcm_obj_lgt_dst6),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_lgt_dst6Req(int32_t ec_fcm_obj_lgt_dst6) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_lgt_dst6);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJLGTDST6);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_lgt_rel_spd6Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_lgt_rel_spd6 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_lgt_rel_spd6");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_lgt_rel_spd6 = round(getActualFloatValue(mPropertyManager->getCProValue(mp), 5, -130));
      mHal->onPropertyValue(*Create_ec_fcm_lgt_rel_spd6Req(ec_fcm_lgt_rel_spd6),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_lgt_rel_spd6Req(int32_t ec_fcm_lgt_rel_spd6) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_lgt_rel_spd6);
    req->prop = toInt(VehicleProperty::GECKO_FCM_LGTRELSPD6);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_posn_agl6Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_posn_agl6 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_posn_agl6");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_posn_agl6 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.01, -3.14));
      mHal->onPropertyValue(*Create_ec_fcm_obj_posn_agl6Req(ec_fcm_obj_posn_agl6),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_posn_agl6Req(int32_t ec_fcm_obj_posn_agl6) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_posn_agl6);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJPOSNAGL6);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_dir6Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_movmt_dir6 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_movmt_dir6");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_movmt_dir6 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_movmt_dir6Req(ec_fcm_obj_movmt_dir6),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_movmt_dir6Req(int32_t ec_fcm_obj_movmt_dir6) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_movmt_dir6);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJMOVMTDIR6);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_sta6Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_movmt_sta6 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_movmt_sta6");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_movmt_sta6 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_movmt_sta6Req(ec_fcm_obj_movmt_sta6),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_movmt_sta6Req(int32_t ec_fcm_obj_movmt_sta6) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_movmt_sta6);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJMOVMTSTA6);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_typ7Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_typ7 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_typ7");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_typ7 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_typ7Req(ec_fcm_obj_typ7),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_typ7Req(int32_t ec_fcm_obj_typ7) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_typ7);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJTYP7);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_lat_dst7Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_lat_dst7 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_lat_dst7");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_lat_dst7 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.1, -6.4));
      mHal->onPropertyValue(*Create_ec_fcm_obj_lat_dst7Req(ec_fcm_obj_lat_dst7),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_lat_dst7Req(int32_t ec_fcm_obj_lat_dst7) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_lat_dst7);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJLATDST7);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_lgt_dst7Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_lgt_dst7 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_lgt_dst7");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_lgt_dst7 = round(getActualFloatValue(mPropertyManager->getCProValue(mp), 0.5, -100));
      mHal->onPropertyValue(*Create_ec_fcm_obj_lgt_dst7Req(ec_fcm_obj_lgt_dst7),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_lgt_dst7Req(int32_t ec_fcm_obj_lgt_dst7) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_lgt_dst7);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJLGTDST7);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_lgt_rel_spd7Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_lgt_rel_spd7 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_lgt_rel_spd7");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_lgt_rel_spd7 = round(getActualFloatValue(mPropertyManager->getCProValue(mp), 5, -130));
      mHal->onPropertyValue(*Create_ec_fcm_lgt_rel_spd7Req(ec_fcm_lgt_rel_spd7),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_lgt_rel_spd7Req(int32_t ec_fcm_lgt_rel_spd7) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_lgt_rel_spd7);
    req->prop = toInt(VehicleProperty::GECKO_FCM_LGTRELSPD7);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_posn_agl7Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_posn_agl7 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_posn_agl7");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_posn_agl7 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.01, -3.14));
      mHal->onPropertyValue(*Create_ec_fcm_obj_posn_agl7Req(ec_fcm_obj_posn_agl7),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_posn_agl7Req(int32_t ec_fcm_obj_posn_agl7) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_posn_agl7);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJPOSNAGL7);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_dir7Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_movmt_dir7 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_movmt_dir7");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_movmt_dir7 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_movmt_dir7Req(ec_fcm_obj_movmt_dir7),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_movmt_dir7Req(int32_t ec_fcm_obj_movmt_dir7) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_movmt_dir7);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJMOVMTDIR7);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_sta7Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_movmt_sta7 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_movmt_sta7");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_movmt_sta7 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_movmt_sta7Req(ec_fcm_obj_movmt_sta7),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_movmt_sta7Req(int32_t ec_fcm_obj_movmt_sta7) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_movmt_sta7);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJMOVMTSTA7);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_fcm_obj_typ8Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_typ8 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_typ8");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_typ8 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_typ8Req(ec_fcm_obj_typ8),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_typ8Req(int32_t ec_fcm_obj_typ8) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_typ8);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJTYP8);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_lat_dst8Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_lat_dst8 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_lat_dst8");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_lat_dst8 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.1, -6.4));
      mHal->onPropertyValue(*Create_ec_fcm_obj_lat_dst8Req(ec_fcm_obj_lat_dst8),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_lat_dst8Req(int32_t ec_fcm_obj_lat_dst8) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_lat_dst8);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJLATDST8);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_lgt_dst8Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_lgt_dst8 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_lgt_dst8");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_lgt_dst8 = round(getActualFloatValue(mPropertyManager->getCProValue(mp), 0.5, -100));
      mHal->onPropertyValue(*Create_ec_fcm_obj_lgt_dst8Req(ec_fcm_obj_lgt_dst8),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_lgt_dst8Req(int32_t ec_fcm_obj_lgt_dst8) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_lgt_dst8);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJLGTDST8);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_lgt_rel_spd8Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_lgt_rel_spd8 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_lgt_rel_spd8");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_lgt_rel_spd8 = round(getActualFloatValue(mPropertyManager->getCProValue(mp), 5, -130));
      mHal->onPropertyValue(*Create_ec_fcm_lgt_rel_spd8Req(ec_fcm_lgt_rel_spd8),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_lgt_rel_spd8Req(int32_t ec_fcm_lgt_rel_spd8) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_lgt_rel_spd8);
    req->prop = toInt(VehicleProperty::GECKO_FCM_LGTRELSPD8);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_posn_agl8Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_posn_agl8 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_posn_agl8");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_posn_agl8 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.01, -3.14));
      mHal->onPropertyValue(*Create_ec_fcm_obj_posn_agl8Req(ec_fcm_obj_posn_agl8),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_posn_agl8Req(int32_t ec_fcm_obj_posn_agl8) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_posn_agl8);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJPOSNAGL8);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_dir8Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_movmt_dir8 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_movmt_dir8");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_movmt_dir8 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_movmt_dir8Req(ec_fcm_obj_movmt_dir8),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_movmt_dir8Req(int32_t ec_fcm_obj_movmt_dir8) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_movmt_dir8);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJMOVMTDIR8);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_sta8Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_movmt_sta8 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_movmt_sta8");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_movmt_sta8 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_movmt_sta8Req(ec_fcm_obj_movmt_sta8),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_movmt_sta8Req(int32_t ec_fcm_obj_movmt_sta8) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_movmt_sta8);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJMOVMTSTA8);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_typ9Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_typ9 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_typ9");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_typ9 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_typ9Req(ec_fcm_obj_typ9),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_typ9Req(int32_t ec_fcm_obj_typ9) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_typ9);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJTYP9);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_lat_dst9Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_lat_dst9 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_lat_dst9");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_lat_dst9 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.1, -6.4));
      mHal->onPropertyValue(*Create_ec_fcm_obj_lat_dst9Req(ec_fcm_obj_lat_dst9),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_lat_dst9Req(int32_t ec_fcm_obj_lat_dst9) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_lat_dst9);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJLATDST9);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_lgt_dst9Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_lgt_dst9 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_lgt_dst9");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_lgt_dst9 = round(getActualFloatValue(mPropertyManager->getCProValue(mp), 0.5, -100));
      mHal->onPropertyValue(*Create_ec_fcm_obj_lgt_dst9Req(ec_fcm_obj_lgt_dst9),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_lgt_dst9Req(int32_t ec_fcm_obj_lgt_dst9) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_lgt_dst9);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJLGTDST9);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_lgt_rel_spd9Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_lgt_rel_spd9 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_lgt_rel_spd9");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_lgt_rel_spd9 = round(getActualFloatValue(mPropertyManager->getCProValue(mp), 5, -130));
      mHal->onPropertyValue(*Create_ec_fcm_lgt_rel_spd9Req(ec_fcm_lgt_rel_spd9),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_lgt_rel_spd9Req(int32_t ec_fcm_lgt_rel_spd9) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_lgt_rel_spd9);
    req->prop = toInt(VehicleProperty::GECKO_FCM_LGTRELSPD9);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_posn_agl9Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_posn_agl9 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_posn_agl9");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_posn_agl9 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.01, -3.14));
      mHal->onPropertyValue(*Create_ec_fcm_obj_posn_agl9Req(ec_fcm_obj_posn_agl9),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_posn_agl9Req(int32_t ec_fcm_obj_posn_agl9) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_posn_agl9);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJPOSNAGL9);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_dir9Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_movmt_dir9 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_movmt_dir9");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_movmt_dir9 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_movmt_dir9Req(ec_fcm_obj_movmt_dir9),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_movmt_dir9Req(int32_t ec_fcm_obj_movmt_dir9) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_movmt_dir9);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJMOVMTDIR9);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_sta9Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_movmt_sta9 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_movmt_sta9");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_movmt_sta9 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_movmt_sta9Req(ec_fcm_obj_movmt_sta9),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_movmt_sta9Req(int32_t ec_fcm_obj_movmt_sta9) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_movmt_sta9);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJMOVMTSTA9);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_typ10Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_typ10 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_typ10");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_typ10 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_typ10Req(ec_fcm_obj_typ10),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_typ10Req(int32_t ec_fcm_obj_typ10) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_typ10);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJTYP10);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_lat_dst10Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_lat_dst10 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_lat_dst10");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_lat_dst10 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.1, -6.4));
      mHal->onPropertyValue(*Create_ec_fcm_obj_lat_dst10Req(ec_fcm_obj_lat_dst10),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_lat_dst10Req(int32_t ec_fcm_obj_lat_dst10) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_lat_dst10);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJLATDST10);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_lgt_dst10Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_lgt_dst10 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_lgt_dst10");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_lgt_dst10 = round(getActualFloatValue(mPropertyManager->getCProValue(mp), 0.5, -100));
      mHal->onPropertyValue(*Create_ec_fcm_obj_lgt_dst10Req(ec_fcm_obj_lgt_dst10),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_lgt_dst10Req(int32_t ec_fcm_obj_lgt_dst10) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_lgt_dst10);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJLGTDST10);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_lgt_rel_spd10Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_lgt_rel_spd10 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_lgt_rel_spd10");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_lgt_rel_spd10 = round(getActualFloatValue(mPropertyManager->getCProValue(mp), 5, -130));
      mHal->onPropertyValue(*Create_ec_fcm_lgt_rel_spd10Req(ec_fcm_lgt_rel_spd10),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_lgt_rel_spd10Req(int32_t ec_fcm_lgt_rel_spd10) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_lgt_rel_spd10);
    req->prop = toInt(VehicleProperty::GECKO_FCM_LGTRELSPD10);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_posn_agl10Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_posn_agl10 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_posn_agl10");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_posn_agl10 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.01, -3.14));
      mHal->onPropertyValue(*Create_ec_fcm_obj_posn_agl10Req(ec_fcm_obj_posn_agl10),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_posn_agl10Req(int32_t ec_fcm_obj_posn_agl10) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_posn_agl10);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJPOSNAGL10);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_dir10Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_movmt_dir10 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_movmt_dir10");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_movmt_dir10 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_movmt_dir10Req(ec_fcm_obj_movmt_dir10),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_movmt_dir10Req(int32_t ec_fcm_obj_movmt_dir10) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_movmt_dir10);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJMOVMTDIR10);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_sta10Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_movmt_sta10 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_movmt_sta10");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_movmt_sta10 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_movmt_sta10Req(ec_fcm_obj_movmt_sta10),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_movmt_sta10Req(int32_t ec_fcm_obj_movmt_sta10) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_movmt_sta10);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJMOVMTSTA10);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_typ11Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_typ11 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_typ11");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_typ11 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_typ11Req(ec_fcm_obj_typ11),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_typ11Req(int32_t ec_fcm_obj_typ11) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_typ11);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJTYP11);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_lat_dst11Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_lat_dst11 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_lat_dst11");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_lat_dst11 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.1, -6.4));
      mHal->onPropertyValue(*Create_ec_fcm_obj_lat_dst11Req(ec_fcm_obj_lat_dst11),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_lat_dst11Req(int32_t ec_fcm_obj_lat_dst11) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_lat_dst11);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJLATDST11);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_lgt_dst11Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_lgt_dst11 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_lgt_dst11");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_lgt_dst11 = round(getActualFloatValue(mPropertyManager->getCProValue(mp), 0.5, -100));
      mHal->onPropertyValue(*Create_ec_fcm_obj_lgt_dst11Req(ec_fcm_obj_lgt_dst11),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_lgt_dst11Req(int32_t ec_fcm_obj_lgt_dst11) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_lgt_dst11);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJLGTDST11);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_lgt_rel_spd11Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_lgt_rel_spd11 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_lgt_rel_spd11");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_lgt_rel_spd11 = round(getActualFloatValue(mPropertyManager->getCProValue(mp), 5, -130));
      mHal->onPropertyValue(*Create_ec_fcm_lgt_rel_spd11Req(ec_fcm_lgt_rel_spd11),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_lgt_rel_spd11Req(int32_t ec_fcm_lgt_rel_spd11) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_lgt_rel_spd11);
    req->prop = toInt(VehicleProperty::GECKO_FCM_LGTRELSPD11);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_posn_agl11Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_posn_agl11 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_posn_agl11");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_posn_agl11 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.01, -3.14));
      mHal->onPropertyValue(*Create_ec_fcm_obj_posn_agl11Req(ec_fcm_obj_posn_agl11),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_posn_agl11Req(int32_t ec_fcm_obj_posn_agl11) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_posn_agl11);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJPOSNAGL11);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_dir11Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_movmt_dir11 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_movmt_dir11");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_movmt_dir11 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_movmt_dir11Req(ec_fcm_obj_movmt_dir11),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_movmt_dir11Req(int32_t ec_fcm_obj_movmt_dir11) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_movmt_dir11);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJMOVMTDIR11);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_sta11Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_movmt_sta11 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_movmt_sta11");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_movmt_sta11 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_movmt_sta11Req(ec_fcm_obj_movmt_sta11),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_movmt_sta11Req(int32_t ec_fcm_obj_movmt_sta11) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_movmt_sta11);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJMOVMTSTA11);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_typ12Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_typ12 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_typ12");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_typ12 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_typ12Req(ec_fcm_obj_typ12),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_typ12Req(int32_t ec_fcm_obj_typ12) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_typ12);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJTYP12);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_lat_dst12Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_lat_dst12 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_lat_dst12");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_lat_dst12 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.1, -6.4));
      mHal->onPropertyValue(*Create_ec_fcm_obj_lat_dst12Req(ec_fcm_obj_lat_dst12),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_lat_dst12Req(int32_t ec_fcm_obj_lat_dst12) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_lat_dst12);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJLATDST12);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_lgt_dst12Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_lgt_dst12 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_lgt_dst12");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_lgt_dst12 = round(getActualFloatValue(mPropertyManager->getCProValue(mp), 0.5, -100));
      mHal->onPropertyValue(*Create_ec_fcm_obj_lgt_dst12Req(ec_fcm_obj_lgt_dst12),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_lgt_dst12Req(int32_t ec_fcm_obj_lgt_dst12) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_lgt_dst12);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJLGTDST12);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_lgt_rel_spd12Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_lgt_rel_spd12 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_lgt_rel_spd12");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_lgt_rel_spd12 = round(getActualFloatValue(mPropertyManager->getCProValue(mp), 5, -130));
      mHal->onPropertyValue(*Create_ec_fcm_lgt_rel_spd12Req(ec_fcm_lgt_rel_spd12),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_lgt_rel_spd12Req(int32_t ec_fcm_lgt_rel_spd12) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_lgt_rel_spd12);
    req->prop = toInt(VehicleProperty::GECKO_FCM_LGTRELSPD12);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_posn_agl12Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_posn_agl12 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_posn_agl12");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_posn_agl12 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.01, -3.14));
      mHal->onPropertyValue(*Create_ec_fcm_obj_posn_agl12Req(ec_fcm_obj_posn_agl12),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_posn_agl12Req(int32_t ec_fcm_obj_posn_agl12) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_posn_agl12);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJPOSNAGL12);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_dir12Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_movmt_dir12 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_movmt_dir12");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_movmt_dir12 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_movmt_dir12Req(ec_fcm_obj_movmt_dir12),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_movmt_dir12Req(int32_t ec_fcm_obj_movmt_dir12) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_movmt_dir12);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJMOVMTDIR12);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_sta12Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_movmt_sta12 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_movmt_sta12");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_movmt_sta12 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_movmt_sta12Req(ec_fcm_obj_movmt_sta12),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_movmt_sta12Req(int32_t ec_fcm_obj_movmt_sta12) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_movmt_sta12);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJMOVMTSTA12);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_typ13Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_typ13 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_typ13");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_typ13 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_typ13Req(ec_fcm_obj_typ13),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_typ13Req(int32_t ec_fcm_obj_typ13) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_typ13);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJTYP13);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_lat_dst13Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_lat_dst13 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_lat_dst13");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_lat_dst13 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.1, -6.4));
      mHal->onPropertyValue(*Create_ec_fcm_obj_lat_dst13Req(ec_fcm_obj_lat_dst13),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_lat_dst13Req(int32_t ec_fcm_obj_lat_dst13) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_lat_dst13);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJLATDST13);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_lgt_dst13Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_lgt_dst13 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_lgt_dst13");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_lgt_dst13 = round(getActualFloatValue(mPropertyManager->getCProValue(mp), 0.5, -100));
      mHal->onPropertyValue(*Create_ec_fcm_obj_lgt_dst13Req(ec_fcm_obj_lgt_dst13),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_lgt_dst13Req(int32_t ec_fcm_obj_lgt_dst13) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_lgt_dst13);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJLGTDST13);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_lgt_rel_spd13Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_lgt_rel_spd13 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_lgt_rel_spd13");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_lgt_rel_spd13 = round(getActualFloatValue(mPropertyManager->getCProValue(mp), 5, -130));
      mHal->onPropertyValue(*Create_ec_fcm_lgt_rel_spd13Req(ec_fcm_lgt_rel_spd13),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_lgt_rel_spd13Req(int32_t ec_fcm_lgt_rel_spd13) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_lgt_rel_spd13);
    req->prop = toInt(VehicleProperty::GECKO_FCM_LGTRELSPD13);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_posn_agl13Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_posn_agl13 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_posn_agl13");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_posn_agl13 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.01, -3.14));
      mHal->onPropertyValue(*Create_ec_fcm_obj_posn_agl13Req(ec_fcm_obj_posn_agl13),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_posn_agl13Req(int32_t ec_fcm_obj_posn_agl13) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_posn_agl13);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJPOSNAGL13);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_dir13Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_movmt_dir13 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_movmt_dir13");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_movmt_dir13 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_movmt_dir13Req(ec_fcm_obj_movmt_dir13),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_movmt_dir13Req(int32_t ec_fcm_obj_movmt_dir13) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_movmt_dir13);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJMOVMTDIR13);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_sta13Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_movmt_sta13 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_movmt_sta13");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_movmt_sta13 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_movmt_sta13Req(ec_fcm_obj_movmt_sta13),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_movmt_sta13Req(int32_t ec_fcm_obj_movmt_sta13) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_movmt_sta13);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJMOVMTSTA13);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_typ14Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_typ14 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_typ14");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_typ14 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_typ14Req(ec_fcm_obj_typ14),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_typ14Req(int32_t ec_fcm_obj_typ14) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_typ14);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJTYP14);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_lat_dst14Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_lat_dst14 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_lat_dst14");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_lat_dst14 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.1, -6.4));
      mHal->onPropertyValue(*Create_ec_fcm_obj_lat_dst14Req(ec_fcm_obj_lat_dst14),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_lat_dst14Req(int32_t ec_fcm_obj_lat_dst14) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_lat_dst14);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJLATDST14);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_lgt_dst14Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_lgt_dst14 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_lgt_dst14");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_lgt_dst14 = round(getActualFloatValue(mPropertyManager->getCProValue(mp), 0.5, -100));
      mHal->onPropertyValue(*Create_ec_fcm_obj_lgt_dst14Req(ec_fcm_obj_lgt_dst14),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_lgt_dst14Req(int32_t ec_fcm_obj_lgt_dst14) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_lgt_dst14);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJLGTDST14);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_lgt_rel_spd14Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_lgt_rel_spd14 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_lgt_rel_spd14");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_lgt_rel_spd14 = round(getActualFloatValue(mPropertyManager->getCProValue(mp), 5, -130));
      mHal->onPropertyValue(*Create_ec_fcm_lgt_rel_spd14Req(ec_fcm_lgt_rel_spd14),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_lgt_rel_spd14Req(int32_t ec_fcm_lgt_rel_spd14) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_lgt_rel_spd14);
    req->prop = toInt(VehicleProperty::GECKO_FCM_LGTRELSPD14);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_posn_agl14Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_posn_agl14 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_posn_agl14");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_posn_agl14 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.01, -3.14));
      mHal->onPropertyValue(*Create_ec_fcm_obj_posn_agl14Req(ec_fcm_obj_posn_agl14),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_posn_agl14Req(int32_t ec_fcm_obj_posn_agl14) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_posn_agl14);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJPOSNAGL14);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_dir14Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_movmt_dir14 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_movmt_dir14");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_movmt_dir14 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_movmt_dir14Req(ec_fcm_obj_movmt_dir14),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_movmt_dir14Req(int32_t ec_fcm_obj_movmt_dir14) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_movmt_dir14);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJMOVMTDIR14);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_sta14Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_movmt_sta14 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_movmt_sta14");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_movmt_sta14 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_movmt_sta14Req(ec_fcm_obj_movmt_sta14),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_movmt_sta14Req(int32_t ec_fcm_obj_movmt_sta14) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_movmt_sta14);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJMOVMTSTA14);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_typ15Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_typ15 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_typ15");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_typ15 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_typ15Req(ec_fcm_obj_typ15),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_typ15Req(int32_t ec_fcm_obj_typ15) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_typ15);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJTYP15);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_lat_dst15Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_lat_dst15 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_lat_dst15");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_lat_dst15 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.1, -6.4));
      mHal->onPropertyValue(*Create_ec_fcm_obj_lat_dst15Req(ec_fcm_obj_lat_dst15),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_lat_dst15Req(int32_t ec_fcm_obj_lat_dst15) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_lat_dst15);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJLATDST15);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_lgt_dst15Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_lgt_dst15 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_lgt_dst15");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_lgt_dst15 = round(getActualFloatValue(mPropertyManager->getCProValue(mp), 0.5, -100));
      mHal->onPropertyValue(*Create_ec_fcm_obj_lgt_dst15Req(ec_fcm_obj_lgt_dst15),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_lgt_dst15Req(int32_t ec_fcm_obj_lgt_dst15) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_lgt_dst15);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJLGTDST15);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_lgt_rel_spd15Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_lgt_rel_spd15 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_lgt_rel_spd15");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_lgt_rel_spd15 = round(getActualFloatValue(mPropertyManager->getCProValue(mp), 5, -130));
      mHal->onPropertyValue(*Create_ec_fcm_lgt_rel_spd15Req(ec_fcm_lgt_rel_spd15),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_lgt_rel_spd15Req(int32_t ec_fcm_lgt_rel_spd15) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_lgt_rel_spd15);
    req->prop = toInt(VehicleProperty::GECKO_FCM_LGTRELSPD15);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_posn_agl15Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_posn_agl15 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_posn_agl15");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_posn_agl15 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.01, -3.14));
      mHal->onPropertyValue(*Create_ec_fcm_obj_posn_agl15Req(ec_fcm_obj_posn_agl15),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_posn_agl15Req(int32_t ec_fcm_obj_posn_agl15) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_posn_agl15);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJPOSNAGL15);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_dir15Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_movmt_dir15 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_movmt_dir15");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_movmt_dir15 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_movmt_dir15Req(ec_fcm_obj_movmt_dir15),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_movmt_dir15Req(int32_t ec_fcm_obj_movmt_dir15) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_movmt_dir15);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJMOVMTDIR15);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_sta15Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_movmt_sta15 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_movmt_sta15");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_movmt_sta15 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_movmt_sta15Req(ec_fcm_obj_movmt_sta15),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_movmt_sta15Req(int32_t ec_fcm_obj_movmt_sta15) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_movmt_sta15);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJMOVMTSTA15);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_typ16Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_typ16 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_typ16");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_typ16 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_typ16Req(ec_fcm_obj_typ16),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_typ16Req(int32_t ec_fcm_obj_typ16) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_typ16);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJTYP16);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_lat_dst16Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_lat_dst16 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_lat_dst16");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_lat_dst16 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.1, -6.4));
      mHal->onPropertyValue(*Create_ec_fcm_obj_lat_dst16Req(ec_fcm_obj_lat_dst16),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_lat_dst16Req(int32_t ec_fcm_obj_lat_dst16) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_lat_dst16);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJLATDST16);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_lgt_dst16Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_lgt_dst16 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_lgt_dst16");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_lgt_dst16 = round(getActualFloatValue(mPropertyManager->getCProValue(mp), 0.5, -100));
      mHal->onPropertyValue(*Create_ec_fcm_obj_lgt_dst16Req(ec_fcm_obj_lgt_dst16),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_lgt_dst16Req(int32_t ec_fcm_obj_lgt_dst16) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_lgt_dst16);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJLGTDST16);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_lgt_rel_spd16Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_lgt_rel_spd16 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_lgt_rel_spd16");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_lgt_rel_spd16 = round(getActualFloatValue(mPropertyManager->getCProValue(mp), 5, -130));
      mHal->onPropertyValue(*Create_ec_fcm_lgt_rel_spd16Req(ec_fcm_lgt_rel_spd16),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_lgt_rel_spd16Req(int32_t ec_fcm_lgt_rel_spd16) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_lgt_rel_spd16);
    req->prop = toInt(VehicleProperty::GECKO_FCM_LGTRELSPD16);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_posn_agl16Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_posn_agl16 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_posn_agl16");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_posn_agl16 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.01, -3.14));
      mHal->onPropertyValue(*Create_ec_fcm_obj_posn_agl16Req(ec_fcm_obj_posn_agl16),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_posn_agl16Req(int32_t ec_fcm_obj_posn_agl16) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_posn_agl16);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJPOSNAGL16);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_dir16Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_movmt_dir16 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_movmt_dir16");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_movmt_dir16 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_movmt_dir16Req(ec_fcm_obj_movmt_dir16),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_movmt_dir16Req(int32_t ec_fcm_obj_movmt_dir16) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_movmt_dir16);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJMOVMTDIR16);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_sta16Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_movmt_sta16 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_movmt_sta16");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_movmt_sta16 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_movmt_sta16Req(ec_fcm_obj_movmt_sta16),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_movmt_sta16Req(int32_t ec_fcm_obj_movmt_sta16) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_movmt_sta16);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJMOVMTSTA16);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_typ17Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_typ17 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_typ17");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_typ17 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_typ17Req(ec_fcm_obj_typ17),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_typ17Req(int32_t ec_fcm_obj_typ17) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_typ17);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJTYP17);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_lat_dst17Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_lat_dst17 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_lat_dst17");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_lat_dst17 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.1, -6.4));
      mHal->onPropertyValue(*Create_ec_fcm_obj_lat_dst17Req(ec_fcm_obj_lat_dst17),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_lat_dst17Req(int32_t ec_fcm_obj_lat_dst17) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_lat_dst17);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJLATDST17);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_lgt_dst17Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_lgt_dst17 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_lgt_dst17");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_lgt_dst17 = round(getActualFloatValue(mPropertyManager->getCProValue(mp), 0.5, -100));
      mHal->onPropertyValue(*Create_ec_fcm_obj_lgt_dst17Req(ec_fcm_obj_lgt_dst17),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_lgt_dst17Req(int32_t ec_fcm_obj_lgt_dst17) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_lgt_dst17);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJLGTDST17);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_lgt_rel_spd17Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_lgt_rel_spd17 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_lgt_rel_spd17");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_lgt_rel_spd17 = round(getActualFloatValue(mPropertyManager->getCProValue(mp), 5, -130));
      mHal->onPropertyValue(*Create_ec_fcm_lgt_rel_spd17Req(ec_fcm_lgt_rel_spd17),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_lgt_rel_spd17Req(int32_t ec_fcm_lgt_rel_spd17) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_lgt_rel_spd17);
    req->prop = toInt(VehicleProperty::GECKO_FCM_LGTRELSPD17);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_posn_agl17Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_posn_agl17 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_posn_agl17");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_posn_agl17 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.01, -3.14));
      mHal->onPropertyValue(*Create_ec_fcm_obj_posn_agl17Req(ec_fcm_obj_posn_agl17),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_posn_agl17Req(int32_t ec_fcm_obj_posn_agl17) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_posn_agl17);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJPOSNAGL17);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_dir17Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_movmt_dir17 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_movmt_dir17");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_movmt_dir17 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_movmt_dir17Req(ec_fcm_obj_movmt_dir17),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_movmt_dir17Req(int32_t ec_fcm_obj_movmt_dir17) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_movmt_dir17);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJMOVMTDIR17);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_sta17Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_movmt_sta17 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_movmt_sta17");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_movmt_sta17 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_movmt_sta17Req(ec_fcm_obj_movmt_sta17),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_movmt_sta17Req(int32_t ec_fcm_obj_movmt_sta17) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_movmt_sta17);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJMOVMTSTA17);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_typ18Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_typ18 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_typ18");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_typ18 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_typ18Req(ec_fcm_obj_typ18),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_typ18Req(int32_t ec_fcm_obj_typ18) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_typ18);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJTYP18);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_lat_dst18Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_lat_dst18 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_lat_dst18");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_lat_dst18 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.1, -6.4));
      mHal->onPropertyValue(*Create_ec_fcm_obj_lat_dst18Req(ec_fcm_obj_lat_dst18),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_lat_dst18Req(int32_t ec_fcm_obj_lat_dst18) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_lat_dst18);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJLATDST18);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_lgt_dst18Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_lgt_dst18 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_lgt_dst18");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_lgt_dst18 = round(getActualFloatValue(mPropertyManager->getCProValue(mp), 0.5, -100));
      mHal->onPropertyValue(*Create_ec_fcm_obj_lgt_dst18Req(ec_fcm_obj_lgt_dst18),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_lgt_dst18Req(int32_t ec_fcm_obj_lgt_dst18) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_lgt_dst18);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJLGTDST18);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_lgt_rel_spd18Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_lgt_rel_spd18 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_lgt_rel_spd18");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_lgt_rel_spd18 = round(getActualFloatValue(mPropertyManager->getCProValue(mp), 5, -130));
      mHal->onPropertyValue(*Create_ec_fcm_lgt_rel_spd18Req(ec_fcm_lgt_rel_spd18),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_lgt_rel_spd18Req(int32_t ec_fcm_lgt_rel_spd18) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_lgt_rel_spd18);
    req->prop = toInt(VehicleProperty::GECKO_FCM_LGTRELSPD18);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_posn_agl18Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_posn_agl18 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_posn_agl18");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_posn_agl18 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.01, -3.14));
      mHal->onPropertyValue(*Create_ec_fcm_obj_posn_agl18Req(ec_fcm_obj_posn_agl18),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_posn_agl18Req(int32_t ec_fcm_obj_posn_agl18) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_posn_agl18);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJPOSNAGL18);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_dir18Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_movmt_dir18 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_movmt_dir18");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_movmt_dir18 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_movmt_dir18Req(ec_fcm_obj_movmt_dir18),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_movmt_dir18Req(int32_t ec_fcm_obj_movmt_dir18) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_movmt_dir18);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJMOVMTDIR18);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_obj_movmt_sta18Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_obj_movmt_sta18 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_obj_movmt_sta18");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_obj_movmt_sta18 = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_obj_movmt_sta18Req(ec_fcm_obj_movmt_sta18),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_obj_movmt_sta18Req(int32_t ec_fcm_obj_movmt_sta18) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_obj_movmt_sta18);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OBJMOVMTSTA18);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_fcm_nr_of_lineWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_nr_of_line = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_nr_of_line");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_nr_of_line = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_nr_of_lineReq(ec_fcm_nr_of_line),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_nr_of_lineReq(int32_t ec_fcm_nr_of_line) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_nr_of_line);
    req->prop = toInt(VehicleProperty::GECKO_FCM_NROFLINE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_le_line_typWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_le_line_typ = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_le_line_typ");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_le_line_typ = mPropertyManager->getCProValue(mp);
      LOG(INFO)<<"ec_fcm_le_line_typ"<<ec_fcm_le_line_typ;
      mHal->onPropertyValue(*Create_ec_fcm_le_line_typReq(ec_fcm_le_line_typ),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_le_line_typReq(int32_t ec_fcm_le_line_typ) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_le_line_typ);
    req->prop = toInt(VehicleProperty::GECKO_FCM_LELINETYP);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_le_line_rdWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_le_line_rd = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_le_line_rd");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_le_line_rd = round(getActualFloatValue(mPropertyManager->getCProValue(mp), 50, -3150));
      mHal->onPropertyValue(*Create_ec_fcm_le_line_rdReq(ec_fcm_le_line_rd),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_le_line_rdReq(int32_t ec_fcm_le_line_rd) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_le_line_rd);
    req->prop = toInt(VehicleProperty::GECKO_FCM_LELINERD);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_le_line_dstWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_le_line_dst = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_le_line_dst");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_le_line_dst = round(getActualFloatValue(mPropertyManager->getCProValue(mp), 0.1, 0));
      mHal->onPropertyValue(*Create_ec_fcm_le_line_dstReq(ec_fcm_le_line_dst),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_le_line_dstReq(int32_t ec_fcm_le_line_dst) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_le_line_dst);
    req->prop = toInt(VehicleProperty::GECKO_FCM_LELINEDST);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_le_line_c1Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_le_line_c1 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_le_line_c1");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_le_line_c1 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.001, -1.6));
      mHal->onPropertyValue(*Create_ec_fcm_le_line_c1Req(ec_fcm_le_line_c1),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_le_line_c1Req(int32_t ec_fcm_le_line_c1) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_le_line_c1);
    req->prop = toInt(VehicleProperty::GECKO_FCM_LELINEC1);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_le_line_c2Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_le_line_c2 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_le_line_c2");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_le_line_c2 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.0001, -0.025));
      mHal->onPropertyValue(*Create_ec_fcm_le_line_c2Req(ec_fcm_le_line_c2),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_le_line_c2Req(int32_t ec_fcm_le_line_c2) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_le_line_c2);
    req->prop = toInt(VehicleProperty::GECKO_FCM_LELINEC2);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_le_line_c3Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_le_line_c3 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_le_line_c3");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_le_line_c3 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.0000038147, -0.0078125));
      mHal->onPropertyValue(*Create_ec_fcm_le_line_c3Req(ec_fcm_le_line_c3),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_le_line_c3Req(int32_t ec_fcm_le_line_c3) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_le_line_c3);
    req->prop = toInt(VehicleProperty::GECKO_FCM_LELINEC3);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_ri_line_typWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_ri_line_typ = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_ri_line_typ");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_ri_line_typ = mPropertyManager->getCProValue(mp);
      LOG(INFO)<<"ec_fcm_ri_line_typ = " << ec_fcm_ri_line_typ;
      mHal->onPropertyValue(*Create_ec_fcm_ri_line_typReq(ec_fcm_ri_line_typ),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_ri_line_typReq(int32_t ec_fcm_ri_line_typ) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_ri_line_typ);
    req->prop = toInt(VehicleProperty::GECKO_FCM_RILINETYP);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_ri_line_rdWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_ri_line_rd = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_ri_line_rd");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_ri_line_rd = round(getActualFloatValue(mPropertyManager->getCProValue(mp), 50, -3150));
      mHal->onPropertyValue(*Create_ec_fcm_ri_line_rdReq(ec_fcm_ri_line_rd),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_ri_line_rdReq(int32_t ec_fcm_ri_line_rd) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_ri_line_rd);
    req->prop = toInt(VehicleProperty::GECKO_FCM_RILINERD);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_ri_line_dstWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_ri_line_dst = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_ri_line_dst");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_ri_line_dst = round(getActualFloatValue(mPropertyManager->getCProValue(mp), 0.1, 0));
      mHal->onPropertyValue(*Create_ec_fcm_ri_line_dstReq(ec_fcm_ri_line_dst),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_ri_line_dstReq(int32_t ec_fcm_ri_line_dst) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_ri_line_dst);
    req->prop = toInt(VehicleProperty::GECKO_FCM_RILINEDST);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_ri_line_c1Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_ri_line_c1 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_ri_line_c1");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_ri_line_c1 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.001, -1.6));
      mHal->onPropertyValue(*Create_ec_fcm_ri_line_c1Req(ec_fcm_ri_line_c1),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_ri_line_c1Req(int32_t ec_fcm_ri_line_c1) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_ri_line_c1);
    req->prop = toInt(VehicleProperty::GECKO_FCM_RILINEC1);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_ri_line_c2Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_ri_line_c2 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_ri_line_c2");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_ri_line_c2 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.0001, -0.025));
      mHal->onPropertyValue(*Create_ec_fcm_ri_line_c2Req(ec_fcm_ri_line_c2),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_ri_line_c2Req(int32_t ec_fcm_ri_line_c2) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_ri_line_c2);
    req->prop = toInt(VehicleProperty::GECKO_FCM_RILINEC2);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_ri_line_c3Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_ri_line_c3 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_ri_line_c3");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_ri_line_c3 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.0000038147, -0.0078125));
      mHal->onPropertyValue(*Create_ec_fcm_ri_line_c3Req(ec_fcm_ri_line_c3),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_ri_line_c3Req(int32_t ec_fcm_ri_line_c3) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_ri_line_c3);
    req->prop = toInt(VehicleProperty::GECKO_FCM_RILINEC3);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_le_le_line_typWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_le_le_line_typ = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_le_le_line_typ");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_le_le_line_typ = mPropertyManager->getCProValue(mp);
      LOG(INFO)<<"ec_fcm_le_le_line_typ = " << ec_fcm_le_le_line_typ;
      mHal->onPropertyValue(*Create_ec_fcm_le_le_line_typReq(ec_fcm_le_le_line_typ),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_le_le_line_typReq(int32_t ec_fcm_le_le_line_typ) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_le_le_line_typ);
    req->prop = toInt(VehicleProperty::GECKO_FCM_LELELINETYP);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_le_le_line_rdWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_le_le_line_rd = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_le_le_line_rd");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_le_le_line_rd = round(getActualFloatValue(mPropertyManager->getCProValue(mp), 50, -3150));
      mHal->onPropertyValue(*Create_ec_fcm_le_le_line_rdReq(ec_fcm_le_le_line_rd),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_le_le_line_rdReq(int32_t ec_fcm_le_le_line_rd) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_le_le_line_rd);
    req->prop = toInt(VehicleProperty::GECKO_FCM_LELELINERD);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_le_le_line_dstWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_le_le_line_dst = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_le_le_line_dst");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_le_le_line_dst = round(getActualFloatValue(mPropertyManager->getCProValue(mp), 0.1, 0));
      mHal->onPropertyValue(*Create_ec_fcm_le_le_line_dstReq(ec_fcm_le_le_line_dst),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_le_le_line_dstReq(int32_t ec_fcm_le_le_line_dst) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_le_le_line_dst);
    req->prop = toInt(VehicleProperty::GECKO_FCM_LELELINEDST);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_le_le_line_c1Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_le_le_line_c1 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_le_le_line_c1");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_le_le_line_c1 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.001, -1.6));
      mHal->onPropertyValue(*Create_ec_fcm_le_le_line_c1Req(ec_fcm_le_le_line_c1),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_le_le_line_c1Req(int32_t ec_fcm_le_le_line_c1) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_le_le_line_c1);
    req->prop = toInt(VehicleProperty::GECKO_FCM_LELELINEC1);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_le_le_line_c2Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_le_le_line_c2 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_le_le_line_c2");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_le_le_line_c2 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.0001, -0.025));
      mHal->onPropertyValue(*Create_ec_fcm_le_le_line_c2Req(ec_fcm_le_le_line_c2),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_le_le_line_c2Req(int32_t ec_fcm_le_le_line_c2) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_le_le_line_c2);
    req->prop = toInt(VehicleProperty::GECKO_FCM_LELELINEC2);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_le_le_line_c3Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_le_le_line_c3 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_le_le_line_c3");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_le_le_line_c3 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.0000038147, -0.0078125));
      mHal->onPropertyValue(*Create_ec_fcm_le_le_line_c3Req(ec_fcm_le_le_line_c3),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_le_le_line_c3Req(int32_t ec_fcm_le_le_line_c3) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_le_le_line_c3);
    req->prop = toInt(VehicleProperty::GECKO_FCM_LELELINEC3);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_ri_ri_line_typWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_ri_ri_line_typ = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_ri_ri_line_typ");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_ri_ri_line_typ = mPropertyManager->getCProValue(mp);
      LOG(INFO)<<"ec_fcm_ri_ri_line_typ = " << ec_fcm_ri_ri_line_typ;
      mHal->onPropertyValue(*Create_ec_fcm_ri_ri_line_typReq(ec_fcm_ri_ri_line_typ),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_ri_ri_line_typReq(int32_t ec_fcm_ri_ri_line_typ) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_ri_ri_line_typ);
    req->prop = toInt(VehicleProperty::GECKO_FCM_RIRILINETYP);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_ri_ri_line_rdWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_ri_ri_line_rd = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_ri_ri_line_rd");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_ri_ri_line_rd = round(getActualFloatValue(mPropertyManager->getCProValue(mp), 50, -3150));
      mHal->onPropertyValue(*Create_ec_fcm_ri_ri_line_rdReq(ec_fcm_ri_ri_line_rd),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_ri_ri_line_rdReq(int32_t ec_fcm_ri_ri_line_rd) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_ri_ri_line_rd);
    req->prop = toInt(VehicleProperty::GECKO_FCM_RIRILINERD);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_ri_ri_line_dstWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_ri_ri_line_dst = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_ri_ri_line_dst");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_ri_ri_line_dst = round(getActualFloatValue(mPropertyManager->getCProValue(mp), 0.1, 0));
      mHal->onPropertyValue(*Create_ec_fcm_ri_ri_line_dstReq(ec_fcm_ri_ri_line_dst),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_ri_ri_line_dstReq(int32_t ec_fcm_ri_ri_line_dst) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_ri_ri_line_dst);
    req->prop = toInt(VehicleProperty::GECKO_FCM_RIRILINEDST);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_ri_ri_line_c1Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_ri_ri_line_c1 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_ri_ri_line_c1");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_ri_ri_line_c1 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.001, -1.6));
      mHal->onPropertyValue(*Create_ec_fcm_ri_ri_line_c1Req(ec_fcm_ri_ri_line_c1),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_ri_ri_line_c1Req(int32_t ec_fcm_ri_ri_line_c1) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_ri_ri_line_c1);
    req->prop = toInt(VehicleProperty::GECKO_FCM_RIRILINEC1);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_ri_ri_line_c2Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_ri_ri_line_c2 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_ri_ri_line_c2");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_ri_ri_line_c2 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.0001, -0.025));
      mHal->onPropertyValue(*Create_ec_fcm_ri_ri_line_c2Req(ec_fcm_ri_ri_line_c2),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_ri_ri_line_c2Req(int32_t ec_fcm_ri_ri_line_c2) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_ri_ri_line_c2);
    req->prop = toInt(VehicleProperty::GECKO_FCM_RIRILINEC2);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_ri_ri_line_c3Watcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_ri_ri_line_c3 = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_ri_ri_line_c3");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_ri_ri_line_c3 = round(getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.0000038147, -0.0078125));
      mHal->onPropertyValue(*Create_ec_fcm_ri_ri_line_c3Req(ec_fcm_ri_ri_line_c3),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_ri_ri_line_c3Req(int32_t ec_fcm_ri_ri_line_c3) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_ri_ri_line_c3);
    req->prop = toInt(VehicleProperty::GECKO_FCM_RIRILINEC3);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_fcm_spd_downin_cor_sfkWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_fcm_spd_downin_cor_sfk = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_spd_downin_cor_sfk");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_fcm_spd_downin_cor_sfk = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_fcm_spd_downin_cor_sfkReq(ec_fcm_spd_downin_cor_sfk),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_spd_downin_cor_sfkReq(int32_t ec_fcm_spd_downin_cor_sfk) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_spd_downin_cor_sfk);
    req->prop = toInt(VehicleProperty::GECKO_HU_SPDDOWNINCORENABLESW);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_vcu_speed_limit_level_set_fbWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t bc_vcu_speed_limit_level_set_fb = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("bc_vcu_speed_limit_level_set_fb");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      bc_vcu_speed_limit_level_set_fb = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_bc_vcu_speed_limit_level_set_fbReq(bc_vcu_speed_limit_level_set_fb),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_vcu_speed_limit_level_set_fbReq(int32_t bc_vcu_speed_limit_level_set_fb) {
    auto req = mValueObjectPool->obtainInt32(bc_vcu_speed_limit_level_set_fb);
    req->prop = toInt(VehicleProperty::GECKO_VCU_SPEEDLIMITLEVELSETFB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_abs_active_staWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_esc_abs_active_sta = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_abs_active_sta");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_esc_abs_active_sta = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_esc_abs_active_staReq(ec_esc_abs_active_sta),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_abs_active_staReq(int32_t ec_esc_abs_active_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_abs_active_sta);
    req->prop = toInt(VehicleProperty::GECKO_ESC_ABSACTIVESTA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}


void GarageModeServerSideHandlerImpl::mc_remind_inrWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t mc_remind_inr = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("mc_remind_inr");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      mc_remind_inr = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_mc_remind_inrReq(mc_remind_inr),true);
  }
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_mc_remind_inrReq(int32_t mc_remind_inr) {
    auto req = mValueObjectPool->obtainInt32(mc_remind_inr);
    req->prop = toInt(VehicleProperty::GECKO_SERVICE_REMIND_TIME_SET);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::mc_remind_start_timeWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  uint32_t mc_remind_start_time = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("mc_remind_start_time");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      mc_remind_start_time = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_mc_remind_start_timeReq(mc_remind_start_time),true);
  }
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_mc_remind_start_timeReq(uint32_t mc_remind_start_time) {
    auto req = mValueObjectPool->obtainInt32(mc_remind_start_time);
    req->prop = toInt(VehicleProperty::GECKO_SERVICE_REMIND_START_TIME);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}


void GarageModeServerSideHandlerImpl::mc_remind_distanceWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  uint32_t mc_remind_distance = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("mc_remind_distance");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      mc_remind_distance = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_mc_remind_distanceReq(mc_remind_distance),true);
  }
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_mc_remind_distanceReq(uint32_t mc_remind_distance) {
    auto req = mValueObjectPool->obtainInt32(mc_remind_distance);
    req->prop = toInt(VehicleProperty::GECKO_SERVICE_REMIND_DISTANCE_SET);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::mc_remind_start_odoWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  float mc_remind_start_odo = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("mc_remind_start_odo");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      mc_remind_start_odo = getActualFloatValue(mPropertyManager->getCProValue(mp),0.1,0);
      mHal->onPropertyValue(*Create_mc_remind_start_odoReq(mc_remind_start_odo),true);
  }
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_mc_remind_start_odoReq(float mc_remind_start_odo) {
    auto req = mValueObjectPool->obtainFloat(mc_remind_start_odo);
    req->prop = toInt(VehicleProperty::GECKO_SERVICE_REMIND_START_ODO);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_dcc_actl_oprt_modeWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_ipu_dcc_actl_oprt_mode = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_dcc_actl_oprt_mode");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ipu_dcc_actl_oprt_mode = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_ipu_dcc_actl_oprt_modeReq(ec_ipu_dcc_actl_oprt_mode),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_dcc_actl_oprt_modeReq(int32_t ec_ipu_dcc_actl_oprt_mode) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_dcc_actl_oprt_mode);
    req->prop = toInt(VehicleProperty::GECKO_IPU_DCCACTL_OPTMODE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}


void GarageModeServerSideHandlerImpl::ec_ipu_over_temperature_failWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_ipu_over_temperature_fail = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_over_temperature_fail");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ipu_over_temperature_fail = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_ipu_over_temperature_failReq(ec_ipu_over_temperature_fail),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_over_temperature_failReq(int32_t ec_ipu_over_temperature_fail) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_over_temperature_fail);
    req->prop = toInt(VehicleProperty::GECKO_IPU_OVER_TEMPERATURE_FAIL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_accl_pedal_posWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_accl_pedal_pos = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_accl_pedal_pos");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_accl_pedal_pos = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_vcu_accl_pedal_posReq(ec_vcu_accl_pedal_pos),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_accl_pedal_posReq(int32_t ec_vcu_accl_pedal_pos) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_accl_pedal_pos);
    req->prop = toInt(VehicleProperty::GECKO_VCU_ACCLPEDAL_POS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_brk_pedal_posWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_vcu_brk_pedal_pos = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_brk_pedal_pos");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_vcu_brk_pedal_pos = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_vcu_brk_pedal_posReq(ec_vcu_brk_pedal_pos),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_brk_pedal_posReq(int32_t ec_vcu_brk_pedal_pos) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_brk_pedal_pos);
    req->prop = toInt(VehicleProperty::GECKO_VCU_BRKPEDAL_POS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_iso_resistanceWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_bms_iso_resistance = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_iso_resistance");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_bms_iso_resistance = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_bms_iso_resistanceReq(ec_bms_iso_resistance),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_iso_resistanceReq(int32_t ec_bms_iso_resistance) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_iso_resistance);
    req->prop = toInt(VehicleProperty::GECKO_BMS_ISORESISTANCE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ehb_brk_pedl_valWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_ehb_brk_pedl_val = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ehb_brk_pedl_val");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ehb_brk_pedl_val = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_ehb_brk_pedl_valReq(ec_ehb_brk_pedl_val),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ehb_brk_pedl_valReq(int32_t ec_ehb_brk_pedl_val) {
    auto req = mValueObjectPool->obtainInt32(ec_ehb_brk_pedl_val);
    req->prop = toInt(VehicleProperty::GECKO_EHB_BRKPEDL_VAL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ehb_brk_pedl_val_vldWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_ehb_brk_pedl_val_vld = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ehb_brk_pedl_val_vld");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ehb_brk_pedl_val_vld = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_ehb_brk_pedl_val_vldReq(ec_ehb_brk_pedl_val_vld),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ehb_brk_pedl_val_vldReq(int32_t ec_ehb_brk_pedl_val_vld) {
    auto req = mValueObjectPool->obtainInt32(ec_ehb_brk_pedl_val_vld);
    req->prop = toInt(VehicleProperty::GECKO_EHB_BRKPEDL_VALVLD);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ehb_brk_pedl_val_percWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_ehb_brk_pedl_val_perc = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ehb_brk_pedl_val_perc");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ehb_brk_pedl_val_perc = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_ehb_brk_pedl_val_percReq(ec_ehb_brk_pedl_val_perc),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ehb_brk_pedl_val_percReq(int32_t ec_ehb_brk_pedl_val_perc) {
    auto req = mValueObjectPool->obtainInt32(ec_ehb_brk_pedl_val_perc);
    req->prop = toInt(VehicleProperty::GECKO_EHB_BRKPEDL_VALPERC);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ehb_brk_pedl_val_perc_vldWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(800));
  int32_t ec_ehb_brk_pedl_val_perc_vld = 0;
  ConfigDBC* mp = mPropertyManager->findCProperty("ec_ehb_brk_pedl_val_perc_vld");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      ec_ehb_brk_pedl_val_perc_vld = mPropertyManager->getCProValue(mp);
      mHal->onPropertyValue(*Create_ec_ehb_brk_pedl_val_perc_vldReq(ec_ehb_brk_pedl_val_perc_vld),true);
  }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ehb_brk_pedl_val_perc_vldReq(int32_t ec_ehb_brk_pedl_val_perc_vld) {
    auto req = mValueObjectPool->obtainInt32(ec_ehb_brk_pedl_val_perc_vld);
    req->prop = toInt(VehicleProperty::GECKO_EHB_BRKPEDL_VALPERCVLD);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::mc_travel_average_speedWatcher() {
  std::this_thread::sleep_for(std::chrono::milliseconds(6000));
  float mc_travel_average_speed = 0.0;
  ConfigDBC* mp = mPropertyManager->findCProperty("mc_travel_average_speed");
  while(!mShuttingDownFlag.load()){
      mPropertyManager->getUpdateCState(mp);
      mc_travel_average_speed = getActualFloatValue(mPropertyManager->getCProValue(mp), 0.1, 0);
      LOG(INFO) << "mc_travel_average_speed:"<< mc_travel_average_speed;
      mHal->onPropertyValue(*Create_mc_travel_average_speedReq(mc_travel_average_speed),true);
  }
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_mc_travel_average_speedReq(float mc_travel_average_speed) {
    auto req = mValueObjectPool->obtainFloat(mc_travel_average_speed);
    req->prop = toInt(VehicleProperty::GECKO_MCU_TRAVEL_AVERAGE_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_dcc_sys_fail_staWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ipu_dcc_sys_fail_sta = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_dcc_sys_fail_sta");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ipu_dcc_sys_fail_sta = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ipu_dcc_sys_fail_staReq(ec_ipu_dcc_sys_fail_sta),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_dcc_sys_fail_staReq(int32_t ec_ipu_dcc_sys_fail_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_dcc_sys_fail_sta);
    req->prop = toInt(VehicleProperty::GECKO_IPU_DCC_SYSFAILSTA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_chrg_target_socWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_chrg_target_soc = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_chrg_target_soc");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_chrg_target_soc = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_chrg_target_socReq(ec_bms_chrg_target_soc),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_chrg_target_socReq(int32_t ec_bms_chrg_target_soc) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_chrg_target_soc);
    req->prop = toInt(VehicleProperty::GECKO_BMS_CHRGTARGETSOC);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bcm_brake_pedal_staWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bcm_brake_pedal_sta = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bcm_brake_pedal_sta");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bcm_brake_pedal_sta = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bcm_brake_pedal_staReq(ec_bcm_brake_pedal_sta),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bcm_brake_pedal_staReq(int32_t ec_bcm_brake_pedal_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_bcm_brake_pedal_sta);
    req->prop = toInt(VehicleProperty::GECKO_BCM_BRAKEPEDALSTA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::fcm_adas_drvr_reqWatcher(){
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t fcm_adas_drvr_req = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("fcm_adas_drvr_req");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        fcm_adas_drvr_req = mPropertyManager->getCProValue(mp);
        LOG(INFO)<<"fcm_adas_drvr_req "<<fcm_adas_drvr_req;
        mHal->onPropertyValue(*Create_fcm_adas_drvr_req(fcm_adas_drvr_req),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_fcm_adas_drvr_req(int32_t value)
{
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_FCM_ADASDRVRREQ);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
} 

void GarageModeServerSideHandlerImpl::fcm_elk_stsWatcher(){
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t fcm_elk_sts = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("fcm_elk_sts");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        fcm_elk_sts = mPropertyManager->getCProValue(mp);
        LOG(INFO)<<"fcm_elk_sts "<<fcm_elk_sts;
        mHal->onPropertyValue(*Create_fcm_elk_sts(fcm_elk_sts),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_fcm_elk_sts(int32_t value)
{
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_FCM_ELKSTS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
} 

void GarageModeServerSideHandlerImpl::fcm_slifs_spd_limWatcher(){
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t fcm_slifs_spd_lim = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("fcm_slifs_spd_lim");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        fcm_slifs_spd_lim = mPropertyManager->getCProValue(mp);
        LOG(INFO)<<"fcm_slifs_spd_lim "<<fcm_slifs_spd_lim;
        mHal->onPropertyValue(*Create_fcm_slifs_spd_lim(fcm_slifs_spd_lim),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_fcm_slifs_spd_lim(int32_t value)
{
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_FCM_SLIFSPDLIM);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
} 

void GarageModeServerSideHandlerImpl::fcm_aeb_statusWatcher(){
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t fcm_aeb_status = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("fcm_aeb_status");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        fcm_aeb_status = mPropertyManager->getCProValue(mp);
        LOG(INFO)<<"fcm_aeb_status "<<fcm_aeb_status;
        mHal->onPropertyValue(*Create_fcm_aeb_status(fcm_aeb_status),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_fcm_aeb_status(int32_t value)
{
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_FCM_AEB_STATUS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
} 

void GarageModeServerSideHandlerImpl::fcm_aeb_statsadsusWatcher(){
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t fcm_aeb_statsadsus = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("fcm_aeb_statsadsus");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        fcm_aeb_statsadsus = mPropertyManager->getCProValue(mp);
        LOG(INFO)<<"fcm_aeb_statsadsus "<<fcm_aeb_statsadsus;
        mHal->onPropertyValue(*Create_fcm_aeb_statsadsus(fcm_aeb_statsadsus),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_fcm_aeb_statsadsus(int32_t value)
{
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_FCM_AEB_STATSADSUS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
} 

void GarageModeServerSideHandlerImpl::hu_dowenaswtWatcher(){
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t hu_dowenaswt = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("hu_dowenaswt");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        hu_dowenaswt = mPropertyManager->getCProValue(mp);
        LOG(INFO)<<"hu_dowenaswt "<<hu_dowenaswt;
        mHal->onPropertyValue(*Create_hu_dowenaswt(hu_dowenaswt),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_hu_dowenaswt(int32_t value)
{
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_HU_DOWENASWT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
} 

    
    
void GarageModeServerSideHandlerImpl::sc_fcm_acc_take_over_reqWatcher(){
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t sc_fcm_acc_take_over_req = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("sc_fcm_acc_take_over_req");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        sc_fcm_acc_take_over_req = mPropertyManager->getCProValue(mp);
        LOG(INFO)<<"sc_fcm_acc_take_over_req "<<sc_fcm_acc_take_over_req;
        mHal->onPropertyValue(*Create_sc_fcm_acc_take_over_reqWatcher(sc_fcm_acc_take_over_req),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_sc_fcm_acc_take_over_reqWatcher(int32_t value)
     {
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_FCM_ACCTAKEOVERREQ);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
} 

void GarageModeServerSideHandlerImpl::fcm_tjatakeoverreqWatcher(){
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t fcm_tjatakeoverreq = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("fcm_tjatakeoverreq");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        fcm_tjatakeoverreq = mPropertyManager->getCProValue(mp);
        LOG(INFO)<<"fcm_tjatakeoverreq "<<fcm_tjatakeoverreq;
        mHal->onPropertyValue(*Create_fcm_tjatakeoverreqWatcher(fcm_tjatakeoverreq),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_fcm_tjatakeoverreqWatcher(int32_t value)
     {
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_FCM_TJATAKEOVERREQ);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
} 

void GarageModeServerSideHandlerImpl::bc_fcm_aeb_recreqWatcher(){
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t bc_fcm_aeb_recreq = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_aeb_recreq");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        bc_fcm_aeb_recreq = mPropertyManager->getCProValue(mp);
        LOG(INFO)<<"bc_fcm_aeb_recreq "<<bc_fcm_aeb_recreq;
        mHal->onPropertyValue(*Create_bc_fcm_aeb_recreqWatcher(bc_fcm_aeb_recreq),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_aeb_recreqWatcher(int32_t value)
     {
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_FCM_AEBRECREQ);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
} 

void GarageModeServerSideHandlerImpl::hu_hma_enable_swWatcher(){
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t hu_hma_enable_sw = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("hu_hma_enable_sw");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        hu_hma_enable_sw = mPropertyManager->getCProValue(mp);
        LOG(INFO)<<"hu_hma_enable_sw "<<hu_hma_enable_sw;
        mHal->onPropertyValue(*Create_hu_hma_enable_swWatcher(hu_hma_enable_sw),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_hu_hma_enable_swWatcher(int32_t value)
     {
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_HU_HMA_ENABLESW);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
} 

void GarageModeServerSideHandlerImpl::hu_ica_enable_sw_tWatcher(){
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t hu_ica_enable_sw_t = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("hu_ica_enable_sw_t");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        hu_ica_enable_sw_t = mPropertyManager->getCProValue(mp);
        LOG(INFO)<<"hu_ica_enable_sw_t "<<hu_ica_enable_sw_t;
        mHal->onPropertyValue(*Create_hu_ica_enable_sw_tWatcher(hu_ica_enable_sw_t),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_hu_ica_enable_sw_tWatcher(int32_t value)
     {
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_HU_ICAENASWT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
} 

void GarageModeServerSideHandlerImpl::hu_ica_avd_truck_setWatcher(){
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t hu_ica_avd_truck_set = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("hu_ica_avd_truck_set");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        hu_ica_avd_truck_set = mPropertyManager->getCProValue(mp);
        LOG(INFO)<<"hu_ica_avd_truck_set "<<hu_ica_avd_truck_set;
        mHal->onPropertyValue(*Create_hu_ica_avd_truck_setWatcher(hu_ica_avd_truck_set),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_hu_ica_avd_truck_setWatcher(int32_t value)
     {
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_HU_ICAAVDTRUCKSET);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
} 

void GarageModeServerSideHandlerImpl::hu_ldw_alert_method_swWatcher(){
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t hu_ldw_alert_method_sw = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("hu_ldw_alert_method_sw");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        hu_ldw_alert_method_sw = mPropertyManager->getCProValue(mp);
        LOG(INFO)<<"hu_ldw_alert_method_sw "<<hu_ldw_alert_method_sw;
        mHal->onPropertyValue(*Create_hu_ldw_alert_method_swWatcher(hu_ldw_alert_method_sw),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_hu_ldw_alert_method_swWatcher(int32_t value)
     {
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_HU_LDW_ALERTMETHODSW);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
} 

void GarageModeServerSideHandlerImpl::hu_lka_enable_swWatcher(){
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t hu_lka_enable_sw = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("hu_lka_enable_sw");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        hu_lka_enable_sw = mPropertyManager->getCProValue(mp);
        LOG(INFO)<<"hu_lka_enable_sw "<<hu_lka_enable_sw;
        mHal->onPropertyValue(*Create_hu_lka_enable_swWatcher(hu_lka_enable_sw),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_hu_lka_enable_swWatcher(int32_t value)
     {
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_HU_LKA_ENABLESW);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
} 

void GarageModeServerSideHandlerImpl::hu_elk_enb_swWatcher(){
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t hu_elk_enb_sw = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("hu_elk_enb_sw");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        hu_elk_enb_sw = mPropertyManager->getCProValue(mp);
        LOG(INFO)<<"hu_elk_enb_sw "<<hu_elk_enb_sw;
        mHal->onPropertyValue(*Create_hu_elk_enb_swWatcher(hu_elk_enb_sw),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_hu_elk_enb_swWatcher(int32_t value)
     {
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_HU_ELKENBSW);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
} 
     
void GarageModeServerSideHandlerImpl::hu_fcw_enable_swWatcher(){
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t hu_fcw_enable_sw = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("hu_fcw_enable_sw");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        hu_fcw_enable_sw = mPropertyManager->getCProValue(mp);
        LOG(INFO)<<"hu_fcw_enable_sw "<<hu_fcw_enable_sw;
        mHal->onPropertyValue(*Create_hu_fcw_enable_swWatcher(hu_fcw_enable_sw),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_hu_fcw_enable_swWatcher(int32_t value)
     {
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_HU_FCW_ENABLESW);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
} 

void GarageModeServerSideHandlerImpl::hu_abe_enable_swWatcher(){
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t hu_abe_enable_sw = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("hu_abe_enable_sw");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        hu_abe_enable_sw = mPropertyManager->getCProValue(mp);
        LOG(INFO)<<"hu_abe_enable_sw "<<hu_abe_enable_sw;
        mHal->onPropertyValue(*Create_hu_abe_enable_swWatcher(hu_abe_enable_sw),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_hu_abe_enable_swWatcher(int32_t value)
     {
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_HU_AEB_ENABLESW);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
} 

void GarageModeServerSideHandlerImpl::hu_bsd_enable_swWatcher(){
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t hu_bsd_enable_sw = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("hu_bsd_enable_sw");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        hu_bsd_enable_sw = mPropertyManager->getCProValue(mp);
        LOG(INFO)<<"hu_bsd_enable_sw "<<hu_bsd_enable_sw;
        mHal->onPropertyValue(*Create_hu_bsd_enable_swWatcher(hu_bsd_enable_sw),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_hu_bsd_enable_swWatcher(int32_t value)
     {
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_HU_BSD_ENABLESW);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
} 

void GarageModeServerSideHandlerImpl::hu_rcw_enable_swWatcher(){
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t hu_rcw_enable_sw = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("hu_rcw_enable_sw");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        hu_rcw_enable_sw = mPropertyManager->getCProValue(mp);
        LOG(INFO)<<"hu_rcw_enable_sw "<<hu_rcw_enable_sw;
        mHal->onPropertyValue(*Create_hu_rcw_enable_swWatcher(hu_rcw_enable_sw),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_hu_rcw_enable_swWatcher(int32_t value)
     {
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_HU_RCW_ENABLESW);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
} 

void GarageModeServerSideHandlerImpl::hu_rcta_enable_swWatcher(){
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t hu_rcta_enable_sw = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("hu_rcta_enable_sw");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        hu_rcta_enable_sw = mPropertyManager->getCProValue(mp);
        LOG(INFO)<<"hu_rcta_enable_sw "<<hu_rcta_enable_sw;
        mHal->onPropertyValue(*Create_hu_rcta_enable_swWatcher(hu_rcta_enable_sw),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_hu_rcta_enable_swWatcher(int32_t value)
     {
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_HU_RCTA_ENABLESW);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
} 

void GarageModeServerSideHandlerImpl::hu_slif_enableswWatcher(){
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t hu_slif_enablesw = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("hu_slif_enablesw");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        hu_slif_enablesw = mPropertyManager->getCProValue(mp);
        LOG(INFO)<<"hu_slif_enablesw "<<hu_slif_enablesw;
        mHal->onPropertyValue(*Create_hu_slif_enableswWatcher(hu_slif_enablesw),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_hu_slif_enableswWatcher(int32_t value)
     {
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_HU_SLIF_ENABLESW);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
} 

void GarageModeServerSideHandlerImpl::hu_slwf_enableswWatcher(){
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t hu_slwf_enablesw = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("hu_slwf_enablesw");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        hu_slwf_enablesw = mPropertyManager->getCProValue(mp);
        LOG(INFO)<<"hu_slwf_enablesw "<<hu_slwf_enablesw;
        mHal->onPropertyValue(*Create_hu_slwf_enableswWatcher(hu_slwf_enablesw),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_hu_slwf_enableswWatcher(int32_t value)
{
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_HU_SLWF_ENABLESW);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
} 

void GarageModeServerSideHandlerImpl::hu_navi_country_codeWatcher(){
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t hu_navi_country_code = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("hu_navi_country_code");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        hu_navi_country_code = mPropertyManager->getCProValue(mp);
        LOG(INFO)<<"hu_navi_country_code "<<hu_navi_country_code;
        mHal->onPropertyValue(*Create_hu_navi_country_codeWatcher(hu_navi_country_code),true);
    }
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_hu_navi_country_codeWatcher(int32_t value)
{
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_HU_NAVICOUNTRYCODE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
} 

void GarageModeServerSideHandlerImpl::bc_bcm_avalueble_key_in_carWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t bc_bcm_avalueble_key_in_car = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_avalueble_key_in_car");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        bc_bcm_avalueble_key_in_car = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_bc_bcm_avalueble_key_in_carReq(bc_bcm_avalueble_key_in_car),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_avalueble_key_in_carReq(int32_t bc_bcm_avalueble_key_in_car) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_avalueble_key_in_car);
    req->prop = toInt(VehicleProperty::GECKO_BCM_AVALUEBLEKEYINCAR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_sys_fail_staWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_vcu_sys_fail_sta = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_sys_fail_sta");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_vcu_sys_fail_sta = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_vcu_sys_fail_staReq(ec_vcu_sys_fail_sta),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_sys_fail_staReq(int32_t ec_vcu_sys_fail_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_sys_fail_sta);
    req->prop = toInt(VehicleProperty::GECKO_VCU_SYSFAILSTA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ccu_remt_steer_whl_heat_fbWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ccu_remt_steer_whl_heat_fb = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccu_remt_steer_whl_heat_fb");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ccu_remt_steer_whl_heat_fb = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ccu_remt_steer_whl_heat_fbReq(ec_ccu_remt_steer_whl_heat_fb),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccu_remt_steer_whl_heat_fbReq(int32_t ec_ccu_remt_steer_whl_heat_fb) {
    auto req = mValueObjectPool->obtainInt32(ec_ccu_remt_steer_whl_heat_fb);
    req->prop = toInt(VehicleProperty::GECKO_CCU_REMTSTEERWHLHEATFB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ccu_remt_power_ctrl_fbWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ccu_remt_power_ctrl_fb = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccu_remt_power_ctrl_fb");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ccu_remt_power_ctrl_fb = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ccu_remt_power_ctrl_fbReq(ec_ccu_remt_power_ctrl_fb),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccu_remt_power_ctrl_fbReq(int32_t ec_ccu_remt_power_ctrl_fb) {
    auto req = mValueObjectPool->obtainInt32(ec_ccu_remt_power_ctrl_fb);
    req->prop = toInt(VehicleProperty::GECKO_CCU_REMTPOWERCTRLFB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ccu_remt_mai_dr_seat_heat_fbWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ccu_remt_mai_dr_seat_heat_fb = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccu_remt_mai_dr_seat_heat_fb");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ccu_remt_mai_dr_seat_heat_fb = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ccu_remt_mai_dr_seat_heat_fbReq(ec_ccu_remt_mai_dr_seat_heat_fb),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccu_remt_mai_dr_seat_heat_fbReq(int32_t ec_ccu_remt_mai_dr_seat_heat_fb) {
    auto req = mValueObjectPool->obtainInt32(ec_ccu_remt_mai_dr_seat_heat_fb);
    req->prop = toInt(VehicleProperty::GECKO_CCU_REMTMAIDRSEATHEATFB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}


void GarageModeServerSideHandlerImpl::bc_pp_sensor_fault_sts_rlWatcher()
{
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t bc_pp_sensor_fault_sts_rl = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("bc_pp_sensor_fault_sts_rl");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        bc_pp_sensor_fault_sts_rl = mPropertyManager->getCProValue(mp);
        LOG(INFO)<<"bc_pp_sensor_fault_sts_rl "<<bc_pp_sensor_fault_sts_rl;
        mHal->onPropertyValue(*Create_bc_pp_sensor_fault_sts_rlReq(bc_pp_sensor_fault_sts_rl),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_pp_sensor_fault_sts_rlReq(int32_t value)
     {
        auto req = mValueObjectPool->obtainInt32(value);
        req->prop = toInt(VehicleProperty::GECKO_PP_SENSOR_FAULT_STS_RL);
        req->areaId = 0;
        req->timestamp = elapsedRealtimeNano();
        req->status = VehiclePropertyStatus::AVAILABLE;
        return req;
    }

void GarageModeServerSideHandlerImpl::bc_pp_sensor_fault_sts_rlmWatcher()
{
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t bc_pp_sensor_fault_sts_rlm = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("bc_pp_sensor_fault_sts_rlm");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        bc_pp_sensor_fault_sts_rlm = mPropertyManager->getCProValue(mp);
        LOG(INFO)<<"bc_pp_sensor_fault_sts_rlm "<<bc_pp_sensor_fault_sts_rlm;
        mHal->onPropertyValue(*Create_bc_pp_sensor_fault_sts_rlmReq(bc_pp_sensor_fault_sts_rlm),true);
    }
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_pp_sensor_fault_sts_rlmReq(int32_t value)
    {
        auto req = mValueObjectPool->obtainInt32(value);
        req->prop = toInt(VehicleProperty::GECKO_PP_SENSOR_FAULT_STS_RLM);
        req->areaId = 0;
        req->timestamp = elapsedRealtimeNano();
        req->status = VehiclePropertyStatus::AVAILABLE;
        return req;
    }

void GarageModeServerSideHandlerImpl::bc_pp_sensor_fault_sts_rrmWatcher()
{
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t bc_pp_sensor_fault_sts_rrm = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("bc_pp_sensor_fault_sts_rrm");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        bc_pp_sensor_fault_sts_rrm = mPropertyManager->getCProValue(mp);
        LOG(INFO)<<"bc_pp_sensor_fault_sts_rrm "<<bc_pp_sensor_fault_sts_rrm;
        mHal->onPropertyValue(*Create_bc_pp_sensor_fault_sts_rrmReq(bc_pp_sensor_fault_sts_rrm),true);
    }
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_pp_sensor_fault_sts_rrmReq(int32_t value)
    {
        auto req = mValueObjectPool->obtainInt32(value);
        req->prop = toInt(VehicleProperty::GECKO_PP_SENSOR_FAULT_STS_RRM);
        req->areaId = 0;
        req->timestamp = elapsedRealtimeNano();
        req->status = VehiclePropertyStatus::AVAILABLE;
        return req;
    }

void GarageModeServerSideHandlerImpl::bc_pp_sensor_fault_sts_rrWatcher()
{
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t bc_pp_sensor_fault_sts_rr = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("bc_pp_sensor_fault_sts_rr");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        bc_pp_sensor_fault_sts_rr = mPropertyManager->getCProValue(mp);
        LOG(INFO)<<"bc_pp_sensor_fault_sts_rr "<<bc_pp_sensor_fault_sts_rr;
        mHal->onPropertyValue(*Create_bc_pp_sensor_fault_sts_rrReq(bc_pp_sensor_fault_sts_rr),true);
    }
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_pp_sensor_fault_sts_rrReq(int32_t value)
    {
        auto req = mValueObjectPool->obtainInt32(value);
        req->prop = toInt(VehicleProperty::GECKO_PP_SENSOR_FAULT_STS_RR);
        req->areaId = 0;
        req->timestamp = elapsedRealtimeNano();
        req->status = VehiclePropertyStatus::AVAILABLE;
        return req;
    }

void GarageModeServerSideHandlerImpl::bc_pp_rl_distWatcher()
{
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t bc_pp_rl_dist = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("bc_pp_rl_dist");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        bc_pp_rl_dist = mPropertyManager->getCProValue(mp);
        LOG(INFO)<<"bc_pp_rl_dist "<<bc_pp_rl_dist;
        mHal->onPropertyValue(*Create_bc_pp_rl_distReq(bc_pp_rl_dist),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_pp_rl_distReq(int32_t value)
    {
        auto req = mValueObjectPool->obtainInt32(value);
        req->prop = toInt(VehicleProperty::GECKO_PP_RLDIST);
        req->areaId = 0;
        req->timestamp = elapsedRealtimeNano();
        req->status = VehiclePropertyStatus::AVAILABLE;
        return req;
    }

void GarageModeServerSideHandlerImpl::bc_pp_rlm_distWatcher()
{
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t bc_pp_rlm_dist = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("bc_pp_rlm_dist");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        bc_pp_rlm_dist = mPropertyManager->getCProValue(mp);
        LOG(INFO)<<"bc_pp_rlm_dist "<<bc_pp_rlm_dist;
        mHal->onPropertyValue(*Create_bc_pp_rlm_distReq(bc_pp_rlm_dist),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_pp_rlm_distReq(int32_t value)
    {
        auto req = mValueObjectPool->obtainInt32(value);
        req->prop = toInt(VehicleProperty::GECKO_PP_RLMDIST);
        req->areaId = 0;
        req->timestamp = elapsedRealtimeNano();
        req->status = VehiclePropertyStatus::AVAILABLE;
        return req;
    }

void GarageModeServerSideHandlerImpl::bc_pp_rrm_distWatcher()
{
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t bc_pp_rrm_dist = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("bc_pp_rrm_dist");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        bc_pp_rrm_dist = mPropertyManager->getCProValue(mp);
        LOG(INFO)<<"bc_pp_rrm_dist "<<bc_pp_rrm_dist;
        mHal->onPropertyValue(*Create_bc_pp_rrm_distReq(bc_pp_rrm_dist),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_pp_rrm_distReq(int32_t value)
    {
        auto req = mValueObjectPool->obtainInt32(value);
        req->prop = toInt(VehicleProperty::GECKO_PP_RRMDIST);
        req->areaId = 0;
        req->timestamp = elapsedRealtimeNano();
        req->status = VehiclePropertyStatus::AVAILABLE;
        return req;
    }

void GarageModeServerSideHandlerImpl::bc_pp_rr_distWatcher()
{
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t bc_pp_rr_dist = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("bc_pp_rr_dist");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        bc_pp_rr_dist = mPropertyManager->getCProValue(mp);
        LOG(INFO)<<"bc_pp_rr_dist "<<bc_pp_rr_dist;
        mHal->onPropertyValue(*Create_bc_pp_rr_distReq(bc_pp_rr_dist),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_pp_rr_distReq(int32_t value)
    {
        auto req = mValueObjectPool->obtainInt32(value);
        req->prop = toInt(VehicleProperty::GECKO_PP_RRDIST);
        req->areaId = 0;
        req->timestamp = elapsedRealtimeNano();
        req->status = VehiclePropertyStatus::AVAILABLE;
        return req;
    }

void GarageModeServerSideHandlerImpl::bc_pp_sdwfsr_distWatcher()
{
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t bc_pp_sdwfsr_dist = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("bc_pp_sdwfsr_dist");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        bc_pp_sdwfsr_dist = mPropertyManager->getCProValue(mp);
        LOG(INFO)<<"bc_pp_sdwfsr_dist "<<bc_pp_sdwfsr_dist;
        mHal->onPropertyValue(*Create_bc_pp_sdwfsr_distReq(bc_pp_sdwfsr_dist),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_pp_sdwfsr_distReq(int32_t value)
     {
        auto req = mValueObjectPool->obtainInt32(value);
        req->prop = toInt(VehicleProperty::GECKO_PP_SDWFSRDIST);
        req->areaId = 0;
        req->timestamp = elapsedRealtimeNano();
        req->status = VehiclePropertyStatus::AVAILABLE;
        return req;
    }

void GarageModeServerSideHandlerImpl::bc_pp_sdwrsl_distWatcher()
{
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t bc_pp_sdwrsl_dist = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("bc_pp_sdwrsl_dist");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        bc_pp_sdwrsl_dist = mPropertyManager->getCProValue(mp);
        LOG(INFO)<<"bc_pp_sdwrsl_dist "<<bc_pp_sdwrsl_dist;
        mHal->onPropertyValue(*Create_bc_pp_sdwrsl_distReq(bc_pp_sdwrsl_dist),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_pp_sdwrsl_distReq(int32_t value)
    {
        auto req = mValueObjectPool->obtainInt32(value);
        req->prop = toInt(VehicleProperty::GECKO_PP_SDWRSL_DIST);
        req->areaId = 0;
        req->timestamp = elapsedRealtimeNano();
        req->status = VehiclePropertyStatus::AVAILABLE;
        return req;
    }

void GarageModeServerSideHandlerImpl::bc_pp_sdwrsl_mid_distWatcher()
{
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t bc_pp_sdwrsl_mid_dist = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("bc_pp_sdwrsl_mid_dist");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        bc_pp_sdwrsl_mid_dist = mPropertyManager->getCProValue(mp);
        LOG(INFO)<<"bc_pp_sdwrsl_mid_dist "<<bc_pp_sdwrsl_mid_dist;

        mHal->onPropertyValue(*Create_bc_pp_sdwrsl_mid_distReq(bc_pp_sdwrsl_mid_dist),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_pp_sdwrsl_mid_distReq(int32_t value)
    {
        auto req = mValueObjectPool->obtainInt32(value);
        req->prop = toInt(VehicleProperty::GECKO_PP_SDWRSL_MID_DIST);
        req->areaId = 0;
        req->timestamp = elapsedRealtimeNano();
        req->status = VehiclePropertyStatus::AVAILABLE;
        return req;
    }

void GarageModeServerSideHandlerImpl::bc_pp_sdwrsr_mid_distWatcher()
{
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t bc_pp_sdwrsr_mid_dist = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("bc_pp_sdwrsr_mid_dist");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        bc_pp_sdwrsr_mid_dist = mPropertyManager->getCProValue(mp);
        LOG(INFO)<<"bc_pp_sdwrsr_mid_dist "<<bc_pp_sdwrsr_mid_dist;
        mHal->onPropertyValue(*Create_bc_pp_sdwrsr_mid_distReq(bc_pp_sdwrsr_mid_dist),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_pp_sdwrsr_mid_distReq(int32_t value)
    {
        auto req = mValueObjectPool->obtainInt32(value);
        req->prop = toInt(VehicleProperty::GECKO_PP_SDWRSR_MID_DIST);
        req->areaId = 0;
        req->timestamp = elapsedRealtimeNano();
        req->status = VehiclePropertyStatus::AVAILABLE;
        return req;
    }

static bool isHexadecimalNumber(const std::string& hexStr) {
    for (char c : hexStr) {
        if (!((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'))) {
            return false;
        }
    }
    return true;
}

void GarageModeServerSideHandlerImpl::bc_fm_auto_seek_resWatcher()
{
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    std::string bc_fm_auto_seek_res;
    ConfigDBC* mp = mPropertyManager->findCProperty("bc_fm_auto_seek_res");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        bc_fm_auto_seek_res = mPropertyManager->getCProStrValue(mp);
        LOG(INFO)<<"bc_fm_auto_seek_res "<<bc_fm_auto_seek_res;
        std::vector<int16_t> value{0};
        std::string flag = bc_fm_auto_seek_res.substr(0, 2);
        if(!isHexadecimalNumber(bc_fm_auto_seek_res))
        {
            ALOGE(" bc_fm_auto_seek_resWatcher msg:%s is err", bc_fm_auto_seek_res.c_str());
            return;
        }
        size_t count = std::stoi(flag,  nullptr, 16);
        if (count > 0) {
            value.clear();
            std::string newStr = bc_fm_auto_seek_res.substr(2);
            size_t start = 0;
            size_t length = 4;
            while (start < newStr.size()) {
                std::string channel = newStr.substr(start, length);
                value.push_back(std::stoi(channel, nullptr, 16));
                start += length;
                ALOGI(" bc_fm_auto_seek_resWatcher channel:%d", std::stoi(channel, nullptr, 16));
            }
        }
        mHal->onPropertyValue(*Create_bc_fm_auto_seek_resWatcherReq(value),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fm_auto_seek_resWatcherReq(std::vector<int16_t> value)
{
    auto req = mValueObjectPool->obtain(VehiclePropertyType::INT32_VEC, value.size());
    req->prop = toInt(VehicleProperty::GECKO_FM_AUTO_SEEK_RES);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    for(int i = 0; i < (int)value.size(); i++){
      req->value.int32Values[i] = value[i];
    }
    return req;
}
void GarageModeServerSideHandlerImpl::fm_searchWatcher()
{
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    std::string fm_search;
    ConfigDBC* mp = mPropertyManager->findCProperty("fm_search");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        fm_search = mPropertyManager->getCProStrValue(mp);
        LOG(INFO)<<"fm_search "<<fm_search;
        if(fm_search.length() < 6){
          ALOGE("fm_search length error %s", fm_search.c_str());
          return;
        }
        std::string flag = fm_search.substr(0, 2);
        std::string data("0000");
        if(flag == "01"){
          //seek
          data.clear();
          data = fm_search.substr(2);
        }
        int32_t value = std::stoi(data, nullptr, 16);
        LOG(INFO)<<"fm_search:"<<fm_search<<" value:"<<value<< " data:"<<data;
        mHal->onPropertyValue(*Create_fm_searchWatcherReq(value),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_fm_searchWatcherReq(int32_t value)
    {
        auto req = mValueObjectPool->obtainInt32(value);
        req->prop = toInt(VehicleProperty::GECKO_CCM_FM_SEARCH);
        req->areaId = 0;
        req->timestamp = elapsedRealtimeNano();
        req->status = VehiclePropertyStatus::AVAILABLE;
        return req;
    }


void GarageModeServerSideHandlerImpl::fm_volumeWatcher()
{
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t fm_volume = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("fm_volume");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        fm_volume = mPropertyManager->getCProValue(mp);
        LOG(INFO)<<"fm_volume "<<fm_volume;
        mHal->onPropertyValue(*Create_fm_volumeWatcherReq(fm_volume),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_fm_volumeWatcherReq(int32_t value)
{
    auto req = mValueObjectPool->obtainInt32(value);
    req->prop = toInt(VehicleProperty::GECKO_CCM_FM_VOLUME);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_err_amountWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_vcu_err_amount = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_err_amount");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_vcu_err_amount = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_vcu_err_amountReq(ec_vcu_err_amount),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_err_amountReq(int32_t ec_vcu_err_amount) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_err_amount);
    req->prop = toInt(VehicleProperty::GECKO_VCU_ERRAMOUNT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_err_bitWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_vcu_err_bit = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_err_bit");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_vcu_err_bit = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_vcu_err_bitReq(ec_vcu_err_bit),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_err_bitReq(int32_t ec_vcu_err_bit) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_err_bit);
    req->prop = toInt(VehicleProperty::GECKO_VCU_ERRBIT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_carriage_light_staWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t bc_bcm_carriage_light_sta = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_carriage_light_sta");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        bc_bcm_carriage_light_sta = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_bc_bcm_carriage_light_staReq(bc_bcm_carriage_light_sta),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_carriage_light_staReq(int32_t bc_bcm_carriage_light_sta) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_carriage_light_sta);
    req->prop = toInt(VehicleProperty::GECKO_BCM_CARRIAGELIGHTSTA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_eps_steer_wheel_angleWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_eps_steer_wheel_angle = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_eps_steer_wheel_angle");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_eps_steer_wheel_angle = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_eps_steer_wheel_angleReq(ec_eps_steer_wheel_angle),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_eps_steer_wheel_angleReq(int32_t ec_eps_steer_wheel_angle) {
    auto req = mValueObjectPool->obtainInt32(ec_eps_steer_wheel_angle);
    req->prop = toInt(VehicleProperty::GECKO_EPS_STEER_WHEEL_ANGLE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_eps_steer_wheel_angle_validWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_eps_steer_wheel_angle_valid = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_eps_steer_wheel_angle_valid");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_eps_steer_wheel_angle_valid = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_eps_steer_wheel_angle_validReq(ec_eps_steer_wheel_angle_valid),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_eps_steer_wheel_angle_validReq(int32_t ec_eps_steer_wheel_angle_valid) {
    auto req = mValueObjectPool->obtainInt32(ec_eps_steer_wheel_angle_valid);
    req->prop = toInt(VehicleProperty::GECKO_EPS_STEER_WHEEL_ANGLE_VALID);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_eps_rot_speedWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_eps_rot_speed = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_eps_rot_speed");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_eps_rot_speed = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_eps_rot_speedReq(ec_eps_rot_speed),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_eps_rot_speedReq(int32_t ec_eps_rot_speed) {
    auto req = mValueObjectPool->obtainInt32(ec_eps_rot_speed);
    req->prop = toInt(VehicleProperty::GECKO_EPS_ROT_SPEED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_eps_steer_wheel_angle_failureWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_eps_steer_wheel_angle_failure = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_eps_steer_wheel_angle_failure");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_eps_steer_wheel_angle_failure = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_eps_steer_wheel_angle_failureReq(ec_eps_steer_wheel_angle_failure),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_eps_steer_wheel_angle_failureReq(int32_t ec_eps_steer_wheel_angle_failure) {
    auto req = mValueObjectPool->obtainInt32(ec_eps_steer_wheel_angle_failure);
    req->prop = toInt(VehicleProperty::GECKO_EPS_STEER_WHEEL_ANGLE_FAILURE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_eps_electric_power_staWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_eps_electric_power_sta = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_eps_electric_power_sta");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_eps_electric_power_sta = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_eps_electric_power_staReq(ec_eps_electric_power_sta),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_eps_electric_power_staReq(int32_t ec_eps_electric_power_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_eps_electric_power_sta);
    req->prop = toInt(VehicleProperty::GECKO_EPS_ELECTRIC_POWER_STA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_eps_steer_wheel_angle_calibratedWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_eps_steer_wheel_angle_calibrated = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_eps_steer_wheel_angle_calibrated");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_eps_steer_wheel_angle_calibrated = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_eps_steer_wheel_angle_calibratedReq(ec_eps_steer_wheel_angle_calibrated),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_eps_steer_wheel_angle_calibratedReq(int32_t ec_eps_steer_wheel_angle_calibrated) {
    auto req = mValueObjectPool->obtainInt32(ec_eps_steer_wheel_angle_calibrated);
    req->prop = toInt(VehicleProperty::GECKO_EPS_STEER_WHEEL_ANGLE_CALIBRATED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_eps_mot_tqWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_eps_mot_tq = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_eps_mot_tq");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_eps_mot_tq = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_eps_mot_tqReq(ec_eps_mot_tq),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_eps_mot_tqReq(int32_t ec_eps_mot_tq) {
    auto req = mValueObjectPool->obtainInt32(ec_eps_mot_tq);
    req->prop = toInt(VehicleProperty::GECKO_EPS_MOT_TQ);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

	
void GarageModeServerSideHandlerImpl::ec_fcm_lgt_fct_actv_flgWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_fcm_lgt_fct_actv_flg = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_lgt_fct_actv_flg");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_fcm_lgt_fct_actv_flg = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_fcm_lgt_fct_actv_flgReq(ec_fcm_lgt_fct_actv_flg),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_lgt_fct_actv_flgReq(int32_t ec_fcm_lgt_fct_actv_flg) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_lgt_fct_actv_flg);
    req->prop = toInt(VehicleProperty::GECKO_FCM_LGT_FCTACTV_FLG);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_fcm_eps_set_steer_whl_aglWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_fcm_eps_set_steer_whl_agl = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_eps_set_steer_whl_agl");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_fcm_eps_set_steer_whl_agl = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_fcm_eps_set_steer_whl_aglReq(ec_fcm_eps_set_steer_whl_agl),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_eps_set_steer_whl_aglReq(int32_t ec_fcm_eps_set_steer_whl_agl) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_eps_set_steer_whl_agl);
    req->prop = toInt(VehicleProperty::GECKO_FCM_EPS_SET_STEERWHLAGL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_fcm_steer_tq_req_activeWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_fcm_steer_tq_req_active = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_steer_tq_req_active");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_fcm_steer_tq_req_active = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_fcm_steer_tq_req_activeReq(ec_fcm_steer_tq_req_active),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_steer_tq_req_activeReq(int32_t ec_fcm_steer_tq_req_active) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_steer_tq_req_active);
    req->prop = toInt(VehicleProperty::GECKO_FCM_STEER_TQREQ_ACTIVE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_fcm_eps_ctrl_reqWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_fcm_eps_ctrl_req = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_eps_ctrl_req");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_fcm_eps_ctrl_req = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_fcm_eps_ctrl_reqReq(ec_fcm_eps_ctrl_req),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_eps_ctrl_reqReq(int32_t ec_fcm_eps_ctrl_req) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_eps_ctrl_req);
    req->prop = toInt(VehicleProperty::GECKO_FCM_EPS_CTRL_REQ);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_fcm_drvr_warn_vib_reqWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_fcm_drvr_warn_vib_req = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_drvr_warn_vib_req");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_fcm_drvr_warn_vib_req = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_fcm_drvr_warn_vib_reqReq(ec_fcm_drvr_warn_vib_req),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_drvr_warn_vib_reqReq(int32_t ec_fcm_drvr_warn_vib_req) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_drvr_warn_vib_req);
    req->prop = toInt(VehicleProperty::GECKO_FCM_DRVR_WARNVIB_REQ);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_fcm_daeps_mode_reqWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_fcm_daeps_mode_req = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_daeps_mode_req");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_fcm_daeps_mode_req = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_fcm_daeps_mode_reqReq(ec_fcm_daeps_mode_req),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_daeps_mode_reqReq(int32_t ec_fcm_daeps_mode_req) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_daeps_mode_req);
    req->prop = toInt(VehicleProperty::GECKO_FCM_DAEPS_MODE_REQ);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_fcm_act_drv_asst_stsWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_fcm_act_drv_asst_sts = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_act_drv_asst_sts");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_fcm_act_drv_asst_sts = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_fcm_act_drv_asst_stsReq(ec_fcm_act_drv_asst_sts),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_act_drv_asst_stsReq(int32_t ec_fcm_act_drv_asst_sts) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_act_drv_asst_sts);
    req->prop = toInt(VehicleProperty::GECKO_FCM_ACTDRV_ASSTSTS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_fcm_overtake_ass_sys_stsWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_fcm_overtake_ass_sys_sts = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_overtake_ass_sys_sts");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_fcm_overtake_ass_sys_sts = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_fcm_overtake_ass_sys_stsReq(ec_fcm_overtake_ass_sys_sts),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_overtake_ass_sys_stsReq(int32_t ec_fcm_overtake_ass_sys_sts) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_overtake_ass_sys_sts);
    req->prop = toInt(VehicleProperty::GECKO_FCM_OVERTAKE_ASSSYSSTS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_fcm_turn_lamp_reqWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_fcm_turn_lamp_req = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_turn_lamp_req");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_fcm_turn_lamp_req = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_fcm_turn_lamp_reqReq(ec_fcm_turn_lamp_req),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_turn_lamp_reqReq(int32_t ec_fcm_turn_lamp_req) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_turn_lamp_req);
    req->prop = toInt(VehicleProperty::GECKO_FCM_TURN_LAMP_REQ);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_tjaica_supps_abortnWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_fcm_tjaica_supps_abortn = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_tjaica_supps_abortn");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_fcm_tjaica_supps_abortn = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_fcm_tjaica_supps_abortnReq(ec_fcm_tjaica_supps_abortn),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_tjaica_supps_abortnReq(int32_t ec_fcm_tjaica_supps_abortn) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_tjaica_supps_abortn);
    req->prop = toInt(VehicleProperty::GECKO_FCM_TJAICA_SUPPS_ABORTN);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_fcm_lka_torq_fact_reqWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    float ec_fcm_lka_torq_fact_req = 0.0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_lka_torq_fact_req");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_fcm_lka_torq_fact_req = getActualFloatValue(mPropertyManager->getCProValue(mp), 0.01, 0);
        mHal->onPropertyValue(*Create_ec_fcm_lka_torq_fact_reqReq(ec_fcm_lka_torq_fact_req),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_lka_torq_fact_reqReq(float ec_fcm_lka_torq_fact_req) {
    auto req = mValueObjectPool->obtainFloat(ec_fcm_lka_torq_fact_req);
    req->prop = toInt(VehicleProperty::GECKO_FCM_LKATORQ_FACT_REQ);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_fcm_hma_supps_abortnWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_fcm_hma_supps_abortn = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_hma_supps_abortn");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_fcm_hma_supps_abortn = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_fcm_hma_supps_abortnReq(ec_fcm_hma_supps_abortn),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_hma_supps_abortnReq(int32_t ec_fcm_hma_supps_abortn) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_hma_supps_abortn);
    req->prop = toInt(VehicleProperty::GECKO_FCM_HMA_SUPPS_ABORTN);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_fcm_lkaldw_supps_abortnWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_fcm_lkaldw_supps_abortn = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_lkaldw_supps_abortn");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_fcm_lkaldw_supps_abortn = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_fcm_lkaldw_supps_abortnReq(ec_fcm_lkaldw_supps_abortn),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_lkaldw_supps_abortnReq(int32_t ec_fcm_lkaldw_supps_abortn) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_lkaldw_supps_abortn);
    req->prop = toInt(VehicleProperty::GECKO_FCM_LKALDW_SUPPS_ABORTN);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_fcm_flt_stsWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_fcm_flt_sts = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_flt_sts");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_fcm_flt_sts = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_fcm_flt_stsReq(ec_fcm_flt_sts),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_flt_stsReq(int32_t ec_fcm_flt_sts) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_flt_sts);
    req->prop = toInt(VehicleProperty::GECKO_FCM_FLTSTS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_fcm_elk_supps_abortnWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_fcm_elk_supps_abortn = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_elk_supps_abortn");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_fcm_elk_supps_abortn = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_fcm_elk_supps_abortnReq(ec_fcm_elk_supps_abortn),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_elk_supps_abortnReq(int32_t ec_fcm_elk_supps_abortn) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_elk_supps_abortn);
    req->prop = toInt(VehicleProperty::GECKO_FCM_ELK_SUPPS_ABORTN);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_fcm_acc_whl_tq_req_valWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_fcm_acc_whl_tq_req_val = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_acc_whl_tq_req_val");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_fcm_acc_whl_tq_req_val = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_fcm_acc_whl_tq_req_valReq(ec_fcm_acc_whl_tq_req_val),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_acc_whl_tq_req_valReq(int32_t ec_fcm_acc_whl_tq_req_val) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_acc_whl_tq_req_val);
    req->prop = toInt(VehicleProperty::GECKO_FCM_ACCWHL_TQREQVAL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}


void GarageModeServerSideHandlerImpl::ec_fcm_acc_whl_tq_req_actvWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_fcm_acc_whl_tq_req_actv = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_acc_whl_tq_req_actv");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_fcm_acc_whl_tq_req_actv = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_fcm_acc_whl_tq_req_actvReq(ec_fcm_acc_whl_tq_req_actv),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_acc_whl_tq_req_actvReq(int32_t ec_fcm_acc_whl_tq_req_actv) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_acc_whl_tq_req_actv);
    req->prop = toInt(VehicleProperty::GECKO_FCM_ACCWHL_TQREQACTV);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_fcm_acc_whl_deceWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    float ec_fcm_acc_whl_dece = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_acc_whl_dece");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_fcm_acc_whl_dece = getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.05, -9.5);
        mHal->onPropertyValue(*Create_ec_fcm_acc_whl_deceReq(ec_fcm_acc_whl_dece),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_acc_whl_deceReq(float ec_fcm_acc_whl_dece) {
    auto req = mValueObjectPool->obtainFloat(ec_fcm_acc_whl_dece);
    req->prop = toInt(VehicleProperty::GECKO_FCM_ACCWHL_DECE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_fcm_acc_tar_accrnWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    float ec_fcm_acc_tar_accrn = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_acc_tar_accrn");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_fcm_acc_tar_accrn = getActualFloatValue(mPropertyManager->getCProValue(mp), 0.05, -5);
        mHal->onPropertyValue(*Create_ec_fcm_acc_tar_accrnReq(ec_fcm_acc_tar_accrn),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_acc_tar_accrnReq(float ec_fcm_acc_tar_accrn) {
    auto req = mValueObjectPool->obtainFloat(ec_fcm_acc_tar_accrn);
    req->prop = toInt(VehicleProperty::GECKO_FCM_ACCTAR_ACCRN);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_fcm_acc_supp_abortWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_fcm_acc_supp_abort = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_acc_supp_abort");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_fcm_acc_supp_abort = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_fcm_acc_supp_abortReq(ec_fcm_acc_supp_abort),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_acc_supp_abortReq(int32_t ec_fcm_acc_supp_abort) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_acc_supp_abort);
    req->prop = toInt(VehicleProperty::GECKO_FCM_ACCSUPP_ABORT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_fcm_acc_tar_accrn_req_actvWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_fcm_acc_tar_accrn_req_actv = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_acc_tar_accrn_req_actv");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_fcm_acc_tar_accrn_req_actv = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_fcm_acc_tar_accrn_req_actvReq(ec_fcm_acc_tar_accrn_req_actv),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_acc_tar_accrn_req_actvReq(int32_t ec_fcm_acc_tar_accrn_req_actv) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_acc_tar_accrn_req_actv);
    req->prop = toInt(VehicleProperty::GECKO_FCM_ACCTAR_ACCRN_REQACTV);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_fcm_epb_req_vWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_fcm_epb_req_v = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_epb_req_v");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_fcm_epb_req_v = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_fcm_epb_req_vReq(ec_fcm_epb_req_v),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_epb_req_vReq(int32_t ec_fcm_epb_req_v) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_epb_req_v);
    req->prop = toInt(VehicleProperty::GECKO_FCM_EPB_REQV);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_fcm_epb_reqWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_fcm_epb_req = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_epb_req");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_fcm_epb_req = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_fcm_epb_reqReq(ec_fcm_epb_req),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_epb_reqReq(int32_t ec_fcm_epb_req) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_epb_req);
    req->prop = toInt(VehicleProperty::GECKO_FCM_EPB_REQ);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_fcm_acc_shutdown_modeWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_fcm_acc_shutdown_mode = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_acc_shutdown_mode");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_fcm_acc_shutdown_mode = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_fcm_acc_shutdown_modeReq(ec_fcm_acc_shutdown_mode),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_acc_shutdown_modeReq(int32_t ec_fcm_acc_shutdown_mode) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_acc_shutdown_mode);
    req->prop = toInt(VehicleProperty::GECKO_FCM_ACC_SHUTDOWN_MODE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}
void GarageModeServerSideHandlerImpl::ec_fcm_ahd_obj_idWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_fcm_ahd_obj_id = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_ahd_obj_id");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_fcm_ahd_obj_id = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_fcm_ahd_obj_idReq(ec_fcm_ahd_obj_id),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_ahd_obj_idReq(int32_t ec_fcm_ahd_obj_id) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_ahd_obj_id);
    req->prop = toInt(VehicleProperty::GECKO_FCM_AHDOBJID);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_fcm_acc_tgt_axWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    float ec_fcm_acc_tgt_ax = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_acc_tgt_ax");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_fcm_acc_tgt_ax = getActualFloatValue_offset_is_float(mPropertyManager->getCProValue(mp), 0.05, -9.5);
        mHal->onPropertyValue(*Create_ec_fcm_acc_tgt_axReq(ec_fcm_acc_tgt_ax),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_acc_tgt_axReq(float ec_fcm_acc_tgt_ax) {
    auto req = mValueObjectPool->obtainFloat(ec_fcm_acc_tgt_ax);
    req->prop = toInt(VehicleProperty::GECKO_FCM_ACC_TGTAX);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_fcm_aeb_tgt_axWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_fcm_aeb_tgt_ax = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_aeb_tgt_ax");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_fcm_aeb_tgt_ax = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_fcm_aeb_tgt_axReq(ec_fcm_aeb_tgt_ax),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_aeb_tgt_axReq(int32_t ec_fcm_aeb_tgt_ax) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_aeb_tgt_ax);
    req->prop = toInt(VehicleProperty::GECKO_FCM_AEB_TGTAX);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_fcm_acc_modeWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_fcm_acc_mode = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_acc_mode");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_fcm_acc_mode = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_fcm_acc_modeReq(ec_fcm_acc_mode),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_acc_modeReq(int32_t ec_fcm_acc_mode) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_acc_mode);
    req->prop = toInt(VehicleProperty::GECKO_FCM_ACC_MODE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_fcm_acc_req_standstillWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_fcm_acc_req_standstill = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_acc_req_standstill");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_fcm_acc_req_standstill = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_fcm_acc_req_standstillReq(ec_fcm_acc_req_standstill),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_acc_req_standstillReq(int32_t ec_fcm_acc_req_standstill) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_acc_req_standstill);
    req->prop = toInt(VehicleProperty::GECKO_FCM_ACC_REQSTANDSTILL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_fcm_aeb_reqWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_fcm_aeb_req = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_aeb_req");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_fcm_aeb_req = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_fcm_aeb_reqReq(ec_fcm_aeb_req),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_aeb_reqReq(int32_t ec_fcm_aeb_req) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_aeb_req);
    req->prop = toInt(VehicleProperty::GECKO_FCM_AEB_REQ);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_fcm_aeb_standstill_stsWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_fcm_aeb_standstill_sts = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_aeb_standstill_sts");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_fcm_aeb_standstill_sts = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_fcm_aeb_standstill_stsReq(ec_fcm_aeb_standstill_sts),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_aeb_standstill_stsReq(int32_t ec_fcm_aeb_standstill_sts) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_aeb_standstill_sts);
    req->prop = toInt(VehicleProperty::GECKO_FCM_AEB_STANDSTILLSTS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_fcm_aeb_standstill_sts_vWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_fcm_aeb_standstill_sts_v = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_aeb_standstill_sts_v");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_fcm_aeb_standstill_sts_v = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_fcm_aeb_standstill_sts_vReq(ec_fcm_aeb_standstill_sts_v),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_aeb_standstill_sts_vReq(int32_t ec_fcm_aeb_standstill_sts_v) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_aeb_standstill_sts_v);
    req->prop = toInt(VehicleProperty::GECKO_FCM_AEB_STANDSTILLSTSV);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_fcm_aba_levelWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_fcm_aba_level = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_aba_level");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_fcm_aba_level = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_fcm_aba_levelReq(ec_fcm_aba_level),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_aba_levelReq(int32_t ec_fcm_aba_level) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_aba_level);
    req->prop = toInt(VehicleProperty::GECKO_FCM_ABA_LEVEL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_fcm_awb_levelWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_fcm_awb_level = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_awb_level");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_fcm_awb_level = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_fcm_awb_levelReq(ec_fcm_awb_level),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_awb_levelReq(int32_t ec_fcm_awb_level) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_awb_level);
    req->prop = toInt(VehicleProperty::GECKO_FCM_AWB_LEVEL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_fcm_aba_reqWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_fcm_aba_req = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_aba_req");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_fcm_aba_req = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_fcm_aba_reqReq(ec_fcm_aba_req),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_aba_reqReq(int32_t ec_fcm_aba_req) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_aba_req);
    req->prop = toInt(VehicleProperty::GECKO_FCM_ABA_REQ);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_fcm_eba_reqWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_fcm_eba_req = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_eba_req");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_fcm_eba_req = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_fcm_eba_reqReq(ec_fcm_eba_req),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_eba_reqReq(int32_t ec_fcm_eba_req) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_eba_req);
    req->prop = toInt(VehicleProperty::GECKO_FCM_EBA_REQ);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_fcm_awb_reqWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_fcm_awb_req = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_awb_req");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_fcm_awb_req = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_fcm_awb_reqReq(ec_fcm_awb_req),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_awb_reqReq(int32_t ec_fcm_awb_req) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_awb_req);
    req->prop = toInt(VehicleProperty::GECKO_FCM_AWB_REQ);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_fcm_abp_reqWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_fcm_abp_req = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_abp_req");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_fcm_abp_req = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_fcm_abp_reqReq(ec_fcm_abp_req),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_abp_reqReq(int32_t ec_fcm_abp_req) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_abp_req);
    req->prop = toInt(VehicleProperty::GECKO_FCM_ABP_REQ);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_fcm_acc_tgt_ax_reqWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_fcm_acc_tgt_ax_req = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_acc_tgt_ax_req");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_fcm_acc_tgt_ax_req = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_fcm_acc_tgt_ax_reqReq(ec_fcm_acc_tgt_ax_req),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_acc_tgt_ax_reqReq(int32_t ec_fcm_acc_tgt_ax_req) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_acc_tgt_ax_req);
    req->prop = toInt(VehicleProperty::GECKO_FCM_ACC_TGTAX_REQ);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_fcm_crv_decel_staWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_fcm_crv_decel_sta = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_crv_decel_sta");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_fcm_crv_decel_sta = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_fcm_crv_decel_staReq(ec_fcm_crv_decel_sta),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_crv_decel_staReq(int32_t ec_fcm_crv_decel_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_crv_decel_sta);
    req->prop = toInt(VehicleProperty::GECKO_FCM_CRV_DECEL_STA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_fcm_acc_req_drive_offWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_fcm_acc_req_drive_off = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_acc_req_drive_off");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_fcm_acc_req_drive_off = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_fcm_acc_req_drive_offReq(ec_fcm_acc_req_drive_off),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_acc_req_drive_offReq(int32_t ec_fcm_acc_req_drive_off) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_acc_req_drive_off);
    req->prop = toInt(VehicleProperty::GECKO_FCM_ACC_REQDRIVEOFF);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::mc_scs_frnt_wipr_swt_stWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t mc_scs_frnt_wipr_swt_st = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("mc_scs_frnt_wipr_swt_st");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        mc_scs_frnt_wipr_swt_st = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_mc_scs_frnt_wipr_swt_stReq(mc_scs_frnt_wipr_swt_st),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_mc_scs_frnt_wipr_swt_stReq(int32_t mc_scs_frnt_wipr_swt_st) {
    auto req = mValueObjectPool->obtainInt32(mc_scs_frnt_wipr_swt_st);
    req->prop = toInt(VehicleProperty::GECKO_SCS_FRNTWIPR_SWTST);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::mc_scs_low_beam_swt_stWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t mc_scs_low_beam_swt_st = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("mc_scs_low_beam_swt_st");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        mc_scs_low_beam_swt_st = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_mc_scs_low_beam_swt_stReq(mc_scs_low_beam_swt_st),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_mc_scs_low_beam_swt_stReq(int32_t mc_scs_low_beam_swt_st) {
    auto req = mValueObjectPool->obtainInt32(mc_scs_low_beam_swt_st);
    req->prop = toInt(VehicleProperty::GECKO_SCS_LOWBEAM_SWTST);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::mc_scs_hi_beam_swt_stWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t mc_scs_hi_beam_swt_st = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("mc_scs_hi_beam_swt_st");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        mc_scs_hi_beam_swt_st = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_mc_scs_hi_beam_swt_stReq(mc_scs_hi_beam_swt_st),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_mc_scs_hi_beam_swt_stReq(int32_t mc_scs_hi_beam_swt_st) {
    auto req = mValueObjectPool->obtainInt32(mc_scs_hi_beam_swt_st);
    req->prop = toInt(VehicleProperty::GECKO_SCS_HIBEAM_SWTST);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::mc_scs_over_veh_beam_swt_stWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t mc_scs_over_veh_beam_swt_st = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("mc_scs_over_veh_beam_swt_st");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        mc_scs_over_veh_beam_swt_st = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_mc_scs_over_veh_beam_swt_stReq(mc_scs_over_veh_beam_swt_st),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_mc_scs_over_veh_beam_swt_stReq(int32_t mc_scs_over_veh_beam_swt_st) {
    auto req = mValueObjectPool->obtainInt32(mc_scs_over_veh_beam_swt_st);
    req->prop = toInt(VehicleProperty::GECKO_SCS_OVERVEHBEAM_SWTST);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::mc_scs_lamp_auto_stWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t mc_scs_lamp_auto_st = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("mc_scs_lamp_auto_st");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        mc_scs_lamp_auto_st = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_mc_scs_lamp_auto_stReq(mc_scs_lamp_auto_st),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_mc_scs_lamp_auto_stReq(int32_t mc_scs_lamp_auto_st) {
    auto req = mValueObjectPool->obtainInt32(mc_scs_lamp_auto_st);
    req->prop = toInt(VehicleProperty::GECKO_SCS_LAMP_AUTO_ST);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::mc_scs_le_turn_lmp_swt_stWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t mc_scs_le_turn_lmp_swt_st = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("mc_scs_le_turn_lmp_swt_st");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        mc_scs_le_turn_lmp_swt_st = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_mc_scs_le_turn_lmp_swt_stReq(mc_scs_le_turn_lmp_swt_st),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_mc_scs_le_turn_lmp_swt_stReq(int32_t mc_scs_le_turn_lmp_swt_st) {
    auto req = mValueObjectPool->obtainInt32(mc_scs_le_turn_lmp_swt_st);
    req->prop = toInt(VehicleProperty::GECKO_SCS_LETURNLMP_SWTST);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::mc_scs_ri_turn_lmp_swt_stWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t mc_scs_ri_turn_lmp_swt_st = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("mc_scs_ri_turn_lmp_swt_st");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        mc_scs_ri_turn_lmp_swt_st = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_mc_scs_ri_turn_lmp_swt_stReq(mc_scs_ri_turn_lmp_swt_st),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_mc_scs_ri_turn_lmp_swt_stReq(int32_t mc_scs_ri_turn_lmp_swt_st) {
    auto req = mValueObjectPool->obtainInt32(mc_scs_ri_turn_lmp_swt_st);
    req->prop = toInt(VehicleProperty::GECKO_SCS_RITURNLMP_SWTST);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_hv_bat_cell_temp_aveWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_hv_bat_cell_temp_ave = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_hv_bat_cell_temp_ave");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_hv_bat_cell_temp_ave = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_hv_bat_cell_temp_aveReq(ec_bms_hv_bat_cell_temp_ave),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_hv_bat_cell_temp_aveReq(int32_t ec_bms_hv_bat_cell_temp_ave) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_hv_bat_cell_temp_ave);
    req->prop = toInt(VehicleProperty::GECKO_BMS_HV_BAT_CELL_TEMP_AVE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_dcs_actl_chrg_currentWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_dcs_actl_chrg_current = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_dcs_actl_chrg_current");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_dcs_actl_chrg_current = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_dcs_actl_chrg_currentReq(ec_bms_dcs_actl_chrg_current),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_dcs_actl_chrg_currentReq(int32_t ec_bms_dcs_actl_chrg_current) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_dcs_actl_chrg_current);
    req->prop = toInt(VehicleProperty::GECKO_BMS_DCS_ACTL_CHRG_CURRENT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_scs_gear_shift_lever_pst_reqWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_scs_gear_shift_lever_pst_req = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_scs_gear_shift_lever_pst_req");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_scs_gear_shift_lever_pst_req = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_scs_gear_shift_lever_pst_reqReq(ec_scs_gear_shift_lever_pst_req),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_scs_gear_shift_lever_pst_reqReq(int32_t ec_scs_gear_shift_lever_pst_req) {
    auto req = mValueObjectPool->obtainInt32(ec_scs_gear_shift_lever_pst_req);
    req->prop = toInt(VehicleProperty::GECKO_SCS_GEAR_SHIFT_LEVER_PST_REQ);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_ac_chrg_atcl_staWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_ac_chrg_atcl_sta = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_ac_chrg_atcl_sta");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_ac_chrg_atcl_sta = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_ac_chrg_atcl_staReq(ec_bms_ac_chrg_atcl_sta),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_ac_chrg_atcl_staReq(int32_t ec_bms_ac_chrg_atcl_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_ac_chrg_atcl_sta);
    req->prop = toInt(VehicleProperty::GECKO_BMS_AC_CHRG_ATCL_STA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_outlet_coolant_actl_tempWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_outlet_coolant_actl_temp = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_outlet_coolant_actl_temp");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_outlet_coolant_actl_temp = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_outlet_coolant_actl_tempReq(ec_bms_outlet_coolant_actl_temp),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_outlet_coolant_actl_tempReq(int32_t ec_bms_outlet_coolant_actl_temp) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_outlet_coolant_actl_temp);
    req->prop = toInt(VehicleProperty::GECKO_BMS_OUTLET_COOLANT_ACTL_TEMP);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_outlet_coolant_actl_temp_validWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_outlet_coolant_actl_temp_valid = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_outlet_coolant_actl_temp_valid");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_outlet_coolant_actl_temp_valid = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_outlet_coolant_actl_temp_validReq(ec_bms_outlet_coolant_actl_temp_valid),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_outlet_coolant_actl_temp_validReq(int32_t ec_bms_outlet_coolant_actl_temp_valid) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_outlet_coolant_actl_temp_valid);
    req->prop = toInt(VehicleProperty::GECKO_BMS_OUTLET_COOLANT_ACTL_TEMP_VALID);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_inlet_coolant_actl_tempWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_inlet_coolant_actl_temp = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_inlet_coolant_actl_temp");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_inlet_coolant_actl_temp = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_inlet_coolant_actl_tempReq(ec_bms_inlet_coolant_actl_temp),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_inlet_coolant_actl_tempReq(int32_t ec_bms_inlet_coolant_actl_temp) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_inlet_coolant_actl_temp);
    req->prop = toInt(VehicleProperty::GECKO_BMS_INLET_COOLANT_ACTL_TEMP);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_inlet_coolant_actl_temp_validWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_inlet_coolant_actl_temp_valid = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_inlet_coolant_actl_temp_valid");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_inlet_coolant_actl_temp_valid = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_inlet_coolant_actl_temp_validReq(ec_bms_inlet_coolant_actl_temp_valid),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_inlet_coolant_actl_temp_validReq(int32_t ec_bms_inlet_coolant_actl_temp_valid) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_inlet_coolant_actl_temp_valid);
    req->prop = toInt(VehicleProperty::GECKO_BMS_INLET_COOLANT_ACTL_TEMP_VALID);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_max_chrg_voltage_acWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_max_chrg_voltage_ac = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_max_chrg_voltage_ac");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_max_chrg_voltage_ac = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_max_chrg_voltage_acReq(ec_bms_max_chrg_voltage_ac),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_max_chrg_voltage_acReq(int32_t ec_bms_max_chrg_voltage_ac) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_max_chrg_voltage_ac);
    req->prop = toInt(VehicleProperty::GECKO_BMS_MAX_CHRG_VOLTAGE_AC);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_max_chrg_current_acWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_max_chrg_current_ac = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_max_chrg_current_ac");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_max_chrg_current_ac = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_max_chrg_current_acReq(ec_bms_max_chrg_current_ac),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_max_chrg_current_acReq(int32_t ec_bms_max_chrg_current_ac) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_max_chrg_current_ac);
    req->prop = toInt(VehicleProperty::GECKO_BMS_MAX_CHRG_CURRENT_AC);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_bat_sohWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_bat_soh = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_bat_soh");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_bat_soh = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_bat_sohReq(ec_bms_bat_soh),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_bat_sohReq(int32_t ec_bms_bat_soh) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_bat_soh);
    req->prop = toInt(VehicleProperty::GECKO_BMS_BAT_SOH);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_temp_max_dc_charge_socketWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_temp_max_dc_charge_socket = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_temp_max_dc_charge_socket");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_temp_max_dc_charge_socket = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_temp_max_dc_charge_socketReq(ec_bms_temp_max_dc_charge_socket),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_temp_max_dc_charge_socketReq(int32_t ec_bms_temp_max_dc_charge_socket) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_temp_max_dc_charge_socket);
    req->prop = toInt(VehicleProperty::GECKO_BMS_TEMP_MAX_DC_CHARGE_SOCKET);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_pcb_temp_maxWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_pcb_temp_max = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_pcb_temp_max");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_pcb_temp_max = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_pcb_temp_maxReq(ec_bms_pcb_temp_max),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_pcb_temp_maxReq(int32_t ec_bms_pcb_temp_max) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_pcb_temp_max);
    req->prop = toInt(VehicleProperty::GECKO_BMS_PCB_TEMP_MAX);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_max_allow_chrg_cur_dcWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_max_allow_chrg_cur_dc = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_max_allow_chrg_cur_dc");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_max_allow_chrg_cur_dc = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_max_allow_chrg_cur_dcReq(ec_bms_max_allow_chrg_cur_dc),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_max_allow_chrg_cur_dcReq(int32_t ec_bms_max_allow_chrg_cur_dc) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_max_allow_chrg_cur_dc);
    req->prop = toInt(VehicleProperty::GECKO_BMS_MAX_ALLOW_CHRG_CUR_DC);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_max_allow_chrg_vol_dcWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_max_allow_chrg_vol_dc = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_max_allow_chrg_vol_dc");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_max_allow_chrg_vol_dc = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_max_allow_chrg_vol_dcReq(ec_bms_max_allow_chrg_vol_dc),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_max_allow_chrg_vol_dcReq(int32_t ec_bms_max_allow_chrg_vol_dc) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_max_allow_chrg_vol_dc);
    req->prop = toInt(VehicleProperty::GECKO_BMS_MAX_ALLOW_CHRG_VOL_DC);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_electronic_lock_ctrlWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_electronic_lock_ctrl = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_electronic_lock_ctrl");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_electronic_lock_ctrl = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_electronic_lock_ctrlReq(ec_bms_electronic_lock_ctrl),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_electronic_lock_ctrlReq(int32_t ec_bms_electronic_lock_ctrl) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_electronic_lock_ctrl);
    req->prop = toInt(VehicleProperty::GECKO_BMS_ELECTRONIC_LOCK_CTRL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_electronic_lock_stateWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_electronic_lock_state = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_electronic_lock_state");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_electronic_lock_state = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_electronic_lock_stateReq(ec_bms_electronic_lock_state),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_electronic_lock_stateReq(int32_t ec_bms_electronic_lock_state) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_electronic_lock_state);
    req->prop = toInt(VehicleProperty::GECKO_BMS_ELECTRONIC_LOCK_STATE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_contactor_state_dc_chargerWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_contactor_state_dc_charger = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_contactor_state_dc_charger");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_contactor_state_dc_charger = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_contactor_state_dc_chargerReq(ec_bms_contactor_state_dc_charger),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_contactor_state_dc_chargerReq(int32_t ec_bms_contactor_state_dc_charger) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_contactor_state_dc_charger);
    req->prop = toInt(VehicleProperty::GECKO_BMS_CONTACTOR_STATE_DC_CHARGER);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_dcs_charge_requestWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_dcs_charge_request = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_dcs_charge_request");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_dcs_charge_request = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_dcs_charge_requestReq(ec_bms_dcs_charge_request),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_dcs_charge_requestReq(int32_t ec_bms_dcs_charge_request) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_dcs_charge_request);
    req->prop = toInt(VehicleProperty::GECKO_BMS_DCS_CHARGE_REQUEST);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_dcs_chrg_a_plusWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_dcs_chrg_a_plus = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_dcs_chrg_a_plus");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_dcs_chrg_a_plus = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_dcs_chrg_a_plusReq(ec_bms_dcs_chrg_a_plus),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_dcs_chrg_a_plusReq(int32_t ec_bms_dcs_chrg_a_plus) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_dcs_chrg_a_plus);
    req->prop = toInt(VehicleProperty::GECKO_BMS_DCS_CHRG_A_PLUS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_run_stateWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_run_state = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_run_state");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_run_state = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_run_stateReq(ec_bms_run_state),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_run_stateReq(int32_t ec_bms_run_state) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_run_state);
    req->prop = toInt(VehicleProperty::GECKO_BMS_RUN_STATE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_contactor_state_negativeWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_contactor_state_negative = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_contactor_state_negative");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_contactor_state_negative = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_contactor_state_negativeReq(ec_bms_contactor_state_negative),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_contactor_state_negativeReq(int32_t ec_bms_contactor_state_negative) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_contactor_state_negative);
    req->prop = toInt(VehicleProperty::GECKO_BMS_CONTACTOR_STATE_NEGATIVE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_contactor_state_positiveWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_contactor_state_positive = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_contactor_state_positive");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_contactor_state_positive = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_contactor_state_positiveReq(ec_bms_contactor_state_positive),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_contactor_state_positiveReq(int32_t ec_bms_contactor_state_positive) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_contactor_state_positive);
    req->prop = toInt(VehicleProperty::GECKO_BMS_CONTACTOR_STATE_POSITIVE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_contactor_state_prechargeWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_contactor_state_precharge = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_contactor_state_precharge");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_contactor_state_precharge = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_contactor_state_prechargeReq(ec_bms_contactor_state_precharge),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_contactor_state_prechargeReq(int32_t ec_bms_contactor_state_precharge) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_contactor_state_precharge);
    req->prop = toInt(VehicleProperty::GECKO_BMS_CONTACTOR_STATE_PRECHARGE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_supply_voltage_statusWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_supply_voltage_status = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_supply_voltage_status");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_supply_voltage_status = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_supply_voltage_statusReq(ec_bms_supply_voltage_status),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_supply_voltage_statusReq(int32_t ec_bms_supply_voltage_status) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_supply_voltage_status);
    req->prop = toInt(VehicleProperty::GECKO_BMS_SUPPLY_VOLTAGE_STATUS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_emeshutdown_reqWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_emeshutdown_req = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_emeshutdown_req");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_emeshutdown_req = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_emeshutdown_reqReq(ec_bms_emeshutdown_req),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_emeshutdown_reqReq(int32_t ec_bms_emeshutdown_req) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_emeshutdown_req);
    req->prop = toInt(VehicleProperty::GECKO_BMS_EMESHUTDOWN_REQ);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_charge_interlock_staWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_charge_interlock_sta = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_charge_interlock_sta");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_charge_interlock_sta = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_charge_interlock_staReq(ec_bms_charge_interlock_sta),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_charge_interlock_staReq(int32_t ec_bms_charge_interlock_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_charge_interlock_sta);
    req->prop = toInt(VehicleProperty::GECKO_BMS_CHARGE_INTERLOCK_STA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_dis_charge_interlock_staWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_dis_charge_interlock_sta = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_dis_charge_interlock_sta");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_dis_charge_interlock_sta = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_dis_charge_interlock_staReq(ec_bms_dis_charge_interlock_sta),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_dis_charge_interlock_staReq(int32_t ec_bms_dis_charge_interlock_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_dis_charge_interlock_sta);
    req->prop = toInt(VehicleProperty::GECKO_BMS_DIS_CHARGE_INTERLOCK_STA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_batt_balance_staWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_batt_balance_sta = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_batt_balance_sta");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_batt_balance_sta = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_batt_balance_staReq(ec_bms_batt_balance_sta),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_batt_balance_staReq(int32_t ec_bms_batt_balance_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_batt_balance_sta);
    req->prop = toInt(VehicleProperty::GECKO_BMS_BATT_BALANCE_STA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_therm_runaway_snsr_fltWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_therm_runaway_snsr_flt = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_therm_runaway_snsr_flt");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_therm_runaway_snsr_flt = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_therm_runaway_snsr_fltReq(ec_bms_therm_runaway_snsr_flt),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_therm_runaway_snsr_fltReq(int32_t ec_bms_therm_runaway_snsr_flt) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_therm_runaway_snsr_flt);
    req->prop = toInt(VehicleProperty::GECKO_BMS_THERM_RUNAWAY_SNSR_FLT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_therm_runaway_vlv_stWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_therm_runaway_vlv_st = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_therm_runaway_vlv_st");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_therm_runaway_vlv_st = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_therm_runaway_vlv_stReq(ec_bms_therm_runaway_vlv_st),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_therm_runaway_vlv_stReq(int32_t ec_bms_therm_runaway_vlv_st) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_therm_runaway_vlv_st);
    req->prop = toInt(VehicleProperty::GECKO_BMS_THERM_RUNAWAY_VLV_ST);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_obc_uac_act_l1Watcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ipu_obc_uac_act_l1 = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_obc_uac_act_l1");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ipu_obc_uac_act_l1 = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ipu_obc_uac_act_l1Req(ec_ipu_obc_uac_act_l1),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_obc_uac_act_l1Req(int32_t ec_ipu_obc_uac_act_l1) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_obc_uac_act_l1);
    req->prop = toInt(VehicleProperty::GECKO_IPU_OBC_UAC_ACT_L1);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_obc_uac_act_l2Watcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ipu_obc_uac_act_l2 = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_obc_uac_act_l2");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ipu_obc_uac_act_l2 = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ipu_obc_uac_act_l2Req(ec_ipu_obc_uac_act_l2),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_obc_uac_act_l2Req(int32_t ec_ipu_obc_uac_act_l2) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_obc_uac_act_l2);
    req->prop = toInt(VehicleProperty::GECKO_IPU_OBC_UAC_ACT_L2);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_obc_uac_act_l3Watcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ipu_obc_uac_act_l3 = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_obc_uac_act_l3");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ipu_obc_uac_act_l3 = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ipu_obc_uac_act_l3Req(ec_ipu_obc_uac_act_l3),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_obc_uac_act_l3Req(int32_t ec_ipu_obc_uac_act_l3) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_obc_uac_act_l3);
    req->prop = toInt(VehicleProperty::GECKO_IPU_OBC_UAC_ACT_L3);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_obc_iac_act_l1Watcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ipu_obc_iac_act_l1 = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_obc_iac_act_l1");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ipu_obc_iac_act_l1 = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ipu_obc_iac_act_l1Req(ec_ipu_obc_iac_act_l1),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_obc_iac_act_l1Req(int32_t ec_ipu_obc_iac_act_l1) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_obc_iac_act_l1);
    req->prop = toInt(VehicleProperty::GECKO_IPU_OBC_IAC_ACT_L1);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_obc_iac_act_l2Watcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ipu_obc_iac_act_l2 = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_obc_iac_act_l2");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ipu_obc_iac_act_l2 = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ipu_obc_iac_act_l2Req(ec_ipu_obc_iac_act_l2),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_obc_iac_act_l2Req(int32_t ec_ipu_obc_iac_act_l2) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_obc_iac_act_l2);
    req->prop = toInt(VehicleProperty::GECKO_IPU_OBC_IAC_ACT_L2);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_obc_iac_act_l3Watcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ipu_obc_iac_act_l3 = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_obc_iac_act_l3");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ipu_obc_iac_act_l3 = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ipu_obc_iac_act_l3Req(ec_ipu_obc_iac_act_l3),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_obc_iac_act_l3Req(int32_t ec_ipu_obc_iac_act_l3) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_obc_iac_act_l3);
    req->prop = toInt(VehicleProperty::GECKO_IPU_OBC_IAC_ACT_L3);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_device_int_tempWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ipu_device_int_temp = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_device_int_temp");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ipu_device_int_temp = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ipu_device_int_tempReq(ec_ipu_device_int_temp),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_device_int_tempReq(int32_t ec_ipu_device_int_temp) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_device_int_temp);
    req->prop = toInt(VehicleProperty::GECKO_IPU_DEVICE_INT_TEMP);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_obc_temp_inletWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ipu_obc_temp_inlet = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_obc_temp_inlet");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ipu_obc_temp_inlet = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ipu_obc_temp_inletReq(ec_ipu_obc_temp_inlet),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_obc_temp_inletReq(int32_t ec_ipu_obc_temp_inlet) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_obc_temp_inlet);
    req->prop = toInt(VehicleProperty::GECKO_IPU_OBC_TEMP_INLET);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_obc_ac_max_pw_allowWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ipu_obc_ac_max_pw_allow = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_obc_ac_max_pw_allow");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ipu_obc_ac_max_pw_allow = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ipu_obc_ac_max_pw_allowReq(ec_ipu_obc_ac_max_pw_allow),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_obc_ac_max_pw_allowReq(int32_t ec_ipu_obc_ac_max_pw_allow) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_obc_ac_max_pw_allow);
    req->prop = toInt(VehicleProperty::GECKO_IPU_OBC_AC_MAX_PW_ALLOW);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_obc_inlet_electronic_lockWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ipu_obc_inlet_electronic_lock = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_obc_inlet_electronic_lock");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ipu_obc_inlet_electronic_lock = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ipu_obc_inlet_electronic_lockReq(ec_ipu_obc_inlet_electronic_lock),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_obc_inlet_electronic_lockReq(int32_t ec_ipu_obc_inlet_electronic_lock) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_obc_inlet_electronic_lock);
    req->prop = toInt(VehicleProperty::GECKO_IPU_OBC_INLET_ELECTRONIC_LOCK);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_obc_s2_stateWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ipu_obc_s2_state = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_obc_s2_state");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ipu_obc_s2_state = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ipu_obc_s2_stateReq(ec_ipu_obc_s2_state),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_obc_s2_stateReq(int32_t ec_ipu_obc_s2_state) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_obc_s2_state);
    req->prop = toInt(VehicleProperty::GECKO_IPU_OBC_S2_STATE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_obc_wake_up_modeWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ipu_obc_wake_up_mode = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_obc_wake_up_mode");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ipu_obc_wake_up_mode = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ipu_obc_wake_up_modeReq(ec_ipu_obc_wake_up_mode),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_obc_wake_up_modeReq(int32_t ec_ipu_obc_wake_up_mode) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_obc_wake_up_mode);
    req->prop = toInt(VehicleProperty::GECKO_IPU_OBC_WAKE_UP_MODE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_obc_voltage_ok_l1Watcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ipu_obc_voltage_ok_l1 = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_obc_voltage_ok_l1");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ipu_obc_voltage_ok_l1 = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ipu_obc_voltage_ok_l1Req(ec_ipu_obc_voltage_ok_l1),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_obc_voltage_ok_l1Req(int32_t ec_ipu_obc_voltage_ok_l1) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_obc_voltage_ok_l1);
    req->prop = toInt(VehicleProperty::GECKO_IPU_OBC_VOLTAGE_OK_L1);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_obc_voltage_ok_l2Watcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ipu_obc_voltage_ok_l2 = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_obc_voltage_ok_l2");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ipu_obc_voltage_ok_l2 = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ipu_obc_voltage_ok_l2Req(ec_ipu_obc_voltage_ok_l2),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_obc_voltage_ok_l2Req(int32_t ec_ipu_obc_voltage_ok_l2) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_obc_voltage_ok_l2);
    req->prop = toInt(VehicleProperty::GECKO_IPU_OBC_VOLTAGE_OK_L2);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_obc_voltage_ok_l3Watcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ipu_obc_voltage_ok_l3 = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_obc_voltage_ok_l3");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ipu_obc_voltage_ok_l3 = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ipu_obc_voltage_ok_l3Req(ec_ipu_obc_voltage_ok_l3),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_obc_voltage_ok_l3Req(int32_t ec_ipu_obc_voltage_ok_l3) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_obc_voltage_ok_l3);
    req->prop = toInt(VehicleProperty::GECKO_IPU_OBC_VOLTAGE_OK_L3);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_dcc_high_volt_actl_curWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ipu_dcc_high_volt_actl_cur = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_dcc_high_volt_actl_cur");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ipu_dcc_high_volt_actl_cur = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ipu_dcc_high_volt_actl_curReq(ec_ipu_dcc_high_volt_actl_cur),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_dcc_high_volt_actl_curReq(int32_t ec_ipu_dcc_high_volt_actl_cur) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_dcc_high_volt_actl_cur);
    req->prop = toInt(VehicleProperty::GECKO_IPU_DCC_HIGH_VOLT_ACTL_CUR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_dcc_high_volt_actl_volWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ipu_dcc_high_volt_actl_vol = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_dcc_high_volt_actl_vol");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ipu_dcc_high_volt_actl_vol = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ipu_dcc_high_volt_actl_volReq(ec_ipu_dcc_high_volt_actl_vol),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_dcc_high_volt_actl_volReq(int32_t ec_ipu_dcc_high_volt_actl_vol) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_dcc_high_volt_actl_vol);
    req->prop = toInt(VehicleProperty::GECKO_IPU_DCC_HIGH_VOLT_ACTL_VOL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_obc_hvdc_actl_curWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ipu_obc_hvdc_actl_cur = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_obc_hvdc_actl_cur");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ipu_obc_hvdc_actl_cur = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ipu_obc_hvdc_actl_curReq(ec_ipu_obc_hvdc_actl_cur),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_obc_hvdc_actl_curReq(int32_t ec_ipu_obc_hvdc_actl_cur) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_obc_hvdc_actl_cur);
    req->prop = toInt(VehicleProperty::GECKO_IPU_OBC_HVDC_ACTL_CUR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_obc_connect_main_staWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ipu_obc_connect_main_sta = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_obc_connect_main_sta");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ipu_obc_connect_main_sta = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ipu_obc_connect_main_staReq(ec_ipu_obc_connect_main_sta),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_obc_connect_main_staReq(int32_t ec_ipu_obc_connect_main_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_obc_connect_main_sta);
    req->prop = toInt(VehicleProperty::GECKO_IPU_OBC_CONNECT_MAIN_STA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_obc_requestWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ipu_obc_request = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_obc_request");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ipu_obc_request = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ipu_obc_requestReq(ec_ipu_obc_request),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_obc_requestReq(int32_t ec_ipu_obc_request) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_obc_request);
    req->prop = toInt(VehicleProperty::GECKO_IPU_OBC_REQUEST);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_obc_sys_fail_staWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ipu_obc_sys_fail_sta = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_obc_sys_fail_sta");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ipu_obc_sys_fail_sta = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ipu_obc_sys_fail_staReq(ec_ipu_obc_sys_fail_sta),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_obc_sys_fail_staReq(int32_t ec_ipu_obc_sys_fail_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_obc_sys_fail_sta);
    req->prop = toInt(VehicleProperty::GECKO_IPU_OBC_SYS_FAIL_STA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_obc_hvdc_actl_volWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ipu_obc_hvdc_actl_vol = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_obc_hvdc_actl_vol");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ipu_obc_hvdc_actl_vol = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ipu_obc_hvdc_actl_volReq(ec_ipu_obc_hvdc_actl_vol),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_obc_hvdc_actl_volReq(int32_t ec_ipu_obc_hvdc_actl_vol) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_obc_hvdc_actl_vol);
    req->prop = toInt(VehicleProperty::GECKO_IPU_OBC_HVDC_ACTL_VOL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_obc_errbitWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ipu_obc_errbit = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_obc_errbit");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ipu_obc_errbit = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ipu_obc_errbitReq(ec_ipu_obc_errbit),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_obc_errbitReq(int32_t ec_ipu_obc_errbit) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_obc_errbit);
    req->prop = toInt(VehicleProperty::GECKO_IPU_OBC_ERRBIT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_dcc_low_vol_actl_volWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ipu_dcc_low_vol_actl_vol = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_dcc_low_vol_actl_vol");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ipu_dcc_low_vol_actl_vol = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ipu_dcc_low_vol_actl_volReq(ec_ipu_dcc_low_vol_actl_vol),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_dcc_low_vol_actl_volReq(int32_t ec_ipu_dcc_low_vol_actl_vol) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_dcc_low_vol_actl_vol);
    req->prop = toInt(VehicleProperty::GECKO_IPU_DCC_LOW_VOL_ACTL_VOL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_dcc_low_vol_actl_curWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ipu_dcc_low_vol_actl_cur = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_dcc_low_vol_actl_cur");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ipu_dcc_low_vol_actl_cur = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ipu_dcc_low_vol_actl_curReq(ec_ipu_dcc_low_vol_actl_cur),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_dcc_low_vol_actl_curReq(int32_t ec_ipu_dcc_low_vol_actl_cur) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_dcc_low_vol_actl_cur);
    req->prop = toInt(VehicleProperty::GECKO_IPU_DCC_LOW_VOL_ACTL_CUR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_dcc_precharge_completeWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ipu_dcc_precharge_complete = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_dcc_precharge_complete");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ipu_dcc_precharge_complete = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ipu_dcc_precharge_completeReq(ec_ipu_dcc_precharge_complete),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_dcc_precharge_completeReq(int32_t ec_ipu_dcc_precharge_complete) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_dcc_precharge_complete);
    req->prop = toInt(VehicleProperty::GECKO_IPU_DCC_PRECHARGE_COMPLETE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_dcc_derating_oprt_staWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ipu_dcc_derating_oprt_sta = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_dcc_derating_oprt_sta");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ipu_dcc_derating_oprt_sta = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ipu_dcc_derating_oprt_staReq(ec_ipu_dcc_derating_oprt_sta),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_dcc_derating_oprt_staReq(int32_t ec_ipu_dcc_derating_oprt_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_dcc_derating_oprt_sta);
    req->prop = toInt(VehicleProperty::GECKO_IPU_DCC_DERATING_OPRT_STA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_hvil_fail_staWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ipu_hvil_fail_sta = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_hvil_fail_sta");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ipu_hvil_fail_sta = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ipu_hvil_fail_staReq(ec_ipu_hvil_fail_sta),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_hvil_fail_staReq(int32_t ec_ipu_hvil_fail_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_hvil_fail_sta);
    req->prop = toInt(VehicleProperty::GECKO_IPU_HVIL_FAIL_STA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_dcc_errbitWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ipu_dcc_errbit = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_dcc_errbit");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ipu_dcc_errbit = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ipu_dcc_errbitReq(ec_ipu_dcc_errbit),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_dcc_errbitReq(int32_t ec_ipu_dcc_errbit) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_dcc_errbit);
    req->prop = toInt(VehicleProperty::GECKO_IPU_DCC_ERRBIT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_obc_c_cor_cp_cnctd_stsWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ipu_obc_c_cor_cp_cnctd_sts = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_obc_c_cor_cp_cnctd_sts");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ipu_obc_c_cor_cp_cnctd_sts = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ipu_obc_c_cor_cp_cnctd_stsReq(ec_ipu_obc_c_cor_cp_cnctd_sts),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_obc_c_cor_cp_cnctd_stsReq(int32_t ec_ipu_obc_c_cor_cp_cnctd_sts) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_obc_c_cor_cp_cnctd_sts);
    req->prop = toInt(VehicleProperty::GECKO_IPU_OBC_C_COR_CP_CNCTD_STS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_obc_cp_dutyWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ipu_obc_cp_duty = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_obc_cp_duty");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ipu_obc_cp_duty = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ipu_obc_cp_dutyReq(ec_ipu_obc_cp_duty),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_obc_cp_dutyReq(int32_t ec_ipu_obc_cp_duty) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_obc_cp_duty);
    req->prop = toInt(VehicleProperty::GECKO_IPU_OBC_CP_DUTY);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_obc_cp_max_voltWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ipu_obc_cp_max_volt = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_obc_cp_max_volt");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ipu_obc_cp_max_volt = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ipu_obc_cp_max_voltReq(ec_ipu_obc_cp_max_volt),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_obc_cp_max_voltReq(int32_t ec_ipu_obc_cp_max_volt) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_obc_cp_max_volt);
    req->prop = toInt(VehicleProperty::GECKO_IPU_OBC_CP_MAX_VOLT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_obc_process_codeWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ipu_obc_process_code = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_obc_process_code");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ipu_obc_process_code = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ipu_obc_process_codeReq(ec_ipu_obc_process_code),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_obc_process_codeReq(int32_t ec_ipu_obc_process_code) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_obc_process_code);
    req->prop = toInt(VehicleProperty::GECKO_IPU_OBC_PROCESS_CODE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ipu_obc_cc_resisdentWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ipu_obc_cc_resisdent = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ipu_obc_cc_resisdent");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ipu_obc_cc_resisdent = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ipu_obc_cc_resisdentReq(ec_ipu_obc_cc_resisdent),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ipu_obc_cc_resisdentReq(int32_t ec_ipu_obc_cc_resisdent) {
    auto req = mValueObjectPool->obtainInt32(ec_ipu_obc_cc_resisdent);
    req->prop = toInt(VehicleProperty::GECKO_IPU_OBC_CC_RESISDENT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_eps_torsion_bar_torqueWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_eps_torsion_bar_torque = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_eps_torsion_bar_torque");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_eps_torsion_bar_torque = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_eps_torsion_bar_torqueReq(ec_eps_torsion_bar_torque),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_eps_torsion_bar_torqueReq(int32_t ec_eps_torsion_bar_torque) {
    auto req = mValueObjectPool->obtainInt32(ec_eps_torsion_bar_torque);
    req->prop = toInt(VehicleProperty::GECKO_EPS_TORSION_BAR_TORQUE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_eps_torsion_bar_torque_dirWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_eps_torsion_bar_torque_dir = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_eps_torsion_bar_torque_dir");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_eps_torsion_bar_torque_dir = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_eps_torsion_bar_torque_dirReq(ec_eps_torsion_bar_torque_dir),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_eps_torsion_bar_torque_dirReq(int32_t ec_eps_torsion_bar_torque_dir) {
    auto req = mValueObjectPool->obtainInt32(ec_eps_torsion_bar_torque_dir);
    req->prop = toInt(VehicleProperty::GECKO_EPS_TORSION_BAR_TORQUE_DIR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_eps_torsion_bar_torque_validWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_eps_torsion_bar_torque_valid = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_eps_torsion_bar_torque_valid");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_eps_torsion_bar_torque_valid = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_eps_torsion_bar_torque_validReq(ec_eps_torsion_bar_torque_valid),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_eps_torsion_bar_torque_validReq(int32_t ec_eps_torsion_bar_torque_valid) {
    auto req = mValueObjectPool->obtainInt32(ec_eps_torsion_bar_torque_valid);
    req->prop = toInt(VehicleProperty::GECKO_EPS_TORSION_BAR_TORQUE_VALID);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_eps_elect_power_consumptionWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_eps_elect_power_consumption = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_eps_elect_power_consumption");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_eps_elect_power_consumption = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_eps_elect_power_consumptionReq(ec_eps_elect_power_consumption),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_eps_elect_power_consumptionReq(int32_t ec_eps_elect_power_consumption) {
    auto req = mValueObjectPool->obtainInt32(ec_eps_elect_power_consumption);
    req->prop = toInt(VehicleProperty::GECKO_EPS_ELECT_POWER_CONSUMPTION);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_eps_advanced_mode_statusWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_eps_advanced_mode_status = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_eps_advanced_mode_status");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_eps_advanced_mode_status = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_eps_advanced_mode_statusReq(ec_eps_advanced_mode_status),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_eps_advanced_mode_statusReq(int32_t ec_eps_advanced_mode_status) {
    auto req = mValueObjectPool->obtainInt32(ec_eps_advanced_mode_status);
    req->prop = toInt(VehicleProperty::GECKO_EPS_ADVANCED_MODE_STATUS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_eps_lat_drv_lvl12_srv_avlWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_eps_lat_drv_lvl12_srv_avl = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_eps_lat_drv_lvl12_srv_avl");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_eps_lat_drv_lvl12_srv_avl = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_eps_lat_drv_lvl12_srv_avlReq(ec_eps_lat_drv_lvl12_srv_avl),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_eps_lat_drv_lvl12_srv_avlReq(int32_t ec_eps_lat_drv_lvl12_srv_avl) {
    auto req = mValueObjectPool->obtainInt32(ec_eps_lat_drv_lvl12_srv_avl);
    req->prop = toInt(VehicleProperty::GECKO_EPS_LAT_DRV_LVL12_SRV_AVL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_eps_lat_mc_hptc_wrn_srv_avlWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_eps_lat_mc_hptc_wrn_srv_avl = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_eps_lat_mc_hptc_wrn_srv_avl");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_eps_lat_mc_hptc_wrn_srv_avl = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_eps_lat_mc_hptc_wrn_srv_avlReq(ec_eps_lat_mc_hptc_wrn_srv_avl),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_eps_lat_mc_hptc_wrn_srv_avlReq(int32_t ec_eps_lat_mc_hptc_wrn_srv_avl) {
    auto req = mValueObjectPool->obtainInt32(ec_eps_lat_mc_hptc_wrn_srv_avl);
    req->prop = toInt(VehicleProperty::GECKO_EPS_LAT_MC_HPTC_WRN_SRV_AVL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_eps_pscm_int_rpc_max_trqWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_eps_pscm_int_rpc_max_trq = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_eps_pscm_int_rpc_max_trq");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_eps_pscm_int_rpc_max_trq = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_eps_pscm_int_rpc_max_trqReq(ec_eps_pscm_int_rpc_max_trq),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_eps_pscm_int_rpc_max_trqReq(int32_t ec_eps_pscm_int_rpc_max_trq) {
    auto req = mValueObjectPool->obtainInt32(ec_eps_pscm_int_rpc_max_trq);
    req->prop = toInt(VehicleProperty::GECKO_EPS_PSCM_INT_RPC_MAX_TRQ);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_eps_torsion_bar_torque_qfWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_eps_torsion_bar_torque_qf = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_eps_torsion_bar_torque_qf");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_eps_torsion_bar_torque_qf = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_eps_torsion_bar_torque_qfReq(ec_eps_torsion_bar_torque_qf),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_eps_torsion_bar_torque_qfReq(int32_t ec_eps_torsion_bar_torque_qf) {
    auto req = mValueObjectPool->obtainInt32(ec_eps_torsion_bar_torque_qf);
    req->prop = toInt(VehicleProperty::GECKO_EPS_TORSION_BAR_TORQUE_QF);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_eps_pscm_int_rpc_min_trqWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_eps_pscm_int_rpc_min_trq = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_eps_pscm_int_rpc_min_trq");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_eps_pscm_int_rpc_min_trq = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_eps_pscm_int_rpc_min_trqReq(ec_eps_pscm_int_rpc_min_trq),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_eps_pscm_int_rpc_min_trqReq(int32_t ec_eps_pscm_int_rpc_min_trq) {
    auto req = mValueObjectPool->obtainInt32(ec_eps_pscm_int_rpc_min_trq);
    req->prop = toInt(VehicleProperty::GECKO_EPS_PSCM_INT_RPC_MIN_TRQ);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_eps_lat_mc_steer_tq_activeWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_eps_lat_mc_steer_tq_active = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_eps_lat_mc_steer_tq_active");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_eps_lat_mc_steer_tq_active = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_eps_lat_mc_steer_tq_activeReq(ec_eps_lat_mc_steer_tq_active),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_eps_lat_mc_steer_tq_activeReq(int32_t ec_eps_lat_mc_steer_tq_active) {
    auto req = mValueObjectPool->obtainInt32(ec_eps_lat_mc_steer_tq_active);
    req->prop = toInt(VehicleProperty::GECKO_EPS_LAT_MC_STEER_TQ_ACTIVE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_eps_lat_mc_hptc_wrn_activeWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_eps_lat_mc_hptc_wrn_active = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_eps_lat_mc_hptc_wrn_active");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_eps_lat_mc_hptc_wrn_active = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_eps_lat_mc_hptc_wrn_activeReq(ec_eps_lat_mc_hptc_wrn_active),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_eps_lat_mc_hptc_wrn_activeReq(int32_t ec_eps_lat_mc_hptc_wrn_active) {
    auto req = mValueObjectPool->obtainInt32(ec_eps_lat_mc_hptc_wrn_active);
    req->prop = toInt(VehicleProperty::GECKO_EPS_LAT_MC_HPTC_WRN_ACTIVE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_eps_max_allwd_rot_spdWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_eps_max_allwd_rot_spd = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_eps_max_allwd_rot_spd");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_eps_max_allwd_rot_spd = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_eps_max_allwd_rot_spdReq(ec_eps_max_allwd_rot_spd),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_eps_max_allwd_rot_spdReq(int32_t ec_eps_max_allwd_rot_spd) {
    auto req = mValueObjectPool->obtainInt32(ec_eps_max_allwd_rot_spd);
    req->prop = toInt(VehicleProperty::GECKO_EPS_MAX_ALLWD_ROT_SPD);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_eps_lks_agl_sys_stsWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_eps_lks_agl_sys_sts = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_eps_lks_agl_sys_sts");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_eps_lks_agl_sys_sts = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_eps_lks_agl_sys_stsReq(ec_eps_lks_agl_sys_sts),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_eps_lks_agl_sys_stsReq(int32_t ec_eps_lks_agl_sys_sts) {
    auto req = mValueObjectPool->obtainInt32(ec_eps_lks_agl_sys_sts);
    req->prop = toInt(VehicleProperty::GECKO_EPS_LKS_AGL_SYS_STS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_eps_max_allwd_aglWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_eps_max_allwd_agl = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_eps_max_allwd_agl");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_eps_max_allwd_agl = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_eps_max_allwd_aglReq(ec_eps_max_allwd_agl),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_eps_max_allwd_aglReq(int32_t ec_eps_max_allwd_agl) {
    auto req = mValueObjectPool->obtainInt32(ec_eps_max_allwd_agl);
    req->prop = toInt(VehicleProperty::GECKO_EPS_MAX_ALLWD_AGL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_eps_steer_tqWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_eps_steer_tq = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_eps_steer_tq");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_eps_steer_tq = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_eps_steer_tqReq(ec_eps_steer_tq),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_eps_steer_tqReq(int32_t ec_eps_steer_tq) {
    auto req = mValueObjectPool->obtainInt32(ec_eps_steer_tq);
    req->prop = toInt(VehicleProperty::GECKO_EPS_STEER_TQ);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_eps_lks_agl_ctrl_avl_stsWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_eps_lks_agl_ctrl_avl_sts = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_eps_lks_agl_ctrl_avl_sts");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_eps_lks_agl_ctrl_avl_sts = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_eps_lks_agl_ctrl_avl_stsReq(ec_eps_lks_agl_ctrl_avl_sts),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_eps_lks_agl_ctrl_avl_stsReq(int32_t ec_eps_lks_agl_ctrl_avl_sts) {
    auto req = mValueObjectPool->obtainInt32(ec_eps_lks_agl_ctrl_avl_sts);
    req->prop = toInt(VehicleProperty::GECKO_EPS_LKS_AGL_CTRL_AVL_STS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_req_brake_light_onWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_esc_req_brake_light_on = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_req_brake_light_on");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_esc_req_brake_light_on = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_esc_req_brake_light_onReq(ec_esc_req_brake_light_on),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_req_brake_light_onReq(int32_t ec_esc_req_brake_light_on) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_req_brake_light_on);
    req->prop = toInt(VehicleProperty::GECKO_ESC_REQ_BRAKE_LIGHT_ON);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_ebd_active_staWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_esc_ebd_active_sta = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_ebd_active_sta");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_esc_ebd_active_sta = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_esc_ebd_active_staReq(ec_esc_ebd_active_sta),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_ebd_active_staReq(int32_t ec_esc_ebd_active_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_ebd_active_sta);
    req->prop = toInt(VehicleProperty::GECKO_ESC_EBD_ACTIVE_STA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_ess_activeWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_esc_ess_active = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_ess_active");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_esc_ess_active = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_esc_ess_activeReq(ec_esc_ess_active),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_ess_activeReq(int32_t ec_esc_ess_active) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_ess_active);
    req->prop = toInt(VehicleProperty::GECKO_ESC_ESS_ACTIVE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_cdp_activeWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_esc_cdp_active = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_cdp_active");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_esc_cdp_active = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_esc_cdp_activeReq(ec_esc_cdp_active),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_cdp_activeReq(int32_t ec_esc_cdp_active) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_cdp_active);
    req->prop = toInt(VehicleProperty::GECKO_ESC_CDP_ACTIVE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_brake_temp_over_heatWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_esc_brake_temp_over_heat = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_brake_temp_over_heat");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_esc_brake_temp_over_heat = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_esc_brake_temp_over_heatReq(ec_esc_brake_temp_over_heat),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_brake_temp_over_heatReq(int32_t ec_esc_brake_temp_over_heat) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_brake_temp_over_heat);
    req->prop = toInt(VehicleProperty::GECKO_ESC_BRAKE_TEMP_OVER_HEAT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_dtc_active_stsWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_esc_dtc_active_sts = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_dtc_active_sts");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_esc_dtc_active_sts = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_esc_dtc_active_stsReq(ec_esc_dtc_active_sts),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_dtc_active_stsReq(int32_t ec_esc_dtc_active_sts) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_dtc_active_sts);
    req->prop = toInt(VehicleProperty::GECKO_ESC_DTC_ACTIVE_STS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_vhcl_standstill_staWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_esc_vhcl_standstill_sta = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_vhcl_standstill_sta");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_esc_vhcl_standstill_sta = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_esc_vhcl_standstill_staReq(ec_esc_vhcl_standstill_sta),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_vhcl_standstill_staReq(int32_t ec_esc_vhcl_standstill_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_vhcl_standstill_sta);
    req->prop = toInt(VehicleProperty::GECKO_ESC_VHCL_STANDSTILL_STA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_dtc_request_rbs_stsWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_esc_dtc_request_rbs_sts = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_dtc_request_rbs_sts");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_esc_dtc_request_rbs_sts = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_esc_dtc_request_rbs_stsReq(ec_esc_dtc_request_rbs_sts),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_dtc_request_rbs_stsReq(int32_t ec_esc_dtc_request_rbs_sts) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_dtc_request_rbs_sts);
    req->prop = toInt(VehicleProperty::GECKO_ESC_DTC_REQUEST_RBS_STS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_dtc_failure_stsWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_esc_dtc_failure_sts = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_dtc_failure_sts");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_esc_dtc_failure_sts = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_esc_dtc_failure_stsReq(ec_esc_dtc_failure_sts),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_dtc_failure_stsReq(int32_t ec_esc_dtc_failure_sts) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_dtc_failure_sts);
    req->prop = toInt(VehicleProperty::GECKO_ESC_DTC_FAILURE_STS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_wheel_speed_kph_v_flWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_esc_wheel_speed_kph_v_fl = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_wheel_speed_kph_v_fl");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_esc_wheel_speed_kph_v_fl = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_esc_wheel_speed_kph_v_flReq(ec_esc_wheel_speed_kph_v_fl),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_wheel_speed_kph_v_flReq(int32_t ec_esc_wheel_speed_kph_v_fl) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_wheel_speed_kph_v_fl);
    req->prop = toInt(VehicleProperty::GECKO_ESC_WHEEL_SPEED_KPH_V_FL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_wheel_direction_flWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_esc_wheel_direction_fl = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_wheel_direction_fl");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_esc_wheel_direction_fl = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_esc_wheel_direction_flReq(ec_esc_wheel_direction_fl),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_wheel_direction_flReq(int32_t ec_esc_wheel_direction_fl) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_wheel_direction_fl);
    req->prop = toInt(VehicleProperty::GECKO_ESC_WHEEL_DIRECTION_FL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_wheel_speed_kph_flWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_esc_wheel_speed_kph_fl = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_wheel_speed_kph_fl");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_esc_wheel_speed_kph_fl = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_esc_wheel_speed_kph_flReq(ec_esc_wheel_speed_kph_fl),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_wheel_speed_kph_flReq(int32_t ec_esc_wheel_speed_kph_fl) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_wheel_speed_kph_fl);
    req->prop = toInt(VehicleProperty::GECKO_ESC_WHEEL_SPEED_KPH_FL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_wheel_speed_kph_v_frWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_esc_wheel_speed_kph_v_fr = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_wheel_speed_kph_v_fr");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_esc_wheel_speed_kph_v_fr = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_esc_wheel_speed_kph_v_frReq(ec_esc_wheel_speed_kph_v_fr),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_wheel_speed_kph_v_frReq(int32_t ec_esc_wheel_speed_kph_v_fr) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_wheel_speed_kph_v_fr);
    req->prop = toInt(VehicleProperty::GECKO_ESC_WHEEL_SPEED_KPH_V_FR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_wheel_direction_frWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_esc_wheel_direction_fr = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_wheel_direction_fr");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_esc_wheel_direction_fr = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_esc_wheel_direction_frReq(ec_esc_wheel_direction_fr),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_wheel_direction_frReq(int32_t ec_esc_wheel_direction_fr) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_wheel_direction_fr);
    req->prop = toInt(VehicleProperty::GECKO_ESC_WHEEL_DIRECTION_FR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_wheel_speed_kph_frWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_esc_wheel_speed_kph_fr = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_wheel_speed_kph_fr");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_esc_wheel_speed_kph_fr = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_esc_wheel_speed_kph_frReq(ec_esc_wheel_speed_kph_fr),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_wheel_speed_kph_frReq(int32_t ec_esc_wheel_speed_kph_fr) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_wheel_speed_kph_fr);
    req->prop = toInt(VehicleProperty::GECKO_ESC_WHEEL_SPEED_KPH_FR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_master_cylinder_presrWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_esc_master_cylinder_presr = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_master_cylinder_presr");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_esc_master_cylinder_presr = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_esc_master_cylinder_presrReq(ec_esc_master_cylinder_presr),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_master_cylinder_presrReq(int32_t ec_esc_master_cylinder_presr) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_master_cylinder_presr);
    req->prop = toInt(VehicleProperty::GECKO_ESC_MASTER_CYLINDER_PRESR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_master_cylinder_presr_vWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_esc_master_cylinder_presr_v = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_master_cylinder_presr_v");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_esc_master_cylinder_presr_v = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_esc_master_cylinder_presr_vReq(ec_esc_master_cylinder_presr_v),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_master_cylinder_presr_vReq(int32_t ec_esc_master_cylinder_presr_v) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_master_cylinder_presr_v);
    req->prop = toInt(VehicleProperty::GECKO_ESC_MASTER_CYLINDER_PRESR_V);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_wheel_speed_kph_v_rlWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_esc_wheel_speed_kph_v_rl = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_wheel_speed_kph_v_rl");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_esc_wheel_speed_kph_v_rl = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_esc_wheel_speed_kph_v_rlReq(ec_esc_wheel_speed_kph_v_rl),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_wheel_speed_kph_v_rlReq(int32_t ec_esc_wheel_speed_kph_v_rl) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_wheel_speed_kph_v_rl);
    req->prop = toInt(VehicleProperty::GECKO_ESC_WHEEL_SPEED_KPH_V_RL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_wheel_direction_rlWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_esc_wheel_direction_rl = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_wheel_direction_rl");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_esc_wheel_direction_rl = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_esc_wheel_direction_rlReq(ec_esc_wheel_direction_rl),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_wheel_direction_rlReq(int32_t ec_esc_wheel_direction_rl) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_wheel_direction_rl);
    req->prop = toInt(VehicleProperty::GECKO_ESC_WHEEL_DIRECTION_RL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_wheel_speed_kph_rlWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_esc_wheel_speed_kph_rl = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_wheel_speed_kph_rl");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_esc_wheel_speed_kph_rl = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_esc_wheel_speed_kph_rlReq(ec_esc_wheel_speed_kph_rl),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_wheel_speed_kph_rlReq(int32_t ec_esc_wheel_speed_kph_rl) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_wheel_speed_kph_rl);
    req->prop = toInt(VehicleProperty::GECKO_ESC_WHEEL_SPEED_KPH_RL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_wheel_speed_kph_v_rrWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_esc_wheel_speed_kph_v_rr = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_wheel_speed_kph_v_rr");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_esc_wheel_speed_kph_v_rr = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_esc_wheel_speed_kph_v_rrReq(ec_esc_wheel_speed_kph_v_rr),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_wheel_speed_kph_v_rrReq(int32_t ec_esc_wheel_speed_kph_v_rr) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_wheel_speed_kph_v_rr);
    req->prop = toInt(VehicleProperty::GECKO_ESC_WHEEL_SPEED_KPH_V_RR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_wheel_direction_rrWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_esc_wheel_direction_rr = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_wheel_direction_rr");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_esc_wheel_direction_rr = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_esc_wheel_direction_rrReq(ec_esc_wheel_direction_rr),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_wheel_direction_rrReq(int32_t ec_esc_wheel_direction_rr) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_wheel_direction_rr);
    req->prop = toInt(VehicleProperty::GECKO_ESC_WHEEL_DIRECTION_RR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_wheel_speed_kph_rrWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_esc_wheel_speed_kph_rr = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_wheel_speed_kph_rr");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_esc_wheel_speed_kph_rr = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_esc_wheel_speed_kph_rrReq(ec_esc_wheel_speed_kph_rr),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_wheel_speed_kph_rrReq(int32_t ec_esc_wheel_speed_kph_rr) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_wheel_speed_kph_rr);
    req->prop = toInt(VehicleProperty::GECKO_ESC_WHEEL_SPEED_KPH_RR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_wheel_speed_rc_sts_flWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_esc_wheel_speed_rc_sts_fl = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_wheel_speed_rc_sts_fl");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_esc_wheel_speed_rc_sts_fl = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_esc_wheel_speed_rc_sts_flReq(ec_esc_wheel_speed_rc_sts_fl),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_wheel_speed_rc_sts_flReq(int32_t ec_esc_wheel_speed_rc_sts_fl) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_wheel_speed_rc_sts_fl);
    req->prop = toInt(VehicleProperty::GECKO_ESC_WHEEL_SPEED_RC_STS_FL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_wheel_speed_rc_sts_frWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_esc_wheel_speed_rc_sts_fr = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_wheel_speed_rc_sts_fr");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_esc_wheel_speed_rc_sts_fr = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_esc_wheel_speed_rc_sts_frReq(ec_esc_wheel_speed_rc_sts_fr),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_wheel_speed_rc_sts_frReq(int32_t ec_esc_wheel_speed_rc_sts_fr) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_wheel_speed_rc_sts_fr);
    req->prop = toInt(VehicleProperty::GECKO_ESC_WHEEL_SPEED_RC_STS_FR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_wheel_speed_rc_sts_rlWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_esc_wheel_speed_rc_sts_rl = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_wheel_speed_rc_sts_rl");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_esc_wheel_speed_rc_sts_rl = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_esc_wheel_speed_rc_sts_rlReq(ec_esc_wheel_speed_rc_sts_rl),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_wheel_speed_rc_sts_rlReq(int32_t ec_esc_wheel_speed_rc_sts_rl) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_wheel_speed_rc_sts_rl);
    req->prop = toInt(VehicleProperty::GECKO_ESC_WHEEL_SPEED_RC_STS_RL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_wheel_speed_rc_sts_rrWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_esc_wheel_speed_rc_sts_rr = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_wheel_speed_rc_sts_rr");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_esc_wheel_speed_rc_sts_rr = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_esc_wheel_speed_rc_sts_rrReq(ec_esc_wheel_speed_rc_sts_rr),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_wheel_speed_rc_sts_rrReq(int32_t ec_esc_wheel_speed_rc_sts_rr) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_wheel_speed_rc_sts_rr);
    req->prop = toInt(VehicleProperty::GECKO_ESC_WHEEL_SPEED_RC_STS_RR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_wheel_speed_rc_flWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_esc_wheel_speed_rc_fl = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_wheel_speed_rc_fl");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_esc_wheel_speed_rc_fl = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_esc_wheel_speed_rc_flReq(ec_esc_wheel_speed_rc_fl),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_wheel_speed_rc_flReq(int32_t ec_esc_wheel_speed_rc_fl) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_wheel_speed_rc_fl);
    req->prop = toInt(VehicleProperty::GECKO_ESC_WHEEL_SPEED_RC_FL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_wheel_speed_rc_frWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_esc_wheel_speed_rc_fr = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_wheel_speed_rc_fr");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_esc_wheel_speed_rc_fr = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_esc_wheel_speed_rc_frReq(ec_esc_wheel_speed_rc_fr),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_wheel_speed_rc_frReq(int32_t ec_esc_wheel_speed_rc_fr) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_wheel_speed_rc_fr);
    req->prop = toInt(VehicleProperty::GECKO_ESC_WHEEL_SPEED_RC_FR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_wheel_speed_rc_rlWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_esc_wheel_speed_rc_rl = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_wheel_speed_rc_rl");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_esc_wheel_speed_rc_rl = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_esc_wheel_speed_rc_rlReq(ec_esc_wheel_speed_rc_rl),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_wheel_speed_rc_rlReq(int32_t ec_esc_wheel_speed_rc_rl) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_wheel_speed_rc_rl);
    req->prop = toInt(VehicleProperty::GECKO_ESC_WHEEL_SPEED_RC_RL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_wheel_speed_rc_rrWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_esc_wheel_speed_rc_rr = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_wheel_speed_rc_rr");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_esc_wheel_speed_rc_rr = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_esc_wheel_speed_rc_rrReq(ec_esc_wheel_speed_rc_rr),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_wheel_speed_rc_rrReq(int32_t ec_esc_wheel_speed_rc_rr) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_wheel_speed_rc_rr);
    req->prop = toInt(VehicleProperty::GECKO_ESC_WHEEL_SPEED_RC_RR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_long_acc_sensor_valueWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_esc_long_acc_sensor_value = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_long_acc_sensor_value");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_esc_long_acc_sensor_value = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_esc_long_acc_sensor_valueReq(ec_esc_long_acc_sensor_value),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_long_acc_sensor_valueReq(int32_t ec_esc_long_acc_sensor_value) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_long_acc_sensor_value);
    req->prop = toInt(VehicleProperty::GECKO_ESC_LONG_ACC_SENSOR_VALUE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_long_acc_sensor_value_vldWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_esc_long_acc_sensor_value_vld = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_long_acc_sensor_value_vld");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_esc_long_acc_sensor_value_vld = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_esc_long_acc_sensor_value_vldReq(ec_esc_long_acc_sensor_value_vld),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_long_acc_sensor_value_vldReq(int32_t ec_esc_long_acc_sensor_value_vld) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_long_acc_sensor_value_vld);
    req->prop = toInt(VehicleProperty::GECKO_ESC_LONG_ACC_SENSOR_VALUE_VLD);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_lat_acc_sensor_value_vldWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_esc_lat_acc_sensor_value_vld = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_lat_acc_sensor_value_vld");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_esc_lat_acc_sensor_value_vld = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_esc_lat_acc_sensor_value_vldReq(ec_esc_lat_acc_sensor_value_vld),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_lat_acc_sensor_value_vldReq(int32_t ec_esc_lat_acc_sensor_value_vld) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_lat_acc_sensor_value_vld);
    req->prop = toInt(VehicleProperty::GECKO_ESC_LAT_ACC_SENSOR_VALUE_VLD);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_lat_acc_sensor_valueWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_esc_lat_acc_sensor_value = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_lat_acc_sensor_value");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_esc_lat_acc_sensor_value = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_esc_lat_acc_sensor_valueReq(ec_esc_lat_acc_sensor_value),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_lat_acc_sensor_valueReq(int32_t ec_esc_lat_acc_sensor_value) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_lat_acc_sensor_value);
    req->prop = toInt(VehicleProperty::GECKO_ESC_LAT_ACC_SENSOR_VALUE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_yaw_rate_vldWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_esc_yaw_rate_vld = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_yaw_rate_vld");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_esc_yaw_rate_vld = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_esc_yaw_rate_vldReq(ec_esc_yaw_rate_vld),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_yaw_rate_vldReq(int32_t ec_esc_yaw_rate_vld) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_yaw_rate_vld);
    req->prop = toInt(VehicleProperty::GECKO_ESC_YAW_RATE_VLD);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_yaw_rateWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_esc_yaw_rate = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_yaw_rate");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_esc_yaw_rate = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_esc_yaw_rateReq(ec_esc_yaw_rate),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_yaw_rateReq(int32_t ec_esc_yaw_rate) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_yaw_rate);
    req->prop = toInt(VehicleProperty::GECKO_ESC_YAW_RATE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_epb_right_currentWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_esc_epb_right_current = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_epb_right_current");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_esc_epb_right_current = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_esc_epb_right_currentReq(ec_esc_epb_right_current),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_epb_right_currentReq(int32_t ec_esc_epb_right_current) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_epb_right_current);
    req->prop = toInt(VehicleProperty::GECKO_ESC_EPB_RIGHT_CURRENT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_epb_right_fault_stateWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_esc_epb_right_fault_state = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_epb_right_fault_state");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_esc_epb_right_fault_state = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_esc_epb_right_fault_stateReq(ec_esc_epb_right_fault_state),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_epb_right_fault_stateReq(int32_t ec_esc_epb_right_fault_state) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_epb_right_fault_state);
    req->prop = toInt(VehicleProperty::GECKO_ESC_EPB_RIGHT_FAULT_STATE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_hbb_hbc_availableWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_esc_hbb_hbc_available = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_hbb_hbc_available");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_esc_hbb_hbc_available = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_esc_hbb_hbc_availableReq(ec_esc_hbb_hbc_available),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_hbb_hbc_availableReq(int32_t ec_esc_hbb_hbc_available) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_hbb_hbc_available);
    req->prop = toInt(VehicleProperty::GECKO_ESC_HBB_HBC_AVAILABLE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_epb_actuator_st_rWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_esc_epb_actuator_st_r = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_epb_actuator_st_r");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_esc_epb_actuator_st_r = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_esc_epb_actuator_st_rReq(ec_esc_epb_actuator_st_r),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_epb_actuator_st_rReq(int32_t ec_esc_epb_actuator_st_r) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_epb_actuator_st_r);
    req->prop = toInt(VehicleProperty::GECKO_ESC_EPB_ACTUATOR_ST_R);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_hbb_hbc_activeWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_esc_hbb_hbc_active = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_hbb_hbc_active");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_esc_hbb_hbc_active = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_esc_hbb_hbc_activeReq(ec_esc_hbb_hbc_active),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_hbb_hbc_activeReq(int32_t ec_esc_hbb_hbc_active) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_hbb_hbc_active);
    req->prop = toInt(VehicleProperty::GECKO_ESC_HBB_HBC_ACTIVE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_whl_tq_dec_req_actvWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_esc_whl_tq_dec_req_actv = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_whl_tq_dec_req_actv");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_esc_whl_tq_dec_req_actv = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_esc_whl_tq_dec_req_actvReq(ec_esc_whl_tq_dec_req_actv),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_whl_tq_dec_req_actvReq(int32_t ec_esc_whl_tq_dec_req_actv) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_whl_tq_dec_req_actv);
    req->prop = toInt(VehicleProperty::GECKO_ESC_WHL_TQ_DEC_REQ_ACTV);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_whl_tq_dec_req_valWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_esc_whl_tq_dec_req_val = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_whl_tq_dec_req_val");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_esc_whl_tq_dec_req_val = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_esc_whl_tq_dec_req_valReq(ec_esc_whl_tq_dec_req_val),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_whl_tq_dec_req_valReq(int32_t ec_esc_whl_tq_dec_req_val) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_whl_tq_dec_req_val);
    req->prop = toInt(VehicleProperty::GECKO_ESC_WHL_TQ_DEC_REQ_VAL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_whl_tq_inc_req_actvWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_esc_whl_tq_inc_req_actv = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_whl_tq_inc_req_actv");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_esc_whl_tq_inc_req_actv = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_esc_whl_tq_inc_req_actvReq(ec_esc_whl_tq_inc_req_actv),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_whl_tq_inc_req_actvReq(int32_t ec_esc_whl_tq_inc_req_actv) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_whl_tq_inc_req_actv);
    req->prop = toInt(VehicleProperty::GECKO_ESC_WHL_TQ_INC_REQ_ACTV);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_esc_whl_tq_inc_req_valWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_esc_whl_tq_inc_req_val = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_esc_whl_tq_inc_req_val");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_esc_whl_tq_inc_req_val = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_esc_whl_tq_inc_req_valReq(ec_esc_whl_tq_inc_req_val),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_esc_whl_tq_inc_req_valReq(int32_t ec_esc_whl_tq_inc_req_val) {
    auto req = mValueObjectPool->obtainInt32(ec_esc_whl_tq_inc_req_val);
    req->prop = toInt(VehicleProperty::GECKO_ESC_WHL_TQ_INC_REQ_VAL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ehb_cdp_requestWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ehb_cdp_request = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ehb_cdp_request");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ehb_cdp_request = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ehb_cdp_requestReq(ec_ehb_cdp_request),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ehb_cdp_requestReq(int32_t ec_ehb_cdp_request) {
    auto req = mValueObjectPool->obtainInt32(ec_ehb_cdp_request);
    req->prop = toInt(VehicleProperty::GECKO_EHB_CDP_REQUEST);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ehb_hhc_active_staWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ehb_hhc_active_sta = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ehb_hhc_active_sta");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ehb_hhc_active_sta = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ehb_hhc_active_staReq(ec_ehb_hhc_active_sta),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ehb_hhc_active_staReq(int32_t ec_ehb_hhc_active_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_ehb_hhc_active_sta);
    req->prop = toInt(VehicleProperty::GECKO_EHB_HHC_ACTIVE_STA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ehb_rgn_brk_stWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ehb_rgn_brk_st = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ehb_rgn_brk_st");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ehb_rgn_brk_st = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ehb_rgn_brk_stReq(ec_ehb_rgn_brk_st),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ehb_rgn_brk_stReq(int32_t ec_ehb_rgn_brk_st) {
    auto req = mValueObjectPool->obtainInt32(ec_ehb_rgn_brk_st);
    req->prop = toInt(VehicleProperty::GECKO_EHB_RGN_BRK_ST);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ehb_ext_req_statusWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ehb_ext_req_status = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ehb_ext_req_status");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ehb_ext_req_status = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ehb_ext_req_statusReq(ec_ehb_ext_req_status),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ehb_ext_req_statusReq(int32_t ec_ehb_ext_req_status) {
    auto req = mValueObjectPool->obtainInt32(ec_ehb_ext_req_status);
    req->prop = toInt(VehicleProperty::GECKO_EHB_EXT_REQ_STATUS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ehb_blaWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ehb_bla = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ehb_bla");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ehb_bla = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ehb_blaReq(ec_ehb_bla),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ehb_blaReq(int32_t ec_ehb_bla) {
    auto req = mValueObjectPool->obtainInt32(ec_ehb_bla);
    req->prop = toInt(VehicleProperty::GECKO_EHB_BLA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ehb_hmi_warning_onWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ehb_hmi_warning_on = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ehb_hmi_warning_on");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ehb_hmi_warning_on = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ehb_hmi_warning_onReq(ec_ehb_hmi_warning_on),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ehb_hmi_warning_onReq(int32_t ec_ehb_hmi_warning_on) {
    auto req = mValueObjectPool->obtainInt32(ec_ehb_hmi_warning_on);
    req->prop = toInt(VehicleProperty::GECKO_EHB_HMI_WARNING_ON);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ehb_epb_dynamic_apply_staWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ehb_epb_dynamic_apply_sta = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ehb_epb_dynamic_apply_sta");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ehb_epb_dynamic_apply_sta = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ehb_epb_dynamic_apply_staReq(ec_ehb_epb_dynamic_apply_sta),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ehb_epb_dynamic_apply_staReq(int32_t ec_ehb_epb_dynamic_apply_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_ehb_epb_dynamic_apply_sta);
    req->prop = toInt(VehicleProperty::GECKO_EHB_EPB_DYNAMIC_APPLY_STA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ehb_pedl_trvl_snsr_fail_pdfWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ehb_pedl_trvl_snsr_fail_pdf = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ehb_pedl_trvl_snsr_fail_pdf");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ehb_pedl_trvl_snsr_fail_pdf = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ehb_pedl_trvl_snsr_fail_pdfReq(ec_ehb_pedl_trvl_snsr_fail_pdf),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ehb_pedl_trvl_snsr_fail_pdfReq(int32_t ec_ehb_pedl_trvl_snsr_fail_pdf) {
    auto req = mValueObjectPool->obtainInt32(ec_ehb_pedl_trvl_snsr_fail_pdf);
    req->prop = toInt(VehicleProperty::GECKO_EHB_PEDL_TRVL_SNSR_FAIL_PDF);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ehb_req_brk_li_onWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ehb_req_brk_li_on = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ehb_req_brk_li_on");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ehb_req_brk_li_on = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ehb_req_brk_li_onReq(ec_ehb_req_brk_li_on),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ehb_req_brk_li_onReq(int32_t ec_ehb_req_brk_li_on) {
    auto req = mValueObjectPool->obtainInt32(ec_ehb_req_brk_li_on);
    req->prop = toInt(VehicleProperty::GECKO_EHB_REQ_BRK_LI_ON);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ehb_pedl_trvl_snsr_fail_pdtWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ehb_pedl_trvl_snsr_fail_pdt = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ehb_pedl_trvl_snsr_fail_pdt");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ehb_pedl_trvl_snsr_fail_pdt = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ehb_pedl_trvl_snsr_fail_pdtReq(ec_ehb_pedl_trvl_snsr_fail_pdt),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ehb_pedl_trvl_snsr_fail_pdtReq(int32_t ec_ehb_pedl_trvl_snsr_fail_pdt) {
    auto req = mValueObjectPool->obtainInt32(ec_ehb_pedl_trvl_snsr_fail_pdt);
    req->prop = toInt(VehicleProperty::GECKO_EHB_PEDL_TRVL_SNSR_FAIL_PDT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ehb_p_runout_pressureWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ehb_p_runout_pressure = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ehb_p_runout_pressure");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ehb_p_runout_pressure = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ehb_p_runout_pressureReq(ec_ehb_p_runout_pressure),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ehb_p_runout_pressureReq(int32_t ec_ehb_p_runout_pressure) {
    auto req = mValueObjectPool->obtainInt32(ec_ehb_p_runout_pressure);
    req->prop = toInt(VehicleProperty::GECKO_EHB_P_RUNOUT_PRESSURE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ehb_brake_pedal_appliedWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ehb_brake_pedal_applied = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ehb_brake_pedal_applied");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ehb_brake_pedal_applied = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ehb_brake_pedal_appliedReq(ec_ehb_brake_pedal_applied),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ehb_brake_pedal_appliedReq(int32_t ec_ehb_brake_pedal_applied) {
    auto req = mValueObjectPool->obtainInt32(ec_ehb_brake_pedal_applied);
    req->prop = toInt(VehicleProperty::GECKO_EHB_BRAKE_PEDAL_APPLIED);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ehb_brake_pedal_applied_qWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ehb_brake_pedal_applied_q = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ehb_brake_pedal_applied_q");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ehb_brake_pedal_applied_q = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ehb_brake_pedal_applied_qReq(ec_ehb_brake_pedal_applied_q),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ehb_brake_pedal_applied_qReq(int32_t ec_ehb_brake_pedal_applied_q) {
    auto req = mValueObjectPool->obtainInt32(ec_ehb_brake_pedal_applied_q);
    req->prop = toInt(VehicleProperty::GECKO_EHB_BRAKE_PEDAL_APPLIED_Q);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ehb_cdd_temp_offWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ehb_cdd_temp_off = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ehb_cdd_temp_off");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ehb_cdd_temp_off = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ehb_cdd_temp_offReq(ec_ehb_cdd_temp_off),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ehb_cdd_temp_offReq(int32_t ec_ehb_cdd_temp_off) {
    auto req = mValueObjectPool->obtainInt32(ec_ehb_cdd_temp_off);
    req->prop = toInt(VehicleProperty::GECKO_EHB_CDD_TEMP_OFF);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ehb_s_output_rod_hydraulic_targetWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ehb_s_output_rod_hydraulic_target = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ehb_s_output_rod_hydraulic_target");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ehb_s_output_rod_hydraulic_target = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ehb_s_output_rod_hydraulic_targetReq(ec_ehb_s_output_rod_hydraulic_target),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ehb_s_output_rod_hydraulic_targetReq(int32_t ec_ehb_s_output_rod_hydraulic_target) {
    auto req = mValueObjectPool->obtainInt32(ec_ehb_s_output_rod_hydraulic_target);
    req->prop = toInt(VehicleProperty::GECKO_EHB_S_OUTPUT_ROD_HYDRAULIC_TARGET);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ehb_s_output_rod_driver_percWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ehb_s_output_rod_driver_perc = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ehb_s_output_rod_driver_perc");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ehb_s_output_rod_driver_perc = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ehb_s_output_rod_driver_percReq(ec_ehb_s_output_rod_driver_perc),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ehb_s_output_rod_driver_percReq(int32_t ec_ehb_s_output_rod_driver_perc) {
    auto req = mValueObjectPool->obtainInt32(ec_ehb_s_output_rod_driver_perc);
    req->prop = toInt(VehicleProperty::GECKO_EHB_S_OUTPUT_ROD_DRIVER_PERC);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ehb_epb_actuator_st_rWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ehb_epb_actuator_st_r = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ehb_epb_actuator_st_r");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ehb_epb_actuator_st_r = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ehb_epb_actuator_st_rReq(ec_ehb_epb_actuator_st_r),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ehb_epb_actuator_st_rReq(int32_t ec_ehb_epb_actuator_st_r) {
    auto req = mValueObjectPool->obtainInt32(ec_ehb_epb_actuator_st_r);
    req->prop = toInt(VehicleProperty::GECKO_EHB_EPB_ACTUATOR_ST_R);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ehb_aba_active_staWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ehb_aba_active_sta = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ehb_aba_active_sta");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ehb_aba_active_sta = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ehb_aba_active_staReq(ec_ehb_aba_active_sta),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ehb_aba_active_staReq(int32_t ec_ehb_aba_active_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_ehb_aba_active_sta);
    req->prop = toInt(VehicleProperty::GECKO_EHB_ABA_ACTIVE_STA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ehb_aba_available_staWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ehb_aba_available_sta = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ehb_aba_available_sta");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ehb_aba_available_sta = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ehb_aba_available_staReq(ec_ehb_aba_available_sta),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ehb_aba_available_staReq(int32_t ec_ehb_aba_available_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_ehb_aba_available_sta);
    req->prop = toInt(VehicleProperty::GECKO_EHB_ABA_AVAILABLE_STA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ehb_awb_active_staWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ehb_awb_active_sta = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ehb_awb_active_sta");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ehb_awb_active_sta = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ehb_awb_active_staReq(ec_ehb_awb_active_sta),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ehb_awb_active_staReq(int32_t ec_ehb_awb_active_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_ehb_awb_active_sta);
    req->prop = toInt(VehicleProperty::GECKO_EHB_AWB_ACTIVE_STA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ehb_awb_available_staWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ehb_awb_available_sta = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ehb_awb_available_sta");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ehb_awb_available_sta = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ehb_awb_available_staReq(ec_ehb_awb_available_sta),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ehb_awb_available_staReq(int32_t ec_ehb_awb_available_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_ehb_awb_available_sta);
    req->prop = toInt(VehicleProperty::GECKO_EHB_AWB_AVAILABLE_STA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ehb_aeb_active_staWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ehb_aeb_active_sta = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ehb_aeb_active_sta");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ehb_aeb_active_sta = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ehb_aeb_active_staReq(ec_ehb_aeb_active_sta),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ehb_aeb_active_staReq(int32_t ec_ehb_aeb_active_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_ehb_aeb_active_sta);
    req->prop = toInt(VehicleProperty::GECKO_EHB_AEB_ACTIVE_STA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ehb_aeb_available_staWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ehb_aeb_available_sta = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ehb_aeb_available_sta");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ehb_aeb_available_sta = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ehb_aeb_available_staReq(ec_ehb_aeb_available_sta),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ehb_aeb_available_staReq(int32_t ec_ehb_aeb_available_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_ehb_aeb_available_sta);
    req->prop = toInt(VehicleProperty::GECKO_EHB_AEB_AVAILABLE_STA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ehb_abp_active_staWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ehb_abp_active_sta = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ehb_abp_active_sta");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ehb_abp_active_sta = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ehb_abp_active_staReq(ec_ehb_abp_active_sta),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ehb_abp_active_staReq(int32_t ec_ehb_abp_active_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_ehb_abp_active_sta);
    req->prop = toInt(VehicleProperty::GECKO_EHB_ABP_ACTIVE_STA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ehb_abp_available_staWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ehb_abp_available_sta = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ehb_abp_available_sta");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ehb_abp_available_sta = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ehb_abp_available_staReq(ec_ehb_abp_available_sta),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ehb_abp_available_staReq(int32_t ec_ehb_abp_available_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_ehb_abp_available_sta);
    req->prop = toInt(VehicleProperty::GECKO_EHB_ABP_AVAILABLE_STA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_pp_raeb_set_fbWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_pp_raeb_set_fb = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_pp_raeb_set_fb");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_pp_raeb_set_fb = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_pp_raeb_set_fbReq(ec_pp_raeb_set_fb),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_pp_raeb_set_fbReq(int32_t ec_pp_raeb_set_fb) {
    auto req = mValueObjectPool->obtainInt32(ec_pp_raeb_set_fb);
    req->prop = toInt(VehicleProperty::GECKO_PP_RAEB_SET_FB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_pp_raeb_brkg_reqWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_pp_raeb_brkg_req = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_pp_raeb_brkg_req");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_pp_raeb_brkg_req = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_pp_raeb_brkg_reqReq(ec_pp_raeb_brkg_req),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_pp_raeb_brkg_reqReq(int32_t ec_pp_raeb_brkg_req) {
    auto req = mValueObjectPool->obtainInt32(ec_pp_raeb_brkg_req);
    req->prop = toInt(VehicleProperty::GECKO_PP_RAEB_BRKG_REQ);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_pp_raeb_brkg_req_valWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_pp_raeb_brkg_req_val = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_pp_raeb_brkg_req_val");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_pp_raeb_brkg_req_val = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_pp_raeb_brkg_req_valReq(ec_pp_raeb_brkg_req_val),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_pp_raeb_brkg_req_valReq(int32_t ec_pp_raeb_brkg_req_val) {
    auto req = mValueObjectPool->obtainInt32(ec_pp_raeb_brkg_req_val);
    req->prop = toInt(VehicleProperty::GECKO_PP_RAEB_BRKG_REQ_VAL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_pp_raeb_distance_to_collisionWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_pp_raeb_distance_to_collision = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_pp_raeb_distance_to_collision");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_pp_raeb_distance_to_collision = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_pp_raeb_distance_to_collisionReq(ec_pp_raeb_distance_to_collision),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_pp_raeb_distance_to_collisionReq(int32_t ec_pp_raeb_distance_to_collision) {
    auto req = mValueObjectPool->obtainInt32(ec_pp_raeb_distance_to_collision);
    req->prop = toInt(VehicleProperty::GECKO_PP_RAEB_DISTANCE_TO_COLLISION);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_crrr_rctb_decelarationWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_crrr_rctb_decelaration = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_crrr_rctb_decelaration");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_crrr_rctb_decelaration = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_crrr_rctb_decelarationReq(ec_crrr_rctb_decelaration),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_crrr_rctb_decelarationReq(int32_t ec_crrr_rctb_decelaration) {
    auto req = mValueObjectPool->obtainInt32(ec_crrr_rctb_decelaration);
    req->prop = toInt(VehicleProperty::GECKO_CRRR_RCTB_DECELARATION);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_crrr_rctb_reqWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_crrr_rctb_req = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_crrr_rctb_req");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_crrr_rctb_req = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_crrr_rctb_reqReq(ec_crrr_rctb_req),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_crrr_rctb_reqReq(int32_t ec_crrr_rctb_req) {
    auto req = mValueObjectPool->obtainInt32(ec_crrr_rctb_req);
    req->prop = toInt(VehicleProperty::GECKO_CRRR_RCTB_REQ);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_crrr_rctb_brkg_vldWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_crrr_rctb_brkg_vld = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_crrr_rctb_brkg_vld");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_crrr_rctb_brkg_vld = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_crrr_rctb_brkg_vldReq(ec_crrr_rctb_brkg_vld),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_crrr_rctb_brkg_vldReq(int32_t ec_crrr_rctb_brkg_vld) {
    auto req = mValueObjectPool->obtainInt32(ec_crrr_rctb_brkg_vld);
    req->prop = toInt(VehicleProperty::GECKO_CRRR_RCTB_BRKG_VLD);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_crrr_fov_chg_set_fbWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_crrr_fov_chg_set_fb = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_crrr_fov_chg_set_fb");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_crrr_fov_chg_set_fb = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_crrr_fov_chg_set_fbReq(ec_crrr_fov_chg_set_fb),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_crrr_fov_chg_set_fbReq(int32_t ec_crrr_fov_chg_set_fb) {
    auto req = mValueObjectPool->obtainInt32(ec_crrr_fov_chg_set_fb);
    req->prop = toInt(VehicleProperty::GECKO_CRRR_FOV_CHG_SET_FB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_max_con_dis_curntWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_max_con_dis_curnt = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_max_con_dis_curnt");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_max_con_dis_curnt = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_max_con_dis_curntReq(ec_bms_max_con_dis_curnt),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_max_con_dis_curntReq(int32_t ec_bms_max_con_dis_curnt) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_max_con_dis_curnt);
    req->prop = toInt(VehicleProperty::GECKO_BMS_MAX_CON_DIS_CURNT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_pwr_recup_max_con_chrg_curntWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_pwr_recup_max_con_chrg_curnt = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_pwr_recup_max_con_chrg_curnt");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_pwr_recup_max_con_chrg_curnt = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_pwr_recup_max_con_chrg_curntReq(ec_bms_pwr_recup_max_con_chrg_curnt),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_pwr_recup_max_con_chrg_curntReq(int32_t ec_bms_pwr_recup_max_con_chrg_curnt) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_pwr_recup_max_con_chrg_curnt);
    req->prop = toInt(VehicleProperty::GECKO_BMS_PWR_RECUP_MAX_CON_CHRG_CURNT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_max_instan_dis_curntWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_max_instan_dis_curnt = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_max_instan_dis_curnt");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_max_instan_dis_curnt = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_max_instan_dis_curntReq(ec_bms_max_instan_dis_curnt),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_max_instan_dis_curntReq(int32_t ec_bms_max_instan_dis_curnt) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_max_instan_dis_curnt);
    req->prop = toInt(VehicleProperty::GECKO_BMS_MAX_INSTAN_DIS_CURNT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_pwr_recup_max_instan_chrg_curntWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_pwr_recup_max_instan_chrg_curnt = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_pwr_recup_max_instan_chrg_curnt");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_pwr_recup_max_instan_chrg_curnt = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_pwr_recup_max_instan_chrg_curntReq(ec_bms_pwr_recup_max_instan_chrg_curnt),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_pwr_recup_max_instan_chrg_curntReq(int32_t ec_bms_pwr_recup_max_instan_chrg_curnt) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_pwr_recup_max_instan_chrg_curnt);
    req->prop = toInt(VehicleProperty::GECKO_BMS_PWR_RECUP_MAX_INSTAN_CHRG_CURNT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_cell_vol_aveWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_cell_vol_ave = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_cell_vol_ave");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_cell_vol_ave = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_cell_vol_aveReq(ec_bms_cell_vol_ave),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_cell_vol_aveReq(int32_t ec_bms_cell_vol_ave) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_cell_vol_ave);
    req->prop = toInt(VehicleProperty::GECKO_BMS_CELL_VOL_AVE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_contactor_temp_negativeWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_contactor_temp_negative = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_contactor_temp_negative");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_contactor_temp_negative = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_contactor_temp_negativeReq(ec_bms_contactor_temp_negative),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_contactor_temp_negativeReq(int32_t ec_bms_contactor_temp_negative) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_contactor_temp_negative);
    req->prop = toInt(VehicleProperty::GECKO_BMS_CONTACTOR_TEMP_NEGATIVE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_max_cell_temp_limitWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_max_cell_temp_limit = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_max_cell_temp_limit");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_max_cell_temp_limit = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_max_cell_temp_limitReq(ec_bms_max_cell_temp_limit),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_max_cell_temp_limitReq(int32_t ec_bms_max_cell_temp_limit) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_max_cell_temp_limit);
    req->prop = toInt(VehicleProperty::GECKO_BMS_MAX_CELL_TEMP_LIMIT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_max_cell_vol_limitWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_max_cell_vol_limit = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_max_cell_vol_limit");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_max_cell_vol_limit = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_max_cell_vol_limitReq(ec_bms_max_cell_vol_limit),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_max_cell_vol_limitReq(int32_t ec_bms_max_cell_vol_limit) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_max_cell_vol_limit);
    req->prop = toInt(VehicleProperty::GECKO_BMS_MAX_CELL_VOL_LIMIT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_pwr_limd_flgWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_pwr_limd_flg = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_pwr_limd_flg");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_pwr_limd_flg = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_pwr_limd_flgReq(ec_bms_pwr_limd_flg),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_pwr_limd_flgReq(int32_t ec_bms_pwr_limd_flg) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_pwr_limd_flg);
    req->prop = toInt(VehicleProperty::GECKO_BMS_PWR_LIMD_FLG);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_min_cell_temp_limitWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_min_cell_temp_limit = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_min_cell_temp_limit");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_min_cell_temp_limit = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_min_cell_temp_limitReq(ec_bms_min_cell_temp_limit),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_min_cell_temp_limitReq(int32_t ec_bms_min_cell_temp_limit) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_min_cell_temp_limit);
    req->prop = toInt(VehicleProperty::GECKO_BMS_MIN_CELL_TEMP_LIMIT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_min_cell_vol_limitWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_min_cell_vol_limit = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_min_cell_vol_limit");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_min_cell_vol_limit = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_min_cell_vol_limitReq(ec_bms_min_cell_vol_limit),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_min_cell_vol_limitReq(int32_t ec_bms_min_cell_vol_limit) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_min_cell_vol_limit);
    req->prop = toInt(VehicleProperty::GECKO_BMS_MIN_CELL_VOL_LIMIT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_err_tab_indexWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_err_tab_index = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_err_tab_index");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_err_tab_index = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_err_tab_indexReq(ec_bms_err_tab_index),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_err_tab_indexReq(int32_t ec_bms_err_tab_index) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_err_tab_index);
    req->prop = toInt(VehicleProperty::GECKO_BMS_ERR_TAB_INDEX);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_battery_typeWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_battery_type = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_battery_type");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_battery_type = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_battery_typeReq(ec_bms_battery_type),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_battery_typeReq(int32_t ec_bms_battery_type) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_battery_type);
    req->prop = toInt(VehicleProperty::GECKO_BMS_BATTERY_TYPE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_hw_versionWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_hw_version = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_hw_version");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_hw_version = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_hw_versionReq(ec_bms_hw_version),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_hw_versionReq(int32_t ec_bms_hw_version) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_hw_version);
    req->prop = toInt(VehicleProperty::GECKO_BMS_HW_VERSION);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_pack_identityWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_pack_identity = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_pack_identity");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_pack_identity = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_pack_identityReq(ec_bms_pack_identity),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_pack_identityReq(int32_t ec_bms_pack_identity) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_pack_identity);
    req->prop = toInt(VehicleProperty::GECKO_BMS_PACK_IDENTITY);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_nom_cell_capWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_nom_cell_cap = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_nom_cell_cap");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_nom_cell_cap = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_nom_cell_capReq(ec_bms_nom_cell_cap),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_nom_cell_capReq(int32_t ec_bms_nom_cell_cap) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_nom_cell_cap);
    req->prop = toInt(VehicleProperty::GECKO_BMS_NOM_CELL_CAP);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_bat_capacityWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_bat_capacity = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_bat_capacity");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_bat_capacity = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_bat_capacityReq(ec_bms_bat_capacity),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_bat_capacityReq(int32_t ec_bms_bat_capacity) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_bat_capacity);
    req->prop = toInt(VehicleProperty::GECKO_BMS_BAT_CAPACITY);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bem_spn2560_aaReq(int32_t ec_bem_spn2560_aa) {
    auto req = mValueObjectPool->obtainInt32(ec_bem_spn2560_aa);
    req->prop = toInt(VehicleProperty::GECKO_BEM_SPN2560_AA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bem_spn2560_00Req(int32_t ec_bem_spn2560_00) {
    auto req = mValueObjectPool->obtainInt32(ec_bem_spn2560_00);
    req->prop = toInt(VehicleProperty::GECKO_BEM_SPN2560_00);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bem_spn3904_croReq(int32_t ec_bem_spn3904_cro) {
    auto req = mValueObjectPool->obtainInt32(ec_bem_spn3904_cro);
    req->prop = toInt(VehicleProperty::GECKO_BEM_SPN3904_CRO);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bem_spn3903_cml_ctsReq(int32_t ec_bem_spn3903_cml_cts) {
    auto req = mValueObjectPool->obtainInt32(ec_bem_spn3903_cml_cts);
    req->prop = toInt(VehicleProperty::GECKO_BEM_SPN3903_CML_CTS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bem_spn3906_cstReq(int32_t ec_bem_spn3906_cst) {
    auto req = mValueObjectPool->obtainInt32(ec_bem_spn3906_cst);
    req->prop = toInt(VehicleProperty::GECKO_BEM_SPN3906_CST);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bem_spn3905_ccsReq(int32_t ec_bem_spn3905_ccs) {
    auto req = mValueObjectPool->obtainInt32(ec_bem_spn3905_ccs);
    req->prop = toInt(VehicleProperty::GECKO_BEM_SPN3905_CCS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bem_spn3907_csdReq(int32_t ec_bem_spn3907_csd) {
    auto req = mValueObjectPool->obtainInt32(ec_bem_spn3907_csd);
    req->prop = toInt(VehicleProperty::GECKO_BEM_SPN3907_CSD);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_cem_bms_identify_timoutReq(int32_t ec_cem_bms_identify_timout) {
    auto req = mValueObjectPool->obtainInt32(ec_cem_bms_identify_timout);
    req->prop = toInt(VehicleProperty::GECKO_CEM_BMS_IDENTIFY_TIMOUT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_cem_bms_finish_charge_timeoutReq(int32_t ec_cem_bms_finish_charge_timeout) {
    auto req = mValueObjectPool->obtainInt32(ec_cem_bms_finish_charge_timeout);
    req->prop = toInt(VehicleProperty::GECKO_CEM_BMS_FINISH_CHARGE_TIMEOUT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_cem_battery_parameter_timoutReq(int32_t ec_cem_battery_parameter_timout) {
    auto req = mValueObjectPool->obtainInt32(ec_cem_battery_parameter_timout);
    req->prop = toInt(VehicleProperty::GECKO_CEM_BATTERY_PARAMETER_TIMOUT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_cem_bms_abort_charge_timeoutReq(int32_t ec_cem_bms_abort_charge_timeout) {
    auto req = mValueObjectPool->obtainInt32(ec_cem_bms_abort_charge_timeout);
    req->prop = toInt(VehicleProperty::GECKO_CEM_BMS_ABORT_CHARGE_TIMEOUT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_cem_battery_charge_require_timeoutReq(int32_t ec_cem_battery_charge_require_timeout) {
    auto req = mValueObjectPool->obtainInt32(ec_cem_battery_charge_require_timeout);
    req->prop = toInt(VehicleProperty::GECKO_CEM_BATTERY_CHARGE_REQUIRE_TIMEOUT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_cem_battery_state_timeoutReq(int32_t ec_cem_battery_state_timeout) {
    auto req = mValueObjectPool->obtainInt32(ec_cem_battery_state_timeout);
    req->prop = toInt(VehicleProperty::GECKO_CEM_BATTERY_STATE_TIMEOUT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_cem_bms_charge_statistics_timeoutReq(int32_t ec_cem_bms_charge_statistics_timeout) {
    auto req = mValueObjectPool->obtainInt32(ec_cem_bms_charge_statistics_timeout);
    req->prop = toInt(VehicleProperty::GECKO_CEM_BMS_CHARGE_STATISTICS_TIMEOUT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bst_abort_achive_dcsReq(int32_t ec_bst_abort_achive_dcs) {
    auto req = mValueObjectPool->obtainInt32(ec_bst_abort_achive_dcs);
    req->prop = toInt(VehicleProperty::GECKO_BST_ABORT_ACHIVE_DCS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bst_abort_achive_single_voltReq(int32_t ec_bst_abort_achive_single_volt) {
    auto req = mValueObjectPool->obtainInt32(ec_bst_abort_achive_single_volt);
    req->prop = toInt(VehicleProperty::GECKO_BST_ABORT_ACHIVE_SINGLE_VOLT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bst_abort_achive_total_voltReq(int32_t ec_bst_abort_achive_total_volt) {
    auto req = mValueObjectPool->obtainInt32(ec_bst_abort_achive_total_volt);
    req->prop = toInt(VehicleProperty::GECKO_BST_ABORT_ACHIVE_TOTAL_VOLT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bst_abort_achive_socReq(int32_t ec_bst_abort_achive_soc) {
    auto req = mValueObjectPool->obtainInt32(ec_bst_abort_achive_soc);
    req->prop = toInt(VehicleProperty::GECKO_BST_ABORT_ACHIVE_SOC);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bst_abort_fault_connectorReq(int32_t ec_bst_abort_fault_connector) {
    auto req = mValueObjectPool->obtainInt32(ec_bst_abort_fault_connector);
    req->prop = toInt(VehicleProperty::GECKO_BST_ABORT_FAULT_CONNECTOR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bst_abort_fault_bms_tempReq(int32_t ec_bst_abort_fault_bms_temp) {
    auto req = mValueObjectPool->obtainInt32(ec_bst_abort_fault_bms_temp);
    req->prop = toInt(VehicleProperty::GECKO_BST_ABORT_FAULT_BMS_TEMP);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bst_abort_fault_connector_tempReq(int32_t ec_bst_abort_fault_connector_temp) {
    auto req = mValueObjectPool->obtainInt32(ec_bst_abort_fault_connector_temp);
    req->prop = toInt(VehicleProperty::GECKO_BST_ABORT_FAULT_CONNECTOR_TEMP);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bst_abort_fault_insulationReq(int32_t ec_bst_abort_fault_insulation) {
    auto req = mValueObjectPool->obtainInt32(ec_bst_abort_fault_insulation);
    req->prop = toInt(VehicleProperty::GECKO_BST_ABORT_FAULT_INSULATION);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bst_abort_fault_otherReq(int32_t ec_bst_abort_fault_other) {
    auto req = mValueObjectPool->obtainInt32(ec_bst_abort_fault_other);
    req->prop = toInt(VehicleProperty::GECKO_BST_ABORT_FAULT_OTHER);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bst_abort_fault_voltageReq(int32_t ec_bst_abort_fault_voltage) {
    auto req = mValueObjectPool->obtainInt32(ec_bst_abort_fault_voltage);
    req->prop = toInt(VehicleProperty::GECKO_BST_ABORT_FAULT_VOLTAGE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bst_abort_fault_hvReq(int32_t ec_bst_abort_fault_hv) {
    auto req = mValueObjectPool->obtainInt32(ec_bst_abort_fault_hv);
    req->prop = toInt(VehicleProperty::GECKO_BST_ABORT_FAULT_HV);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bst_abort_fault_battery_tempReq(int32_t ec_bst_abort_fault_battery_temp) {
    auto req = mValueObjectPool->obtainInt32(ec_bst_abort_fault_battery_temp);
    req->prop = toInt(VehicleProperty::GECKO_BST_ABORT_FAULT_BATTERY_TEMP);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bst_abort_error_voltageReq(int32_t ec_bst_abort_error_voltage) {
    auto req = mValueObjectPool->obtainInt32(ec_bst_abort_error_voltage);
    req->prop = toInt(VehicleProperty::GECKO_BST_ABORT_ERROR_VOLTAGE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bst_abort_error_currentReq(int32_t ec_bst_abort_error_current) {
    auto req = mValueObjectPool->obtainInt32(ec_bst_abort_error_current);
    req->prop = toInt(VehicleProperty::GECKO_BST_ABORT_ERROR_CURRENT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_cst_abort_by_bmsWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_cst_abort_by_bms = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_cst_abort_by_bms");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_cst_abort_by_bms = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_cst_abort_by_bmsReq(ec_cst_abort_by_bms),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_cst_abort_by_bmsReq(int32_t ec_cst_abort_by_bms) {
    auto req = mValueObjectPool->obtainInt32(ec_cst_abort_by_bms);
    req->prop = toInt(VehicleProperty::GECKO_CST_ABORT_BY_BMS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_cst_abort_by_faultWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_cst_abort_by_fault = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_cst_abort_by_fault");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_cst_abort_by_fault = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_cst_abort_by_faultReq(ec_cst_abort_by_fault),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_cst_abort_by_faultReq(int32_t ec_cst_abort_by_fault) {
    auto req = mValueObjectPool->obtainInt32(ec_cst_abort_by_fault);
    req->prop = toInt(VehicleProperty::GECKO_CST_ABORT_BY_FAULT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_cst_abort_by_userWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_cst_abort_by_user = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_cst_abort_by_user");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_cst_abort_by_user = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_cst_abort_by_userReq(ec_cst_abort_by_user),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_cst_abort_by_userReq(int32_t ec_cst_abort_by_user) {
    auto req = mValueObjectPool->obtainInt32(ec_cst_abort_by_user);
    req->prop = toInt(VehicleProperty::GECKO_CST_ABORT_BY_USER);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_cst_abort_achive_conditionWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_cst_abort_achive_condition = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_cst_abort_achive_condition");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_cst_abort_achive_condition = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_cst_abort_achive_conditionReq(ec_cst_abort_achive_condition),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_cst_abort_achive_conditionReq(int32_t ec_cst_abort_achive_condition) {
    auto req = mValueObjectPool->obtainInt32(ec_cst_abort_achive_condition);
    req->prop = toInt(VehicleProperty::GECKO_CST_ABORT_ACHIVE_CONDITION);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_cst_abort_fault_energe_transmitWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_cst_abort_fault_energe_transmit = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_cst_abort_fault_energe_transmit");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_cst_abort_fault_energe_transmit = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_cst_abort_fault_energe_transmitReq(ec_cst_abort_fault_energe_transmit),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_cst_abort_fault_energe_transmitReq(int32_t ec_cst_abort_fault_energe_transmit) {
    auto req = mValueObjectPool->obtainInt32(ec_cst_abort_fault_energe_transmit);
    req->prop = toInt(VehicleProperty::GECKO_CST_ABORT_FAULT_ENERGE_TRANSMIT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_cst_abort_fault_charger_inner_tempWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_cst_abort_fault_charger_inner_temp = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_cst_abort_fault_charger_inner_temp");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_cst_abort_fault_charger_inner_temp = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_cst_abort_fault_charger_inner_tempReq(ec_cst_abort_fault_charger_inner_temp),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_cst_abort_fault_charger_inner_tempReq(int32_t ec_cst_abort_fault_charger_inner_temp) {
    auto req = mValueObjectPool->obtainInt32(ec_cst_abort_fault_charger_inner_temp);
    req->prop = toInt(VehicleProperty::GECKO_CST_ABORT_FAULT_CHARGER_INNER_TEMP);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_cst_abort_fault_connetorWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_cst_abort_fault_connetor = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_cst_abort_fault_connetor");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_cst_abort_fault_connetor = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_cst_abort_fault_connetorReq(ec_cst_abort_fault_connetor),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_cst_abort_fault_connetorReq(int32_t ec_cst_abort_fault_connetor) {
    auto req = mValueObjectPool->obtainInt32(ec_cst_abort_fault_connetor);
    req->prop = toInt(VehicleProperty::GECKO_CST_ABORT_FAULT_CONNETOR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_cst_abort_fault_charger_tempWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_cst_abort_fault_charger_temp = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_cst_abort_fault_charger_temp");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_cst_abort_fault_charger_temp = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_cst_abort_fault_charger_tempReq(ec_cst_abort_fault_charger_temp),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_cst_abort_fault_charger_tempReq(int32_t ec_cst_abort_fault_charger_temp) {
    auto req = mValueObjectPool->obtainInt32(ec_cst_abort_fault_charger_temp);
    req->prop = toInt(VehicleProperty::GECKO_CST_ABORT_FAULT_CHARGER_TEMP);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_cst_abort_fault_otherWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_cst_abort_fault_other = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_cst_abort_fault_other");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_cst_abort_fault_other = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_cst_abort_fault_otherReq(ec_cst_abort_fault_other),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_cst_abort_fault_otherReq(int32_t ec_cst_abort_fault_other) {
    auto req = mValueObjectPool->obtainInt32(ec_cst_abort_fault_other);
    req->prop = toInt(VehicleProperty::GECKO_CST_ABORT_FAULT_OTHER);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_cst_abort_fault_charger_stopWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_cst_abort_fault_charger_stop = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_cst_abort_fault_charger_stop");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_cst_abort_fault_charger_stop = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_cst_abort_fault_charger_stopReq(ec_cst_abort_fault_charger_stop),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_cst_abort_fault_charger_stopReq(int32_t ec_cst_abort_fault_charger_stop) {
    auto req = mValueObjectPool->obtainInt32(ec_cst_abort_fault_charger_stop);
    req->prop = toInt(VehicleProperty::GECKO_CST_ABORT_FAULT_CHARGER_STOP);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_cst_abort_error_voltageWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_cst_abort_error_voltage = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_cst_abort_error_voltage");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_cst_abort_error_voltage = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_cst_abort_error_voltageReq(ec_cst_abort_error_voltage),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_cst_abort_error_voltageReq(int32_t ec_cst_abort_error_voltage) {
    auto req = mValueObjectPool->obtainInt32(ec_cst_abort_error_voltage);
    req->prop = toInt(VehicleProperty::GECKO_CST_ABORT_ERROR_VOLTAGE);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_cst_abort_error_currentWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_cst_abort_error_current = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_cst_abort_error_current");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_cst_abort_error_current = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_cst_abort_error_currentReq(ec_cst_abort_error_current),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_cst_abort_error_currentReq(int32_t ec_cst_abort_error_current) {
    auto req = mValueObjectPool->obtainInt32(ec_cst_abort_error_current);
    req->prop = toInt(VehicleProperty::GECKO_CST_ABORT_ERROR_CURRENT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bcm_rear_view_mirr_heating_stsWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bcm_rear_view_mirr_heating_sts = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bcm_rear_view_mirr_heating_sts");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bcm_rear_view_mirr_heating_sts = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bcm_rear_view_mirr_heating_stsReq(ec_bcm_rear_view_mirr_heating_sts),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bcm_rear_view_mirr_heating_stsReq(int32_t ec_bcm_rear_view_mirr_heating_sts) {
    auto req = mValueObjectPool->obtainInt32(ec_bcm_rear_view_mirr_heating_sts);
    req->prop = toInt(VehicleProperty::GECKO_BCM_REAR_VIEW_MIRR_HEATING_STS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_tms_ohx_out_tmpWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_tms_ohx_out_tmp = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_tms_ohx_out_tmp");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_tms_ohx_out_tmp = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_tms_ohx_out_tmpReq(ec_tms_ohx_out_tmp),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_tms_ohx_out_tmpReq(int32_t ec_tms_ohx_out_tmp) {
    auto req = mValueObjectPool->obtainInt32(ec_tms_ohx_out_tmp);
    req->prop = toInt(VehicleProperty::GECKO_TMS_OHX_OUT_TMP);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_tms_evap_tmpWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_tms_evap_tmp = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_tms_evap_tmp");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_tms_evap_tmp = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_tms_evap_tmpReq(ec_tms_evap_tmp),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_tms_evap_tmpReq(int32_t ec_tms_evap_tmp) {
    auto req = mValueObjectPool->obtainInt32(ec_tms_evap_tmp);
    req->prop = toInt(VehicleProperty::GECKO_TMS_EVAP_TMP);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_tms_evap_out_tmpWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_tms_evap_out_tmp = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_tms_evap_out_tmp");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_tms_evap_out_tmp = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_tms_evap_out_tmpReq(ec_tms_evap_out_tmp),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_tms_evap_out_tmpReq(int32_t ec_tms_evap_out_tmp) {
    auto req = mValueObjectPool->obtainInt32(ec_tms_evap_out_tmp);
    req->prop = toInt(VehicleProperty::GECKO_TMS_EVAP_OUT_TMP);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_tms_chiller_out_tmpWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_tms_chiller_out_tmp = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_tms_chiller_out_tmp");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_tms_chiller_out_tmp = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_tms_chiller_out_tmpReq(ec_tms_chiller_out_tmp),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_tms_chiller_out_tmpReq(int32_t ec_tms_chiller_out_tmp) {
    auto req = mValueObjectPool->obtainInt32(ec_tms_chiller_out_tmp);
    req->prop = toInt(VehicleProperty::GECKO_TMS_CHILLER_OUT_TMP);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bcm_high_beam_li_fault_fbWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bcm_high_beam_li_fault_fb = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bcm_high_beam_li_fault_fb");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bcm_high_beam_li_fault_fb = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bcm_high_beam_li_fault_fbReq(ec_bcm_high_beam_li_fault_fb),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bcm_high_beam_li_fault_fbReq(int32_t ec_bcm_high_beam_li_fault_fb) {
    auto req = mValueObjectPool->obtainInt32(ec_bcm_high_beam_li_fault_fb);
    req->prop = toInt(VehicleProperty::GECKO_BCM_HIGH_BEAM_LI_FAULT_FB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bcm_low_beam_li_fault_fbWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bcm_low_beam_li_fault_fb = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bcm_low_beam_li_fault_fb");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bcm_low_beam_li_fault_fb = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bcm_low_beam_li_fault_fbReq(ec_bcm_low_beam_li_fault_fb),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bcm_low_beam_li_fault_fbReq(int32_t ec_bcm_low_beam_li_fault_fb) {
    auto req = mValueObjectPool->obtainInt32(ec_bcm_low_beam_li_fault_fb);
    req->prop = toInt(VehicleProperty::GECKO_BCM_LOW_BEAM_LI_FAULT_FB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bcm_vhcl_seekWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bcm_vhcl_seek = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bcm_vhcl_seek");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bcm_vhcl_seek = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bcm_vhcl_seekReq(ec_bcm_vhcl_seek),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bcm_vhcl_seekReq(int32_t ec_bcm_vhcl_seek) {
    auto req = mValueObjectPool->obtainInt32(ec_bcm_vhcl_seek);
    req->prop = toInt(VehicleProperty::GECKO_BCM_VHCL_SEEK);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bcm_illmnd_stsWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bcm_illmnd_sts = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bcm_illmnd_sts");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bcm_illmnd_sts = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bcm_illmnd_stsReq(ec_bcm_illmnd_sts),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bcm_illmnd_stsReq(int32_t ec_bcm_illmnd_sts) {
    auto req = mValueObjectPool->obtainInt32(ec_bcm_illmnd_sts);
    req->prop = toInt(VehicleProperty::GECKO_BCM_ILLMND_STS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bcm_key_frbdnWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bcm_key_frbdn = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bcm_key_frbdn");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bcm_key_frbdn = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bcm_key_frbdnReq(ec_bcm_key_frbdn),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bcm_key_frbdnReq(int32_t ec_bcm_key_frbdn) {
    auto req = mValueObjectPool->obtainInt32(ec_bcm_key_frbdn);
    req->prop = toInt(VehicleProperty::GECKO_BCM_KEY_FRBDN);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bcm_frbdn_key_nrWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bcm_frbdn_key_nr = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bcm_frbdn_key_nr");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bcm_frbdn_key_nr = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bcm_frbdn_key_nrReq(ec_bcm_frbdn_key_nr),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bcm_frbdn_key_nrReq(int32_t ec_bcm_frbdn_key_nr) {
    auto req = mValueObjectPool->obtainInt32(ec_bcm_frbdn_key_nr);
    req->prop = toInt(VehicleProperty::GECKO_BCM_FRBDN_KEY_NR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bcm_start_reqWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bcm_start_req = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bcm_start_req");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bcm_start_req = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bcm_start_reqReq(ec_bcm_start_req),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bcm_start_reqReq(int32_t ec_bcm_start_req) {
    auto req = mValueObjectPool->obtainInt32(ec_bcm_start_req);
    req->prop = toInt(VehicleProperty::GECKO_BCM_START_REQ);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bcm_drv_pe_authent_acsdWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bcm_drv_pe_authent_acsd = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bcm_drv_pe_authent_acsd");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bcm_drv_pe_authent_acsd = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bcm_drv_pe_authent_acsdReq(ec_bcm_drv_pe_authent_acsd),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bcm_drv_pe_authent_acsdReq(int32_t ec_bcm_drv_pe_authent_acsd) {
    auto req = mValueObjectPool->obtainInt32(ec_bcm_drv_pe_authent_acsd);
    req->prop = toInt(VehicleProperty::GECKO_BCM_DRV_PE_AUTHENT_ACSD);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bcm_frpe_authent_acsdWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bcm_frpe_authent_acsd = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bcm_frpe_authent_acsd");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bcm_frpe_authent_acsd = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bcm_frpe_authent_acsdReq(ec_bcm_frpe_authent_acsd),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bcm_frpe_authent_acsdReq(int32_t ec_bcm_frpe_authent_acsd) {
    auto req = mValueObjectPool->obtainInt32(ec_bcm_frpe_authent_acsd);
    req->prop = toInt(VehicleProperty::GECKO_BCM_FRPE_AUTHENT_ACSD);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bcm_ps_reqWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bcm_ps_req = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bcm_ps_req");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bcm_ps_req = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bcm_ps_reqReq(ec_bcm_ps_req),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bcm_ps_reqReq(int32_t ec_bcm_ps_req) {
    auto req = mValueObjectPool->obtainInt32(ec_bcm_ps_req);
    req->prop = toInt(VehicleProperty::GECKO_BCM_PS_REQ);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bcm_frnt_le_door_hndl_swtWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bcm_frnt_le_door_hndl_swt = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bcm_frnt_le_door_hndl_swt");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bcm_frnt_le_door_hndl_swt = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bcm_frnt_le_door_hndl_swtReq(ec_bcm_frnt_le_door_hndl_swt),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bcm_frnt_le_door_hndl_swtReq(int32_t ec_bcm_frnt_le_door_hndl_swt) {
    auto req = mValueObjectPool->obtainInt32(ec_bcm_frnt_le_door_hndl_swt);
    req->prop = toInt(VehicleProperty::GECKO_BCM_FRNT_LE_DOOR_HNDL_SWT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bcm_frnt_ri_door_hndl_swtWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bcm_frnt_ri_door_hndl_swt = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bcm_frnt_ri_door_hndl_swt");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bcm_frnt_ri_door_hndl_swt = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bcm_frnt_ri_door_hndl_swtReq(ec_bcm_frnt_ri_door_hndl_swt),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bcm_frnt_ri_door_hndl_swtReq(int32_t ec_bcm_frnt_ri_door_hndl_swt) {
    auto req = mValueObjectPool->obtainInt32(ec_bcm_frnt_ri_door_hndl_swt);
    req->prop = toInt(VehicleProperty::GECKO_BCM_FRNT_RI_DOOR_HNDL_SWT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bcm_save_power_staWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bcm_save_power_sta = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bcm_save_power_sta");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bcm_save_power_sta = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bcm_save_power_staReq(ec_bcm_save_power_sta),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bcm_save_power_staReq(int32_t ec_bcm_save_power_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_bcm_save_power_sta);
    req->prop = toInt(VehicleProperty::GECKO_BCM_SAVE_POWER_STA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bcm_front_wiper_motor_stsWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bcm_front_wiper_motor_sts = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bcm_front_wiper_motor_sts");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bcm_front_wiper_motor_sts = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bcm_front_wiper_motor_stsReq(ec_bcm_front_wiper_motor_sts),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bcm_front_wiper_motor_stsReq(int32_t ec_bcm_front_wiper_motor_sts) {
    auto req = mValueObjectPool->obtainInt32(ec_bcm_front_wiper_motor_sts);
    req->prop = toInt(VehicleProperty::GECKO_BCM_FRONT_WIPER_MOTOR_STS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bcm_fl_window_stsWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bcm_fl_window_sts = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bcm_fl_window_sts");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bcm_fl_window_sts = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bcm_fl_window_stsReq(ec_bcm_fl_window_sts),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bcm_fl_window_stsReq(int32_t ec_bcm_fl_window_sts) {
    auto req = mValueObjectPool->obtainInt32(ec_bcm_fl_window_sts);
    req->prop = toInt(VehicleProperty::GECKO_BCM_FL_WINDOW_STS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bcm_fr_window_stsWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bcm_fr_window_sts = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bcm_fr_window_sts");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bcm_fr_window_sts = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bcm_fr_window_stsReq(ec_bcm_fr_window_sts),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bcm_fr_window_stsReq(int32_t ec_bcm_fr_window_sts) {
    auto req = mValueObjectPool->obtainInt32(ec_bcm_fr_window_sts);
    req->prop = toInt(VehicleProperty::GECKO_BCM_FR_WINDOW_STS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bcm_fl_windowmotor_stsWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bcm_fl_windowmotor_sts = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bcm_fl_windowmotor_sts");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bcm_fl_windowmotor_sts = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bcm_fl_windowmotor_stsReq(ec_bcm_fl_windowmotor_sts),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bcm_fl_windowmotor_stsReq(int32_t ec_bcm_fl_windowmotor_sts) {
    auto req = mValueObjectPool->obtainInt32(ec_bcm_fl_windowmotor_sts);
    req->prop = toInt(VehicleProperty::GECKO_BCM_FL_WINDOWMOTOR_STS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bcm_fr_windowmotor_stsWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bcm_fr_windowmotor_sts = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bcm_fr_windowmotor_sts");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bcm_fr_windowmotor_sts = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bcm_fr_windowmotor_stsReq(ec_bcm_fr_windowmotor_sts),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bcm_fr_windowmotor_stsReq(int32_t ec_bcm_fr_windowmotor_sts) {
    auto req = mValueObjectPool->obtainInt32(ec_bcm_fr_windowmotor_sts);
    req->prop = toInt(VehicleProperty::GECKO_BCM_FR_WINDOWMOTOR_STS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bcm_wiper_ctrl_frontWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bcm_wiper_ctrl_front = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bcm_wiper_ctrl_front");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bcm_wiper_ctrl_front = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bcm_wiper_ctrl_frontReq(ec_bcm_wiper_ctrl_front),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bcm_wiper_ctrl_frontReq(int32_t ec_bcm_wiper_ctrl_front) {
    auto req = mValueObjectPool->obtainInt32(ec_bcm_wiper_ctrl_front);
    req->prop = toInt(VehicleProperty::GECKO_BCM_WIPER_CTRL_FRONT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bcm_drv_seat_occupant_sensor_stsWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bcm_drv_seat_occupant_sensor_sts = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bcm_drv_seat_occupant_sensor_sts");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bcm_drv_seat_occupant_sensor_sts = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bcm_drv_seat_occupant_sensor_stsReq(ec_bcm_drv_seat_occupant_sensor_sts),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bcm_drv_seat_occupant_sensor_stsReq(int32_t ec_bcm_drv_seat_occupant_sensor_sts) {
    auto req = mValueObjectPool->obtainInt32(ec_bcm_drv_seat_occupant_sensor_sts);
    req->prop = toInt(VehicleProperty::GECKO_BCM_DRV_SEAT_OCCUPANT_SENSOR_STS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bcm_heavy_rain_indWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bcm_heavy_rain_ind = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bcm_heavy_rain_ind");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bcm_heavy_rain_ind = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bcm_heavy_rain_indReq(ec_bcm_heavy_rain_ind),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bcm_heavy_rain_indReq(int32_t ec_bcm_heavy_rain_ind) {
    auto req = mValueObjectPool->obtainInt32(ec_bcm_heavy_rain_ind);
    req->prop = toInt(VehicleProperty::GECKO_BCM_HEAVY_RAIN_IND);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_tpms_pressure_value_rrWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_tpms_pressure_value_rr = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_tpms_pressure_value_rr");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_tpms_pressure_value_rr = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_tpms_pressure_value_rrReq(ec_tpms_pressure_value_rr),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_tpms_pressure_value_rrReq(int32_t ec_tpms_pressure_value_rr) {
    auto req = mValueObjectPool->obtainInt32(ec_tpms_pressure_value_rr);
    req->prop = toInt(VehicleProperty::GECKO_TPMS_PRESSURE_VALUE_RR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_tpms_pressure_value_rlWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_tpms_pressure_value_rl = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_tpms_pressure_value_rl");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_tpms_pressure_value_rl = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_tpms_pressure_value_rlReq(ec_tpms_pressure_value_rl),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_tpms_pressure_value_rlReq(int32_t ec_tpms_pressure_value_rl) {
    auto req = mValueObjectPool->obtainInt32(ec_tpms_pressure_value_rl);
    req->prop = toInt(VehicleProperty::GECKO_TPMS_PRESSURE_VALUE_RL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_tpms_pressure_sta_rlWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_tpms_pressure_sta_rl = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_tpms_pressure_sta_rl");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_tpms_pressure_sta_rl = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_tpms_pressure_sta_rlReq(ec_tpms_pressure_sta_rl),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_tpms_pressure_sta_rlReq(int32_t ec_tpms_pressure_sta_rl) {
    auto req = mValueObjectPool->obtainInt32(ec_tpms_pressure_sta_rl);
    req->prop = toInt(VehicleProperty::GECKO_TPMS_PRESSURE_STA_RL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_tpms_pressure_sta_rrWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_tpms_pressure_sta_rr = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_tpms_pressure_sta_rr");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_tpms_pressure_sta_rr = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_tpms_pressure_sta_rrReq(ec_tpms_pressure_sta_rr),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_tpms_pressure_sta_rrReq(int32_t ec_tpms_pressure_sta_rr) {
    auto req = mValueObjectPool->obtainInt32(ec_tpms_pressure_sta_rr);
    req->prop = toInt(VehicleProperty::GECKO_TPMS_PRESSURE_STA_RR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_tpms_pressure_value_frWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_tpms_pressure_value_fr = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_tpms_pressure_value_fr");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_tpms_pressure_value_fr = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_tpms_pressure_value_frReq(ec_tpms_pressure_value_fr),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_tpms_pressure_value_frReq(int32_t ec_tpms_pressure_value_fr) {
    auto req = mValueObjectPool->obtainInt32(ec_tpms_pressure_value_fr);
    req->prop = toInt(VehicleProperty::GECKO_TPMS_PRESSURE_VALUE_FR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_tpms_pressure_value_flWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_tpms_pressure_value_fl = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_tpms_pressure_value_fl");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_tpms_pressure_value_fl = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_tpms_pressure_value_flReq(ec_tpms_pressure_value_fl),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_tpms_pressure_value_flReq(int32_t ec_tpms_pressure_value_fl) {
    auto req = mValueObjectPool->obtainInt32(ec_tpms_pressure_value_fl);
    req->prop = toInt(VehicleProperty::GECKO_TPMS_PRESSURE_VALUE_FL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_tpms_pressure_sta_flWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_tpms_pressure_sta_fl = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_tpms_pressure_sta_fl");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_tpms_pressure_sta_fl = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_tpms_pressure_sta_flReq(ec_tpms_pressure_sta_fl),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_tpms_pressure_sta_flReq(int32_t ec_tpms_pressure_sta_fl) {
    auto req = mValueObjectPool->obtainInt32(ec_tpms_pressure_sta_fl);
    req->prop = toInt(VehicleProperty::GECKO_TPMS_PRESSURE_STA_FL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_tpms_pressure_sta_frWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_tpms_pressure_sta_fr = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_tpms_pressure_sta_fr");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_tpms_pressure_sta_fr = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_tpms_pressure_sta_frReq(ec_tpms_pressure_sta_fr),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_tpms_pressure_sta_frReq(int32_t ec_tpms_pressure_sta_fr) {
    auto req = mValueObjectPool->obtainInt32(ec_tpms_pressure_sta_fr);
    req->prop = toInt(VehicleProperty::GECKO_TPMS_PRESSURE_STA_FR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bcm_dome_light_staWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bcm_dome_light_sta = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bcm_dome_light_sta");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bcm_dome_light_sta = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bcm_dome_light_staReq(ec_bcm_dome_light_sta),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bcm_dome_light_staReq(int32_t ec_bcm_dome_light_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_bcm_dome_light_sta);
    req->prop = toInt(VehicleProperty::GECKO_BCM_DOME_LIGHT_STA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bcm_back_lamp_staWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bcm_back_lamp_sta = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bcm_back_lamp_sta");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bcm_back_lamp_sta = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bcm_back_lamp_staReq(ec_bcm_back_lamp_sta),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bcm_back_lamp_staReq(int32_t ec_bcm_back_lamp_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_bcm_back_lamp_sta);
    req->prop = toInt(VehicleProperty::GECKO_BCM_BACK_LAMP_STA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bcm_bass_horn_reqWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bcm_bass_horn_req = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bcm_bass_horn_req");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bcm_bass_horn_req = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bcm_bass_horn_reqReq(ec_bcm_bass_horn_req),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bcm_bass_horn_reqReq(int32_t ec_bcm_bass_horn_req) {
    auto req = mValueObjectPool->obtainInt32(ec_bcm_bass_horn_req);
    req->prop = toInt(VehicleProperty::GECKO_BCM_BASS_HORN_REQ);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bcm_ajar_sta_v_hoodWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bcm_ajar_sta_v_hood = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bcm_ajar_sta_v_hood");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bcm_ajar_sta_v_hood = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bcm_ajar_sta_v_hoodReq(ec_bcm_ajar_sta_v_hood),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bcm_ajar_sta_v_hoodReq(int32_t ec_bcm_ajar_sta_v_hood) {
    auto req = mValueObjectPool->obtainInt32(ec_bcm_ajar_sta_v_hood);
    req->prop = toInt(VehicleProperty::GECKO_BCM_AJAR_STA_V_HOOD);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bcm_frnt_fog_li_sw_sigWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bcm_frnt_fog_li_sw_sig = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bcm_frnt_fog_li_sw_sig");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bcm_frnt_fog_li_sw_sig = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bcm_frnt_fog_li_sw_sigReq(ec_bcm_frnt_fog_li_sw_sig),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bcm_frnt_fog_li_sw_sigReq(int32_t ec_bcm_frnt_fog_li_sw_sig) {
    auto req = mValueObjectPool->obtainInt32(ec_bcm_frnt_fog_li_sw_sig);
    req->prop = toInt(VehicleProperty::GECKO_BCM_FRNT_FOG_LI_SW_SIG);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bcm_rear_fog_li_sw_sigWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bcm_rear_fog_li_sw_sig = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bcm_rear_fog_li_sw_sig");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bcm_rear_fog_li_sw_sig = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bcm_rear_fog_li_sw_sigReq(ec_bcm_rear_fog_li_sw_sig),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bcm_rear_fog_li_sw_sigReq(int32_t ec_bcm_rear_fog_li_sw_sig) {
    auto req = mValueObjectPool->obtainInt32(ec_bcm_rear_fog_li_sw_sig);
    req->prop = toInt(VehicleProperty::GECKO_BCM_REAR_FOG_LI_SW_SIG);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bcm_day_run_light_staWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bcm_day_run_light_sta = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bcm_day_run_light_sta");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bcm_day_run_light_sta = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bcm_day_run_light_staReq(ec_bcm_day_run_light_sta),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bcm_day_run_light_staReq(int32_t ec_bcm_day_run_light_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_bcm_day_run_light_sta);
    req->prop = toInt(VehicleProperty::GECKO_BCM_DAY_RUN_LIGHT_STA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bcm_reverse_lamp_staWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bcm_reverse_lamp_sta = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bcm_reverse_lamp_sta");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bcm_reverse_lamp_sta = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bcm_reverse_lamp_staReq(ec_bcm_reverse_lamp_sta),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bcm_reverse_lamp_staReq(int32_t ec_bcm_reverse_lamp_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_bcm_reverse_lamp_sta);
    req->prop = toInt(VehicleProperty::GECKO_BCM_REVERSE_LAMP_STA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bcm_brake_lamp_staWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bcm_brake_lamp_sta = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bcm_brake_lamp_sta");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bcm_brake_lamp_sta = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bcm_brake_lamp_staReq(ec_bcm_brake_lamp_sta),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bcm_brake_lamp_staReq(int32_t ec_bcm_brake_lamp_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_bcm_brake_lamp_sta);
    req->prop = toInt(VehicleProperty::GECKO_BCM_BRAKE_LAMP_STA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bcm_turn_li_stsWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bcm_turn_li_sts = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bcm_turn_li_sts");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bcm_turn_li_sts = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bcm_turn_li_stsReq(ec_bcm_turn_li_sts),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bcm_turn_li_stsReq(int32_t ec_bcm_turn_li_sts) {
    auto req = mValueObjectPool->obtainInt32(ec_bcm_turn_li_sts);
    req->prop = toInt(VehicleProperty::GECKO_BCM_TURN_LI_STS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_act_whl_tqReq(int32_t ec_vcu_act_whl_tq) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_act_whl_tq);
    req->prop = toInt(VehicleProperty::GECKO_VCU_ACT_WHL_TQ);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_act_whl_tq_vldReq(int32_t ec_vcu_act_whl_tq_vld) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_act_whl_tq_vld);
    req->prop = toInt(VehicleProperty::GECKO_VCU_ACT_WHL_TQ_VLD);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_drv_req_whl_tqReq(int32_t ec_vcu_drv_req_whl_tq) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_drv_req_whl_tq);
    req->prop = toInt(VehicleProperty::GECKO_VCU_DRV_REQ_WHL_TQ);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_drv_whl_tq_allwd_maxReq(int32_t ec_vcu_drv_whl_tq_allwd_max) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_drv_whl_tq_allwd_max);
    req->prop = toInt(VehicleProperty::GECKO_VCU_DRV_WHL_TQ_ALLWD_MAX);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_pwr_recup_max_avlb_whl_tq_stsReq(int32_t ec_vcu_pwr_recup_max_avlb_whl_tq_sts) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_pwr_recup_max_avlb_whl_tq_sts);
    req->prop = toInt(VehicleProperty::GECKO_VCU_PWR_RECUP_MAX_AVLB_WHL_TQ_STS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_pwr_recup_actl_whl_tq_stsReq(int32_t ec_vcu_pwr_recup_actl_whl_tq_sts) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_pwr_recup_actl_whl_tq_sts);
    req->prop = toInt(VehicleProperty::GECKO_VCU_PWR_RECUP_ACTL_WHL_TQ_STS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_brk_pwr_recup_max_avlb_whl_tqReq(int32_t ec_vcu_brk_pwr_recup_max_avlb_whl_tq) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_brk_pwr_recup_max_avlb_whl_tq);
    req->prop = toInt(VehicleProperty::GECKO_VCU_BRK_PWR_RECUP_MAX_AVLB_WHL_TQ);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_pwr_recup_act_whl_tqReq(int32_t ec_vcu_pwr_recup_act_whl_tq) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_pwr_recup_act_whl_tq);
    req->prop = toInt(VehicleProperty::GECKO_VCU_PWR_RECUP_ACT_WHL_TQ);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_brk_pwr_recup_act_whl_tqReq(int32_t ec_vcu_brk_pwr_recup_act_whl_tq) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_brk_pwr_recup_act_whl_tq);
    req->prop = toInt(VehicleProperty::GECKO_VCU_BRK_PWR_RECUP_ACT_WHL_TQ);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_brk_pwr_recup_actl_whl_tq_stsReq(int32_t ec_vcu_brk_pwr_recup_actl_whl_tq_sts) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_brk_pwr_recup_actl_whl_tq_sts);
    req->prop = toInt(VehicleProperty::GECKO_VCU_BRK_PWR_RECUP_ACTL_WHL_TQ_STS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_acc_req_drive_offReq(int32_t ec_vcu_acc_req_drive_off) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_acc_req_drive_off);
    req->prop = toInt(VehicleProperty::GECKO_VCU_ACC_REQ_DRIVE_OFF);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_actl_motor_rotate_spdWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_vcu_actl_motor_rotate_spd = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_actl_motor_rotate_spd");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_vcu_actl_motor_rotate_spd = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_vcu_actl_motor_rotate_spdReq(ec_vcu_actl_motor_rotate_spd),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_actl_motor_rotate_spdReq(int32_t ec_vcu_actl_motor_rotate_spd) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_actl_motor_rotate_spd);
    req->prop = toInt(VehicleProperty::GECKO_VCU_ACTL_MOTOR_ROTATE_SPD);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_actl_motor_rotate_spd_vWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_vcu_actl_motor_rotate_spd_v = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_actl_motor_rotate_spd_v");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_vcu_actl_motor_rotate_spd_v = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_vcu_actl_motor_rotate_spd_vReq(ec_vcu_actl_motor_rotate_spd_v),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_actl_motor_rotate_spd_vReq(int32_t ec_vcu_actl_motor_rotate_spd_v) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_actl_motor_rotate_spd_v);
    req->prop = toInt(VehicleProperty::GECKO_VCU_ACTL_MOTOR_ROTATE_SPD_V);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_remt_ac_ctrl_stWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_vcu_remt_ac_ctrl_st = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_remt_ac_ctrl_st");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_vcu_remt_ac_ctrl_st = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_vcu_remt_ac_ctrl_stReq(ec_vcu_remt_ac_ctrl_st),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_remt_ac_ctrl_stReq(int32_t ec_vcu_remt_ac_ctrl_st) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_remt_ac_ctrl_st);
    req->prop = toInt(VehicleProperty::GECKO_VCU_REMT_AC_CTRL_ST);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_remt_ac_defrostl_reqWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_vcu_remt_ac_defrostl_req = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_remt_ac_defrostl_req");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_vcu_remt_ac_defrostl_req = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_vcu_remt_ac_defrostl_reqReq(ec_vcu_remt_ac_defrostl_req),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_remt_ac_defrostl_reqReq(int32_t ec_vcu_remt_ac_defrostl_req) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_remt_ac_defrostl_req);
    req->prop = toInt(VehicleProperty::GECKO_VCU_REMT_AC_DEFROSTL_REQ);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_remt_ac_ctrl_reqWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_vcu_remt_ac_ctrl_req = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_remt_ac_ctrl_req");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_vcu_remt_ac_ctrl_req = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_vcu_remt_ac_ctrl_reqReq(ec_vcu_remt_ac_ctrl_req),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_remt_ac_ctrl_reqReq(int32_t ec_vcu_remt_ac_ctrl_req) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_remt_ac_ctrl_req);
    req->prop = toInt(VehicleProperty::GECKO_VCU_REMT_AC_CTRL_REQ);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_charging_conditions_fbWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_vcu_charging_conditions_fb = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_charging_conditions_fb");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_vcu_charging_conditions_fb = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_vcu_charging_conditions_fbReq(ec_vcu_charging_conditions_fb),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_charging_conditions_fbReq(int32_t ec_vcu_charging_conditions_fb) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_charging_conditions_fb);
    req->prop = toInt(VehicleProperty::GECKO_VCU_CHARGING_CONDITIONS_FB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_accl_pedal_pos_snsr_staWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_vcu_accl_pedal_pos_snsr_sta = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_accl_pedal_pos_snsr_sta");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_vcu_accl_pedal_pos_snsr_sta = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_vcu_accl_pedal_pos_snsr_staReq(ec_vcu_accl_pedal_pos_snsr_sta),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_accl_pedal_pos_snsr_staReq(int32_t ec_vcu_accl_pedal_pos_snsr_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_accl_pedal_pos_snsr_sta);
    req->prop = toInt(VehicleProperty::GECKO_VCU_ACCL_PEDAL_POS_SNSR_STA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_req_epbWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_vcu_req_epb = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_req_epb");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_vcu_req_epb = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_vcu_req_epbReq(ec_vcu_req_epb),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_req_epbReq(int32_t ec_vcu_req_epb) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_req_epb);
    req->prop = toInt(VehicleProperty::GECKO_VCU_REQ_EPB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_acc_trq_ctrl_avlWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_vcu_acc_trq_ctrl_avl = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_acc_trq_ctrl_avl");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_vcu_acc_trq_ctrl_avl = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_vcu_acc_trq_ctrl_avlReq(ec_vcu_acc_trq_ctrl_avl),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_acc_trq_ctrl_avlReq(int32_t ec_vcu_acc_trq_ctrl_avl) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_acc_trq_ctrl_avl);
    req->prop = toInt(VehicleProperty::GECKO_VCU_ACC_TRQ_CTRL_AVL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_acc_standstill_reqWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_vcu_acc_standstill_req = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_acc_standstill_req");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_vcu_acc_standstill_req = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_vcu_acc_standstill_reqReq(ec_vcu_acc_standstill_req),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_acc_standstill_reqReq(int32_t ec_vcu_acc_standstill_req) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_acc_standstill_req);
    req->prop = toInt(VehicleProperty::GECKO_VCU_ACC_STANDSTILL_REQ);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_acc_tgt_axWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_vcu_acc_tgt_ax = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_acc_tgt_ax");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_vcu_acc_tgt_ax = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_vcu_acc_tgt_axReq(ec_vcu_acc_tgt_ax),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_acc_tgt_axReq(int32_t ec_vcu_acc_tgt_ax) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_acc_tgt_ax);
    req->prop = toInt(VehicleProperty::GECKO_VCU_ACC_TGT_AX);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_acc_tgt_ax_reqWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_vcu_acc_tgt_ax_req = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_acc_tgt_ax_req");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_vcu_acc_tgt_ax_req = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_vcu_acc_tgt_ax_reqReq(ec_vcu_acc_tgt_ax_req),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_acc_tgt_ax_reqReq(int32_t ec_vcu_acc_tgt_ax_req) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_acc_tgt_ax_req);
    req->prop = toInt(VehicleProperty::GECKO_VCU_ACC_TGT_AX_REQ);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_drv_req_torq_override_fcmWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_vcu_drv_req_torq_override_fcm = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_drv_req_torq_override_fcm");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_vcu_drv_req_torq_override_fcm = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_vcu_drv_req_torq_override_fcmReq(ec_vcu_drv_req_torq_override_fcm),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_drv_req_torq_override_fcmReq(int32_t ec_vcu_drv_req_torq_override_fcm) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_drv_req_torq_override_fcm);
    req->prop = toInt(VehicleProperty::GECKO_VCU_DRV_REQ_TORQ_OVERRIDE_FCM);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_cruise_ctr_tgt_spdWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_vcu_cruise_ctr_tgt_spd = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_cruise_ctr_tgt_spd");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_vcu_cruise_ctr_tgt_spd = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_vcu_cruise_ctr_tgt_spdReq(ec_vcu_cruise_ctr_tgt_spd),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_cruise_ctr_tgt_spdReq(int32_t ec_vcu_cruise_ctr_tgt_spd) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_cruise_ctr_tgt_spd);
    req->prop = toInt(VehicleProperty::GECKO_VCU_CRUISE_CTR_TGT_SPD);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_cruise_ctrl_staWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_vcu_cruise_ctrl_sta = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_cruise_ctrl_sta");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_vcu_cruise_ctrl_sta = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_vcu_cruise_ctrl_staReq(ec_vcu_cruise_ctrl_sta),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_cruise_ctrl_staReq(int32_t ec_vcu_cruise_ctrl_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_cruise_ctrl_sta);
    req->prop = toInt(VehicleProperty::GECKO_VCU_CRUISE_CTRL_STA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_eps_lks_abort_fbWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_eps_lks_abort_fb = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_eps_lks_abort_fb");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_eps_lks_abort_fb = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_eps_lks_abort_fbReq(ec_eps_lks_abort_fb),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_eps_lks_abort_fbReq(int32_t ec_eps_lks_abort_fb) {
    auto req = mValueObjectPool->obtainInt32(ec_eps_lks_abort_fb);
    req->prop = toInt(VehicleProperty::GECKO_EPS_LKS_ABORT_FB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_sw_versionWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_sw_version = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_sw_version");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_sw_version = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_sw_versionReq(ec_bms_sw_version),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_sw_versionReq(int32_t ec_bms_sw_version) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_sw_version);
    req->prop = toInt(VehicleProperty::GECKO_BMS_SW_VERSION);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_scs_right_11_swtWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_scs_right_11_swt = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_scs_right_11_swt");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_scs_right_11_swt = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_scs_right_11_swtReq(ec_scs_right_11_swt),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_scs_right_11_swtReq(int32_t ec_scs_right_11_swt) {
    auto req = mValueObjectPool->obtainInt32(ec_scs_right_11_swt);
    req->prop = toInt(VehicleProperty::GECKO_SCS_RIGHT_11SWT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_scs_right_12_swtWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_scs_right_12_swt = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_scs_right_12_swt");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_scs_right_12_swt = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_scs_right_12_swtReq(ec_scs_right_12_swt),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_scs_right_12_swtReq(int32_t ec_scs_right_12_swt) {
    auto req = mValueObjectPool->obtainInt32(ec_scs_right_12_swt);
    req->prop = toInt(VehicleProperty::GECKO_SCS_RIGHT_12SWT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_scs_right_13_swtWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_scs_right_13_swt = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_scs_right_13_swt");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_scs_right_13_swt = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_scs_right_13_swtReq(ec_scs_right_13_swt),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_scs_right_13_swtReq(int32_t ec_scs_right_13_swt) {
    auto req = mValueObjectPool->obtainInt32(ec_scs_right_13_swt);
    req->prop = toInt(VehicleProperty::GECKO_SCS_RIGHT_13SWT);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ehb_epb_actuator_st_lWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ehb_epb_actuator_st_l = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ehb_epb_actuator_st_l");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ehb_epb_actuator_st_l = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ehb_epb_actuator_st_lReq(ec_ehb_epb_actuator_st_l),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ehb_epb_actuator_st_lReq(int32_t ec_ehb_epb_actuator_st_l) {
    auto req = mValueObjectPool->obtainInt32(ec_ehb_epb_actuator_st_l);
    req->prop = toInt(VehicleProperty::GECKO_EHB_EPB_ACTUATOR_ST_L);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_scs_gear_shift_lever_pst_req_vdWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_scs_gear_shift_lever_pst_req_vd = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_scs_gear_shift_lever_pst_req_vd");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_scs_gear_shift_lever_pst_req_vd = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_scs_gear_shift_lever_pst_req_vdReq(ec_scs_gear_shift_lever_pst_req_vd),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_scs_gear_shift_lever_pst_req_vdReq(int32_t ec_scs_gear_shift_lever_pst_req_vd) {
    auto req = mValueObjectPool->obtainInt32(ec_scs_gear_shift_lever_pst_req_vd);
    req->prop = toInt(VehicleProperty::GECKO_SCS_GEAR_SHIFT_LEVER_PST_REQ_VD);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_dcs_actl_chrg_powerWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_dcs_actl_chrg_power = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_dcs_actl_chrg_power");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_dcs_actl_chrg_power = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_dcs_actl_chrg_powerReq(ec_bms_dcs_actl_chrg_power),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_dcs_actl_chrg_powerReq(int32_t ec_bms_dcs_actl_chrg_power) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_dcs_actl_chrg_power);
    req->prop = toInt(VehicleProperty::GECKO_BMS_DCS_ACTL_CHRG_POWER);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_ccu_keep_awake_staWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_ccu_keep_awake_sta = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_ccu_keep_awake_sta");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_ccu_keep_awake_sta = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_ccu_keep_awake_staReq(ec_ccu_keep_awake_sta),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_ccu_keep_awake_staReq(int32_t ec_ccu_keep_awake_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_ccu_keep_awake_sta);
    req->prop = toInt(VehicleProperty::GECKO_CCU_KEEPAWAKESTA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_vcu_bra_tor_reqWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_vcu_bra_tor_req = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_vcu_bra_tor_req");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_vcu_bra_tor_req = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_vcu_bra_tor_reqReq(ec_vcu_bra_tor_req),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_bra_tor_reqReq(int32_t ec_vcu_bra_tor_req) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_bra_tor_req);
    req->prop = toInt(VehicleProperty::GECKO_VCU_BRA_TOR_REQ);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_pp_sensor_fault_sts_flmWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_pp_sensor_fault_sts_flm = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_pp_sensor_fault_sts_flm");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_pp_sensor_fault_sts_flm = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_pp_sensor_fault_sts_flmReq(ec_pp_sensor_fault_sts_flm),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_pp_sensor_fault_sts_flmReq(int32_t ec_pp_sensor_fault_sts_flm) {
    auto req = mValueObjectPool->obtainInt32(ec_pp_sensor_fault_sts_flm);
    req->prop = toInt(VehicleProperty::GECKO_PP_SENSORFAULTSTSFLM);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_pp_sensor_fault_sts_flWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_pp_sensor_fault_sts_fl = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_pp_sensor_fault_sts_fl");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_pp_sensor_fault_sts_fl = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_pp_sensor_fault_sts_flReq(ec_pp_sensor_fault_sts_fl),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_pp_sensor_fault_sts_flReq(int32_t ec_pp_sensor_fault_sts_fl) {
    auto req = mValueObjectPool->obtainInt32(ec_pp_sensor_fault_sts_fl);
    req->prop = toInt(VehicleProperty::GECKO_PP_SENSORFAULTSTSFL);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bcm_authent_key_nrWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bcm_authent_key_nr = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bcm_authent_key_nr");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bcm_authent_key_nr = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bcm_authent_key_nrReq(ec_bcm_authent_key_nr),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bcm_authent_key_nrReq(int32_t ec_bcm_authent_key_nr) {
    auto req = mValueObjectPool->obtainInt32(ec_bcm_authent_key_nr);
    req->prop = toInt(VehicleProperty::GECKO_BCM_AUTHENT_KEY_NR);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bcm_key_staWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bcm_key_sta = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bcm_key_sta");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bcm_key_sta = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bcm_key_staReq(ec_bcm_key_sta),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bcm_key_staReq(int32_t ec_bcm_key_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_bcm_key_sta);
    req->prop = toInt(VehicleProperty::GECKO_BCM_KEY_STA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bcm_wiper_stop_pos_staWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bcm_wiper_stop_pos_sta = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bcm_wiper_stop_pos_sta");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bcm_wiper_stop_pos_sta = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bcm_wiper_stop_pos_staReq(ec_bcm_wiper_stop_pos_sta),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bcm_wiper_stop_pos_staReq(int32_t ec_bcm_wiper_stop_pos_sta) {
    auto req = mValueObjectPool->obtainInt32(ec_bcm_wiper_stop_pos_sta);
    req->prop = toInt(VehicleProperty::GECKO_BCM_WIPER_STOP_POS_STA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_vcu_drv_req_whl_tq_vldReq(int32_t ec_vcu_drv_req_whl_tq_vld) {
    auto req = mValueObjectPool->obtainInt32(ec_vcu_drv_req_whl_tq_vld);
    req->prop = toInt(VehicleProperty::GECKO_VCU_DRV_REQ_WHL_TQ_VLD);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bms_insulation_wrningWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bms_insulation_wrning = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bms_insulation_wrning");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bms_insulation_wrning = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bms_insulation_wrningReq(ec_bms_insulation_wrning),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bms_insulation_wrningReq(int32_t ec_bms_insulation_wrning) {
    auto req = mValueObjectPool->obtainInt32(ec_bms_insulation_wrning);
    req->prop = toInt(VehicleProperty::GECKO_BMS_INSULATION_WRNING);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_pp_raeb_work_stsWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_pp_raeb_work_sts = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_pp_raeb_work_sts");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_pp_raeb_work_sts = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_pp_raeb_work_stsReq(ec_pp_raeb_work_sts),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_pp_raeb_work_stsReq(int32_t ec_pp_raeb_work_sts) {
    auto req = mValueObjectPool->obtainInt32(ec_pp_raeb_work_sts);
    req->prop = toInt(VehicleProperty::GECKO_PP_RAEB_WORK_STS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_fcm_tau_gap_setWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_fcm_tau_gap_set = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_tau_gap_set");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_fcm_tau_gap_set = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_fcm_tau_gap_setReq(ec_fcm_tau_gap_set),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_tau_gap_setReq(int32_t ec_fcm_tau_gap_set) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_tau_gap_set);
    req->prop = toInt(VehicleProperty::GECKO_FCM_TAUGAPSET);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::gecko_e2p_rom_resultWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t gecko_e2p_rom_result = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("gecko_e2p_rom_result");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        gecko_e2p_rom_result = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_gecko_e2p_rom_resultReq(gecko_e2p_rom_result),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_gecko_e2p_rom_resultReq(int32_t gecko_e2p_rom_result) {
    auto req = mValueObjectPool->obtainInt32(gecko_e2p_rom_result);
    req->prop = toInt(VehicleProperty::GECKO_ENGINEER_MODE_TEST);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::gecko_key_code_resultWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t gecko_key_code_result = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("gecko_key_code_result");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        gecko_key_code_result = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_gecko_key_code_resultReq(gecko_key_code_result),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_gecko_key_code_resultReq(int32_t gecko_key_code_result) {
    auto req = mValueObjectPool->obtainInt32(gecko_key_code_result);
    req->prop = toInt(VehicleProperty::GECKO_ENGINEER_MODE_TEST);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_fcm_hma_highbeam_reqWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_fcm_hma_highbeam_req = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_fcm_hma_highbeam_req");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_fcm_hma_highbeam_req = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_fcm_hma_highbeam_reqReq(ec_fcm_hma_highbeam_req),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_fcm_hma_highbeam_reqReq(int32_t ec_fcm_hma_highbeam_req) {
    auto req = mValueObjectPool->obtainInt32(ec_fcm_hma_highbeam_req);
    req->prop = toInt(VehicleProperty::GECKO_FCM_HMA_HIGHBEAMREQ);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::ec_bcm_hazard_lamp_stsWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t ec_bcm_hazard_lamp_sts = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("ec_bcm_hazard_lamp_sts");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        ec_bcm_hazard_lamp_sts = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_ec_bcm_hazard_lamp_stsReq(ec_bcm_hazard_lamp_sts),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_ec_bcm_hazard_lamp_stsReq(int32_t ec_bcm_hazard_lamp_sts) {
    auto req = mValueObjectPool->obtainInt32(ec_bcm_hazard_lamp_sts);
    req->prop = toInt(VehicleProperty::GECKO_BCM_HAZARD_LAMPSTS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_rke_reqWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t bc_bcm_rke_req = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_rke_req");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        bc_bcm_rke_req = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_bc_bcm_rke_reqReq(bc_bcm_rke_req),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_rke_reqReq(int32_t bc_bcm_rke_req) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_rke_req);
    req->prop = toInt(VehicleProperty::GECKO_BCM_RKEREQ);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_fcm_hma_stsWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t bc_fcm_hma_sts = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("bc_fcm_hma_sts");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        bc_fcm_hma_sts = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_bc_fcm_hma_stsReq(bc_fcm_hma_sts),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_fcm_hma_stsReq(int32_t bc_fcm_hma_sts) {
    auto req = mValueObjectPool->obtainInt32(bc_fcm_hma_sts);
    req->prop = toInt(VehicleProperty::GECKO_FCM_HMA_STS);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_le_turn_li_fault_fbWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t bc_bcm_le_turn_li_fault_fb = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_le_turn_li_fault_fb");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        bc_bcm_le_turn_li_fault_fb = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_bc_bcm_le_turn_li_fault_fbReq(bc_bcm_le_turn_li_fault_fb),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_le_turn_li_fault_fbReq(int32_t bc_bcm_le_turn_li_fault_fb) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_le_turn_li_fault_fb);
    req->prop = toInt(VehicleProperty::GECKO_BCM_LETURNLIFAULTFB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_bcm_ri_turn_li_fault_fbWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t bc_bcm_ri_turn_li_fault_fb = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("bc_bcm_ri_turn_li_fault_fb");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        bc_bcm_ri_turn_li_fault_fb = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_bc_bcm_ri_turn_li_fault_fbReq(bc_bcm_ri_turn_li_fault_fb),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_bcm_ri_turn_li_fault_fbReq(int32_t bc_bcm_ri_turn_li_fault_fb) {
    auto req = mValueObjectPool->obtainInt32(bc_bcm_ri_turn_li_fault_fb);
    req->prop = toInt(VehicleProperty::GECKO_BCM_RITURNLIFAULTFB);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::bc_ac_ac_sta_fbWatcher() {
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    int32_t bc_ac_ac_sta_fb = 0;
    ConfigDBC* mp = mPropertyManager->findCProperty("bc_ac_ac_sta_fb");
    while(!mShuttingDownFlag.load()){
        mPropertyManager->getUpdateCState(mp);
        bc_ac_ac_sta_fb = mPropertyManager->getCProValue(mp);
        mHal->onPropertyValue(*Create_bc_ac_ac_sta_fbReq(bc_ac_ac_sta_fb),true);
    }
}
recyclable_ptr<VehiclePropValue> GarageModeServerSideHandlerImpl::Create_bc_ac_ac_sta_fbReq(int32_t bc_ac_ac_sta_fb) {
    auto req = mValueObjectPool->obtainInt32(bc_ac_ac_sta_fb);
    req->prop = toInt(VehicleProperty::GECKO_HVAC_AC_STA);
    req->areaId = 0;
    req->timestamp = elapsedRealtimeNano();
    req->status = VehiclePropertyStatus::AVAILABLE;
    return req;
}

void GarageModeServerSideHandlerImpl::interval_time(){
  uint32_t count = 0;
  while(true){
    //int64_t currentTime = elapsedRealtime();

    if(powerOnSts > 0){
      //
        #if 0
        travelTimes = (currentTime - travelBeginTimes)/1000/60;
        if(travelTimes >= lastTravelTimes && travelBeginTimes > 0){
            lastTravelTimes = travelTimes;
            if(travelTimes != updateTravelTimes){
                mHal->onPropertyValue(*Create_power_on_timeReq(travelTimes), true);
                updateTravelTimes = travelTimes;
            }
            
            if(count%9 == 0){
                LOG(INFO) << "travelTimes:"<< travelTimes<<" travelBeginTimes:"<<travelBeginTimes<<" updateTravelTimes:"<< updateTravelTimes;
            }
        }

        ConfigDBC* mp = mPropertyManager->findCProperty("sc_ccm_vehicle_spd_dsp");
        int32_t speed = getActualFloatValue(mPropertyManager->getCProValue(mp),0.05625,0);
        HandlePowerOnspd(speed);
        #endif
    }
    std::this_thread::sleep_for(std::chrono::milliseconds(100));
    count++;
    if(count > 100000)count = 0;
  }
  std::this_thread::sleep_for(std::chrono::milliseconds(100));
}

}  // namespace android::hardware::automotive::vehicle::V2_0::impl
